<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "JSONiq.ent">
%BOOK_ENTITIES;
]>
<chapter id ="section-json-value-construction">
  <title>Construction of JSON values</title>
  
  <para>
    JSONiq Constructors create Objects, and Arrays.
    If an Object Constructor or an Array Constructor contains only literal data, as a rule of thumb, the syntax is the same as the JSON serialization.
    Constructors can also contain XQuery expressions to create content as the result of a query.
  </para>
  
  <para>Here is the syntax for object and array constructors:</para>
  
  <programlisting>
      PrimaryExpr ::= -- everything so far --
        | JSONConstructor

      JSONConstructor ::=
          ArrayConstructor
        | ObjectConstructor

      ArrayConstructor ::= "[" Expr? "]"

      ObjectConstructor ::= 
          "{" ( PairConstructor ("," PairConstructor)* )? "}"
        | | "{|" Expr "|}"
      PairConstructor ::=  ExprSingle (":" | "?:") ExprSingle
    </programlisting>
  
  <para>XQuery expressions can occur within JSON constructors, and JSON constructors can occur within XQuery expressions. The semantics of
    such expressions are discussed in <xref linkend="section-combining-xml-and-json"/>.</para>
  
  <section>
    <title>Array Constructors</title>
    <para>The expression in an Array Constructor, if present, evaluates to a sequence of zero or more items. The members of
      the constructed array are copies of these items, in the same order.</para>
    
    <example>
      <title>Array Constructors</title>
      
      <para>An Array Constructor:</para>
      <programlisting>
        [ "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday" ]
      </programlisting>
      
      <para>Arrays can nest.</para>
      
      <programlisting>
          [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
          ]
        </programlisting>
      
      <para>Combining an Array Constructor with XQuery expressions:</para>
      
      <para>Query:</para>
      
      <programlisting>
        [ 10 to 15 ]
      </programlisting>
      
      <para>Result:</para>
      <programlisting>
        [ 10, 11, 12, 13, 14, 15 ]
      </programlisting>
      
    </example>
  </section>
  
  <section>
    <title>Object Constructors</title>
    <para>
      An Object Constructor is made of Pair Constructors. Each Pair Constructor creates a single string/item pair as follows:
      <itemizedlist>
        <listitem>
          <para>
            The string is the result of evaluating the left operand, atomizing it, checking that it results in a single atomic item,
            and casting it to <code>xs:string</code>. Errors such as <code>jerr:JNTY0004</code> or <code>err:XPTY0004</code> may be
            raised upon failure of one of these steps.
          </para>
        </listitem>
        <listitem>
          <para>
            If the right operand evaluates to a single item, the value of the pair is a copy of this result.
          </para>
          <para>
            If the right operand evaluates to the empty sequence, the value of the pair is the atomic value null (of type <code>js:null</code>). However, if the
            colon is preceded with a question mark, the pair is omitted instead.
          </para>
          <para>
            If the right operand evaluates to a sequence of more than one item, the value of the pair is an array containing copies
            of all items in this sequence, in the same order.
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      An object is constructed, the pairs property of which comprise all pairs generated by the pair constructors.
      An error <code>jerr:JNDY0003</code> is raised if two pairs have the same name (the comparison is made using <code>fn:codepoint-equal</code>).
    </para>
    
    <example>
      <title>Object Constructors</title>
      
      <para>An Object Constructor with literal data:</para>
      
      <programlisting>
          {
            "id" : 404,
            "name" : "Stanco Grease Pot",
            "price" : 6.49,
            "weight" : 3.8,
            "uses" : ["Grease storage","Backpacking pot"]
          }
        </programlisting>
      
      <para>Combining an Object Constructor with XQuery expressions:</para>
      
      <para>Query:</para>
      
      <programlisting>
          {
            "Sunday" : 1,
            "Monday" : 1 + 1,
            "Tuesday" : 3 * 1,
            "Wednesday" : 8 div 2,
            "Thursday" : 5,
            "Friday" : count(for $i in 1 to 6 return $i),
            "Saturday" : 10 - 3,
            "NotADay" ?: ()
          }
        </programlisting>
      
      <para>Result:</para>
      
      <programlisting>
          {
            "Sunday" : 1,
            "Monday" : 2,
            "Tuesday" : 3,
            "Wednesday" : 4,
            "Thursday" : 5,
            "Friday" : 6,
            "Saturday" : 7
          }
        </programlisting>
      
    </example>
    
    <para>Note:</para>
    
    <para>
      A JSON item cannot be a child of an XML element or
      attribute. If a JSON item is used in the content expression
      of an XQuery constructor, the result will raise an error, as described in <xref
        linkend="section-combining-xml-and-json"/>.
    </para>

    <para>
      There is also a syntax for dynamic object construction, which merges all the objects returned by the inner expression into a single object with a so-called
      "simple object union".
      
      A simple object union creates a new object, the pairs property of which is obtained by accumulating the pairs of all
      operand objects. An error <code>jerr:JNDY0003</code> is raised if two pairs with the same name are encountered.
    </para>
    
    <example>
      <title>Dynamically building an object</title>
      
      <para>Query:</para>
      <programlisting>
          let $object1 := { "Captain" : "Kirk" }
          let $object2 := { "First officer" : "Spock" }
          return {| $object1, $object2 |}
        </programlisting>
      
      <para>Result:</para>
      <programlisting>
          {
            "Captain" : "Kirk",
            "First officer" : "Spock"
          }
        </programlisting>
      <para>Query:</para>
      
      <programlisting>
          {|
            for $d at $i in ("Sunday",
                             "Monday",
                             "Tuesday",
                             "Wednesday",
                             "Thursday",
                             "Friday",
                             "Saturday" )
            return { $d : $i }
          |}
      </programlisting>
      
      <para>Result:</para>
      
      <programlisting>
          {
            "Sunday" : 1,
            "Monday" : 2,
            "Tuesday" : 3,
            "Wednesday" : 4,
            "Thursday" : 5,
            "Friday" : 6,
            "Saturday" : 7
          }
        </programlisting>
    </example>    
  </section>
  
  <section>
    <title>Strings</title>
    
    <para>
      Strings can be constructed using XQuery String Literals.
    </para>
    
    <example>
      <title>JSON String construction</title>
      <programlisting>
          "This is a string"
        </programlisting>
    </example>
    
  </section>
  
  <section>
    <title>Numbers</title>
    
    <para>Numbers can be constructed using XQuery Integer, Decimal and Double literals.</para>
    
    <example>
      <title>JSON Number construction</title>
      <programlisting>
          42
          3.14
          6.022E23
        </programlisting>
    </example>
    
  </section>
  
  <section>
    <title>Booleans</title>
    
    <para>Booleans can be constructed using the XQuery builtin functions fn:true() and fn:false().</para>
  </section>
  
  <section>
    <title>Null</title>
    
    <para>Null can be constructed using the new builtin function jn:null().</para>
  </section>
  
  <section>
    <title>Boolean and null literals</title>
    
    <para>
      A new option <code>jn:jsoniq-boolean-and-null-literals</code> is available ("yes" or "no"), that activates or deactivates the
      interpretation of a standalone NameTest "true", "false" or "null" (meaning: occurring as a PathExpr, i.e., no slashes, no axes) as
      boolean and null literals. By default, it is set to "yes".
      
      <footnote>
        <para>If this feature is activated, a relative path expression that tests for an element
          named <code>true</code>, <code>false</code>, or <code>null</code> must use the <code>./</code> construct,
          as in <code>./true</code>.</para>
      </footnote>
      
    </para>
  </section>
</chapter>
