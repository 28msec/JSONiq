<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="EN"><head><META http-equiv="Content-Type" content="text/html; charset=utf-8"><title>[Shared XPath/XQuery Specification]   </title><style type="text/css">
.wsspec      { font-family: monospace; font-size: small; font-style: italic }      
.xpath         { color: red; background-color: white }
.xquery      { color: green; background-color: white }

.xpath:link { color: red; background-color: white }
.xpath:visited { color: red; background-color: white }

.shared:link { color: black; background-color: white }
.shared:visited { color: black; background-color: white }

.xquery:link { color: green; background-color: white }
.xquery:visited { color: green; background-color: white }


code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

table.small    { font-size: x-small; }
    </style><link type="text/css" rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-WD.css"></head><body><div class="head"><p><a href="http://www.w3.org/"><img width="72" height="48" alt="W3C" src="http://www.w3.org/Icons/w3c_home"></a></p>
<h1><a id="title" name="title"></a>[Shared XPath/XQuery Specification]   </h1>
<h2><a id="w3c-doctype" name="w3c-doctype"></a>W3C Working Draft 15 September 2005</h2><dl><dt>This version:</dt><dd>
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2005/WD-xquery-20050915/">http://www.w3.org/TR/2005/WD-xquery-20050915/</a></span></span>
<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2005/WD-xpath20-20050915/">http://www.w3.org/TR/2005/WD-xpath20-20050915/</a></span></span>
</dd><dt>Latest version:</dt><dd>
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a></span></span>
<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a></span></span></dd><dt>Previous versions:</dt><dd>
<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2005/WD-xpath20-20050404/">http://www.w3.org/TR/2005/WD-xpath20-20050404/</a></span></span>
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2005/WD-xquery-20050404/">http://www.w3.org/TR/2005/WD-xquery-20050404/</a></span></span>

<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2005/WD-xpath20-20050211/">http://www.w3.org/TR/2005/WD-xpath20-20050211/</a></span></span>
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2005/WD-xquery-20050211/">http://www.w3.org/TR/2005/WD-xquery-20050211/</a></span></span>

<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2004/WD-xpath20-20040723/">http://www.w3.org/TR/2004/WD-xpath20-20040723/</a></span></span>
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2004/WD-xquery-20040723/">http://www.w3.org/TR/2004/WD-xquery-20040723/</a></span></span>

<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2003/WD-xpath20-20031112/">http://www.w3.org/TR/2003/WD-xpath20-20031112/</a></span></span>
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2003/WD-xquery-20031112/">http://www.w3.org/TR/2003/WD-xquery-20031112/</a></span></span>

<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2003/WD-xpath20-20030822/">http://www.w3.org/TR/2003/WD-xpath20-20030822/</a></span></span>
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2003/WD-xquery-20030822/">http://www.w3.org/TR/2003/WD-xquery-20030822/</a></span></span>

<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2003/WD-xpath20-20030502/">http://www.w3.org/TR/2003/WD-xpath20-20030502/</a></span></span>
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2003/WD-xquery-20030502/">http://www.w3.org/TR/2003/WD-xquery-20030502/</a></span></span>

</dd><dt>Editors:</dt><span class="xpath"><dd class="xpath">Anders Berglund (XSL WG), IBM  Research <a href="mailto:alrb@us.ibm.com">&lt;alrb@us.ibm.com&gt;</a></dd></span><dd>Scott Boag (XSL WG), IBM  Research <a href="mailto:scott_boag@us.ibm.com">&lt;scott_boag@us.ibm.com&gt;</a></dd><dd>Don Chamberlin (XML Query
WG), IBM Almaden Research Center <a href="mailto:chamberlin@almaden.ibm.com">&lt;chamberlin@almaden.ibm.com&gt;</a></dd><dd>Mary F. Fern&aacute;ndez (XML Query
WG), AT&amp;T Labs <a href="mailto:mff@research.att.com">&lt;mff@research.att.com&gt;</a></dd><span class="xquery"><dd class="xquery">Daniela Florescu (XML Query WG), Oracle <a href="mailto:dana.florescu@oracle.com">&lt;dana.florescu@oracle.com&gt;</a></dd></span><span class="xpath"><dd class="xpath">Michael Kay (XSL WG), Saxonica, via <a href="http://www.saxonica.com/">http://www.saxonica.com/</a></dd></span><dd>Jonathan
Robie (XML Query WG), DataDirect Technologies <a href="mailto:jonathan.robie@datadirect-technologies.com">&lt;jonathan.robie@datadirect-technologies.com&gt;</a></dd><dd>J&eacute;r&ocirc;me Sim&eacute;on (XML Query
WG), IBM T.J. Watson Research Center
 <a href="mailto:simeon@us.ibm.com">&lt;simeon@us.ibm.com&gt;</a></dd></dl><p>This document is also available in these non-normative formats: <span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2005/WD-xquery-20050915/xquery.xml">XML</a></span></span>, <span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2005/WD-xquery-20050915/diff-from-20050404.html">Revisions to LC Draft</a></span></span>, <span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2005/WD-xpath20-20050915/xpath20.xml">XML</a></span></span>, and&nbsp;<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2005/WD-xpath20-20050915/diff-from-20050404.html">Revisions to LC Draft</a></span></span>.</p><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;&copy;&nbsp;2005&nbsp;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p></div><hr><div>
<h2><a id="abstract" name="abstract"></a>Abstract</h2><span class="xpath"><div class="xpath"><p class="xpath">XPath 2.0 is an expression
language that allows the processing of values conforming to the data
model defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. The data model provides a
tree representation of XML documents as well as atomic values such as
integers, strings, and booleans, and sequences that may contain both
references to nodes in an XML document and atomic values. The result
of an XPath expression may be a selection of nodes from the input
documents, or an atomic value, or more generally, any sequence allowed
by the data model. The name of the language derives from its most
distinctive feature, the path expression, which provides a means of
hierarchic addressing of the nodes in an XML tree. 

XPath 2.0 is a superset of <a href="#XPath">[XPath 1.0]</a>, with the added
capability to support a richer set of data types, and to take
advantage of the type information that becomes available when
documents are validated using XML Schema. A backwards compatibility
mode is provided to ensure that nearly all XPath 1.0 expressions
continue to deliver the same result with XPath 2.0; exceptions to this
policy are noted in [<a href="#id-backwards-compatibility"><b>L Backwards Compatibility with
XPath 1.0</b></a>].</p></div></span><span class="xquery"><div class="xquery"><p class="xquery">XML is a versatile markup language,
capable of labeling the information content of diverse data sources
including structured and semi-structured documents, relational
databases, and object repositories. A query language that uses the
structure of XML intelligently can express queries across all these
kinds of data, whether physically stored in XML or viewed as XML via
middleware.  This specification describes a query language called
XQuery, which is designed to be broadly applicable across many types of
XML data sources.</p></div></span></div><div>
<h2><a id="status" name="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time
of its publication. Other documents may supersede this document. A
list of current W3C publications and the latest revision of this
technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at
http://www.w3.org/TR/.</em></p><p>This is a public W3C Working Draft for review by W3C Members and
other interested parties.
Publication as a Working Draft does not imply endorsement by the W3C
Membership. This is a draft document and may be updated, replaced or
obsoleted by other documents at any time. It is inappropriate to cite
this document as other than work in progress.
</p><p>[XPath/XQuery] [2.0/1.0] has been defined jointly by the <a href="http://www.w3.org/XML/Query">XML Query Working Group</a> and
the <a href="http://www.w3.org/Style/XSL/">XSL Working Group</a>
(both part of the <a href="http://www.w3.org/XML/Activity.html">XML
Activity</a>).  The
XPath 2.0 and XQuery 1.0 Working Drafts are generated from a common
source.  These languages are closely related, sharing much of the same
expression syntax and semantics, and much of the text found in the two
Working Drafts is identical.</p><p>This draft includes corrections and changes based on public
comments on the
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/TR/2005/WD-xquery-20050404/">Last Call Working Draft</a></span></span>
<span class="xpath"><span class="xpath"><a href="http://www.w3.org/TR/2005/WD-xpath20-20050404/">Last Call Working Draft</a></span></span>
dated 04 April 2005,
reflecting decisions made by the working groups up to 31 August 2005.
These decisions
<span class="xpath"><span class="xpath"><a href="http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&short_desc_type=allwordssubstr&short_desc=&product=XPath+%2F+XQuery+%2F+XSLT&component=XPath&version=Last+Call+drafts&long_desc_type=allwordssubstr&long_desc=&bug_file_loc_type=allwordssubstr&bug_file_loc=&status_whiteboard_type=allwordssubstr&status_whiteboard=&keywords_type=allwords&keywords=&bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&bug_status=RESOLVED&bug_status=CLOSED&emailtype1=substring&email1=&emailtype2=substring&email2=&bugidtype=include&bug_id=&votes=&chfieldfrom=&chfieldto=Now&chfieldvalue=&cmdtype=doit&order=Reuse+same+sort+as+last+time&field0-0-0=noop&type0-0-0=noop&value0-0-0=">are recorded</a></span></span>
<span class="xquery"><span class="xquery"><a href="http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&short_desc_type=allwordssubstr&short_desc=&product=XPath+%2F+XQuery+%2F+XSLT&component=XQuery&version=Last+Call+drafts&long_desc_type=allwordssubstr&long_desc=&bug_file_loc_type=allwordssubstr&bug_file_loc=&status_whiteboard_type=allwordssubstr&status_whiteboard=&keywords_type=allwords&keywords=&bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&bug_status=RESOLVED&bug_status=CLOSED&emailtype1=substring&email1=&emailtype2=substring&email2=&bugidtype=include&bug_id=&votes=&chfieldfrom=&chfieldto=Now&chfieldvalue=&cmdtype=doit&order=Reuse+same+sort+as+last+time&field0-0-0=noop&type0-0-0=noop&value0-0-0=">are recorded</a></span></span>
in the second Last Call public bugzilla repository
(<a href="http://www.w3.org/Bugs/Public/">http://www.w3.org/Bugs/Public/</a>).
A full list of changes since the Last Call Working Draft of 04 April
2005 can be found in <a href="#id-revisions-log"><b>M Revision
Log</b></a>.</p><p>This draft is being provided to permit public review of the changes that
have been made as a result of the Last Call comments. Comments on the
changes should be made against the pertinent Last Call comment
(instructions can be found at
<a href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is
not feasible, you may send your comments to the W3C mailing list,
<a href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>
(archived at <a href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>).
Please start the subject line
<span class="xpath"><span class="xpath"><span class="xpath">with &ldquo;[XPath]&rdquo;</span></span></span>
<span class="xquery"><span class="xquery"><span class="xquery">with &ldquo;[XQuery]&rdquo;</span></span></span>
so comments can be classified correctly.</p><p>The XML Query and XSL Working Groups expect to progress this document to
<a href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR">Candidate
Recommendation</a> status in
the very near future.</p><p>The patent policy for this document is the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February
2004 W3C Patent Policy</a>.
Patent disclosures relevant to this specification may be found on the
<a href="http://www.w3.org/2002/08/xmlquery-IPR-statements">XML Query Working
Group's patent disclosure page</a> and the
<a href="http://www.w3.org/Style/XSL/Disclosures">XSL Working Group's patent
disclosure page</a>. An
individual who has actual knowledge of a patent which the individual
believes contains Essential Claim(s) with respect to this specification
should disclose the information in accordance with
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6</a>
of the W3C Patent Policy.</p></div><div class="toc">
<h2><a id="contents" name="contents"></a>Table of Contents</h2><p class="toc">1 <a href="#id-introduction">Introduction</a><br>
2 <a href="#id-basics">     Basics</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#context">Expression Context</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.1 <a href="#static_context">Static Context</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.2 <a href="#eval_context">Dynamic Context</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#id-processing-model">Processing
                         Model</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1 <a href="#id-data-model-generation">Data Model Generation</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2 <a href="#id-schema-import-processing">Schema Import
Processing</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3 <a href="#id-expression-processing">Expression
Processing</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.1 <a href="#id-static-analysis">Static Analysis Phase</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.2 <a href="#id-dynamic-evaluation">Dynamic Evaluation Phase</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.4 <a href="#id-serialization">Serialization</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.5 <a href="#id-consistency-constraints">Consistency Constraints</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#errors">Error Handling</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1 <a href="#id-kinds-of-errors">Kinds of Errors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2 <a href="#id-identifying-errors">Identifying and Reporting Errors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3 <a href="#id-handling-dynamic">Handling Dynamic Errors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.4 <a href="#id-errors-and-opt">Errors and
      Optimization</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#id-important-concepts">Concepts</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.1 <a href="#N10E77">Document Order</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.2 <a href="#id-atomization">Atomization</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.3 <a href="#id-ebv">Effective Boolean Value</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.4 <a href="#id-input-sources">Input Sources</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.5 <a href="#id-uri-literals">URI Literals</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#id-types">Types</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.1 <a href="#id-predefined-types">Predefined Schema Types</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.2 <a href="#id-typed-value">Typed Value and String Value</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.3 <a href="#id-sequencetype-syntax">SequenceType Syntax</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4 <a href="#id-sequencetype-matching">SequenceType Matching</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.1 <a href="#id-matching-value">Matching a SequenceType and a Value</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.2 <a href="#id-matching-item">Matching an ItemType and an
Item</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.3 <a href="#id-element-test">Element Test</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.4 <a href="#id-schema-element-test">Schema Element Test</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.5 <a href="#id-attribute-test">Attribute Test</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.6 <a href="#id-schema-attribute-test">Schema Attribute Test</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.6 <a href="#comments">Comments</a><br>
3 <a href="#id-expressions">Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#id-primary-expressions">Primary Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.1 <a href="#id-literals">Literals</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.2 <a href="#id-variables">Variable References</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.3 <a href="#id-paren-expressions">Parenthesized Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.4 <a href="#id-context-item-expression">Context Item Expression</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.5 <a href="#id-function-calls">Function Calls</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#id-path-expressions">Path Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1 <a href="#id-steps">Steps</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.1 <a href="#axes">Axes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.2 <a href="#node-tests">Node Tests</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.2 <a href="#id-predicates">Predicates</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.3 <a href="#unabbrev">Unabbreviated Syntax</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.4 <a href="#abbrev">Abbreviated Syntax</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="#id-sequence-expressions">Sequence Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.1 <a href="#construct_seq">Constructing Sequences</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.2 <a href="#id-filter-expr">Filter Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.3 <a href="#combining_seq">Combining Node Sequences</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.4 <a href="#id-arithmetic">Arithmetic Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.5 <a href="#id-comparisons">Comparison Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.1 <a href="#id-value-comparisons">Value Comparisons</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.2 <a href="#id-general-comparisons">General Comparisons</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.3 <a href="#id-node-comparisons">Node Comparisons</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.6 <a href="#id-logical-expressions">Logical Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.7 <a href="#id-constructors">Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1 <a href="#id-element-constructor">Direct Element Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.1 <a href="#id-attributes">Attributes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.2 <a href="#id-namespaces">Namespace Declaration Attributes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.3 <a href="#id-content">Content</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.4 <a href="#id-whitespace">Boundary Whitespace</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.2 <a href="#id-otherConstructors">Other Direct Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3 <a href="#id-computedConstructors">Computed
   Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.1 <a href="#id-computedElements">Computed Element
   Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.2 <a href="#id-computedAttributes">Computed Attribute
   Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.3 <a href="#id-documentConstructors">Document Node Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.4 <a href="#id-textConstructors">Text Node Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.5 <a href="#id-computed-pis">Computed Processing Instruction Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.6 <a href="#id-computed-comments">Computed Comment Constructors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.4 <a href="#id-ns-nodes-on-elements">In-scope Namespaces of a Constructed Element</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.8 <a href="#id-for-expressions">For Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.9 <a href="#id-flwor-expressions">FLWOR Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9.1 <a href="#id-for-let">For and Let Clauses</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9.2 <a href="#id-where">Where Clause</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9.3 <a href="#id-orderby-return">Order By and Return Clauses</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.9.4 <a href="#N148C2">Example</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.10 <a href="#id-unordered-expressions">Ordered and Unordered Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.11 <a href="#id-conditionals">Conditional Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.12 <a href="#id-quantified-expressions">Quantified Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.13 <a href="#id-expressions-on-datatypes">Expressions on SequenceTypes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.13.1 <a href="#id-instance-of">Instance Of</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.13.2 <a href="#id-typeswitch">Typeswitch</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.13.3 <a href="#id-cast">Cast</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.13.4 <a href="#id-castable">Castable</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.13.5 <a href="#id-constructor-functions">Constructor
Functions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.13.6 <a href="#id-treat">Treat</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.14 <a href="#id-validate">Validate Expressions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.15 <a href="#id-extension-expressions">Extension Expressions</a><br>
4 <a href="#id-query-prolog">Modules and Prologs</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href="#id-version-declaration">Version Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href="#id-module-declaration">Module Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.3 <a href="#id-boundary-space-decls">Boundary-space Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.4 <a href="#id-default-collation-declaration">Default Collation Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.5 <a href="#id-base-uri-decl">Base URI Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.6 <a href="#id-construction-declaration">Construction Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.7 <a href="#id-default-ordering-decl">Ordering Mode Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.8 <a href="#id-empty-order-decl">Empty Order Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.9 <a href="#id-copy-namespaces-decl">Copy-Namespaces Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.10 <a href="#id-schema-imports">Schema Import</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.11 <a href="#id-module-imports">Module Import</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.12 <a href="#id-namespace-decls">Namespace Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.13 <a href="#id-default-namespace">Default Namespace Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.14 <a href="#id-variable-declarations">Variable Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.15 <a href="#FunctionDeclns">Function Declaration</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.16 <a href="#id-option-declaration">Option Declaration</a><br>
5 <a href="#id-xquery-conformance">Conformance</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href="#id-minimal-conformance">Minimal Conformance</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="#id-conform-optional-features">Optional Features</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 <a href="#id-schema-import-feature">Schema Import Feature</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 <a href="#id-schema-validation-feature">Schema Validation Feature</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3 <a href="#id-static-typing-feature">Static Typing Feature</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3.1 <a href="#id-static-extensions">Static Typing Extensions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.4 <a href="#id-full-axis-feature">Full Axis Feature</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.5 <a href="#id-module-feature">Module Feature</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.6 <a href="#id-serialization-feature">Serialization Feature</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.3 <a href="#id-data-model-conformance">Data Model Conformance</a><br>
</p>
<h3><a id="appendices" name="appendices"></a>Appendices</h3><p class="toc">A <a href="#nt-bnf">[XPath/XQuery] Grammar</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;A.1 <a href="#id-grammar">EBNF</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.1 <a href="#EBNFNotation">Notation</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.2 <a href="#extra-grammatical-constraints">Extra-grammatical Constraints</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.3 <a href="#notes-on-parsing">Grammar Notes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;A.2 <a href="#lexical-structure">Lexical structure</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.1 <a href="#terminal-symbols">Terminal Symbols</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.2 <a href="#N17673">Terminal Delimitation</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3 <a href="#N17733">End-of-Line Handling</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.1 <a href="#N1773E">XML 1.0 End-of-Line Handling</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.2 <a href="#N1774D">XML 1.1 End-of-Line Handling</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4 <a href="#whitespace-rules">Whitespace Rules</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.1 <a href="#DefaultWhitespaceHandling">Default Whitespace Handling</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.2 <a href="#ExplicitWhitespaceHandling">Explicit  Whitespace Handling</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;A.3 <a href="#id-reserved-fn-names">Reserved Function Names</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;A.4 <a href="#id-precedence-order">Precedence Order</a><br>
B <a href="#N179C4">Type Promotion and Operator Mapping</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;B.1 <a href="#promotion">Type Promotion</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;B.2 <a href="#mapping">Operator Mapping</a><br>
C <a href="#id-xq-context-components">Context Components</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;C.1 <a href="#id-xq-static-context-components">Static Context Components</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;C.2 <a href="#id-xq-evaluation-context-components">Dynamic Context Components</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;C.3 <a href="#id-xq-serialization-parameters">Serialization Parameters</a><br>
D <a href="#id-xp-context-components">Context Components</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;D.1 <a href="#id-xp-static-context-components">Static Context
Components</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;D.2 <a href="#id-xp-evaluation-context-components">Dynamic Context Components</a><br>
E <a href="#id-impl-defined-items">Implementation-Defined Items</a><br>
F <a href="#id-references">References</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;F.1 <a href="#id-normative-references">Normative References</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;F.2 <a href="#id-non-normative-references">Non-normative References</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;F.3 <a href="#id-background-material">Background Material</a><br>
G <a href="#id-xpath-conformance">Conformance</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;G.1 <a href="#id-xpath-static-typing">Static Typing Feature</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.1.1 <a href="#id-xpath-static-extensions">Static Typing Extensions</a><br>
H <a href="#id-errors">Error Conditions</a><br>
I <a href="#id-mime-type">The application/xquery Media Type</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;I.1 <a href="#N19474">Introduction</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;I.2 <a href="#N19486">Registration of MIME Media Type application/xquery</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I.2.1 <a href="#N1949C">Interoperability Considerations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I.2.2 <a href="#N194A1">Applications Using this Media Type</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I.2.3 <a href="#N194B0">File Extensions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I.2.4 <a href="#N194C0">Intended Usage</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I.2.5 <a href="#N194C5">Author/Change Controller</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;I.3 <a href="#xquery-mime-encoding">Encoding Considerations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;I.4 <a href="#xquery-mime-recognizing">Recognizing XQuery Files</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;I.5 <a href="#N194EC">Charset Default Rules</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;I.6 <a href="#N194F1">Security Considerations</a><br>
J <a href="#id-glossary">Glossary</a> (Non-Normative)<br>
K <a href="#N19509">Example Applications</a> (Non-Normative)<br>
&nbsp;&nbsp;&nbsp;&nbsp;K.1 <a href="#id-joins">Joins</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;K.2 <a href="#id-grouping">Grouping</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;K.3 <a href="#id-queries-on-sequence">Queries on Sequence</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;K.4 <a href="#id-recursive-transformations">Recursive Transformations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;K.5 <a href="#id-select-distinct">Selecting Distinct Combinations</a><br>
L <a href="#id-backwards-compatibility">Backwards Compatibility with
XPath 1.0</a> (Non-Normative)<br>
&nbsp;&nbsp;&nbsp;&nbsp;L.1 <a href="#N196D7">Incompatibilities when Compatibility Mode is true</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;L.2 <a href="#N19716">Incompatibilities when Compatibility Mode is false</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;L.3 <a href="#N197D0">Incompatibilities when using a Schema</a><br>
M <a href="#id-revisions-log">Revision
Log</a> (Non-Normative)<br>
&nbsp;&nbsp;&nbsp;&nbsp;M.1 <a href="#N1981D">7 July 2005</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;M.2 <a href="#N19878">15 September 2005</a><br>
</p></div><hr><div class="body"><div class="div1">
<h2><a id="id-introduction" name="id-introduction"></a>1 Introduction</h2><span class="xquery"><div class="xquery"><p class="xquery">As increasing amounts of information are
	stored, exchanged, and presented using XML, the ability to
	intelligently query XML data sources becomes increasingly
	important. One of the great strengths of XML is its
	flexibility in representing many different kinds of
	information from diverse sources. To exploit this flexibility,
	an XML query language must provide features for retrieving and
	interpreting information from these diverse sources.</p></div></span><span class="xquery"><div class="xquery"><p class="xquery">XQuery is designed to meet the requirements
	identified by the W3C XML Query Working Group <a href="#Requirements">[XML Query 1.0 Requirements]</a> and the use cases in <a href="#UseCases">[XML Query Use Cases]</a>. It is designed to be a language in which queries are concise and easily
	understood. It is also flexible enough to query a broad
	spectrum of XML information sources, including both databases
	and documents. The Query Working Group has identified a
	requirement for both a non-XML query syntax and an
	XML-based query syntax. XQuery is designed to meet the first
	of these requirements.  XQuery is derived from an XML query
	language called Quilt <a href="#Quilt">[Quilt]</a>, which in turn
	borrowed features from several other languages, including
	XPath 1.0 <a href="#XPath">[XPath 1.0]</a>, XQL <a href="#XQL">[XQL]</a>,
	XML-QL <a href="#XML-QL">[XML-QL]</a>, SQL <a href="#SQL">[SQL]</a>, and
	OQL <a href="#ODMG">[ODMG]</a>. </p></div></span><span class="xpath"><div class="xpath"><p class="xpath">The primary purpose of XPath is to address the
	nodes of <a href="#XML">[XML 1.0]</a> or <a href="#XML1.1">[XML 1.1]</a> trees.

	XPath gets its name from its use of a path notation for navigating through the hierarchical structure of an XML
	document.

        XPath uses a compact, non-XML syntax to facilitate use of
        XPath within URIs and XML attribute values.</p></div></span><p>[<a title="data model" id="dt-datamodel" name="dt-datamodel">Definition</a>: [XPath/XQuery] operates on the abstract,
	logical structure of an XML document, rather than its surface
	syntax.  This logical structure, known as the <b>data
	model</b>,  is defined in the <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> document.]</p><span class="xpath"><div class="xpath"><p class="xpath">XPath is designed to be embedded in a
	<b>host language</b> such as <a href="#XSLT">[XSLT 2.0]</a> or
	<a href="#xquery">[XQuery]</a>. XPath has a natural subset that can be
	used for matching (testing whether or not a node matches a
	pattern); this use of XPath is described in <a href="#XSLT">[XSLT 2.0]</a>.</p></div></span><p>XQuery Version 1.0 is an extension of XPath Version 2.0. Any expression that is syntactically valid and
	executes successfully in both XPath 2.0 and XQuery 1.0 will
	return the same result in both languages.  Since these
	languages are so closely related, their grammars and language
	descriptions are generated from a common source to ensure
	consistency, and the editors of these specifications work
	together closely.</p><p>[XPath/XQuery] also depends on and is closely related to the
	following specifications:</p><ul><li><p><a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> defines the data model that underlies all [XPath/XQuery] expressions.</p></li><li><p><a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a> defines the static semantics of [XPath/XQuery] and also
	  contains a formal but non-normative description of the
	  dynamic semantics that may be useful for implementors and others
	  who require a formal definition.</p></li><li><p>The type system of [XPath/XQuery] is based on <a href="#XMLSchema">[XML Schema]</a>.</p></li><li><p>The built-in function library  and the operators supported by
	  [XPath/XQuery] are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p></li><span class="xquery"><li class="xquery"><p>One requirement in <a href="#Requirements">[XML Query 1.0 Requirements]</a> is that
	  an XML query language have both a human-readable syntax and
	  an XML-based syntax.  The XML-based syntax for XQuery is
	  described in <a href="#XQueryX">[XQueryX 1.0]</a>. </p></li></span></ul><p>This document specifies a grammar for [XPath/XQuery], using the
		same basic EBNF notation used in <a href="#XML">[XML 1.0]</a>. Unless otherwise noted (see <a href="#lexical-structure"><b>A.2 Lexical structure</b></a>), whitespace is not significant in <span class="xquery"><span class="xquery"><span class="xquery">queries</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">expressions</span></span></span>. Grammar productions are introduced together with the features that they describe, and a complete grammar is also presented in the appendix [<a href="#nt-bnf"><b>A [XPath/XQuery] Grammar</b></a>].  The appendix is the normative version.</p><p>In the grammar productions in this document, named symbols are underlined and literal text is enclosed in double quotes. For example, the following  production describes the syntax of a function call:</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="fakeid_doc-xpath-FunctionCall" name="fakeid_doc-xpath-FunctionCall"></a>[96]&nbsp;&nbsp;&nbsp;</td><td><code>FunctionCall</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a>  "("  (<a href="#doc-xpath-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*)?  ")"</code></td></tr></tbody></table><p>The production should be read as follows: A
		function call consists of a QName followed by an
		open-parenthesis. The open-parenthesis is followed by
		an optional argument list. The argument list (if
		present) consists of one or more expressions,
		separated by commas. The optional argument list is
		followed by a close-parenthesis. </p><p>Certain aspects of language
		processing are described in this specification as
		<b>implementation-defined</b> or
		<b>implementation-dependent</b>.</p><ul><li><p>[<a title="implementation defined" id="dt-implementation-defined" name="dt-implementation-defined">Definition</a>: <b>Implementation-defined</b>
		indicates an aspect that may differ between
		implementations, but must be specified by the
		implementor for each particular
		implementation.]</p></li><li><p>
      [<a title="implementation   dependent" id="dt-implementation-dependent" name="dt-implementation-dependent">Definition</a>: <b>Implementation-dependent</b>
		indicates an aspect that may differ between
		implementations, is not specified by this or any W3C
		specification, and is not required to be specified by
		the implementor for any particular
		implementation.]</p></li></ul><span class="xpath"><div class="xpath"><p class="xpath">A language aspect described in this specification as
<b>implementation-defined</b> or <b>implementation
dependent</b> may be further constrained by the specifications of a
host language in which XPath is embedded.</p></div></span><p>This document normatively defines the dynamic semantics of
[XPath/XQuery]. The static semantics of [XPath/XQuery] are normatively defined
in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>. In this document, examples
and material labeled as "Note" are provided for explanatory purposes
and are not normative.</p></div><div class="div1">
<h2><a id="id-basics" name="id-basics"></a>2      Basics</h2><p>The basic building block of [XPath/XQuery] is the
	 <b>expression</b>, which is a string of <a href="#Unicode">[Unicode]</a> characters (the version of Unicode to be used is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.)
	 The language provides several kinds of expressions which may be constructed
	 from keywords, symbols, and operands. In general, the operands of an expression
	 are other expressions. [XPath/XQuery] allows expressions to be nested with full
generality. <span class="xquery"><span class="xquery"><span class="xquery">(However, unlike a pure functional
language, it does not allow variable substitution if the variable
declaration contains construction of new nodes.)</span></span></span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification contains no 
assumptions or requirements regarding the character set encoding of strings 
of <a href="#Unicode">[Unicode]</a> characters.</p></div><p>Like XML, [XPath/XQuery] is a case-sensitive language. Keywords in
	 [XPath/XQuery] use lower-case characters and are not reserved&mdash;that is, names in [XPath/XQuery] expressions are allowed to be the same as language keywords, except for certain unprefixed function-names listed in <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p><p>[<a title="value" id="dt-value" name="dt-value">Definition</a>: In the <a title="data model" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" href="#dt-sequence">sequence</a>.] [<a title="sequence" id="dt-sequence" name="dt-sequence">Definition</a>: A
<b>sequence</b> is an ordered collection of zero or more
<a title="item" href="#dt-item">items</a>.]
[<a title="item" id="dt-item" name="dt-item">Definition</a>: An
	 <b>item</b> is either an <a title="atomic value" href="#dt-atomic-value">atomic value</a> or a <a title="node" href="#dt-node">node</a>.]
[<a title="atomic value" id="dt-atomic-value" name="dt-atomic-value">Definition</a>: An <b>atomic
	 value</b> is a value in the value space of an <b>atomic
	 type</b>, as defined in <a href="#XMLSchema">[XML Schema]</a>.]
[<a title="node" id="dt-node" name="dt-node">Definition</a>: A <b>node</b> is an instance of one of the
	  <b>node kinds</b> defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.]
Each node has a unique <b>node identity</b>, a <b>typed value</b>, and a <b>string value</b>. In addition, some nodes have a <b>name</b>. The <b>typed value</b> of a node is a sequence
	 of zero or more atomic values. The <b>string value</b> of a node is a
	 value of type <code>xs:string</code>. The <b>name</b> of a node is a value of type <code>xs:QName</code>.</p><p>[<a title="singleton" id="dt-singleton" name="dt-singleton">Definition</a>: A sequence containing exactly one item is called a
	 <b>singleton</b>.] An item is identical to a singleton sequence
	 containing that item. Sequences are never nested&mdash;for example, combining the
	 values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2,
	 3). [<a title="empty sequence" id="dt-empty-sequence" name="dt-empty-sequence">Definition</a>: A sequence containing zero items is called an <b>empty sequence</b>.]</p><p>[<a title="data model instance" id="dt-data-model-instance" name="dt-data-model-instance">Definition</a>: The term <b>data model instance</b> is used, synonymously with the term <b>value</b>, to denote an unconstrained sequence of <a title="node" href="#dt-node">nodes</a> and/or <a title="atomic value" href="#dt-atomic-value">atomic values</a>.] </p><p>Names in [XPath/XQuery] are called <b>QNames</b>, and conform to the syntax in <a href="#XMLNAMES">[XML Names]</a>. [<a title="QName" id="dt-qname" name="dt-qname">Definition</a>: Lexically, a <b>QName</b> consists of an optional namespace prefix and a local name. If the namespace prefix is present, it is separated from the local name by a colon.] A lexical QName can be converted into an <b>expanded QName</b> by resolving its namespace prefix to a namespace URI, using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> [<a title="err:XPST0081" href="#ERRXPST0081">err:XPST0081</a>]. [<a title="expanded QName" id="dt-expanded-qname" name="dt-expanded-qname">Definition</a>: An <b>expanded QName</b> consists of an optional namespace URI and a local name. An expanded QName also retains its original namespace prefix (if any), to facilitate casting the expanded QName into a string.] The namespace URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="#XMLSchema">[XML Schema]</a>. Two expanded QNames are equal if their namespace URIs are equal and their local names are equal (even if their namespace prefixes are not equal). Namespace URIs and local names are compared  on a codepoint basis, without further normalization.</p><span class="xquery"><div class="xquery"><p class="xquery">Certain namespace prefixes are predeclared by XQuery and bound to fixed namespace URIs. These namespace prefixes are as follows:</p></div></span><p><span class="xpath"><span class="xpath"><span class="xpath">This document uses the following namespace prefixes to represent the namespace URIs with which they are listed. Use of these namespace prefix bindings in this document is not normative.</span></span></span></p><ul><span class="xquery"><li class="xquery"><p><code>xml = http://www.w3.org/XML/1998/namespace</code></p></li></span><li><p><code>xs = http://www.w3.org/2001/XMLSchema</code></p></li><span class="xquery"><li class="xquery"><p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p></li></span><li><p><code>fn = http://www.w3.org/2005/xpath-functions</code></p></li><li><p><code>xdt = http://www.w3.org/2005/xpath-datatypes</code></p></li><span class="xquery"><li class="xquery"><p><code>local = http://www.w3.org/2005/xquery-local-functions</code> (see <a href="#FunctionDeclns"><b>4.15 Function Declaration</b></a>.)</p></li></span><span class="xpath"><li class="xpath"><p><code>err = http://www.w3.org/2005/xqt-errors</code> (see <a href="#id-identifying-errors"><b>2.3.2 Identifying and Reporting Errors</b></a>).</p></li></span></ul><span class="xquery"><div class="xquery"><p class="xquery">In addition to the prefixes in the above list, this document uses the prefix <code>err</code> to represent the namespace URI <code>http://www.w3.org/2005/xqt-errors</code> (see <a href="#id-identifying-errors"><b>2.3.2 Identifying and Reporting Errors</b></a>). This namespace prefix is not predeclared and its use in this document is not normative.</p></div></span><p>Element nodes have a property called <b>in-scope namespaces</b>. [<a title="in-scope namespaces" id="dt-in-scope-namespaces" name="dt-in-scope-namespaces">Definition</a>: The <b>in-scope namespaces</b> property of an element node is a set of <b>namespace bindings</b>, each of which associates a namespace prefix with a URI, thus defining the set of namespace prefixes that are available for interpreting QNames within the scope of the element. For a given element, one namespace binding may have an empty prefix; the URI of this namespace binding is the default namespace within the scope of the element.]</p><span class="xpath"><div class="xpath"><p class="xpath">In <a href="#XPath">[XPath 1.0]</a>, the in-scope namespaces of an element node are represented by a collection of <b>namespace nodes</b> arranged on a <b>namespace axis</b>. In XPath Version 2.0, the namespace axis is deprecated and need not be supported by a host language. A host language that does not support the namespace axis need not represent namespace bindings in the form of nodes.</p></div></span><span class="xquery"><div class="note"><p class="prefix"><b>Note:</b></p><p>In <a href="#XPath">[XPath 1.0]</a>, the in-scope namespaces of an element node are represented by a collection of <b>namespace nodes</b> arranged on a <b>namespace axis</b>, which is optional and deprecated in <a href="#XPath20">[XPath 2.0]</a>. XQuery does not support the namespace axis and does not represent namespace bindings in the form of nodes. However, where other specifications such as <a href="#serialization">[XSLT 2.0 and XQuery 1.0 Serialization]</a> refer to namespace nodes, these nodes may be synthesized from the in-scope namespaces of an element node by interpreting each namespace binding as a namespace node.</p></div></span><p>[<a title="URI" id="dt-URI" name="dt-URI">Definition</a>: Within this specification, the term <b>URI</b> refers to a Universal Resource Identifier as
defined in <a href="#RFC3986">[RFC3986]</a> and extended in <a href="#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.]  The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as "Base URI" that are defined or referenced across the whole family of XML specifications.</p><div class="div2">
<h3><a id="context" name="context"></a>2.1 Expression Context</h3><p>[<a title="expression context" id="dt-expression-context" name="dt-expression-context">Definition</a>: The <b>expression context</b> for a given expression consists of
		all the information that can affect the result of the expression.] This
		information is organized into two categories called
	 the <a title="static context" href="#dt-static-context">static
		context</a> and the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a>.</p><div class="div3">
<h4><a id="static_context" name="static_context"></a>2.1.1 Static Context</h4><p>[<a title="static context" id="dt-static-context" name="dt-static-context">Definition</a>: The <b>static context</b> of an expression is
		  the information that is available during static analysis of the expression, prior
		  to its evaluation.] This information can be used to decide whether the
		  expression contains a <a title="static error" href="#dt-static-error">static error</a>.
		  If analysis of an 
expression relies on some component of the <a title="static context" href="#dt-static-context">static context</a> that has not been 
assigned a value, a <a title="static error" href="#dt-static-error">static
		  error</a> is raised [<a title="err:XPST0001" href="#ERRXPST0001">err:XPST0001</a>].</p><p>The individual components of the <a title="static context" href="#dt-static-context">static context</a> are summarized below. <span class="xpath"><span class="xpath"><span class="xpath">A default initial value for each component may be specified by the host language. The scope of each component is specified in <a href="#id-xp-static-context-components"><b>D.1 Static Context
Components</b></a>.</span></span></span> <span class="xquery"><span class="xquery"><span class="xquery">Rules governing the scope and initialization of  these components can be found in  <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>.</span></span></span></p><ul><li><p>[<a title="XPath 1.0 compatibility     mode" id="dt-xpath-compat-mode" name="dt-xpath-compat-mode">Definition</a>: <b>XPath 1.0 compatibility
			 mode.</b> <span class="xquery"><span class="xquery"><span class="xquery">This
			 component must be set by all host languages
			 that include XPath 2.0  as a subset,
			 indicating whether rules for compatibility
			 with XPath 1.0 are in effect.
			 XQuery sets the value of this component to
			 <code>false</code>.
                         </span></span></span> <span class="xpath"><span class="xpath"><span class="xpath">This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is <code>false</code>.</span></span></span>]</p></li><li><p>[<a title="statically known namespaces" id="dt-static-namespaces" name="dt-static-namespaces">Definition</a>: <b>Statically known namespaces.</b> This is a set of (prefix,
				URI) pairs that define all the namespaces that are known during static processing of a given expression.] The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="#XMLSchema">[XML Schema]</a>. Note the difference between <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a>, which is a dynamic property of an element node, and <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, which is a static property of an expression.</p><span class="xquery"><div class="xquery"><p class="xquery">Some namespaces are predefined; additional  namespaces can be added to the statically known namespaces by <a title="namespace declaration" href="#dt-namespace-declaration">namespace declarations</a> in a <a title="Prolog" href="#dt-prolog">Prolog</a> and by <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attributes</a> in <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructors</a>.</p></div></span></li><li><p>[<a title="default element/type namespace" id="dt-def-elemtype-ns" name="dt-def-elemtype-ns">Definition</a>: <b>Default element/type namespace.</b> This is a
				namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a
				position where an element or type name is expected.] The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="#XMLSchema">[XML Schema]</a>.</p></li><li><p>[<a title="default function namespace" id="dt-def-fn-ns" name="dt-def-fn-ns">Definition</a>: <b>Default function namespace.</b> This is a
				namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.] The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="#XMLSchema">[XML Schema]</a>.</p></li><li><p>[<a title="in-scope schema definitions" id="dt-issd" name="dt-issd">Definition</a>: <b>In-scope schema
			 definitions.</b> This is a generic term
			 for all the element declarations, attribute declarations, and schema type
			 definitions that are in scope during
			 processing of an expression.] It includes the
			 following three
			 parts:</p><ul><li><p>

			        [<a title="in-scope schema type" id="dt-is-types" name="dt-is-types">Definition</a>: <b>In-scope schema types.</b> Each schema type
			        definition is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded
			        QName</a> (for a <b>named type</b>)
			        or by an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> type
			        identifier (for an <b>anonymous
			        type</b>). The in-scope schema types include the predefined schema types described in <a href="#id-predefined-types"><b>2.5.1 Predefined Schema Types</b></a>.

                                <span class="xquery"><span class="xquery"><span class="xquery">If the
                                <a title="schema import feature" href="#dt-schema-import-feature">Schema Import Feature</a> is
                                supported, in-scope schema types
                                also include all type definitions
                                found in imported schemas.</span></span></span>

                         ]</p></li><li><p>[<a title="in-scope element declarations" id="dt-is-elems" name="dt-is-elems">Definition</a>: <b>In-scope element declarations.</b> Each element
declaration is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level element
declaration) or by an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a
local element declaration). <span class="xquery"><span class="xquery"><span class="xquery"> If the <a title="schema import feature" href="#dt-schema-import-feature">Schema Import Feature</a> is
supported, in-scope element declarations include all element
declarations found in imported schemas. </span></span></span>] An element
declaration includes information about the element's <a title="substitution group" href="#dt-substitution-group">substitution group</a> affiliation.</p><p>[<a title="substitution group" id="dt-substitution-group" name="dt-substitution-group">Definition</a>: <b>Substitution groups</b> are defined in <a href="#XMLSchema">[XML Schema]</a> Part 1,  Section 2.2.2.2. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of  the set of elements that can be substituted for the head element without affecting the outcome of schema validation.]</p></li><li><p>[<a title="in-scope attribute declarations" id="dt-is-attrs" name="dt-is-attrs">Definition</a>: <b>In-scope attribute
declarations.</b> Each attribute declaration is identified either
by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an
<a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute
declaration).  <span class="xquery"><span class="xquery"><span class="xquery">If the <a title="schema import feature" href="#dt-schema-import-feature">Schema Import Feature</a> is
supported, in-scope attribute declarations include all attribute
declarations found in imported
schemas.</span></span></span>]</p></li></ul></li><li><p>
[<a title="in-scope variables" id="dt-in-scope-variables" name="dt-in-scope-variables">Definition</a>: <b>In-scope variables.</b> This is a set of (expanded QName, type) pairs. It defines the
set of variables that are available for reference within an
expression. The <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the
<a title="static type" href="#dt-static-type">static type</a> of the
variable.]</p><p><span class="xquery"><span class="xquery"><span class="xquery">Variable declarations
in a <a title="Prolog" href="#dt-prolog">Prolog</a> are added to <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a>.</span></span></span> An expression that binds a variable (such as a
<span class="xquery"><span class="xquery"><span class="xquery"><code>let</code>,</span></span></span> <code>for</code>,
<code>some</code>, or <code>every</code> expression) extends the
<a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> of its subexpressions with the new bound variable
and its type. <span class="xquery"><span class="xquery"><span class="xquery">Within a <b>function
declaration</b>, the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> are extended by the names
and types of the <b>function parameters</b>.</span></span></span></p><span class="xquery"><div class="xquery"><p class="xquery">The static type of a variable may be either declared in a query or (if the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a> is enabled) inferred by static type inference rules as described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p></div></span></li><li><p>[<a title="context item static type" id="dt-context-item-static-type" name="dt-context-item-static-type">Definition</a>: <b>Context item static type.</b> This component defines the <a title="static type" href="#dt-static-type">static type</a> of the context item within the scope of a given expression.]</p></li><li><p>[<a title="function signature" id="dt-function-signature" name="dt-function-signature">Definition</a>: <b>Function signatures.</b> This component defines the set of functions that are available
				to be called from within an
			 expression. Each function is uniquely
			 identified by its <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and its arity (number
			 of parameters).] In addition to the name and arity, each function signature specifies the <a title="static type" href="#dt-static-type">static types</a> of the function parameters and  result.</p><p>The <a title="function signature" href="#dt-function-signature">function signatures</a> include the signatures of <a title="constructor function" href="#dt-constructor-function">constructor functions</a>, which are
                         discussed in <a href="#id-constructor-functions"><b>3.13.5 Constructor
Functions</b></a>.</p></li><li><p> [<a title="statically known collations" id="dt-static-collations" name="dt-static-collations">Definition</a>: <b>Statically known collations.</b> This is an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> set of (URI,
				collation) pairs. It defines the names of the collations that are available for
				use in processing <span class="xquery"><span class="xquery"><span class="xquery">queries and</span></span></span> expressions.] [<a title="collation" id="dt-collation" name="dt-collation">Definition</a>: A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.]</p></li><li><p> [<a title="default collation" id="dt-def-collation" name="dt-def-collation">Definition</a>: <b>Default
				collation.</b> This identifies one of the collations in <a title="statically known collations" href="#dt-static-collations">statically known collations</a> as the  collation to be
				used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no
				explicit collation is
				specified.]</p></li><span class="xquery"><li class="xquery"><p>[<a title="construction mode" id="dt-construction-mode" name="dt-construction-mode">Definition</a>: <b>Construction mode.</b> The
			 construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction    retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xdt:untyped</code>; all element nodes copied during node construction receive the type <code>xdt:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xdt:untypedAtomic</code>.]</p></li></span><span class="xquery"><li class="xquery"><p>[<a title="ordering mode" id="dt-ordering-mode" name="dt-ordering-mode">Definition</a>: <b>Ordering mode.</b> Ordering mode, which has the value <code>ordered</code> or <code>unordered</code>, affects the ordering of the result sequence returned by certain <a title="path expression" href="#dt-path-expression">path expressions</a>, <code>union</code>, <code>intersect</code>, and <code>except</code> expressions, and FLWOR expressions that have no <code>order by</code> clause.] Details are provided in the descriptions of these expressions.</p></li></span><span class="xquery"><li class="xquery"><p>[<a title="default order for empty sequences" id="dt-default-empty-order" name="dt-default-empty-order">Definition</a>: <b>Default order for empty sequences.</b> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <a href="#id-orderby-return"><b>3.9.3 Order By and Return Clauses</b></a>.]  Its value may be <code>greatest</code> or <code>least</code>.</p></li></span><span class="xquery"><li class="xquery"><p>[<a title="boundary-space policy" id="dt-boundary-space-policy" name="dt-boundary-space-policy">Definition</a>: <b>Boundary-space
			 policy.</b> This component controls the processing of <a title="boundary whitespace" href="#dt-boundary-whitespace">boundary whitespace</a>
			 by <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructors</a>, as described in <a href="#id-whitespace"><b>3.7.1.4 Boundary Whitespace</b></a>.] Its value may be <code>preserve</code> or <code>strip</code>.</p></li></span><span class="xquery"><li class="xquery"><p>[<a title="copy-namespaces mode" id="dt-copy-namespaces-mode" name="dt-copy-namespaces-mode">Definition</a>: <b>Copy-namespaces mode.</b> This component controls the namespace bindings that 
are assigned when an existing element node is copied by an element 
constructor, as described in <a href="#id-element-constructor"><b>3.7.1 Direct Element Constructors</b></a>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.]</p></li></span><li><p>[<a title="base URI" id="dt-base-uri" name="dt-base-uri">Definition</a>: <b>Base URI.</b> This is an absolute URI, used when necessary in the resolution of relative URIs (for example, by the <code>fn:resolve-uri</code> function.)] The URI value is 
whitespace normalized according to the rules for the <code>xs:anyURI</code> type in <a href="#XMLSchema">[XML Schema]</a>.</p></li><li><p> [<a title="statically known  documents" id="dt-known-docs" name="dt-known-docs">Definition</a>: <b>Statically known documents.</b> This is a mapping
from strings onto types.  The string represents the absolute URI of a
resource that is potentially available using the <code>fn:doc</code>
function.  The type is the <a title="static type" href="#dt-static-type">static type</a> of a call to <code>fn:doc</code>  with the given URI as its
literal argument. ] 
If the argument to <code>fn:doc</code> is a
string literal that is not present in <b>statically known documents</b>, then the
<a title="static type" href="#dt-static-type">static type</a> of
<code>fn:doc</code> is <code>document-node()?</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The purpose of the <b>statically known
documents</b> is to provide static type information, not to determine
which documents are available. A URI need not be found in the
<b>statically known documents</b> to be accessed using
<code>fn:doc</code>. </p></div></li><li><p>[<a title="statically known  collections" id="dt-known-collections" name="dt-known-collections">Definition</a>: <b>Statically known collections.</b> This is a
mapping from strings onto types.  The string represents the absolute
URI of a resource that is potentially available using the
<code>fn:collection</code> function.  The type is the type of the
sequence of nodes that would result from calling the
<code>fn:collection</code> function with this URI as its
argument.] If the argument to
<code>fn:collection</code> is a string literal that is not present in
<b>statically known collections</b>, then the <a title="static type" href="#dt-static-type">static type</a> of
<code>fn:collection</code> is <code>node()*</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The purpose of the <b>statically known
collections</b> is to provide static type information, not to determine
which collections are available. A URI need not be found in the
<b>statically known collections</b> to be accessed using
<code>fn:collection</code>. 
</p></div></li><li><p>[<a title="statically known default collection type" id="dt-known-default-collection" name="dt-known-default-collection">Definition</a>: <b>Statically known default collection type.</b> This is the type of the sequence of nodes that would result from calling the <code>fn:collection</code> function with no arguments.] Unless initialized to some other value by an implementation, the value of <b>statically known default collection type</b> is <code>node()*</code>.</p></li></ul></div><div class="div3">
<h4><a id="eval_context" name="eval_context"></a>2.1.2 Dynamic Context</h4><p>[<a title="dynamic context" id="dt-dynamic-context" name="dt-dynamic-context">Definition</a>: The <b>dynamic
context</b> of an expression is defined as information that is
available at the time the expression is evaluated.] If
evaluation of an expression relies on some part of the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> that has not been
assigned a value, a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised [<a title="err:XPDY0002" href="#ERRXPDY0002">err:XPDY0002</a>].</p><p>The individual
components of the <a title="dynamic context" href="#dt-dynamic-context">dynamic
context</a> are summarized below. Further rules governing the
semantics of these components can be found in <a href="#id-xq-evaluation-context-components"><b>C.2 Dynamic Context Components</b></a><a href="#id-xp-evaluation-context-components"><b>D.2 Dynamic Context Components</b></a>.</p><p>The
<a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> consists
of all the components of the <a title="static context" href="#dt-static-context">static
context</a>, and the additional components listed below.</p><p>[<a title="focus" id="dt-focus" name="dt-focus">Definition</a>: The first three components of
the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a>
(context item, context position, and context size) are called the
<b>focus</b> of the expression. ] The focus enables the
processor to keep track of which items are being processed by the
expression.</p><p>Certain language constructs, notably the <a title="path expression" href="#dt-path-expression">path
expression</a> <code>E1/E2</code> and the <a title="filter expression" href="#dt-filter-expression">filter
expression</a> <code>E1[E2]</code>, create a new focus
for the evaluation of a sub-expression. In these constructs, <code>E2</code> is evaluated once for each item in the
sequence that results from evaluating <code>E1</code>. Each time <code>E2</code> is evaluated, it is evaluated with a
different focus. The focus for evaluating <code>E2</code> is referred to below as the <b>inner
focus</b>, while the focus for evaluating <code>E1</code> is referred to as the <b>outer
focus</b>. The inner focus exists only while <code>E2</code> is being evaluated. When this evaluation
is complete, evaluation of the containing expression continues with
its original focus unchanged.</p><ul><li><p>[<a title="context item" id="dt-context-item" name="dt-context-item">Definition</a>: The <b>context item</b>
is the item currently being processed. An item is
either an atomic value or a node.][<a title="context node" id="dt-context-node" name="dt-context-node">Definition</a>: When the context item is a
node, it can also be referred to as the <b>context
node</b>.] The context item is returned by an expression
consisting of a single dot (<code>.</code>). When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, each item in the
sequence obtained by evaluating <code>E1</code>
becomes the context item in the inner focus for an evaluation of <code>E2</code>. </p></li><li><p>[<a title="context position" id="dt-context-position" name="dt-context-position">Definition</a>: The <b>context
position</b> is the position of the context item within the
sequence of items currently being processed.] It changes whenever the context item
changes. Its value is always an integer greater than zero. The context
position is returned by the expression <code>fn:position()</code>. When an expression <code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context position in
the inner focus for an evaluation of <code>E2</code>
is the position of the context item in the sequence obtained by
evaluating <code>E1</code>. The position of the
first item in a sequence is always 1 (one). The context position is
always less than or equal to the context size.</p></li><li><p>[<a title="context size" id="dt-context-size" name="dt-context-size">Definition</a>: The <b>context
size</b> is the number of items in the sequence of items currently
being processed.] Its value is always an
integer greater than zero. The context size is returned by the
expression <code>fn:last()</code>. When an expression
<code>E1/E2</code> or <code>E1[E2]</code> is evaluated, the context size in the
inner focus for an evaluation of <code>E2</code> is
the number of items in the sequence obtained by evaluating <code>E1</code>. </p></li><li><p> [<a title="variable values" id="dt-variable-values" name="dt-variable-values">Definition</a>: <b>Variable values</b>. This is a set of
				(expanded QName, value) pairs. It contains the
				same <a title="expanded QName" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> in the
				<a title="static context" href="#dt-static-context">static context</a> for the expression. The expanded QName is the name of the variable and the value is the dynamic value of the variable, which includes its <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>.]</p></li><li><p>[<a title="function implementation" id="dt-function-implementation" name="dt-function-implementation">Definition</a>: <b>Function implementations</b>. Each function in <a title="function signature" href="#dt-function-signature">function signatures</a> has a function implementation that enables the function to map instances of its parameter types into an instance of its result type. <span class="xquery"><span class="xquery"><span class="xquery">For a
			 <a title="user-defined function" href="#dt-udf">user-defined function</a>, the
			 function implementation is an XQuery
			 expression. For a <a title="built-in function" href="#dt-built-in-function">built-in function</a> or <a title="external function" href="#dt-external-function">external
			 function</a>, the function implementation is
			 <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</span></span></span>]</p></li><li><p> [<a title="current dateTime" id="dt-date-time" name="dt-date-time">Definition</a>: <b>Current dateTime.</b> This information represents
				an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> point in time during the processing of <span class="xquery"><span class="xquery"><span class="xquery">a query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">an expression</span></span></span>, and includes an explicit timezone. It can be retrieved by the  <code>fn:current-dateTime</code> function. If invoked multiple times during the execution of <span class="xquery"><span class="xquery"><span class="xquery">a query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">an expression</span></span></span>,
				this function always returns the same result.]</p></li><li><p>[<a title="implicit timezone" id="dt-timezone" name="dt-timezone">Definition</a>: <b>Implicit timezone.</b> This is the timezone to be used when a date,
time, or dateTime value that does not have a timezone is used in a
comparison or arithmetic operation. The implicit timezone is an  <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> value of type
<code>xdt:dayTimeDuration</code>. See <a href="#XMLSchema">[XML Schema]</a> for the range of legal values
                         of a timezone.]</p></li><li><p>[<a title="available documents" id="dt-available-docs" name="dt-available-docs">Definition</a>: <b>Available
                         documents.</b> This is a mapping of
                         strings onto document nodes.  The string
                         represents the absolute URI of a
                         resource. The document node is the root of a tree that represents that resource using the <a title="data model" href="#dt-datamodel">data model</a>. The document node is returned by the <code>fn:doc</code> function when applied to that URI.] The set of available
                         documents is not limited to the set of <a title="statically known  documents" href="#dt-known-docs">statically known
                         documents</a>, and it may be
                         empty.</p></li><li><p>[<a title="available collections" id="dt-available-collections" name="dt-available-collections">Definition</a>: <b>Available
                         collections.</b> This is a mapping of
                         strings onto sequences of nodes. The string
                         represents the absolute URI of a
                         resource. The sequence of nodes represents
                         the result of the <code>fn:collection</code>
                         function when that URI is supplied as the
                         argument. ] The set of available
                         collections is not limited to the set of <a title="statically known  collections" href="#dt-known-collections">statically known
                         collections</a>, and it may be empty.</p></li><li><p>[<a title="default collection" id="dt-default-collection" name="dt-default-collection">Definition</a>: <b>Default collection.</b> This is the sequence of nodes that would result from calling the <code>fn:collection</code> function with no arguments.] The value of <b>default collection</b> may be initialized by the implementation.</p></li></ul></div></div><div class="div2">
<h3><a id="id-processing-model" name="id-processing-model"></a>2.2 Processing
                         Model</h3><p>[XPath/XQuery] is defined in terms
                         of the <a title="data model" href="#dt-datamodel">data
                         model</a> and the <a title="expression context" href="#dt-expression-context">expression
                         context</a>.</p><span class="xquery"><img src="ProcMod-XQuery.gif" alt="Processing                          Model Overview"></span><span class="xpath"><img src="ProcMod-XPath.gif" alt="Processing                          Model Overview"></span><p>Figure 1:
                         Processing Model Overview</p><p>Figure 1 provides a schematic overview of the processing steps that
are discussed in detail below. Some of these steps are completely
outside the domain of [XPath/XQuery]; in Figure 1, these are depicted
outside the line that represents the boundaries of the language, an
area labeled <b>external processing</b>. The external processing
domain includes generation of a <a title="data model instance" href="#dt-data-model-instance">data model instance</a> that represents the data to be queried (see <a href="#id-data-model-generation"><b>2.2.1 Data Model Generation</b></a>), schema import processing (see
<a href="#id-schema-import-processing"><b>2.2.2 Schema Import
Processing</b></a>) and serialization (see
<a href="#id-serialization"><b>2.2.4 Serialization</b></a>). The area inside the boundaries of
the language is known as the <span class="xquery"><span class="xquery"><span class="xquery"><b>query processing domain</b></span></span></span><span class="xpath"><span class="xpath"><span class="xpath"><b>XPath processing domain</b></span></span></span>, which includes the static
analysis and dynamic evaluation phases (see <a href="#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>).  Consistency constraints on the
<span class="xquery"><span class="xquery"><span class="xquery">query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">XPath</span></span></span> processing domain are defined in <a href="#id-consistency-constraints"><b>2.2.5 Consistency Constraints</b></a>.</p><div class="div3">
<h4><a id="id-data-model-generation" name="id-data-model-generation"></a>2.2.1 Data Model Generation</h4><p>Before <span class="xquery"><span class="xquery"><span class="xquery">a query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">an expression</span></span></span> can be processed, its input data must be represented as a <a title="data model instance" href="#dt-data-model-instance">data model instance</a>. This process occurs outside
the domain of [XPath/XQuery], which is why Figure 1 represents it in the
external processing domain. Here are some steps by which an XML
document might be converted to a <a title="data model instance" href="#dt-data-model-instance">data
model instance</a>:</p><ol class="enumar"><li><p>A document may be parsed using an XML parser that
generates an <b>XML Information Set</b> (see <a href="#XINFO">[XML Infoset]</a>). The parsed document may then be validated against one
or more schemas. This process, which is described in <a href="#XMLSchema">[XML Schema]</a>, results in an abstract information structure called
the <b>Post-Schema Validation Infoset</b> (PSVI). If a document
has no associated schema, its Information Set is preserved. (See DM1
in Fig. 1.)</p></li><li><p>The Information Set or PSVI may be
transformed into a <a title="data model instance" href="#dt-data-model-instance">data model instance</a>
by a process described in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. (See DM2 in
Fig. 1.)</p></li></ol><p>The above steps provide an example of how a <a title="data model instance" href="#dt-data-model-instance">data model instance</a> might be constructed. A data model instance might
also be synthesized directly from a relational database, or
constructed in some other way (see DM3 in Fig. 1.) [XPath/XQuery] is defined in terms
of the <a title="data model" href="#dt-datamodel">data model</a>,
but it does not place any constraints on how data model instances are constructed.</p><p>[<a title="type annotation" id="dt-type-annotation" name="dt-type-annotation">Definition</a>: Each element node and attribute node in a <a title="data model instance" href="#dt-data-model-instance">data model instance</a> has a <b>type annotation</b> (referred to in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> as its <code>type-name</code> property.) The type annotation of a node is a <a title="schema type" href="#dt-schema-type">schema type</a> that describes the relationship between the <a title="string value" href="#dt-string-value">string value</a> of the node and its <a title="typed value" href="#dt-typed-value">typed value</a>.]  If the <a title="data model instance" href="#dt-data-model-instance">data
model instance</a> was derived from a validated XML document as described in <a href="http://www.w3.org/TR/xpath-datamodel/#const-psvi">Section 
3.3 Construction from a PSVI</a><sup><small>DM</small></sup>, the type annotations of the element and attribute nodes are derived from schema
validation. [XPath/XQuery] does
not provide a way to directly access the type annotation of an element
or attribute node.</p><p>The value of an attribute is represented directly within the
attribute node. An attribute node whose type is unknown (such as might
occur in a schemaless document) is given the <a title="type annotation" href="#dt-type-annotation">type annotation</a>
<code>xdt:untypedAtomic</code>.</p><p>The value of an element is represented by the children of the
element node, which may include text nodes and other element
nodes. The <a title="type annotation" href="#dt-type-annotation">type annotation</a> of an element node indicates how the values in
its child text nodes are to be interpreted. An element that has not been validated (such as might occur in a schemaless document) is annotated
with the schema type <code>xdt:untyped</code>. An element that has been validated and found to be partially valid is annotated with the schema type <code>xs:anyType</code>. If an element node is annotated as <code>xdt:untyped</code>, all its descendant element nodes are also annotated as <code>xdt:untyped</code>. However, if an element node is annotated as <code>xs:anyType</code>, some of its descendant element nodes may have a more specific <a title="type annotation" href="#dt-type-annotation">type annotation</a>.</p></div><div class="div3">
<h4><a id="id-schema-import-processing" name="id-schema-import-processing"></a>2.2.2 Schema Import
Processing</h4><span class="xquery"><div class="xquery"><p class="xquery">The <a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a> in the <a title="static context" href="#dt-static-context">static context</a> may be extracted from
actual XML schemas as described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a> (see step SI1 in Figure 1) or may be
generated by some other mechanism (see step SI2 in Figure 1). In
either case, the result must satisfy the consistency constraints
defined in <a href="#id-consistency-constraints"><b>2.2.5 Consistency Constraints</b></a>.</p></div></span><span class="xpath"><div class="xpath"><p class="xpath">The <a title="in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a> in the <a title="static context" href="#dt-static-context">static
context</a> are provided by the host language (see step SI1 in
Figure 1) and must satisfy the consistency constraints defined in
<a href="#id-consistency-constraints"><b>2.2.5 Consistency Constraints</b></a>.

</p></div></span></div><div class="div3">
<h4><a id="id-expression-processing" name="id-expression-processing"></a>2.2.3 Expression
Processing</h4><p>[XPath/XQuery] defines two phases of processing called
the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>
and the <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
phase</a> (see Fig. 1).  During the static analysis phase, <a title="static error" href="#dt-static-error">static errors</a>,  <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>, or <a title="type error" href="#dt-type-error">type errors</a> may be raised. During the dynamic evaluation phase, only <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a> or <a title="type error" href="#dt-type-error">type errors</a> may be raised. These kinds of errors are defined in <a href="#id-kinds-of-errors"><b>2.3.1 Kinds of Errors</b></a>.  </p><p>Within each phase, an implementation is free to use any
strategy or algorithm whose result conforms to the
specifications in this document.</p><div class="div4">
<h5><a id="id-static-analysis" name="id-static-analysis"></a>2.2.3.1 Static Analysis Phase</h5><p>[<a title="static analysis phase" id="dt-static-analysis" name="dt-static-analysis">Definition</a>: The
<b>static analysis phase</b> depends on the expression itself
and on the <a title="static context" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does
not depend on input data (other than schemas).]</p><p>During the static analysis phase, the <span class="xquery"><span class="xquery"><span class="xquery">query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">XPath expression</span></span></span> is parsed into an
internal representation called the <b>operation tree</b> (step
SQ1 in Figure 1).  A parse error is raised as a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XPST0003" href="#ERRXPST0003">err:XPST0003</a>]. The <a title="static context" href="#dt-static-context">static context</a> is initialized by the implementation (step SQ2). <span class="xquery"><span class="xquery"><span class="xquery">The <a title="static context" href="#dt-static-context">static context</a> is then changed and augmented based on information in the  <b>prolog</b> (step SQ3). If the <a title="schema import feature" href="#dt-schema-import-feature">Schema Import Feature</a> is supported, the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> are populated with information from imported schemas. If the <a title="module feature" href="#dt-module-feature">Module 
Feature</a> is supported, the static context is extended with function 
declarations and variable declarations from imported modules.</span></span></span> The <a title="static context" href="#dt-static-context">static context</a> is used to resolve schema type names, function names, namespace prefixes, and variable names (step
SQ4). 
If a name of one of these kinds in the <b>operation tree</b> is
not found in the <a title="static context" href="#dt-static-context">static context</a>, a <a title="static error" href="#dt-static-error">static error</a> ([<a title="err:XPST0008" href="#ERRXPST0008">err:XPST0008</a>] or [<a title="err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>]) is raised (however, see exceptions to this rule in <a href="#id-element-test"><b>2.5.4.3 Element Test</b></a> and <a href="#id-attribute-test"><b>2.5.4.5 Attribute Test</b></a>.)</p><p>The <b>operation tree</b> is then
<b>normalized</b> by making explicit the implicit operations
such as <a title="atomization" href="#dt-atomization">atomization</a>,
<a title="type promotion" href="#dt-type-promotion">type promotion</a>, and extraction of <a title="effective boolean value" href="#dt-ebv">Effective Boolean Values</a> (step SQ5). The
normalization process is described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p><p> Each expression is then assigned a <a title="static type" href="#dt-static-type">static type</a> (step SQ6). 
[<a title="static type" id="dt-static-type" name="dt-static-type">Definition</a>: The <b>static type</b> of an expression is a type such that, when the expression is evaluated, the resulting value will always conform to the static type.]
If the <span class="xquery"><a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a></span><span class="xpath"><a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a></span> is supported, the <a title="static type" href="#dt-static-type">static types</a> of various expressions are inferred according to the rules described in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>. If the <span class="xquery"><a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a></span><span class="xpath"><a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a></span> is not supported, the static types that are assigned are <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p> During the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>, if the <span class="xquery"><a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a></span><span class="xpath"><a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a></span>
 is in effect and an operand of an expression is found to have
a <a title="static type" href="#dt-static-type">static type</a> that is not appropriate for that operand, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].  If static type
checking raises no errors and assigns a <a title="static type" href="#dt-static-type">static type</a> T to an
expression, then execution of the expression on valid input data is
guaranteed either to produce a value of type T or to raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p><p>The purpose of the  <span class="xquery"><a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a></span><span class="xpath"><a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a></span> is to provide early detection of <a title="type error" href="#dt-type-error">type errors</a> and to infer type information that may be useful in optimizing the evaluation of an expression.</p></div><div class="div4">
<h5><a id="id-dynamic-evaluation" name="id-dynamic-evaluation"></a>2.2.3.2 Dynamic Evaluation Phase</h5><p>[<a title="dynamic evaluation phase" id="dt-dynamic-evaluation" name="dt-dynamic-evaluation">Definition</a>: The <b>dynamic evaluation phase</b> is the phase during which the value of an expression is computed.] It occurs after completion of the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>.</p><p>The dynamic evaluation phase can occur only if no errors were detected during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>. If the <span class="xquery"><a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a></span><span class="xpath"><a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a></span> is in effect, all <a title="type error" href="#dt-type-error">type errors</a> are detected during static analysis and serve to inhibit the dynamic evaluation phase.</p><p>The dynamic evaluation phase depends on the <b>operation
tree</b> of the expression being evaluated (step DQ1), on the input
data (step DQ4), and on the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> (step DQ5), which in turn draws information from  the external environment (step DQ3) and the <a title="static context" href="#dt-static-context">static context</a> (step DQ2). The dynamic evaluation phase may create new data-model values (step DQ4) and it may extend the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> (step DQ5)&mdash;for example, by binding values to variables.</p><p>[<a title="dynamic type" id="dt-dynamic-type" name="dt-dynamic-type">Definition</a>: A <b>dynamic type</b> is associated with each value as it is computed. The dynamic type of a value may be more specific than the <a title="static type" href="#dt-static-type">static type</a> of the expression that computed it (for example, the  static type of an expression might be <code>xs:integer*</code>, denoting a sequence of zero or more integers, but at evaluation time its value may have the dynamic type <code>xs:integer</code>, denoting exactly one integer.)]</p><p> If an operand of an expression is found
to have a <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> that is not appropriate for that operand, a
<a title="type error" href="#dt-type-error">type error</a> is
raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p><p>Even though static typing can catch many <a title="type error" href="#dt-type-error">type errors</a> before an expression is executed, it is possible for an expression to raise an error during evaluation that was not detected by static  analysis. For example, an expression may contain a cast of a string into an integer, which is statically valid. However, if the actual value of the string at run time cannot be cast into an integer, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> will result. Similarly, an expression may apply an arithmetic operator to a value whose <a title="static type" href="#dt-static-type">static type</a> is <code>xdt:untypedAtomic</code>. This is not a <a title="static error" href="#dt-static-error">static error</a>, but at run time, if the value cannot be successfully cast to a <a title="numeric" href="#dt-numeric">numeric</a> type, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> will be raised.</p><p>When the <span class="xquery"><a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a></span><span class="xpath"><a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a></span> is in effect, it is also possible for static analysis of an expression to raise a <a title="type error" href="#dt-type-error">type error</a>, even though execution of the expression on certain inputs would be successful. For example, an expression might contain a function that requires an element as its parameter, and the static analysis phase might infer the <a title="static type" href="#dt-static-type">static type</a> of the function parameter to be an optional element. This case is treated as a <a title="type error" href="#dt-type-error">type error</a> and inhibits evaluation, even though the function call would have been successful for input data in which the optional element is present.</p></div></div><div class="div3">
<h4><a id="id-serialization" name="id-serialization"></a>2.2.4 Serialization</h4><p>[<a title="serialization" id="dt-serialization" name="dt-serialization">Definition</a>: <b>Serialization</b> is the process of converting a <a title="data model instance" href="#dt-data-model-instance">data model instance</a> into a sequence of octets (step DM4 in Figure 1.) ] The general
framework for serialization is described in <a href="#serialization">[XSLT 2.0 and XQuery 1.0 Serialization]</a>.</p><span class="xpath"><div class="xpath"><p class="xpath">The host language may provide a serialization option.</p></div></span><span class="xquery"><div class="xquery"><p class="xquery">An XQuery implementation is not required to provide a serialization interface. For example, an implementation may only provide
a DOM interface (see <a href="#DOM">[Document Object Model]</a>) or an interface based on an event stream. In these cases, serialization would be outside of the scope of this
specification.</p></div></span><span class="xquery"><div class="xquery"><p class="xquery"><a href="#serialization">[XSLT 2.0 and XQuery 1.0 Serialization]</a>
defines a set of <b>serialization parameters</b> that govern the
serialization process. If an XQuery implementation provides a serialization interface, it may support (and may expose to users) any of the serialization parameters listed (with default values) in <a href="#id-xq-serialization-parameters"><b>C.3 Serialization Parameters</b></a>. An XQuery implementation that provides a serialization interface must support some combination of serialization parameters in which <code>method = "xml"</code> and <code>version = "1.0"</code>.</p></div></span><span class="xquery"><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="data model" href="#dt-datamodel">data model</a> permits an element node to have fewer <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a> 
than its parent. Correct serialization of such an element node would 
require "undeclaration" of namespaces, which is a feature of <a href="#XMLNAMES11">[XML Names 1.1]</a>. An implementation that does not support <a href="#XMLNAMES11">[XML Names 1.1]</a> is permitted 
to serialize such an element without "undeclaration" of namespaces, which 
effectively causes the element to inherit the in-scope namespaces of its 
parent.</p></div></span></div><div class="div3">
<h4><a id="id-consistency-constraints" name="id-consistency-constraints"></a>2.2.5 Consistency Constraints</h4><p>In order for [XPath/XQuery] to
be well defined, the input <a title="data model instance" href="#dt-data-model-instance">data model instance</a>, the <a title="static context" href="#dt-static-context">static context</a>, and the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> must be mutually
consistent. The consistency constraints listed below are prerequisites
for correct functioning of an [XPath/XQuery] implementation. Enforcement
of these consistency constraints is beyond the scope of this
specification. This specification does not
define the result of  <span class="xquery"><span class="xquery"><span class="xquery">a query</span></span></span> <span class="xpath"><span class="xpath"><span class="xpath">an expression</span></span></span> under any condition in which one
or more of these constraints is not satisfied.</p><p>Some of the consistency constraints use the term
<b>data model schema</b>. [<a title="data model schema" id="dt-data-model-schema" name="dt-data-model-schema">Definition</a>: For a given node in a <a title="data model instance" href="#dt-data-model-instance">data model instance</a>, the
<b>data model schema</b> is defined as the schema from which the
<a title="type annotation" href="#dt-type-annotation">type annotation</a> of that node was derived.] For a node that was constructed by some
process other than schema validation, the <b>data model schema</b>
consists simply of the schema type definition that is represented by the <a title="type annotation" href="#dt-type-annotation">type annotation</a> of the node.</p><ul><li><p>For every  node that has a type annotation, if that type annotation is found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> (ISSD), then its definition in the ISSD must be equivalent to its definition in the <a title="data model schema" href="#dt-data-model-schema">data model schema</a>. Furthermore, all types that are derived by extension from the given type in the <a title="data model schema" href="#dt-data-model-schema">data model schema</a> must also be known by equivalent definitions in the ISSD.</p></li><li><p>For every element name <em>EN</em> that is found both in a <a title="data model instance" href="#dt-data-model-instance">data model instance</a> and in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> (ISSD), all elements that are known in the <a title="data model schema" href="#dt-data-model-schema">data model schema</a> to be in the <a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by <em>EN</em> must also be known in the ISSD to be in the <a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by <em>EN</em>.</p></li><li><p>Every element name, attribute name, or schema type name referenced in <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> or <a title="function signature" href="#dt-function-signature">function signatures</a> must be in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, unless it is an element name referenced as part of an <a href="#doc-xpath-ElementTest">ElementTest</a> or an attribute name referenced as part of an <a href="#doc-xpath-AttributeTest">AttributeTest</a>.</p></li><li><p>Any reference to a global element, attribute, or type name in
the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> must have a corresponding element, attribute or type
definition in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>.</p></li><li><p> For each mapping of a string to a
document node in <a title="available documents" href="#dt-available-docs">available
documents</a>, if there exists a mapping of the same string to a document type in <a title="statically known  documents" href="#dt-known-docs">statically known documents</a>, the document node must match the document type, using the matching rules in <a href="#id-sequencetype-matching"><b>2.5.4 SequenceType Matching</b></a>.</p></li><li><p> For each mapping of a string to a sequence of nodes in
<a title="available collections" href="#dt-available-collections">available
collections</a>, if there exists a mapping of the same string to
a type in <a title="statically known  collections" href="#dt-known-collections">statically known collections</a>, the sequence of nodes must match the type, using the matching rules in  <a href="#id-sequencetype-matching"><b>2.5.4 SequenceType Matching</b></a>.</p></li><li><p>The sequence of nodes in the <a title="default collection" href="#dt-default-collection">default collection</a> must match the <a title="statically known default collection type" href="#dt-known-default-collection">statically known default collection type</a>, using the matching rules in  <a href="#id-sequencetype-matching"><b>2.5.4 SequenceType Matching</b></a>.</p></li><li><p>The value of the <a title="context item" href="#dt-context-item">context item</a> must match the <a title="context item static type" href="#dt-context-item-static-type">context item static type</a>, using the
matching rules in <a href="#id-sequencetype-matching"><b>2.5.4 SequenceType Matching</b></a>.</p></li><li><p>For each (variable, type) pair in <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> and the corresponding (variable, value) pair in <a title="variable values" href="#dt-variable-values">variable values</a> such that the variable names are equal, the value must match the type, using the matching rules in  <a href="#id-sequencetype-matching"><b>2.5.4 SequenceType Matching</b></a>.</p></li><span class="xquery"><li class="xquery"><p>For each variable declared as <code>external</code>: If the variable declaration includes a declared type, the external environment must provide a value for the variable that matches the declared type,  using the matching rules in  <a href="#id-sequencetype-matching"><b>2.5.4 SequenceType Matching</b></a>. If the variable declaration does not include a declared type, the external environment must provide a type and a matching value, using the same matching rules.</p></li></span><span class="xquery"><li class="xquery"><p>For a given query, define a <b>participating ISSD</b> as the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> of a module that is used in evaluating the query. If two participating ISSDs contain a definition for the same schema type, element name, or attribute name, the definitions must be equivalent in both ISSDs. Furthermore, if two participating ISSDs each contain a definition of a schema type <em>T</em>, the set of types derived by extension from <em>T</em> must be equivalent in both ISSDs. Also, if two participating ISSDs each contain a definition of an element name <em>E</em>, the substitution group headed by <em>E</em> must be equivalent in both ISSDs.</p></li></span><li><p>In the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, the prefix <code>xml</code> must not be bound to any namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>, and no prefix other than <code>xml</code> may be bound to this namespace URI.</p></li></ul></div></div><div class="div2">
<h3><a id="errors" name="errors"></a>2.3 Error Handling</h3><div class="div3">
<h4><a id="id-kinds-of-errors" name="id-kinds-of-errors"></a>2.3.1 Kinds of Errors</h4><p>
As described in <a href="#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>, [XPath/XQuery]
defines a <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>, which does not depend on input
data, and a <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
phase</a>, which does depend on input
data.  Errors may be raised during each phase.</p><p>[<a title="static error" id="dt-static-error" name="dt-static-error">Definition</a>: 
A <b>static error</b> is an 
error that
must be detected during the static analysis phase.
A syntax error is an example of a <a title="static error" href="#dt-static-error">static error</a>.]</p><p>
[<a title="dynamic error" id="dt-dynamic-error" name="dt-dynamic-error">Definition</a>: A <b>dynamic
error</b> is an error that
must be detected during the dynamic evaluation phase and may be detected
during the static analysis phase.
Numeric overflow is an example of a dynamic error. 
]
</p><p>
[<a title="type error" id="dt-type-error" name="dt-type-error">Definition</a>: A <b>type
error</b> may be raised during the static analysis phase or the dynamic evaluation phase.
During the static analysis phase, a <a title="type error" href="#dt-type-error">type error</a> occurs
when the <a title="static type" href="#dt-static-type">static type</a> of an expression does not match the expected type
of the context in which the expression occurs.
During the dynamic evaluation phase, a <a title="type error" href="#dt-type-error">type error</a> occurs 
when the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value does not match the expected type of 
the context in which the value occurs. 
]
</p><p>The outcome of the <a title="static analysis phase" href="#dt-static-analysis">static analysis
phase</a> is either success or one or more <a title="type error" href="#dt-type-error">type errors</a>, <a title="static error" href="#dt-static-error">static errors</a>, or statically-detected <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>. The result of the <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
phase</a> is either a result value, a <a title="type error" href="#dt-type-error">type
error</a>, or a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p><p> During the <a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a>, if the <span class="xquery"><a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a></span><span class="xpath"><a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a></span> is in effect and the <a title="static type" href="#dt-static-type">static type</a> assigned to an expression other than <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XPST0005" href="#ERRXPST0005">err:XPST0005</a>]. This catches cases in which a query refers to an element or attribute that is not present in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, possibly because of a spelling error.</p><p>Independently of whether the <span class="xquery"><a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a></span><span class="xpath"><a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a></span> is in effect, if an implementation can determine during the 
<a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a> that an expression, if evaluated, would necessarily 
raise a <a title="type error" href="#dt-type-error">type
error</a> or a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, the implementation may (but is not required to) report that 
error during the <a title="static analysis phase" href="#dt-static-analysis">static
analysis phase</a>. However, the
<code>fn:error()</code> function must not be evaluated during the
<a title="static analysis phase" href="#dt-static-analysis">static analysis
phase</a>.</p><p>[<a title="warning" id="dt-warning" name="dt-warning">Definition</a>: In addition to <a title="static error" href="#dt-static-error">static errors</a>, <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>, and <a title="type error" href="#dt-type-error">type
errors</a>, an [XPath/XQuery]
implementation may raise <b>warnings</b>, either during the <a title="static analysis phase" href="#dt-static-analysis">static analysis
phase</a> or the
<a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
phase</a>. The circumstances in which warnings are raised, and
the ways in which warnings are handled, are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.]</p><p>In addition to the errors defined in this
specification, an implementation may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> for a reason beyond the scope of this specification. For
example, limitations may exist on the maximum
numbers or sizes of various objects. Any such  limitations, and the
consequences of exceeding them, are <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p></div><div class="div3">
<h4><a id="id-identifying-errors" name="id-identifying-errors"></a>2.3.2 Identifying and Reporting Errors</h4><p>The errors defined in this specification are identified by QNames that have the form <span class="xpath"><code>err:XPYYnnnn</code></span><span class="xquery"><code>err:XXYYnnnn</code></span>, where:</p><ul><li><p><code>err</code> denotes the namespace for XPath and XQuery errors, <code>http://www.w3.org/2005/xqt-errors</code>. This binding of the namespace prefix <code>err</code> is used for convenience in this document, and is not normative.</p></li><span class="xpath"><li class="xpath"><p><code>XP</code> identifies the error as an XPath error.</p></li></span><span class="xquery"><li class="xquery"><p><code>XX</code> denotes the language in which the error is defined, using the following encoding:</p><span class="xquery"><ul><li><p><code>XP</code> denotes an error defined by XPath. Such an error may also occur XQuery since XQuery  includes XPath as a subset.</p></li><li><p><code>XQ</code> denotes an error defined by XQuery.</p></li></ul></span></li></span><li><p><code>YY</code> denotes the error category, using the following encoding:</p><ul><li><p><code>ST</code> denotes a static error.</p></li><li><p><code>DY</code> denotes a dynamic error.</p></li><li><p><code>TY</code> denotes a type error.</p></li></ul></li><li><p><code>nnnn</code> is a unique numeric code.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The namespace URI for  XPath and XQuery errors is not expected to 
change from one version of [XPath/XQuery] to another. However, the contents of this 
namespace may be extended to include additional error definitions.</p></div><p>The method by which an [XPath/XQuery] processor reports error information to the external environment is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p><p>An error can be represented by a URI reference that is derived from the error QName as follows: an error with namespace URI <em><code>NS</code></em> and local part <em><code>LP</code></em> can be represented as the URI reference <em><code>NS</code></em><code>#</code><em><code>LP</code></em>. For example, an error whose QName is <code>err:XPST0017</code> could be represented as <code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Along with a code identifying an error, implementations may wish to return additional information, such 
as the location of the error or the processing phase in which it was detected. If an implementation chooses to do so, then the mechanism that 
it uses to return this information is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></div></div><div class="div3">
<h4><a id="id-handling-dynamic" name="id-handling-dynamic"></a>2.3.3 Handling Dynamic Errors</h4><p>Except as noted in this document, if any operand of an expression
raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>, the expression also raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.
If an expression can validly return a value or raise a dynamic
error, the implementation may choose to return the value or raise
the dynamic error.  For example, the logical expression 
<code>expr1 and expr2</code> may return the value <code>false</code> 
if either operand returns <code>false</code>,
or may raise a dynamic error if either operand raises a dynamic
error.</p><p> If more than one operand of an expression raises 
an error, the
implementation may choose which error is raised by the expression.
For example, in this expression:

</p><div class="parse-test"><div class="exampleInner"><pre>($x div $y) + xs:decimal($z)</pre></div></div><p>

both the sub-expressions <code>($x div $y)</code> and <code>xs:decimal($z)</code> may 
raise an error.  The
implementation may choose which error is raised by the "<code>+</code>"
expression.  Once one operand raises an error, the implementation is
not required, but is permitted, to evaluate any other operands.</p><p>[<a title="error value" id="dt-error-value" name="dt-error-value">Definition</a>: In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <b>error values</b>.] An implementation 
may provide a mechanism whereby an
application-defined error handler can process error values and
produce diagnostic messages.</p><p>A dynamic error may be raised by a <a title="built-in function" href="#dt-built-in-function">built-in 
function</a> or operator.  For example,
the <code>div</code> operator raises an error if its operands are <code>xs:decimal</code> values and its second operand
is equal to zero. Errors raised by built-in functions and operators are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p><p>A dynamic error can also be raised explicitly by calling the
<code>fn:error</code> function, which only raises an error and never
returns a value.  This function is defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. For example, the following
function call raises a dynamic
error, providing a QName that identifies the error, a descriptive string, and a diagnostic value (assuming that the prefix <code>app</code> is bound to a namespace containing application-defined error codes):</p><div class="parse-test"><div class="exampleInner"><pre>fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))</pre></div></div></div><div class="div3">
<h4><a id="id-errors-and-opt" name="id-errors-and-opt"></a>2.3.4 Errors and
      Optimization</h4><p>Because different implementations may
      choose to evaluate or optimize an expression in different ways,
      certain aspects of the detection and reporting of <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a> are <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>, as described in this section.</p><p>An implementation is always free to evaluate the operands of an operator in any order.</p><p>In some cases,  a processor can determine the result of an expression without accessing all the data that would be implied by the formal expression semantics. For example, the formal description of <a title="filter expression" href="#dt-filter-expression">filter expressions</a> suggests that <code>$s[1]</code> should be evaluated by examining all the items in sequence <code>$s</code>, and selecting all those that satisfy the predicate <code>position()=1</code>. In practice, many implementations will recognize that they can evaluate this expression by taking the first item in the sequence and then exiting. If <code>$s</code> is defined by an expression such as <code>//book[author eq 'Berners-Lee']</code>, then this strategy may avoid a complete scan of a large document and may therefore greatly improve performance. However, a consequence of this strategy is that a dynamic error or type error that would be detected if the expression semantics were followed literally might not be detected at all if the evaluation exits early. In this example, such an error might occur if there is a <code>book</code> element in the input data with more than one <code>author</code> subelement.</p><p>The extent to which a processor may optimize its access to data, at the cost of not detecting errors, is defined by the following rules.</p><p>Consider an expression <em>Q</em> that has an operand (sub-expression) <em>E</em>. In general the value of <em>E</em> is a sequence. At an intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown. If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible outcomes of evaluating <em>Q</em>, namely the value <em>V</em> or an error, then the processor may deliver the result <em>V</em> without evaluating further items in the operand <em>E</em>. For this purpose, two values are considered to represent the same outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values are the same if they are equal and have exactly the same type.</p><p>There is an exception to this rule: a processor is required to establish that the actual value of the operand <em>E</em> does not violate any constraints on its cardinality. For example, the expression <code>$e eq 0</code> results in a type error if the value of <code>$e</code> contains two or more items. A processor is not allowed to decide, after evaluating the first item in the value of <code>$e</code> and finding it equal to zero, that the only possible outcomes are the value <code>true</code> or a type error caused by the cardinality violation. It must establish that the value of <code>$e</code> contains no more than one item.</p><p>These rules apply to all the operands of an expression considered in combination: thus if an expression has two operands <em>E1</em> and <em>E2</em>, it may be evaluated using any samples of the respective sequences that satisfy the above rules.</p><p>The rules cascade: if <em>A</em> is an operand of <em>B</em> and <em>B</em> is an operand of <em>C</em>, then the processor needs to evaluate only a sufficient sample of <em>B</em> to determine the value of <em>C</em>, and needs to evaluate only a sufficient sample of <em>A</em> to determine this sample of <em>B</em>.</p><p>The effect of these rules is that the processor is free to stop examining further items in a sequence as soon as it can establish that further items would not affect the result except possibly by causing an error. For example, the processor may return <code>true</code> as the result of the expression <code>S1 = S2</code> as soon as it finds a pair of equal values from the two sequences.</p><p>Another consequence of these rules is that where none of the items in a sequence contributes to the result of an expression, the processor is not obliged to evaluate any part of the sequence. Again, however, the processor cannot dispense with a required cardinality check: if an empty sequence is not permitted in the relevant context, then the processor must ensure that the operand is not an empty sequence.</p><p>Examples:</p><ul><li><p>If an implementation can find (for example, by using an index) that at 
least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to 
return <code>true</code> as the result of the <code>some</code> expression, without searching for 
another item returned by <code>$expr1</code> that would raise an error if it were evaluated.
</p><div class="parse-test"><div class="exampleInner"><pre>some $x in $expr1 satisfies $x = 47</pre></div></div></li><li><p>In the following example, if an implementation can find (for example, by using an index) the 
<code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the 
result of the <a title="path expression" href="#dt-path-expression">path expression</a>, without searching for another <code>product</code> node that 
would raise an error because it has an <code>id</code> child whose value is not an integer.</p><div class="parse-test"><div class="exampleInner"><pre>//product[id = 47]</pre></div></div></li></ul><p>For a variety of reasons, including optimization,  implementations are free to rewrite expressions into equivalent expressions.  Other than the raising or not raising of errors, the result of evaluating an equivalent expression must be the same as the result of evaluating the original expression. Expression rewrite is illustrated by the following examples.</p><ul><li><p>Consider the expression <code>//part[color eq "Red"]</code>. An implementation might 
choose to rewrite this expression as <code>//part[color = "Red"][color eq 
"Red"]</code>. The implementation might then process the expression as follows: 
First process the "<code>=</code>" predicate by probing an index on parts by color to 
quickly find all the parts that have a Red color; then process the "<code>eq</code>" 
predicate by checking each of these parts to make sure it has only a 
single color. The result would be as follows: 
<ul><li><p>Parts that have exactly one color that is Red are returned.</p></li><li><p>If some part has color Red together with some other color, an error is 
raised.</p></li><li><p>The existence of some part that has no color Red but has multiple non-Red 
colors does not trigger an error.</p></li></ul></p></li><li><p>The expression in the following example cannot raise a casting error if it is evaluated
exactly as written (i.e., left to right). An implementation is
permitted, however, to reorder the predicates to achieve better
performance (for example, by taking advantage of an index). This
reordering could cause the expression to raise an
error.</p><div class="parse-test"><div class="exampleInner"><pre>$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]</pre></div></div><p>To avoid unexpected errors caused by expression rewrite,
tests that are designed to prevent dynamic errors should be expressed
using conditional <span class="xquery"><span class="xquery"><span class="xquery">or <code>typeswitch</code></span></span></span> expressions. Conditional <span class="xquery"><span class="xquery"><span class="xquery">and <code>typeswitch</code></span></span></span> expressions raise only dynamic errors that occur in the branch that is actually selected. Thus, unlike the previous example, the following example cannot raise a dynamic error if <code>@x</code> is not castable into an <code>xs:date</code>:</p><div class="parse-test"><div class="exampleInner"><pre>$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]</pre></div></div></li></ul></div></div><div class="div2">
<h3><a id="id-important-concepts" name="id-important-concepts"></a>2.4 Concepts</h3><p>This section explains some concepts that are important to the processing of [XPath/XQuery] expressions.</p><div class="div3">
<h4><a id="N10E77" name="N10E77"></a>2.4.1 Document Order</h4><p>An ordering called <b>document order</b> is defined among all the nodes accessible during processing of a given <span class="xquery"><span class="xquery"><span class="xquery">query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">expression</span></span></span>, which may consist of one or more <b>trees</b> (documents or fragments). Document order is defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, and its definition is repeated here for convenience. [<a title="reverse document order" id="dt-reverse-document-order" name="dt-reverse-document-order">Definition</a>: The node ordering that is the reverse of document order is called <b>reverse document order</b>.]</p><p>Document order is a total ordering, although the relative order of some nodes is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.  [<a title="document order" id="dt-document-order" name="dt-document-order">Definition</a>: Informally, <b>document order</b> is the order in
which nodes appear in the XML serialization of a document.]  [<a title="stable" id="stable" name="stable">Definition</a>: Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xquery"><span class="xquery"><span class="xquery">query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">expression</span></span></span>, even if this order is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.]</p><p>Within a tree, document order satisfies the following constraints:</p><ol class="enumar"><li><p>The root node is the first node.</p></li><li><p>Every node occurs before all of its children and descendants.</p></li><span class="xpath"><li class="xpath"><p>Namespace nodes immediately follow the element node with
which they are associated. The relative order of namespace nodes is
stable but <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li></span><li><p>Attribute nodes immediately follow the <span class="xpath"><span class="xpath"><span class="xpath">namespace nodes of the
</span></span></span> element node with which they are associated. The relative order of
attribute nodes is stable but <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li><li><p>The relative order of siblings is the order in which they occur
in the <code>children</code> property of their parent node.</p></li><li><p>Children and descendants occur before following siblings.</p></li></ol><p>The relative order of nodes in distinct trees is stable but
<a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>,
subject to the following constraint: If any node in a given tree T1 is before
any node in a different tree T2, then all nodes in tree T1 are before all nodes in
tree T2.</p></div><div class="div3">
<h4><a id="id-atomization" name="id-atomization"></a>2.4.2 Atomization</h4><p>The semantics of some
[XPath/XQuery] operators depend on a process called <a title="atomization" href="#dt-atomization">atomization</a>. Atomization is
applied to a value when the value is used in a context in which a
sequence of atomic values is required. The result of atomization is
either a sequence of atomic values or a <a title="type error" href="#dt-type-error">type error</a>  [err:FOTY0012].  [<a title="atomization" id="dt-atomization" name="dt-atomization">Definition</a>: <b>Atomization</b> of a sequence
is defined as the result of invoking the <code>fn:data</code> function
on the sequence, as defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.]</p><p> The semantics of
<code>fn:data</code> are repeated here for convenience. The result of
<code>fn:data</code> is the sequence of atomic values produced by
applying the following rules to each item in the input
sequence:</p><ul><li><p>If the item is an atomic value, it is
returned.</p></li><li><p>If the item is a node, 
its <a title="typed value" href="#dt-typed-value">typed value</a> is returned (err:FOTY0012 is raised if the node has no typed value.)</p></li></ul><p>Atomization is  used in
processing the following types of expressions: </p><ul><li><p>Arithmetic expressions</p></li><li><p>Comparison expressions</p></li><li><p>Function calls and returns</p></li><li><p>Cast expressions</p></li><span class="xquery"><li class="xquery"><p>Constructor expressions for various kinds of nodes</p></li></span><span class="xquery"><li class="xquery"><p><code>order by</code> clauses in FLWOR expressions</p></li></span></ul></div><div class="div3">
<h4><a id="id-ebv" name="id-ebv"></a>2.4.3 Effective Boolean Value</h4><p>Under certain circumstances (listed below), it is necessary to find
the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of a
value. [<a title="effective boolean value" id="dt-ebv" name="dt-ebv">Definition</a>: The
<b>effective boolean value</b> of a value is defined as the result
of applying the <code>fn:boolean</code> function to the value, as
defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.]</p><p> The dynamic semantics of <code>fn:boolean</code> are repeated here for convenience:</p><ol class="enumar"><li><p>If its operand is an empty sequence, <code>fn:boolean</code> returns <code>false</code>.</p></li><li><p>If its operand is a sequence whose first item is a node, <code>fn:boolean</code> returns <code>true</code>.</p></li><li><p>If its operand is a <a title="singleton" href="#dt-singleton">singleton</a> value of type <code>xs:boolean</code> or derived from <code>xs:boolean</code>, <code>fn:boolean</code> returns the value of its operand unchanged.</p></li><li><p>If its operand is a <a title="singleton" href="#dt-singleton">singleton</a> value of type <code>xs:string</code>, <code>xdt:untypedAtomic</code>, or a type derived from one of these, <code>fn:boolean</code> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.</p></li><li><p>If its operand is a <a title="singleton" href="#dt-singleton">singleton</a> value of any <a title="numeric" href="#dt-numeric">numeric</a> type or derived from a numeric type, <code>fn:boolean</code> returns <code>false</code> if the operand value is <code>NaN</code> or is numerically equal to zero; otherwise it returns <code>true</code>.</p></li><li><p>



In all other cases, <code>fn:boolean</code> raises a type error [err:FORG0006].
</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The static semantics of  <code>fn:boolean</code> are defined in <a href="http://www.w3.org/TR/xquery-semantics/#sec_fn_boolean">Section 
7.2.4 The fn:boolean function</a><sup><small>FS</small></sup>.</p></div><span class="xquery"><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of a sequence that contains at least one node and at least one atomic value is nondeterministic in regions of a query where <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>unordered</code>.</p></div></span><p>The <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of a sequence is computed implicitly during  processing of the following types of expressions: </p><ul><li><p>Logical expressions (<code>and</code>, <code>or</code>)</p></li><li><p>The <code>fn:not</code> function</p></li><span class="xquery"><li class="xquery"><p>The <code>where</code> clause of a FLWOR expression</p></li></span><li><p>Certain types of <a title="predicate" href="#dt-predicate">predicates</a>, such as <code>a[b]</code></p></li><li><p>Conditional expressions (<code>if</code>)</p></li><li><p>Quantified expressions (<code>some</code>, <code>every</code>)</p></li><span class="xpath"><li class="xpath"><p>General comparisons, in <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0
		compatibility mode</a>.</p></li></span></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The definition of <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> is <em>not</em> used when casting a value to the type <code>xs:boolean</code>, for example in a <code>cast</code> expression or when passing a value to a function whose expected parameter is of type <code>xs:boolean</code>.</p></div></div><div class="div3">
<h4><a id="id-input-sources" name="id-input-sources"></a>2.4.4 Input Sources</h4><p>[XPath/XQuery] has a set of functions that provide access to
    input data. These functions are of particular importance because they provide a way in which an expression can reference a document or a collection of documents. The  input functions are described informally here; they are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p><p>An expression can access input data either by calling one
    of the input functions or by referencing some part of the
    <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> that is initialized by the external
    environment, such as a <a title="variable values" href="#dt-variable-values">variable</a> or 
    <a title="context item" href="#dt-context-item">context item</a>.</p><p>The input functions supported by [XPath/XQuery] are as follows:</p><ul><li><p>The <code>fn:doc</code> function takes a string containing a URI. If that URI is associated with a document in <a title="available documents" href="#dt-available-docs">available documents</a>, <code>fn:doc</code> returns a document node whose content is the <a title="data model" href="#dt-datamodel">data model</a> representation of the given document; otherwise it raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> (see <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a> for details).</p></li><li><p>The <code>fn:collection</code> function with one argument takes a string containing a URI. If that URI is associated with a collection in <a title="available collections" href="#dt-available-collections">available collections</a>, <code>fn:collection</code> returns the data model representation of that collection; otherwise it raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> (see <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a> for details).  A collection may be any sequence of nodes. For example, the expression
    <code>fn:collection("http://example.org")//customer</code>
    identifies all the <code>customer</code> elements that are
    descendants of nodes found in the collection whose URI is
    <code>http://example.org</code>.</p></li><li><p>The <code>fn:collection</code> function with zero arguments returns the <a title="default collection" href="#dt-default-collection">default collection</a>, an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> sequence of nodes.</p></li></ul><p>If one of the above functions is invoked repeatedly with arguments
    that resolve to the same absolute URI during the processing of a single
    <span class="xquery"><span class="xquery"><span class="xquery">query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">expression</span></span></span>, each invocation must return the same node sequence. This rule applies also to repeated invocations of <code>fn:collection</code> with zero arguments during the processing of a single
    <span class="xquery"><span class="xquery"><span class="xquery">query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">expression</span></span></span>.</p></div><span class="xquery"><div class="xquery"><div class="div3">
<h4><a id="id-uri-literals" name="id-uri-literals"></a>2.4.5 URI Literals</h4><p>In certain places in the XQuery grammar, a statically known valid absolute URI is required. These places are denoted by the grammatical symbol <a href="#doc-xpath-URILiteral">URILiteral</a>. For example, URILiterals are used to specify namespaces and collations, both of which must be statically known.</p><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-URILiteral" name="doc-xpath-URILiteral"></a>[143]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-StringLiteral" class="xquery">StringLiteral</a></span></code></td></tr></span></tbody></span></table><p>Syntactically, a URILiteral is identical to a <a href="#doc-xpath-StringLiteral">StringLiteral</a>: a sequence of zero or more characters enclosed in single or double quotes. However, an implementation <a title="may" href="#may">MAY</a> raise a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0046" href="#ERRXQST0046">err:XQST0046</a>] if the value of a URILiteral is of nonzero length and is not in the lexical
space of <code>xs:anyURI</code>, or if it is a string that represents a "relative reference" as
defined in <a href="#RFC3986">[RFC3986]</a>. The value of a URILiteral is whitespace-normalized according to the rules for the <code>xs:anyURI</code> type in <a href="#XMLSchema">[XML Schema]</a>; however, no escaping normalization is applied.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>xs:anyURI</code> type is designed to
anticipate the introduction of Internationalized Resource Identifiers (IRI's)
as defined in <a href="#RFC3987">[RFC3987]</a>.</p></div><p>The following is an example of a valid URILiteral:</p><div class="exampleInner"><pre>"http://www.w3.org/2005/xpath-functions/collation/codepoint"</pre></div></div></div></span></div><div class="div2">
<h3><a id="id-types" name="id-types"></a>2.5 Types</h3><p> The type system of  [XPath/XQuery] is based on
		<a href="#XMLSchema">[XML Schema]</a>, and is formally defined in
		<a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p><p>[<a title="sequence type" id="dt-sequence-type" name="dt-sequence-type">Definition</a>: A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xpath-SequenceType">SequenceType</a>
syntax. Sequence types are used whenever it is necessary to refer to a type in an [XPath/XQuery] expression. The term <b>sequence type</b> suggests that this syntax is used to describe the type of an [XPath/XQuery] value, which is always a sequence.]</p><p>[<a title="schema type" id="dt-schema-type" name="dt-schema-type">Definition</a>: A <b>schema type</b> is a type that is (or could be) defined using the facilities of <a href="#XMLSchema">[XML Schema]</a> (including the built-in types of <a href="#XMLSchema">[XML Schema]</a>).] A schema type  can be used as a type annotation on an
element or attribute node (unless it is a non-instantiable type such as <code>xs:NOTATION</code> or <code>xdt:anyAtomicType</code>, in which case its derived
types can be so used). Every schema type is either a <b>complex type</b> or a
<b>simple type</b>; simple types are further subdivided into <b>list types</b>, <b>union
types</b>, and <b>atomic types</b> (see <a href="#XMLSchema">[XML Schema]</a> for definitions and explanations of these terms.)</p><p>Atomic types represent the intersection between the categories of <a title="sequence type" href="#dt-sequence-type">sequence type</a> and <a title="schema type" href="#dt-schema-type">schema type</a>. An
atomic type, such as <code>xs:integer</code> or <code>my:hatsize</code>, is both a <a title="sequence type" href="#dt-sequence-type">sequence type</a> and a
<a title="schema type" href="#dt-schema-type">schema type</a>.</p><div class="div3">
<h4><a id="id-predefined-types" name="id-predefined-types"></a>2.5.1 Predefined Schema Types</h4><span class="xpath"><div class="xpath"><p class="xpath">The <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>
                 in the <a title="static context" href="#dt-static-context">static
                 context</a> are initialized with a set of
                 predefined schema types that is determined by the host
                 language. This set may include some or all of the
                 schema types defined by <a href="#XMLSchema">[XML Schema]</a> in the
                 namespace
                 <code>http://www.w3.org/2001/XMLSchema</code>,
                 represented in this document by the namespace prefix
                 <code>xs</code>. It may also include the schema types
                 defined in the namespace
                 <code>http://www.w3.org/2005/xpath-datatypes</code>,
                 represented in this document by the namespace prefix
                 <code>xdt</code>. The schema types in this namespace are
                 defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> and
                 are summarized below. </p></div></span><span class="xquery"><div class="xquery"><p class="xquery">The <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> in the <a title="static context" href="#dt-static-context">static context</a>
                   are initialized with certain predefined schema types,
                   including the built-in schema types of <a href="#XMLSchema">[XML Schema]</a>.  These built-in schema types are in the
                   namespace
                   <code>http://www.w3.org/2001/XMLSchema</code>,
                   which has the predefined namespace prefix
                   <code>xs</code>. Some examples of built-in schema
                   types include <code>xs:integer</code>,
                   <code>xs:string</code>, and
                   <code>xs:date</code>. Element and attribute
                   declarations in the <code>xs</code> namespace are
                   not implicitly included in the static context.</p></div></span><span class="xquery"><div class="xquery"><p class="xquery">In addition, the predefined schema types of XQuery include
the schema types defined in the namespace  <code>http://www.w3.org/2005/xpath-datatypes</code>, which has the predefined namespace prefix <code>xdt</code>. The schema types in this namespace are defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> and are summarized below. </p></div></span><ol class="enumar"><li><p>[<a title="xdt:untyped" id="dt-untyped" name="dt-untyped">Definition</a>: <code>xdt:untyped</code> is  used as the <a title="type annotation" href="#dt-type-annotation">type annotation</a> of an element node that has not been validated, or has been validated in <code>skip</code> mode.] No predefined schema types are derived from <code>xdt:untyped</code>.</p></li><li><p>[<a title="xdt:untypedAtomic" id="dt-untypedAtomic" name="dt-untypedAtomic">Definition</a>: <code>xdt:untypedAtomic</code>
is an atomic type that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.] An attribute that has been validated in <code>skip</code> mode is represented in the Data Model by an attribute node with the <a title="type annotation" href="#dt-type-annotation">type annotation</a> <code>xdt:untypedAtomic</code>. No predefined schema types are derived from <code>xdt:untypedAtomic</code>.</p></li><li><p>[<a title="xdt:dayTimeDuration" id="dt-dayTimeDuration" name="dt-dayTimeDuration">Definition</a>: <code>xdt:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The  lexical representation of <code>xdt:dayTimeDuration</code>
is restricted to contain only day, hour, minute, and second
components.]</p></li><li><p>[<a title="xdt:yearMonthDuration" id="dt-yearMonthDuration" name="dt-yearMonthDuration">Definition</a>: <code>xdt:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xdt:yearMonthDuration</code> is
restricted to contain only year and month
components.]</p></li><li><p>[<a title="xdt:anyAtomicType" id="dt-anyAtomicType" name="dt-anyAtomicType">Definition</a>: <code>xdt:anyAtomicType</code> is an atomic type that includes all atomic values (and no values that
are not atomic). Its base type is
<code>xs:anySimpleType</code> from which all simple types, including atomic,
list, and union types, are derived. All primitive atomic types, such as
<code>xs:integer</code>, <code>xs:string</code>, and <code>xdt:untypedAtomic</code>, have <code>xdt:anyAtomicType</code> as their base type.]</p><div class="note"><p class="prefix"><b>Note:</b></p><p><code>xdt:anyAtomicType</code>  will not appear as the type of an actual value in a Data Model instance.</p></div></li></ol><p>The relationships among the schema types in the <code>xs</code> and <code>xdt</code> namespaces are illustrated in Figure 2. A more complete description of the [XPath/XQuery] type hierarchy can be found in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p><img src="types.jpg" alt="Type Hierarchy Diagram"><p>Figure 2: Hierarchy of Schema Types used in [XPath/XQuery]</p></div><div class="div3">
<h4><a id="id-typed-value" name="id-typed-value"></a>2.5.2 Typed Value and String Value</h4><p>Every node
has a <b>typed value</b> and a <b>string value</b>.

[<a title="typed value" id="dt-typed-value" name="dt-typed-value">Definition</a>: The <b>typed value</b> of a node is a sequence of atomic values
and can be extracted by applying the <code>fn:data</code> function to
the node.]  [<a title="string value" id="dt-string-value" name="dt-string-value">Definition</a>: The <b>string
 value</b> of a node is a string and 
 can be extracted by applying the <code>fn:string</code>
 function to the node.]
Definitions of <code>fn:data</code> and <code>fn:string</code> can be found in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p><p>An implementation may store both the <a title="typed value" href="#dt-typed-value">typed value</a> and the <a title="string value" href="#dt-string-value">string value</a> of a node, or it may store only one of these and derive the other from it as needed. The string value of a node must be a valid lexical representation of the typed value of the node, but the node is not required to preserve the string representation from the original source document. For example, if the typed value of a node is the <code>xs:integer</code> value <code>30</code>, its string value might be "<code>30</code>" or "<code>0030</code>".</p><span class="xpath"><div class="xpath"><p class="xpath">The <a title="typed value" href="#dt-typed-value">typed value</a>, <a title="string value" href="#dt-string-value">string value</a>, and <a title="type annotation" href="#dt-type-annotation">type annotation</a> of a node are closely related.  If the node was created by mapping from an Infoset or PSVI, the relationships among these properties are defined by rules in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.</p></div></span><span class="xquery"><div class="xquery"><p class="xquery">The <a title="typed value" href="#dt-typed-value">typed value</a>, <a title="string value" href="#dt-string-value">string value</a>, and <a title="type annotation" href="#dt-type-annotation">type annotation</a> of a node are closely related, and are defined by rules found in the following locations:</p></div></span><span class="xquery"><ul><li><p> If the node was created by mapping from an Infoset or PSVI, see rules in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.</p></li><li><p>If the node was created by an XQuery node constructor, see rules in <a href="#id-element-constructor"><b>3.7.1 Direct Element Constructors</b></a>, <a href="#id-computedElements"><b>3.7.3.1 Computed Element
   Constructors</b></a>, or <a href="#id-computedAttributes"><b>3.7.3.2 Computed Attribute
   Constructors</b></a>.</p></li><li><p>If the node was created by a <code>validate</code> expression, see rules in <a href="#id-validate"><b>3.14 Validate Expressions</b></a>.</p></li></ul></span><p>As a convenience to the reader, the relationship between <a title="typed value" href="#dt-typed-value">typed value</a> and
 <a title="string value" href="#dt-string-value">string value</a> for various kinds of nodes is summarized and illustrated
 by examples below.</p><ol class="enumar"><li><p>For text and document nodes, the typed value of the node is the same as its
string value, as an instance of  the type <code>xdt:untypedAtomic</code>. The
string value of a document node is formed by concatenating the string
values of all its descendant text nodes, in <a title="document order" href="#dt-document-order">document
order</a>.</p></li><li><p>The typed value of a comment<span class="xpath"><span class="xpath"><span class="xpath">, namespace,</span></span></span> or processing instruction node is the same as its string value. It is an instance of the type <code>xs:string</code>.</p></li><li><p>The typed value of an attribute node with
the <a title="type annotation" href="#dt-type-annotation">type annotation</a> <code>xs:anySimpleType</code> or <code>xdt:untypedAtomic</code> is the same as its
string value, as an instance of <code>xdt:untypedAtomic</code>. The
typed value of an attribute node with any other type annotation is
derived from its string value and type annotation using the lexical-to-value-space mapping defined in <a href="#XMLSchema">[XML Schema]</a> Part 2 for
the relevant type.</p><p>Example: A1 is an attribute
having string value <code>"3.14E-2"</code> and type annotation
<code>xs:double</code>.  The typed value of A1 is the
<code>xs:double</code> value whose lexical representation is
<code>3.14E-2</code>. </p><p>Example: A2 is an attribute with type
annotation <code>xs:IDREFS</code>, which is a list datatype whose item type is the atomic datatype <code>xs:IDREF</code>. Its string value is
"<code>bar baz faz</code>". The typed value of A2 is a sequence of
three atomic values ("<code>bar</code>", "<code>baz</code>",
"<code>faz</code>"), each of type <code>xs:IDREF</code>. The typed
value of a node is never treated as an instance of a named list
type. Instead, if the type annotation of a node is a list type (such
as <code>xs:IDREFS</code>), its typed value is treated as a sequence
of the atomic type from which it is derived (such as
<code>xs:IDREF</code>).</p></li><li><p>For an element node, the
relationship between typed value and string value depends on the
node's <a title="type annotation" href="#dt-type-annotation">type annotation</a>, as follows:</p><ol class="enumla"><li><p>If the type annotation is <code>xdt:untyped</code> or <code>xs:anySimpleType</code> or
denotes a complex type with mixed content (including <code>xs:anyType</code>), then the typed value of the
node is equal to its string value, as an instance of
<code>xdt:untypedAtomic</code>.  However, if the <code>nilled</code> 
property of the node is <code>true</code>, then its typed value is the empty sequence.</p><p>Example: E1 is an element node
having type annotation <code>xdt:untyped</code> and string value
"<code>1999-05-31</code>". The typed value of E1 is
"<code>1999-05-31</code>", as an instance of
<code>xdt:untypedAtomic</code>.</p><p>Example: E2 is an element node
with the type annotation <code>formula</code>, which is a complex type
with mixed content. The content of E2 consists of the character
"<code>H</code>", a child element named <code>subscript</code> with
string value "<code>2</code>", and the character "<code>O</code>". The
typed value of E2 is "<code>H2O</code>" as an instance of
<code>xdt:untypedAtomic</code>.</p></li><li><p>If the type
annotation denotes a simple type or a complex type with simple
content, then the typed value of the node is derived from its string
value and its type annotation in a way that is consistent with schema
validation. However, if the <code>nilled</code> 
property of the node is <code>true</code>, then its typed value is the empty sequence.</p><p>Example: E3 is an element node with the type
annotation <code>cost</code>, which is a complex type that has several
attributes and a simple content type of <code>xs:decimal</code>. The
string value of E3 is "<code>74.95</code>". The typed value of E3 is
<code>74.95</code>, as an instance of
<code>xs:decimal</code>.</p><p>Example: E4 is an element node with the
type annotation <code>hatsizelist</code>, which is a simple type
derived from the atomic type <code>hatsize</code>, which in turn is
derived from <code>xs:integer</code>. The string value of E4 is
"<code>7 8 9</code>". The typed value of E4 is a sequence of three
values (<code>7</code>, <code>8</code>, <code>9</code>), each of type
<code>hatsize</code>.</p><p>Example: E5 is an element node with the type annotation <code>my:integer-or-string</code> which is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. The string value of E5 is "<code>47</code>". The typed value of E5 is <code>47</code> as an <code>xs:integer</code>, since <code>xs:integer</code> is the member type that validated the content of E5. In general, when the type annotation of a node is a union type, the typed value of the node will be an instance of one of the member types of the union.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If an implementation stores only the string value of a node, and the type annotation of the node is a union type, the implementation must be able to deliver the typed value of the node as an instance of the appropriate member type.</p></div></li><li><p>If the type annotation
denotes a complex type with empty content, then the typed value of the
node is the empty sequence and its string value is the zero-length string.</p></li><li><p>If the type annotation
denotes a complex type with element-only content, then the typed value
of the node is undefined. The <code>fn:data</code> function raises a
<a title="type error" href="#dt-type-error">type error</a> [err:FOTY0012] when applied to such a node. The string value of such a node is equal to the concatenated string values of all its text node descendants, in document order.</p><p>Example: E6 is an
element node with the type annotation <code>weather</code>, which is a
complex type whose content type specifies
<code>element-only</code>. E6 has two child elements named
<code>temperature</code> and <code>precipitation</code>. The typed
value of E6 is undefined, and the <code>fn:data</code> function
applied to E6 raises an error.
</p></li></ol></li></ol></div><div class="div3">
<h4><a id="id-sequencetype-syntax" name="id-sequencetype-syntax"></a>2.5.3 SequenceType Syntax</h4><p>Whenever it is necessary to refer to a type in an [XPath/XQuery] expression, the <a href="#doc-xpath-SequenceType">SequenceType</a> syntax is used.</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-SequenceType" name="doc-xpath-SequenceType"></a>[122]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-SequenceType">SequenceType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("empty-sequence"  "("  ")")<br>|  (<a href="#doc-xpath-ItemType">ItemType</a>  <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ItemType" name="doc-xpath-ItemType"></a>[124]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ItemType">ItemType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-KindTest">KindTest</a>  |  ("item"  "("  ")")  |  <a href="#doc-xpath-AtomicType">AtomicType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-OccurrenceIndicator" name="doc-xpath-OccurrenceIndicator"></a>[123]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"?"  |  "*"  |  "+"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-AtomicType" name="doc-xpath-AtomicType"></a>[125]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AtomicType">AtomicType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-KindTest" name="doc-xpath-KindTest"></a>[126]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-KindTest">KindTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DocumentTest">DocumentTest</a><br>|  <a href="#doc-xpath-ElementTest">ElementTest</a><br>|  <a href="#doc-xpath-AttributeTest">AttributeTest</a><br>|  <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a><br>|  <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a><br>|  <a href="#doc-xpath-PITest">PITest</a><br>|  <a href="#doc-xpath-CommentTest">CommentTest</a><br>|  <a href="#doc-xpath-TextTest">TextTest</a><br>|  <a href="#doc-xpath-AnyKindTest">AnyKindTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-DocumentTest" name="doc-xpath-DocumentTest"></a>[128]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DocumentTest">DocumentTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"document-node"  "("  (<a href="#doc-xpath-ElementTest">ElementTest</a>  |  <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ElementTest" name="doc-xpath-ElementTest"></a>[136]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ElementTest">ElementTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"element"  "("  (<a href="#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#doc-xpath-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-SchemaElementTest" name="doc-xpath-SchemaElementTest"></a>[138]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-SchemaElementTest">SchemaElementTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-element"  "("  <a href="#doc-xpath-ElementDeclaration">ElementDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ElementDeclaration" name="doc-xpath-ElementDeclaration"></a>[139]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ElementDeclaration">ElementDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ElementName">ElementName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-AttributeTest" name="doc-xpath-AttributeTest"></a>[132]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AttributeTest">AttributeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"attribute"  "("  (<a href="#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#doc-xpath-TypeName">TypeName</a>)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-SchemaAttributeTest" name="doc-xpath-SchemaAttributeTest"></a>[134]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-attribute"  "("  <a href="#doc-xpath-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-AttributeDeclaration" name="doc-xpath-AttributeDeclaration"></a>[135]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AttributeDeclaration">AttributeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AttributeName">AttributeName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ElementNameOrWildcard" name="doc-xpath-ElementNameOrWildcard"></a>[137]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ElementName">ElementName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ElementName" name="doc-xpath-ElementName"></a>[141]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ElementName">ElementName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-AttribNameOrWildcard" name="doc-xpath-AttribNameOrWildcard"></a>[133]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AttributeName">AttributeName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-AttributeName" name="doc-xpath-AttributeName"></a>[140]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AttributeName">AttributeName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-TypeName" name="doc-xpath-TypeName"></a>[142]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-TypeName">TypeName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-PITest" name="doc-xpath-PITest"></a>[131]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PITest">PITest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"processing-instruction"  "("  (<a href="#prod-xpath-NCName">NCName</a>  |  <a href="#doc-xpath-StringLiteral">StringLiteral</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-CommentTest" name="doc-xpath-CommentTest"></a>[130]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CommentTest">CommentTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"comment"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-TextTest" name="doc-xpath-TextTest"></a>[129]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-TextTest">TextTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"text"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-AnyKindTest" name="doc-xpath-AnyKindTest"></a>[127]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AnyKindTest">AnyKindTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"node"  "("  ")"</code></td></tr></tbody></table><p>With the
exception of the special  type <code>empty-sequence()</code>, a <a title="sequence type" href="#dt-sequence-type">sequence type</a> consists of
an <b>item type</b> that constrains the type of each item in the sequence, and a <b>cardinality</b> that
constrains the number of items in the sequence. Apart from the item type <code>item()</code>, which
permits any kind of item, item types divide into <b>node types</b> (such as
<code>element()</code>) and <b>atomic types</b> (such as <code>xs:integer</code>).</p><p>Item types representing element and attribute nodes may specify the
required <a title="type annotation" href="#dt-type-annotation">type annotations</a> of those nodes, in the form of a <a title="schema type" href="#dt-schema-type">schema type</a>. Thus
the item type <code>element(*, us:address)</code> denotes any element node whose type
annotation is (or is derived from) the schema type named <code>us:address</code>.</p><p>Here are some examples of <a title="sequence type" href="#dt-sequence-type">sequence types</a> that
		  might be used in [XPath/XQuery] expressions:</p><ul><li><p> <code>xs:date</code> refers to the built-in atomic schema type named <code>xs:date</code></p></li><li><p> <code>attribute()?</code> refers to an optional attribute node</p></li><li><p> <code>element()</code> refers to any element node</p></li><li><p> <code>element(po:shipto, po:address)</code> refers to an element node that has the name <code>po:shipto</code> and has the type annotation <code>po:address</code> (or a schema type derived from <code>po:address</code>)</p></li><li><p> <code>element(*, po:address)</code> refers to an element node of any name that has the type annotation <code>po:address</code> (or a type derived from <code>po:address</code>)</p></li><li><p><code>element(customer)</code> refers to an element node named <code>customer</code> with any type annotation</p></li><li><p><code>schema-element(customer)</code> refers to an element node whose name is <code>customer</code> (or is in the substitution group headed by <code>customer</code>) and whose type annotation matches the schema type declared for a <code>customer</code> element in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a></p></li><li><p> <code>node()*</code> refers to a sequence of zero or more nodes of any kind</p></li><li><p> <code>item()+</code> refers to a sequence of one or more nodes or atomic values</p></li></ul></div><div class="div3">
<h4><a id="id-sequencetype-matching" name="id-sequencetype-matching"></a>2.5.4 SequenceType Matching</h4><p> [<a title="SequenceType matching" id="dt-sequencetype-matching" name="dt-sequencetype-matching">Definition</a>: During evaluation of an expression, it is sometimes necessary to determine whether a value with a known <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> "matches" an expected  <a title="sequence type" href="#dt-sequence-type">sequence type</a>. This process is known as <b>SequenceType matching</b>.] For example, an <code>instance of</code> expression returns <code>true</code> if the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a given value matches a given <a title="sequence type" href="#dt-sequence-type">sequence type</a>, or <code>false</code> if
it does not.</p><p>QNames appearing in a <a title="sequence type" href="#dt-sequence-type">sequence type</a> have their
		  prefixes expanded to namespace URIs by means of the
		  <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> and (where applicable) the
		  <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type
		  namespace</a>. 

                  As usual, two <a title="expanded QName" href="#dt-expanded-qname">expanded QNames</a> are equal if their local parts are the same and their namespace URI's are the same.

                  An unprefixed attribute QName is in no namespace.</p><p>The rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a> compare the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value
with an expected <a title="sequence type" href="#dt-sequence-type">sequence type</a>. These rules are a subset of the formal rules
that match a value with an expected type defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, because the Formal Semantics must be
able to match values against  types that are not expressible using the
<a href="#doc-xpath-SequenceType">SequenceType</a> syntax.</p><p>Some of the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType matching</a> require determining
whether a given schema type is the same as or derived from an expected
schema type. The given schema type may be
"known"   (defined in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>), or "unknown"
(not defined in the <a title="in-scope schema definitions" href="#dt-issd">in-scope
schema definitions</a>).  An unknown schema type might be encountered,
for example, if a source document has been validated using a schema that was not imported into the <a title="static context" href="#dt-static-context">static context</a>. In this
case, an implementation is allowed (but is not required) to provide an
<a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> mechanism for determining whether the unknown
schema type is derived from the expected schema type. For example, an
implementation might maintain a data dictionary containing information
about type hierarchies.</p><p>[<a title="subtype substitution" id="dt-subtype-substitution" name="dt-subtype-substitution">Definition</a>: The use of a value whose <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> is derived from an expected type is known as <b>subtype substitution</b>.] Subtype substitution does not change the actual type of a value. For example, if an <code>xs:integer</code> value is used where an <code>xs:decimal</code> value is expected, the value retains its type as <code>xs:integer</code>.</p><p>The definition of <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a> relies on a pseudo-function named <code>derives-from(</code><em>AT, ET</em><code>)</code>, which takes
an actual simple or complex schema type <em>AT</em> and an expected simple or
complex schema type <em>ET</em>, and either returns a boolean value or raises a
<a title="type error" href="#dt-type-error">type error</a> [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>]. The pseudo-function <code>derives-from</code>
is
defined below and is defined formally in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p><ul><li><p><code>derives-from(</code><em>AT</em>, <em>ET</em><code>)</code> returns <code>true</code> if <em>ET</em> is a known type and any of the following three conditions is true:</p><ol class="enumar"><li><p><em>AT</em> is a schema type found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, and is the same as
<em>ET</em> or is derived by restriction or
extension from <em>ET</em></p></li><li><p><em>AT</em>
is a schema type not found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, and an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> mechanism is able
to determine that <em>AT</em> is derived by restriction from
<em>ET</em></p></li><li><p>There exists some schema type <em>IT</em> such that 
       <code>derives-from(</code><em>IT, ET</em><code>)</code> and <code>derives-from(</code><em>AT, IT</em><code>)</code> are true. 
</p></li></ol></li><li><p><code>derives-from(</code><em>AT</em>,
<em>ET</em><code>)</code> returns <code>false</code>
if <em>ET</em> is a known type and either the first and third or the second and third of the following conditions are true:</p><ol class="enumar"><li><p><em>AT</em> is a schema type found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, and is not the same as
<em>ET</em>, and is not derived by restriction or
extension from <em>ET</em></p></li><li><p><em>AT</em>
is a schema type not found in the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, and an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> mechanism is able
to determine that <em>AT</em> is not derived by restriction from
<em>ET</em></p></li><li><p>No schema type <em>IT</em> exists such that 
       <code>derives-from(</code><em>IT, ET</em><code>)</code> and <code>derives-from(</code><em>AT, IT</em><code>)</code> are true. 
</p></li></ol></li><li><p><code>derives-from(</code><em>AT</em>,
<em>ET</em><code>)</code> raises a <a title="type error" href="#dt-type-error">type error</a> [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>]
if:</p><ol class="enumar"><li><p><em>ET</em> is an unknown type,
or</p></li><li><p><em>AT</em> is an unknown type, and the
implementation is not able to determine whether <em>AT</em> is
derived by restriction from
<em>ET</em>.</p></li></ol></li></ul><span class="xquery"><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>derives-from</code> pseudo-function cannot be
written as a real XQuery function, because types are not valid
function parameters. </p></div></span><p>The rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a> are given below, with examples (the examples are
for purposes of illustration, and do not cover all possible
cases).</p><div class="div4">
<h5><a id="id-matching-value" name="id-matching-value"></a>2.5.4.1 Matching a SequenceType and a Value</h5><ul><li><p>The <a title="sequence type" href="#dt-sequence-type">sequence type</a> <code>empty-sequence()</code> matches a value that is the empty sequence.</p></li><li><p>An <a href="#doc-xpath-ItemType">ItemType</a> with no <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> matches any value that contains exactly one item if the <a href="#doc-xpath-ItemType">ItemType</a> matches that item (see <a href="#id-matching-item"><b>2.5.4.2 Matching an ItemType and an
Item</b></a>).</p></li><li><p>An <a href="#doc-xpath-ItemType">ItemType</a> with an <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> matches a value if the number of items in the value matches the <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> and the <a href="#doc-xpath-ItemType">ItemType</a> matches each of the items in the value.</p></li></ul><p>An <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> specifies the number of items in
		  a sequence, as follows:</p><ul><li><p> <code>?</code> matches zero or one items</p></li><li><p> <code>*</code> matches zero or more items</p></li><li><p> <code>+</code> matches one or more items</p></li></ul><p>As a consequence of these rules, any <a title="sequence type" href="#dt-sequence-type">sequence type</a> whose
<a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a
value that is an empty sequence.</p></div><div class="div4">
<h5><a id="id-matching-item" name="id-matching-item"></a>2.5.4.2 Matching an ItemType and an
Item</h5><ul><li><p>An <a href="#doc-xpath-ItemType">ItemType</a> consisting simply of a QName is
interpreted as an <a href="#doc-xpath-AtomicType">AtomicType</a>. An AtomicType
<em>AtomicType</em> matches an atomic value whose actual type is
<em>AT</em> if <code>derives-from(</code><em>AT, AtomicType</em><code>)</code> is <code>true</code>. If a QName that is used as an
                  <a href="#doc-xpath-AtomicType">AtomicType</a> is not defined as an atomic
                  type in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>, a <a title="static error" href="#dt-static-error">static error</a> is
                  raised [<a title="err:XPST0051" href="#ERRXPST0051">err:XPST0051</a>].</p><p>Example: The
<a href="#doc-xpath-AtomicType">AtomicType</a> <code>xs:decimal</code> matches the value
<code>12.34</code> (a decimal literal). <code>xs:decimal</code> also
matches a value whose type is <code>shoesize</code>, if
<code>shoesize</code> is an atomic type derived by restriction from
<code>xs:decimal</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p> The names of non-atomic
types such as <code>xs:IDREFS</code> are not accepted in this context,
but can often be replaced by an atomic type with an occurrence
indicator, such as
<code>xs:IDREF+</code>.</p></div></li><li><p><code>item()</code> matches
any single item.</p><p>Example: <code>item()</code> matches the atomic
value <code>1</code> or the element
<code>&lt;a/&gt;</code>.</p></li><li><p><code>node()</code>
matches any node.</p></li><li><p><code>text()</code> matches any
text node.</p></li><li><p><code>processing-instruction()</code>
matches any processing-instruction
node.</p></li><li><p><code>processing-instruction(</code><em>N</em><code>)</code>
matches any processing-instruction node whose name (called its
"PITarget" in XML) is equal to <em>N</em>, where <em>N</em> is
an NCName.</p><p>Example:
<code>processing-instruction(xml-stylesheet)</code> matches any
processing instruction whose PITarget is
<code>xml-stylesheet</code>.</p><p>For backward compatibility with
                                XPath 1.0, the PITarget of a
                                processing instruction may also be expressed as a
                                string literal, as in this example:
				<code>processing-instruction("xml-stylesheet")</code>.</p></li><li><p><code>comment()</code> matches any comment node.</p></li><li><p><code>document-node()</code> matches any document
node.</p></li><li><p><code>document-node(</code><em>E</em><code>)</code>
matches any document node that contains exactly one element node, optionally accompanied by one or more comment and processing instruction nodes, if
<em>E</em> is an <a href="#doc-xpath-ElementTest">ElementTest</a> or <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> that matches the element node (see
<a href="#id-element-test"><b>2.5.4.3 Element Test</b></a> and <a href="#id-schema-element-test"><b>2.5.4.4 Schema Element Test</b></a>).</p><p>Example:
<code>document-node(element(book))</code> matches a document node
containing
exactly one element node that is matched by the ElementTest
<code>element(book)</code>.</p></li><li><p>An <a href="#doc-xpath-ItemType">ItemType</a> that is an
<a href="#doc-xpath-ElementTest">ElementTest</a>, <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a>, <a href="#doc-xpath-AttributeTest">AttributeTest</a>, or <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> matches an element or
attribute node as described in the following
sections.</p></li></ul></div><div class="div4">
<h5><a id="id-element-test" name="id-element-test"></a>2.5.4.3 Element Test</h5><p>An <a href="#doc-xpath-ElementTest">ElementTest</a> is used to match an
element node by its name and/or <a title="type annotation" href="#dt-type-annotation">type annotation</a>. An <a href="#doc-xpath-ElementTest">ElementTest</a> may take any of the following forms. In these forms, <a href="#doc-xpath-ElementName">ElementName</a> need not be present in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>, but  <a href="#doc-xpath-TypeName">TypeName</a> must be present in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>. Note that <a title="substitution group" href="#dt-substitution-group">substitution groups</a> do not affect the semantics of <a href="#doc-xpath-ElementTest">ElementTest</a>.</p><ol class="enumar"><li><p><code>element()</code> and

<code>element(*)</code>  match any
single element node, regardless of its name or
type annotation.</p></li><li><p><code>element(</code><a href="#doc-xpath-ElementName">ElementName</a><code>)</code>
matches any element node whose name is <a href="#doc-xpath-ElementName">ElementName</a>, regardless of its type annotation or <code>nilled</code> property.</p><p>Example: <code>element(person)</code> matches any element node whose name is <code>person</code>.</p></li><li><p><code>element(</code><a href="#doc-xpath-ElementName">ElementName</a><code>,</code> <a href="#doc-xpath-TypeName">TypeName</a><code>)</code>
matches an element node whose name is <a href="#doc-xpath-ElementName">ElementName</a> if <code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a> <code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p><p>Example: <code>element(person, surgeon)</code> matches a
non-nilled element node whose name is <code>person</code> and whose
type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>). </p></li><li><p><code>element(</code><a href="#doc-xpath-ElementName">ElementName</a>, <a href="#doc-xpath-TypeName">TypeName</a><code> ?)</code>
matches an element node whose name is <a href="#doc-xpath-ElementName">ElementName</a> if <code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a><code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.</p><p>Example: <code>element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type
annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>).</p></li><li><p><code>element(*,
</code><a href="#doc-xpath-TypeName">TypeName</a><code>)</code> matches an element
node regardless of its name, if
<code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the element node, and the <code>nilled</code> property of the node is <code>false</code>.</p><p>Example: <code>element(*, surgeon)</code>
matches any non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p></li><li><p><code>element(*,
</code><a href="#doc-xpath-TypeName">TypeName</a><code> ?)</code> matches an element
node regardless of its name, if
<code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a> <code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the element node. The <code>nilled</code> property of the node may be either <code>true</code> or  <code>false</code>.</p><p>Example: <code>element(*, surgeon?)</code>
matches any nilled or non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p></li></ol></div><div class="div4">
<h5><a id="id-schema-element-test" name="id-schema-element-test"></a>2.5.4.4 Schema Element Test</h5><p>A <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> matches an element node against a corresponding
element declaration found in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>.
It takes the following form:</p><p><code>schema-element(</code><a href="#doc-xpath-ElementName">ElementName</a><code>)</code></p><p>If the <a href="#doc-xpath-ElementName">ElementName</a> specified in the <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> is not found in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>, a <a title="static error" href="#dt-static-error">static error</a> is raised
[<a title="err:XPST0008" href="#ERRXPST0008">err:XPST0008</a>].</p><p>A <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> matches a candidate element node if all three of the
following conditions are satisfied:</p><ol class="enumar"><li><p>The name of the candidate node matches the specified <a href="#doc-xpath-ElementName">ElementName</a> or matches the name of an element in a
<a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by an element named <a href="#doc-xpath-ElementName">ElementName</a>.</p></li><li><p><code>derives-from(</code><em>AT, ET</em><code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the candidate node and <em>ET</em> is the schema type declared for element <a href="#doc-xpath-ElementName">ElementName</a> in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>.</p></li><li><p>If the element declaration for 
<a href="#doc-xpath-ElementName">ElementName</a> in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a> is not <code>nillable</code>, then the 
<code>nilled</code> property of the candidate node is <code>false</code>.</p></li></ol><p>Example: The <a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a> <code>schema-element(customer)</code> matches a candidate element node if <code>customer</code> is a top-level element declaration in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>, the name of the candidate node is <code>customer</code> or is in a <a title="substitution group" href="#dt-substitution-group">substitution group</a> headed by <code>customer</code>, the type annotation of the candidate node  is the same as or derived from the schema type declared for the <code>customer</code> element, and either the candidate node is not <code>nilled</code> or <code>customer</code> is declared to be <code>nillable</code>.</p></div><div class="div4">
<h5><a id="id-attribute-test" name="id-attribute-test"></a>2.5.4.5 Attribute Test</h5><p>An <a href="#doc-xpath-AttributeTest">AttributeTest</a> is used to match an
attribute node by its name and/or <a title="type annotation" href="#dt-type-annotation">type annotation</a>. An <a href="#doc-xpath-AttributeTest">AttributeTest</a> any take any of the following forms. In these forms, <a href="#doc-xpath-AttributeName">AttributeName</a> need not be present in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>, but  <a href="#doc-xpath-TypeName">TypeName</a> must be present in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>.</p><ol class="enumar"><li><p><code>attribute()</code> and <code>attribute(*)</code> match any single attribute node,
regardless of its name or type annotation.</p></li><li><p><code>attribute(</code><a href="#doc-xpath-AttributeName">AttributeName</a><code>)</code>
matches any attribute node whose name is <a href="#doc-xpath-AttributeName">AttributeName</a>, regardless of its type annotation.</p><p>Example: <code>attribute(price)</code>
matches any attribute node whose name is <code>price</code>.</p></li><li><p><code>attribute(</code><a href="#doc-xpath-AttributeName">AttributeName</a>, <a href="#doc-xpath-TypeName">TypeName</a><code>)</code>
matches an attribute node whose name is <a href="#doc-xpath-AttributeName">AttributeName</a> if <code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a> <code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the attribute node.</p><p>Example: <code>attribute(price, currency)</code> matches an
attribute node whose name is <code>price</code> and whose type
annotation is
<code>currency</code> (or is derived from <code>currency</code>).</p></li><li><p><code>attribute(*,
</code><a href="#doc-xpath-TypeName">TypeName</a><code>)</code> matches an attribute
node regardless of its name, if
<code>derives-from(</code><em>AT</em>, <a href="#doc-xpath-TypeName">TypeName</a><code>)</code> is
<code>true</code>, where <em>AT</em> is the type annotation of the attribute node.</p><p>Example:
<code>attribute(*, currency)</code> matches any attribute node whose
type annotation is <code>currency</code> (or is derived from <code>currency</code>), regardless of its
name.</p></li></ol></div><div class="div4">
<h5><a id="id-schema-attribute-test" name="id-schema-attribute-test"></a>2.5.4.6 Schema Attribute Test</h5><p>A <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> matches an attribute node against a corresponding
attribute declaration found in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>.
It takes the following form:</p><p><code>schema-attribute(</code><a href="#doc-xpath-AttributeName">AttributeName</a><code>)</code></p><p>If the <a href="#doc-xpath-AttributeName">AttributeName</a> specified in the <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> is not found in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>, a <a title="static error" href="#dt-static-error">static error</a> is raised
[<a title="err:XPST0008" href="#ERRXPST0008">err:XPST0008</a>].</p><p>A <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> matches a candidate attribute node if both of the
following conditions are satisfied:</p><ol class="enumar"><li><p>The name of the candidate node matches the specified <a href="#doc-xpath-AttributeName">AttributeName</a>.</p></li><li><p><code>derives-from(</code><em>AT, ET</em><code>)</code> is <code>true</code>, where <em>AT</em> is the type annotation of the candidate node and <em>ET</em> is the schema type declared for attribute <a href="#doc-xpath-AttributeName">AttributeName</a> in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>.</p></li></ol><p>Example: The <a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a> <code>schema-attribute(color)</code> matches a candidate attribute node if <code>color</code> is a top-level attribute declaration in the <a title="in-scope attribute declarations" href="#dt-is-attrs">in-scope attribute declarations</a>, the name of the candidate node is <code>color</code>, and the type annotation of the candidate node  is the same as or derived from the schema type declared for the <code>color</code> attribute.</p></div></div></div><div class="div2">
<h3><a id="comments" name="comments"></a>2.6 Comments</h3><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-Comment" name="doc-xpath-Comment"></a>[154]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Comment">Comment</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(:"  (<a href="#doc-xpath-CommentContents">CommentContents</a>  |  <a href="#doc-xpath-Comment">Comment</a>)*  ":)"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-CommentContents" name="doc-xpath-CommentContents"></a>[162]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CommentContents">CommentContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xpath-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></td></tr></tbody></table><p>Comments may be used to provide informative annotation for <span class="xquery"><span class="xquery"><span class="xquery">a query, either in the <a title="Prolog" href="#dt-prolog">Prolog</a> or in the <a title="query body" href="#dt-queryBody">Query Body</a></span></span></span><span class="xpath"><span class="xpath"><span class="xpath">an expression</span></span></span>. Comments are lexical constructs only, and do not affect  <span class="xquery"><span class="xquery"><span class="xquery">query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">expression</span></span></span> processing.</p><p>Comments are strings, delimited by the symbols <code>(:</code> and <code>:)</code>. Comments may be nested.</p><p>A comment may be used anywhere <a title="Ignorable whitespace" href="#IgnorableWhitespace">ignorable whitespace</a> is allowed (see <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace Handling</b></a>).</p><p>The following is an example of a comment:</p><div class="exampleInner"><pre>(: Houston, we have a problem :)</pre></div></div></div><div class="div1">
<h2><a id="id-expressions" name="id-expressions"></a>3 Expressions</h2><p>This section discusses each of the basic kinds of expression. Each kind of expression has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the expression. Since [XPath/XQuery] is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</p><p>The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions.  For the complete grammar, see Appendix [<a href="#nt-bnf"><b>A [XPath/XQuery] Grammar</b></a>].</p><p> <span class="xpath"><span class="xpath"><span class="xpath">The highest-level symbol in the XPath grammar is XPath.</span></span></span> <span class="xquery"><span class="xquery"><span class="xquery">[<a title="query" id="dt-query" name="dt-query">Definition</a>: A <b>query</b> consists of one or more <a title="module" href="#dt-module">modules</a>.]  If a query is executable, one of its modules has a <a title="query body" href="#dt-queryBody">Query Body</a>  containing an expression whose value is the result of the query. An expression is represented in the XQuery grammar by the symbol <a href="#doc-xpath-Expr">Expr</a>.</span></span></span></p><table summary="Scrap" class="scrap"><span class="xpath"><tbody><span class="xpath"><tr class="xpath" valign="baseline"><td><a id="doc-xpath-XPath" name="doc-xpath-XPath"></a>[1]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-XPath" class="xpath">XPath</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xpath"><a href="#doc-xpath-Expr" class="xpath">Expr</a></span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="doc-xpath-Expr" name="doc-xpath-Expr"></a>[32]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Expr">Expr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ExprSingle" name="doc-xpath-ExprSingle"></a>[33]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ExprSingle">ExprSingle</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-FLWORExpr" class="xquery">FLWORExpr</a><br>|  <a href="#doc-xpath-ForExpr" class="xpath">ForExpr</a><br>|  <a href="#doc-xpath-QuantifiedExpr">QuantifiedExpr</a><br>|  <a href="#doc-xpath-TypeswitchExpr" class="xquery">TypeswitchExpr</a><br>|  <a href="#doc-xpath-IfExpr">IfExpr</a><br>|  <a href="#doc-xpath-OrExpr">OrExpr</a></code></td></tr></tbody></table><p>The [XPath/XQuery] operator that has lowest precedence is the <a title="comma operator" href="#dt-comma-operator">comma operator</a>, which is used to combine two operands to form a sequence. As shown in the grammar, a general expression (<a href="#doc-xpath-Expr">Expr</a>) can consist of multiple <a href="#doc-xpath-ExprSingle">ExprSingle</a> operands, separated by commas. The name <a href="#doc-xpath-ExprSingle">ExprSingle</a> denotes an expression that does not contain a top-level <a title="comma operator" href="#dt-comma-operator">comma operator</a> (despite its name, an <a href="#doc-xpath-ExprSingle">ExprSingle</a> may evaluate to a sequence containing more than one item.)</p><p>The symbol <a href="#doc-xpath-ExprSingle">ExprSingle</a> is used in various places in the grammar where an expression is not allowed to contain a top-level comma. For example, each of the arguments of a function call must be an <a href="#doc-xpath-ExprSingle">ExprSingle</a>, because commas are used to separate the arguments of a function call.</p><p>After the comma, the expressions that have next lowest precedence are <span class="xquery"><span class="xquery"><span class="xquery"><a href="#doc-xpath-FLWORExpr">FLWORExpr</a>,</span></span></span> <span class="xpath"><span class="xpath"><span class="xpath"><a href="#doc-xpath-ForExpr">ForExpr</a>, </span></span></span><a href="#doc-xpath-QuantifiedExpr">QuantifiedExpr</a>, <span class="xquery"><span class="xquery"><span class="xquery"><a href="#doc-xpath-TypeswitchExpr">TypeswitchExpr</a>, </span></span></span><a href="#doc-xpath-IfExpr">IfExpr</a>, and <a href="#doc-xpath-OrExpr">OrExpr</a>. Each of these expressions is described in a separate section of this document.</p><div class="div2">
<h3><a id="id-primary-expressions" name="id-primary-expressions"></a>3.1 Primary Expressions</h3><p> [<a title="primary expression" id="dt-primary-expression" name="dt-primary-expression">Definition</a>: <b>Primary expressions</b> are the basic primitives of the
	 language. They include literals, variable references,  context item expressions, <span class="xquery"><span class="xquery"><span class="xquery">constructors, </span></span></span>and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.]  <span class="xquery"><span class="xquery"><span class="xquery">Constructors are described in <a href="#id-constructors"><b>3.7 Constructors</b></a>.</span></span></span></p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-PrimaryExpr" name="doc-xpath-PrimaryExpr"></a>[87]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PrimaryExpr">PrimaryExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Literal">Literal</a>  |  <a href="#doc-xpath-VarRef">VarRef</a>  |  <a href="#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</a>  |  <a href="#doc-xpath-ContextItemExpr">ContextItemExpr</a>  |  <a href="#doc-xpath-FunctionCall">FunctionCall</a>  |  <a href="#doc-xpath-OrderedExpr" class="xquery">OrderedExpr</a>  |  <a href="#doc-xpath-UnorderedExpr" class="xquery">UnorderedExpr</a>  |  <a href="#doc-xpath-Constructor" class="xquery">Constructor</a></code></td></tr></tbody></table><div class="div3">
<h4><a id="id-literals" name="id-literals"></a>3.1.1 Literals</h4><p> [<a title="literal" id="dt-literal" name="dt-literal">Definition</a>: A <b>literal</b> is a direct syntactic representation of an
		atomic value.] [XPath/XQuery] supports two kinds of literals: numeric literals and
		string literals.</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-Literal" name="doc-xpath-Literal"></a>[88]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Literal">Literal</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-NumericLiteral">NumericLiteral</a>  |  <a href="#doc-xpath-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-NumericLiteral" name="doc-xpath-NumericLiteral"></a>[89]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-NumericLiteral">NumericLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-IntegerLiteral">IntegerLiteral</a>  |  <a href="#doc-xpath-DecimalLiteral">DecimalLiteral</a>  |  <a href="#doc-xpath-DoubleLiteral">DoubleLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-IntegerLiteral" name="doc-xpath-IntegerLiteral"></a>[144]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-DecimalLiteral" name="doc-xpath-DecimalLiteral"></a>[145]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("."  <a href="#doc-xpath-Digits">Digits</a>)  |  (<a href="#doc-xpath-Digits">Digits</a>  "."  [0-9]*)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-DoubleLiteral" name="doc-xpath-DoubleLiteral"></a>[146]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DoubleLiteral">DoubleLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(("."  <a href="#doc-xpath-Digits">Digits</a>)  |  (<a href="#doc-xpath-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#doc-xpath-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-StringLiteral" name="doc-xpath-StringLiteral"></a>[147]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-StringLiteral">StringLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>('"'  (<a href="#doc-xpath-PredefinedEntityRef" class="xquery">PredefinedEntityRef</a>  |  <a href="#prod-xpath-CharRef" class="xquery">CharRef</a>  |  <a href="#doc-xpath-EscapeQuot">EscapeQuot</a>  |  [^"&amp;])*  '"')  |  ("'"  (<a href="#doc-xpath-PredefinedEntityRef" class="xquery">PredefinedEntityRef</a>  |  <a href="#prod-xpath-CharRef" class="xquery">CharRef</a>  |  <a href="#doc-xpath-EscapeApos">EscapeApos</a>  |  [^'&amp;])*  "'")</code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-PredefinedEntityRef" name="doc-xpath-PredefinedEntityRef"></a>[148]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PredefinedEntityRef" class="xquery">PredefinedEntityRef</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"&amp;"</span>  (<span class="xquery">"lt"</span>  |  <span class="xquery">"gt"</span>  |  <span class="xquery">"amp"</span>  |  <span class="xquery">"quot"</span>  |  <span class="xquery">"apos"</span>)  <span class="xquery">";"</span></span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="doc-xpath-EscapeQuot" name="doc-xpath-EscapeQuot"></a>[149]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-EscapeQuot">EscapeQuot</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>'""'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-EscapeApos" name="doc-xpath-EscapeApos"></a>[150]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-EscapeApos">EscapeApos</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"''"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-Digits" name="doc-xpath-Digits"></a>[161]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Digits">Digits</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>[0-9]+</code></td></tr></tbody></table><p> The value of a <b>numeric literal</b> containing no "<code>.</code>" and no <code>e</code> or <code>E</code> character is  an atomic value of type <code>xs:integer</code>. The value of a numeric literal containing "<code>.</code>" but no <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:decimal</code>. The value of a numeric literal containing an <code>e</code> or <code>E</code> character is an atomic value of type <code>xs:double</code>. The value of the numeric literal is determined by casting it to the 
appropriate type according to the rules for casting from <code>xdt:untypedAtomic</code> 
to a numeric type as specified in <a href="http://www.w3.org/TR/xpath-functions/#casting-from-strings">Section 
17.1.1 Casting from xs:string and xdt:untypedAtomic</a><sup><small>FO</small></sup>.</p><p>The value of a <b>string literal</b> is an atomic value whose  type is <code>xs:string</code> and whose value is the string denoted by the characters between the
		delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes, two adjacent apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted as one quotation mark.</p><span class="xquery"><div class="xquery"><p class="xquery">A string literal may contain a <b>predefined entity reference</b>. [<a title="predefined entity reference" id="dt-predefined-entity-reference" name="dt-predefined-entity-reference">Definition</a>: A <b>predefined entity reference</b> is a short sequence of characters, beginning with an ampersand, that represents a single character that might otherwise have syntactic significance.] Each predefined entity reference is replaced by the character it represents when the string literal is processed. The predefined entity references recognized by XQuery are as follows:</p></div></span><span class="xquery"><div class="xquery"><table width="60%" border="1" class="xquery" summary="Special characters"><tbody><tr><td align="center">Entity Reference</td><td align="center">Character Represented</td></tr><tr><td align="center"><code>&amp;lt;</code></td><td align="center"><code>&lt;</code></td></tr><tr><td align="center"><code>&amp;gt;</code></td><td align="center"><code>&gt;</code></td></tr><tr><td align="center"><code>&amp;amp;</code></td><td align="center"><code>&amp;</code></td></tr><tr><td align="center"><code>&amp;quot;</code></td><td align="center"><code>"</code></td></tr><tr><td align="center"><code>&amp;apos;</code></td><td align="center"><code>'</code></td></tr></tbody></table></div></span><span class="xquery"><div class="xquery"><p class="xquery">A string literal may also contain a <b>character reference</b>. [<a title="character reference" id="dt-character-reference" name="dt-character-reference">Definition</a>: A <b>character reference</b> is an XML-style reference to a <a href="#Unicode">[Unicode]</a> character, identified by its decimal or hexadecimal code point.] For example, the Euro symbol (&euro;) can be represented by the character reference <code>&amp;#8364;</code>. Character references are normatively defined in Section 4.1 of the XML specification (it is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> whether the rules in   <a href="#XML">[XML 1.0]</a> or <a href="#XML1.1">[XML 1.1]</a> apply.)</p></div></span><p>Here are some examples of literal expressions:</p><ul><li><p> <code>"12.5"</code> denotes the string containing the characters '1', '2', '.', and
			 '5'.</p></li><li><p> <code>12</code> denotes the <code>xs:integer</code> value twelve.</p></li><li><p> <code>12.5</code> denotes the <code>xs:decimal</code> value twelve and one half.</p></li><li><p> <code>125E2</code> denotes the <code>xs:double</code> value twelve thousand, five hundred.</p></li><li><p><code>"He said, ""I don't like it."""</code> denotes a string containing two quotation marks and one apostrophe.</p><span class="xpath"><div class="note"><p class="prefix"><b>Note:</b></p><p>When XPath expressions are embedded in contexts where quotation 
marks have special significance, such as inside XML attributes, additional
escaping may be needed.</p></div></span></li><span class="xquery"><li class="xquery"><p><code>"Ben &amp;amp; Jerry&amp;apos;s"</code> denotes the <code>xs:string</code> value  "<code>Ben &amp; Jerry's</code>".</p></li></span><span class="xquery"><li class="xquery"><p><code>"&amp;#8364;99.50"</code> denotes the <code>xs:string</code>  value "<code>&euro;99.50</code>".</p></li></span></ul><p>The <code>xs:boolean</code> values <code>true</code> and <code>false</code> can be represented by calls to the <a title="built-in function" href="#dt-built-in-function">built-in functions</a> <code>fn:true()</code> and <code>fn:false()</code>, respectively.</p><p>Values of other atomic types can be constructed by
		calling the <a title="constructor function" href="#dt-constructor-function">constructor function</a> for the given type. The constructor functions for XML Schema
		built-in types are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. In general, the name of a constructor function for a given type is the same as the name of the type (including its namespace). For
		example:</p><ul><li><p> <code>xs:integer("12")</code> returns the integer value twelve.</p></li><li><p> <code>xs:date("2001-08-25")</code> returns an item whose type is <code>xs:date</code> and whose value represents the date 25th August 2001.</p></li><li><p><code>xdt:dayTimeDuration("PT5H")</code> returns an item whose type is <code>xdt:dayTimeDuration</code> and whose value represents a duration of five hours.</p></li></ul><p>Constructor functions can also be used to create special values that have no literal representation, as in the following examples:<ul><li><p><code>xs:float("NaN")</code> returns the special floating-point value, "Not a Number."</p></li><li><p><code>xs:double("INF")</code> returns the special double-precision value, "positive infinity."</p></li></ul></p><p>It is also possible to construct values of various types by using a <code>cast</code> expression. For example:</p><ul><li><p> <code>9 cast as
                        hatsize</code> returns the atomic value <code>9</code> 
			 whose type is  <code>hatsize</code>.</p></li></ul></div><div class="div3">
<h4><a id="id-variables" name="id-variables"></a>3.1.2 Variable References</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-VarRef" name="doc-xpath-VarRef"></a>[90]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-VarRef">VarRef</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$"  <a href="#doc-xpath-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-VarName" name="doc-xpath-VarName"></a>[91]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-VarName">VarName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody></table><p> [<a title="variable reference" id="dt-variable-reference" name="dt-variable-reference">Definition</a>: A <b>variable reference</b> is a QName preceded by a $-sign.] Two variable references are equivalent if their local names are the same and their namespace prefixes are bound to the same namespace URI in the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. An unprefixed variable reference is in no namespace.</p><p>Every variable reference must match a name in the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a>, which include variables from the following sources:<ol class="enumar"><span class="xquery"><li class="xquery"><p>A variable may be declared in a <a title="Prolog" href="#dt-prolog">Prolog</a>, in the current <a title="module" href="#dt-module">module</a> or an <b>imported module</b>. See <a href="#id-query-prolog"><b>4 Modules and Prologs</b></a> for a discussion of modules and Prologs.</p></li></span><li><p>The <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> may be augmented by <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> variables.</p></li><li><p>A variable may be bound by an [XPath/XQuery] expression. <span class="xpath"><span class="xpath"><span class="xpath">The kinds of expressions that can bind variables are <code>for</code> expressions (<a href="#id-for-expressions"><b>3.8 For Expressions</b></a>) and quantified expressions (<a href="#id-quantified-expressions"><b>3.12 Quantified Expressions</b></a>).</span></span></span><span class="xquery"><span class="xquery"><span class="xquery">The kinds of expressions that can bind variables are FLWOR expressions (<a href="#id-flwor-expressions"><b>3.9 FLWOR Expressions</b></a>), quantified expressions (<a href="#id-quantified-expressions"><b>3.12 Quantified Expressions</b></a>), and <code>typeswitch</code> expressions (<a href="#id-typeswitch"><b>3.13.2 Typeswitch</b></a>).  Function calls also bind values to the formal parameters of functions before executing the function body. </span></span></span></p></li></ol></p><p>Every variable binding has a static scope. The scope defines where
references to the variable can validly occur.

It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XPST0008" href="#ERRXPST0008">err:XPST0008</a>] to reference a variable that is not in scope. If a variable is bound in the <a title="static context" href="#dt-static-context">static context</a> for an expression, that variable is in scope for the entire expression.</p><p>If a variable reference matches two or more variable bindings that are in scope,
then the reference is taken as referring to the
inner binding, that is, the one whose scope is smaller.

At evaluation time, the value of a variable reference is the value of
the expression to which the relevant variable is bound.

The scope of a variable binding is defined separately for each kind of
expression that can bind variables.</p></div><div class="div3">
<h4><a id="id-paren-expressions" name="id-paren-expressions"></a>3.1.3 Parenthesized Expressions</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-ParenthesizedExpr" name="doc-xpath-ParenthesizedExpr"></a>[92]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"("  <a href="#doc-xpath-Expr">Expr</a>?  ")"</code></td></tr></tbody></table><p>Parentheses may be used to enforce a particular evaluation order in
		expressions that contain multiple operators. For example, the expression <code>(2 + 4)
		    * 5</code> evaluates to thirty, since the parenthesized expression <code>(2 + 4)</code> is evaluated first and its result is multiplied by five. Without
			 parentheses, the expression <code>2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher
			 precedence than the addition operator.</p><p>Empty parentheses are used to denote an empty sequence, as
		described in <a href="#construct_seq"><b>3.3.1 Constructing Sequences</b></a>.</p></div><div class="div3">
<h4><a id="id-context-item-expression" name="id-context-item-expression"></a>3.1.4 Context Item Expression</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-ContextItemExpr" name="doc-xpath-ContextItemExpr"></a>[93]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ContextItemExpr">ContextItemExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"."</code></td></tr></tbody></table><p>A <b>context item expression</b> evaluates to
              the <a title="context item" href="#dt-context-item">context item</a>, which may be either a node (as in the
              expression
              <code>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</code>)
              or an atomic value (as in the expression <code>(1 to
              100)[. mod 5 eq 0]</code>).</p><p>If the <a title="context item" href="#dt-context-item">context item</a> is undefined, a context item expression raises a dynamic error [<a title="err:XPDY0002" href="#ERRXPDY0002">err:XPDY0002</a>].</p></div><div class="div3">
<h4><a id="id-function-calls" name="id-function-calls"></a>3.1.5 Function Calls</h4><p> [<a title="built-in function" id="dt-built-in-function" name="dt-built-in-function">Definition</a>: The <b>built-in functions</b> supported by [XPath/XQuery] are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.] <span class="xpath"><span class="xpath"><span class="xpath">Additional functions may be provided in
		the <a title="static context" href="#dt-static-context">static
		context</a>. XPath per se does not provide a way
		to declare functions, but a host language may provide
		such a mechanism.</span></span></span>

		<span class="xquery"><span class="xquery"><span class="xquery">Additional functions may be declared in a
		  <a title="Prolog" href="#dt-prolog">Prolog</a>, imported
		  from a <a title="library module" href="#dt-library-module">library module</a>, or provided by
		  the external environment as part of the <a title="static context" href="#dt-static-context">static
		  context</a>.</span></span></span></p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-FunctionCall" name="doc-xpath-FunctionCall"></a>[96]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-FunctionCall">FunctionCall</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a>  "("  (<a href="#doc-xpath-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*)?  ")"</code></td></tr></tbody></table><p>A <b>function call</b> consists of a QName followed by a
		parenthesized list of zero or more expressions, called
		<b>arguments</b>. If the QName in the function
		call has no namespace prefix, it is considered to be
		in the <a title="default function namespace" href="#dt-def-fn-ns">default function
		namespace.</a></p><p> If the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and number of arguments in a function call do not match the name and arity
		of a <a title="function signature" href="#dt-function-signature">function signature</a> in the <a title="static context" href="#dt-static-context">static context</a>,  a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>].</p><p>A function call is evaluated as follows:</p><ol class="enumar"><li><p>Argument expressions are evaluated, producing argument
			 values. The order of argument evaluation is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> and a function need not evaluate an argument if the function can evaluate its body without evaluating that argument.</p></li><li><p>Each argument value is converted by applying the
			 function conversion rules listed below.</p></li><span class="xpath"><li class="xpath"><p>The function is evaluated using the converted argument values. The result is either an instance of the function's declared return type  or a dynamic error. The <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a function result may be a type that is derived from the declared return type. Errors raised by functions are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p></li></span><span class="xquery"><li class="xquery"><p>If the function is a built-in function, it is evaluated using the converted argument values. The result is either an instance of the function's declared return type or a dynamic error. Errors raised by built-in functions are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p></li></span><span class="xquery"><li class="xquery"><p>If the function is a user-declared
		  function, the converted argument values are bound to
		  the formal parameters of the function, and the
		  function body is evaluated. The value returned by
		  the function body is then converted to the declared
		  return type of the function by applying the function
		  conversion rules.</p><p>When a converted argument
		  value is bound to a function parameter, the argument
		  value retains its most specific <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>, even
		  though this type may be derived from the type of the
		  formal parameter. For example, a function with a
		  parameter <code>$p</code> of type
		  <code>xs:decimal</code> can be invoked with an
		  argument of type <code>xs:integer</code>, which is
		  derived from <code>xs:decimal</code>. During the
		  processing of this function invocation, the <a title="dynamic type" href="#dt-dynamic-type">dynamic
		  type</a> of <code>$p</code> inside the body of the
		  function is considered to be
		  <code>xs:integer</code>. Similarly, the value
		  returned by a function retains its most specific
		  type, which may be derived from the declared return
		  type of the function. For example, a function that
		  has a declared return type of
		  <code>xs:decimal</code> may in fact return a value
		  of dynamic type <code>xs:integer</code>.</p><p>During evaluation of a function body, the <a title="static context" href="#dt-static-context">static context</a> and <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> for expression evaluation are defined by the <a title="module" href="#dt-module">module</a> in which the function is declared, which is not necessarily the same as the <a title="module" href="#dt-module">module</a> in which the function is called. For example, the variables in scope while
evaluating a function body are defined by in-scope variables of the
module that declares the function rather than the module in which the
function is called. During
		  evaluation of a function body, the <a title="focus" href="#dt-focus">focus</a>
		  (context item, context position, and context size) is
		  undefined, except where it is defined by some expression inside the function body.</p></li></span></ol><p>The <b>function conversion rules</b> are used to convert an
		argument value <span class="xquery"><span class="xquery"><span class="xquery">or a return value </span></span></span> to its expected type; that is, to
		the declared type of the function <span class="xpath"><span class="xpath"><span class="xpath">parameter.</span></span></span><span class="xquery"><span class="xquery"><span class="xquery">parameter or return.</span></span></span> The expected type is expressed as a <a title="sequence type" href="#dt-sequence-type">sequence type</a>. The function conversion rules are applied to a given value
		as follows:</p><ul><span class="xpath"><li class="xpath"><p>If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0
		compatibility mode</a> is <code>true</code> and an
		argument is not of the expected type, then the
		following conversions are
		applied sequentially to the argument value V:</p><ol class="enumar"><li><p>If the expected type calls for a single item or optional single item (examples: <code>xs:string</code>, <code>xs:string?</code>, <code>xdt:untypedAtomic</code>, <code>xdt:untypedAtomic?</code>, <code>node()</code>, <code>node()?</code>, <code>item()</code>, <code>item()?</code>), then the value V is effectively replaced by V[1].</p></li><li><p>If the expected type is
		<code>xs:string</code> or <code>xs:string?</code>,
		then the  value <code>V</code> is effectively
		replaced by
		<code>fn:string(V)</code>.</p></li><li><p>If
		the expected type is <code>xs:double</code> or <code>xs:double?</code>, then the value <code>V</code> is effectively replaced by
		<code>fn:number(V)</code>.</p></li></ol></li></span><li><p>If the
		expected type is a sequence of an atomic type
		(possibly with an occurrence indicator <code>*</code>,
		<code>+</code>, or <code>?</code>), the following
		conversions are applied:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied
		to the given value, resulting in a sequence of atomic
		values.</p></li><li><p>Each item in the atomic
		sequence that is of type
		<code>xdt:untypedAtomic</code> is cast to the expected
		atomic type. For <a title="built-in function" href="#dt-built-in-function">built-in functions</a> where the expected type is specified as <a title="numeric" href="#dt-numeric">numeric</a>, arguments of type <code>xdt:untypedAtomic</code> are cast to <code>xs:double</code>.</p></li><li><p>For each <a title="numeric" href="#dt-numeric">numeric</a> item
		in the atomic sequence that can be
		<a title="type promotion" href="#dt-type-promotion">promoted</a> to the expected atomic type
		using numeric promotion as described in <a href="#promotion"><b>B.1 Type Promotion</b></a>, the promotion is
		done.</p></li><li><p>For each item of type <code>xs:anyURI</code>
		in the atomic sequence that can be
		<a title="type promotion" href="#dt-type-promotion">promoted</a> to the expected atomic type
		using URI promotion as described in <a href="#promotion"><b>B.1 Type Promotion</b></a>, the promotion is
		done.</p></li></ol></li><li><p> If, after the
		above conversions, the resulting value does not match
		the expected type according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
		Matching</a>, a <a title="type error" href="#dt-type-error">type error</a> is
		raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].
		<span class="xquery"><span class="xquery"><span class="xquery">If the function call takes place in a <a title="module" href="#dt-module">module</a> other
		than the <a title="module" href="#dt-module">module</a> in which the function is defined, this
		rule must be satisfied in both the module where the
		function is called and the module where the function
		is defined (the test is repeated because the two
		modules may have different <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>.)</span></span></span>
		Note that the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
		Matching</a> permit a value of a derived type to
		be substituted for a value of its base
		type. </p></li></ul><p>Since the arguments of a function call are separated by commas, any
argument expression that contains a top-level <a title="comma operator" href="#dt-comma-operator">comma operator</a> must be
enclosed in parentheses. Here are some illustrative examples of
function calls:</p><ul><li><p> <code>my:three-argument-function(1,
			2, 3)</code> denotes a function call with three arguments.</p></li><li><p> <code>my:two-argument-function((1,
			2), 3)</code> denotes a function call with two arguments, the first of which is a
			 sequence of two values.</p></li><li><p> <code>my:two-argument-function(1,
			())</code> denotes a function call with two arguments, the second of which is an
			 empty sequence.</p></li><li><p> <code>my:one-argument-function((1, 2,
			3))</code> denotes a function call with one argument that is a sequence of three
			 values. </p></li><li><p> <code>my:one-argument-function(( ))</code> denotes a function call with one argument that is an empty sequence.</p></li><li><p> <code>my:zero-argument-function( )</code> denotes a function call with zero arguments.</p></li></ul></div></div><div class="div2">
<h3><a id="id-path-expressions" name="id-path-expressions"></a>3.2 Path Expressions</h3><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-PathExpr" name="doc-xpath-PathExpr"></a>[71]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PathExpr">PathExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("/"  <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a>?)<br>|  ("//"  <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a>)<br>|  <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-RelativePathExpr" name="doc-xpath-RelativePathExpr"></a>[72]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-StepExpr">StepExpr</a>  (("/"  |  "//")  <a href="#doc-xpath-StepExpr">StepExpr</a>)*</code></td></tr></tbody></table><p>[<a title="path expression" id="dt-path-expression" name="dt-path-expression">Definition</a>: A <b>path expression</b> can be used to locate nodes
	 within trees. A path expression consists of a series of one or more
	 <a title="step" href="#dt-step">steps</a>, separated by "<code>/</code>" or
	 "<code>//</code>", and optionally beginning with
	 "<code>/</code>" or "<code>//</code>".] An initial
	 "<code>/</code>" or "<code>//</code>" is an abbreviation for
	 one or more initial steps that are implicitly added to the
	 beginning of the path expression, as described below.</p><p>A
	 path expression consisting of a single step is evaluated as
	 described in <a href="#id-steps"><b>3.2.1 Steps</b></a>.</p><p>A "<code>/</code>"
	 at the beginning of a path expression is an abbreviation for
	 the initial step <code>fn:root(self::node()) treat as
	 document-node()/</code> (however, if the 
	 "<code>/</code>" is the entire path expression, the trailing "<code>/</code>" is omitted from the expansion.) The effect
	 of this initial step is to begin the path at the root node of
	 the tree that contains the context node. If the context item
	 is not a node, a <a title="type error" href="#dt-type-error">type
	 error</a> is raised [<a title="err:XPTY0020" href="#ERRXPTY0020">err:XPTY0020</a>]. At
	 evaluation time, if the root node above the context node is
	 not a document node, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is
	 raised [<a title="err:XPDY0050" href="#ERRXPDY0050">err:XPDY0050</a>].</p><p>A "<code>//</code>" at the beginning of a path expression
	 is an abbreviation for the initial steps
	 <code>fn:root(self::node()) treat as
	 document-node()/descendant-or-self::node()/</code> (however, "<code>//</code>" by itself is not a valid path expression [<a title="err:XPST0003" href="#ERRXPST0003">err:XPST0003</a>].)  The
	 effect of these initial steps is to establish an initial node
	 sequence that contains the root of the tree in which the
	 context node is found, plus all nodes descended from this
	 root.
	 This node sequence is used as the input to subsequent steps
	 in the path expression. If the context item is not a node, a
	 <a title="type error" href="#dt-type-error">type error</a> is
	 raised [<a title="err:XPTY0020" href="#ERRXPTY0020">err:XPTY0020</a>]. At evaluation time, if the
	 root node above the context node is not a document node, a
	 <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is
	 raised [<a title="err:XPDY0050" href="#ERRXPDY0050">err:XPDY0050</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The descendants of a node do not include attribute
	 nodes <span class="xpath"><span class="xpath"><span class="xpath"> or namespace nodes</span></span></span>.</p></div><p>Each
	 non-initial occurrence of "<code>//</code>" in a path expression is
	 expanded as described in <a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>, leaving a
	 sequence of steps separated by "<code>/</code>". This sequence
	 of steps is then evaluated from left to right. Each operation
	 <code>E1/E2</code> is evaluated as follows:
	 Expression <code>E1</code> is evaluated,
	 and if the result is not a (possibly empty) sequence of nodes, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0019" href="#ERRXPTY0019">err:XPTY0019</a>]. Each node resulting from the evaluation of
	 <code>E1</code> then serves in turn to provide an <b>inner
	 focus</b> for an evaluation of <code>E2</code>, as
	 described in <a href="#eval_context"><b>2.1.2 Dynamic Context</b></a>. The sequences resulting from all the evaluations of <code>E2</code> are combined as follows:</p><ol class="enumar"><li><p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of 
nodes, these sequences are combined, and duplicate nodes are eliminated 
based on node identity. <span class="xpath"><span class="xpath"><span class="xpath">The resulting node sequence is returned in <a title="document order" href="#dt-document-order">document
	 order</a>.</span></span></span> <span class="xquery"><span class="xquery"><span class="xquery">If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the resulting node sequence is returned in <a title="document order" href="#dt-document-order">document
	 order</a>; otherwise it is returned in <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> order.</span></span></span></p></li><li><p>If every evaluation of <code>E2</code> returns a (possibly empty) sequence of 
atomic values, these sequences are concatenated<span class="xpath"><span class="xpath"><span class="xpath">, in order,</span></span></span> and returned. <span class="xquery"><span class="xquery"><span class="xquery">If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the returned sequence preserves the orderings within and among the subsequences generated by the evaluations of <code>E2</code>; otherwise the order of the returned sequence is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</span></span></span></p></li><li><p>If the multiple evaluations of <code>E2</code> return at least 
one node and at least one atomic value, a <a title="type error" href="#dt-type-error">type
	 error</a> is raised [<a title="err:XPTY0018" href="#ERRXPTY0018">err:XPTY0018</a>].</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Since each step in a path provides context nodes for the following 
step, in effect, only the last step in a path is allowed to return a 
sequence of atomic values.</p></div><p>As an example of a path expression, <code>child::div1/child::para</code> selects the
	 <code>para</code> element children of the <code>div1</code>
	 element children of the context node, or, in other words, the
	 <code>para</code> element grandchildren of the context node
	 that have <code>div1</code> parents.</p><div class="note"><p class="prefix"><b>Note:</b></p><p id="Chg-slash-note">The "<code>/</code>" character can be used either as a complete path expression or as the beginning of a longer path expression such as "<code>/*</code>".      Also, "<code>*</code>" is both the multiply operator and a wildcard in path     expressions.  This can cause
	 parsing difficulties when "<code>/</code>" appears on the left hand side of "<code>*</code>".    This is resolved using the <a href="#parse-note-leading-lone-slash">leading-lone-slash </a> constraint.    For example, "<code>/*</code>" and "<code>/ *</code>" are valid path
	 expressions containing wildcards, but "<code>/*5</code>" and "<code>/ * 5</code>" raise syntax errors. Parentheses must be used when
	 "<code>/</code>" is used on the left hand side of an operator,
	 as in "<code>(/) * 5</code>". Similarly, "<code>4 + / * 5</code>" raises a syntax error, but "<code>4 + (/) * 5</code>" is a valid expression.  The expression "<code>4 + /</code>" is also valid, because <code>/</code> does not occur on the left hand side of the operator.</p></div><div class="div3">
<h4><a id="id-steps" name="id-steps"></a>3.2.1 Steps</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-StepExpr" name="doc-xpath-StepExpr"></a>[73]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-StepExpr">StepExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-FilterExpr">FilterExpr</a>  |  <a href="#doc-xpath-AxisStep">AxisStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-AxisStep" name="doc-xpath-AxisStep"></a>[74]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AxisStep">AxisStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xpath-ReverseStep">ReverseStep</a>  |  <a href="#doc-xpath-ForwardStep">ForwardStep</a>)  <a href="#doc-xpath-PredicateList">PredicateList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ForwardStep" name="doc-xpath-ForwardStep"></a>[75]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ForwardStep">ForwardStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xpath-ForwardAxis">ForwardAxis</a>  <a href="#doc-xpath-NodeTest">NodeTest</a>)  |  <a href="#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ReverseStep" name="doc-xpath-ReverseStep"></a>[78]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ReverseStep">ReverseStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xpath-ReverseAxis">ReverseAxis</a>  <a href="#doc-xpath-NodeTest">NodeTest</a>)  |  <a href="#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-PredicateList" name="doc-xpath-PredicateList"></a>[85]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PredicateList">PredicateList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Predicate">Predicate</a>*</code></td></tr></tbody></table><p>[<a title="step" id="dt-step" name="dt-step">Definition</a>: A <b>step</b> is a part of a <a title="path expression" href="#dt-path-expression">path expression</a> that generates a sequence of items
		and then filters the sequence by zero or more
		<a title="predicate" href="#dt-predicate">predicates</a>. The value of the step
		consists of those items that satisfy the
		predicates. A step may be either an <a title="axis step" href="#dt-axis-step">axis step</a> or a <a title="filter expression" href="#dt-filter-expression">filter expression</a>.] Filter expressions are described in <a href="#id-filter-expr"><b>3.3.2 Filter Expressions</b></a>.</p><p>[<a title="axis step" id="dt-axis-step" name="dt-axis-step">Definition</a>: An <b>axis step</b> returns a sequence of nodes that are reachable from the context node via a specified axis. Such a step has two parts: an
		<b>axis</b>, which defines the "direction of
		movement" for the step, and a <a title="node test" href="#dt-node-test">node test</a>,
		which selects nodes based on their kind, name, and/or
		<a title="type annotation" href="#dt-type-annotation">type annotation</a>.] If the context item is a node, an axis
		step returns a sequence of zero or more
		nodes; otherwise, a <a title="type error" href="#dt-type-error">type error</a> is
		raised [<a title="err:XPTY0020" href="#ERRXPTY0020">err:XPTY0020</a>].   <span class="xpath"><span class="xpath"><span class="xpath">The resulting node sequence is returned in <a title="document order" href="#dt-document-order">document
	 order</a>.</span></span></span> <span class="xquery"><span class="xquery"><span class="xquery">If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the resulting node sequence is returned in <a title="document order" href="#dt-document-order">document
	 order</a>; otherwise it is returned in <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> order.</span></span></span> An axis step may be either a <b>forward
		step</b> or a <b>reverse step</b>, followed
		by zero or more <a title="predicate" href="#dt-predicate">predicates</a>.</p><p>In the <b>abbreviated syntax</b> for a step, the axis can
		be omitted and other shorthand notations can be used as described in
		<a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p><p>The unabbreviated syntax for an axis step consists of the axis name
		and node test separated by a double colon. The result of the step consists of the nodes
		reachable from the context node via the specified axis that have the node kind, name,
		and/or <a title="type annotation" href="#dt-type-annotation">type annotation</a> specified by the node test. For example, the
		step <code>child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <a href="#axes"><b>3.2.1.1 Axes</b></a>. The
		available node tests are described in <a href="#node-tests"><b>3.2.1.2 Node Tests</b></a>. Examples of 
		steps are provided in <a href="#unabbrev"><b>3.2.3 Unabbreviated Syntax</b></a> and <a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p><div class="div4">
<h5><a id="axes" name="axes"></a>3.2.1.1 Axes</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-ForwardAxis" name="doc-xpath-ForwardAxis"></a>[76]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ForwardAxis">ForwardAxis</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("child"  "::")<br>|  ("descendant"  "::")<br>|  ("attribute"  "::")<br>|  ("self"  "::")<br>|  ("descendant-or-self"  "::")<br>|  ("following-sibling"  "::")<br>|  ("following"  "::")<br>|  (<span class="xpath">"namespace"</span>  <span class="xpath">"::"</span>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ReverseAxis" name="doc-xpath-ReverseAxis"></a>[79]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ReverseAxis">ReverseAxis</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("parent"  "::")<br>|  ("ancestor"  "::")<br>|  ("preceding-sibling"  "::")<br>|  ("preceding"  "::")<br>|  ("ancestor-or-self"  "::")</code></td></tr></tbody></table><span class="xpath"><div class="xpath"><p class="xpath">XPath defines a full set of <b>axes</b>
		  for traversing documents, but a <b>host language</b> may define a subset
		  of these axes. The following axes are defined:</p></div></span><span class="xquery"><div class="xquery"><p class="xquery">XQuery supports the following axes
		  (subject to limitations as described in <a href="#id-full-axis-feature"><b>5.2.4 Full Axis Feature</b></a>):</p></div></span><ul><li><p>The <code>child</code> axis
				contains the children of the context
				node, which are the nodes returned by
				the <code>dm:children</code> accessor
				in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Only document
                                                  nodes and element
                                                  nodes have
                                                  children. If the
                                                  context node is any
                                                  other kind of node,
                                                  or if the context
                                                  node is an empty
                                                  document or element
                                                  node, then the child
                                                  axis is an empty
                                                  sequence.  The
                                                  children of a
                                                  document node or
                                                  element node may be
                                                  element, processing
                                                  instruction,
                                                  comment, or text
                                                  nodes.  Attribute<span class="xpath"><span class="xpath"><span class="xpath">,
                                                  namespace,</span></span></span> and
                                                  document nodes can
                                                  never appear as
                                                  children.</p></div></li><li><p>the <code>descendant</code>
			 axis is defined as the transitive closure of
			 the child axis; it contains the descendants
			 of the context node (the children, the children of the children, and so on)</p></li><li><p>the <code>parent</code>
                                          axis contains the sequence
                                          returned by the
                                          <code>dm:parent</code>
                                          accessor in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, which returns
                                          the parent of the context
                                          node, or an empty sequence
                                          if the context node has no
                                          parent</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An attribute node may have an element node as its parent, even though the attribute node is not a child of the element node.</p></div></li><li><p>the
                                        <code>ancestor</code> axis is
                                        defined as the transitive
                                        closure of the parent axis; it
                                        contains the ancestors of the
                                        context node (the parent, the
                                        parent of the parent, and so
                                        on)</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The ancestor axis
                                        includes the root node of the
                                        tree in which the context node
                                        is found, unless the context
                                        node is the root node.</p></div></li><li><p>the <code>following-sibling</code>
			 axis contains the context node's following
			 siblings, those children of the context
			 node's parent that occur after the context
			 node in <a title="document order" href="#dt-document-order">document order</a>; if the context node
			 is an attribute <span class="xpath"><span class="xpath"><span class="xpath"> or namespace </span></span></span> node, the
			 <code>following-sibling</code> axis is
			 empty</p></li><li><p>the <code>preceding-sibling</code>
			 axis contains the context node's preceding
			 siblings, those children of the context
			 node's parent that occur before the context
			 node in <a title="document order" href="#dt-document-order">document order</a>; if the context node
			 is an attribute <span class="xpath"><span class="xpath"><span class="xpath"> or namespace </span></span></span> node, the
			 <code>preceding-sibling</code> axis is
			 empty</p></li><li><p>the <code>following</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not descendants of the context node,
				and occur after the context node in
				<a title="document order" href="#dt-document-order">document order</a></p></li><li><p>the <code>preceding</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not ancestors of the context node, and
				occur before the context node in
				<a title="document order" href="#dt-document-order">document order</a></p></li><li><p>the <code>attribute</code> axis
			 contains the attributes of the context node,
			 which are the nodes returned by the
			 <code>dm:attributes</code> accessor in
			 <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>; the axis will be
			 empty unless the context node is an
			 element</p></li><li><p>the <code>self</code> axis contains just the context node itself</p></li><li><p>the <code>descendant-or-self</code> axis contains the context node and the descendants of the context
				node</p></li><li><p>the <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node;
				thus, the ancestor-or-self axis will always include the root node</p></li><span class="xpath"><li class="xpath"><p>the <code>namespace</code> axis
				contains the namespace nodes of the
				context node, which are the nodes
				returned by the
				<code>dm:namespace-nodes</code> accessor in
				<a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>; this axis
				is empty unless the context node is an
				element node. The
				<code>namespace</code> axis is
				deprecated in XPath 2.0. If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0
		compatibility mode</a> is <code>true</code>, the <code>namespace</code> axis must be supported. If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0
		compatibility mode</a> is <code>false</code>, then support for the
				<code>namespace</code> axis is
				<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. An implementation
				that does not support the
				<code>namespace</code> axis when <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0
		compatibility mode</a> is <code>false</code> must raise
				a <a title="static error" href="#dt-static-error">static
				error</a> [<a title="err:XPST0010" href="#ERRXPST0010">err:XPST0010</a>] if it is
				used. Applications needing information
				about the <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a> of an element
				should use the functions
				<code>fn:in-scope-prefixes</code>
				and
				<code>fn:namespace-uri-for-prefix</code>
				defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p></li></span></ul><p>Axes can be categorized as <b>forward axes</b> and
		  <b>reverse axes</b>. An axis that only ever contains the context node or
		  nodes that are after the context node in <a title="document order" href="#dt-document-order">document order</a> is a forward axis. An
		  axis that only ever contains the context node or nodes that are before the
		  context node in <a title="document order" href="#dt-document-order">document order</a> is a reverse axis.</p><p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, and <code>preceding-sibling</code> axes are reverse axes; all other axes are forward axes. The <code>ancestor</code>, <code>descendant</code>, <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a document (ignoring attribute <span class="xpath"><span class="xpath"><span class="xpath">and namespace</span></span></span> nodes):
		  they do not overlap and together they contain all the nodes in the
		  document.</p><p>[<a title="principal node kind" id="dt-principal-node-kind" name="dt-principal-node-kind">Definition</a>: Every axis has a <b>principal node kind</b>. If an axis can
		  contain elements, then the principal node kind is element; otherwise, it is the
		  kind of nodes that the axis can contain.] Thus:</p><ul><li><p>For the attribute axis, the principal node kind is
				attribute.</p></li><span class="xpath"><li class="xpath"><p>For the namespace axis, the principal node kind is
				namespace.</p></li></span><li><p>For all other axes, the principal node kind is element.</p></li></ul><p>In a sequence of nodes selected by an axis step, each
		node is assigned a context position that corresponds
		to its position in the sequence. If the axis is a
		forward axis, context positions are assigned to the
		nodes in <a title="document order" href="#dt-document-order">document order</a>, starting with 1. If the axis
		is a reverse axis, context positions are assigned to
		the nodes in <a title="reverse document order" href="#dt-reverse-document-order">reverse document order</a>, starting with
		1. This makes it possible to select a node from the
		sequence by specifying its position.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>One example of an expression that uses the
		context position is a <a title="numeric predicate" href="#dt-numeric-predicate">numeric predicate</a>. The
		expression <code>child::para[1]</code> selects the
		first <code>para</code> element that is a child of the context node.
		</p></div></div><div class="div4">
<h5><a id="node-tests" name="node-tests"></a>3.2.1.2 Node Tests</h5><p>[<a title="node test" id="dt-node-test" name="dt-node-test">Definition</a>: A <b>node test</b> is a condition that must
		  be true for each node selected by a <a title="step" href="#dt-step">step</a>.] The
		  condition may be based on the kind of the node
		  (element, attribute, text, document, comment,
		  or processing instruction), the name of
		  the node, or (in the case of element, attribute, and document
		  nodes), the <a title="type annotation" href="#dt-type-annotation">type annotation</a> of the node.</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-NodeTest" name="doc-xpath-NodeTest"></a>[81]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-NodeTest">NodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-KindTest">KindTest</a>  |  <a href="#doc-xpath-NameTest">NameTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-NameTest" name="doc-xpath-NameTest"></a>[82]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-NameTest">NameTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a>  |  <a href="#doc-xpath-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-Wildcard" name="doc-xpath-Wildcard"></a>[83]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Wildcard">Wildcard</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"*"<br>|  (<a href="#prod-xpath-NCName">NCName</a>  ":"  "*")<br>|  ("*"  ":"  <a href="#prod-xpath-NCName">NCName</a>)</code></td></tr></tbody></table><p>[<a title="name test" id="dt-name-test" name="dt-name-test">Definition</a>: A node test that consists only of a QName or a
		  Wildcard is called a <b>name test</b>.] A name
		  test is true if and only if the <b>kind</b> of
		  the node is the <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a> for the step axis and the
		  <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of the node is equal (on a codepoint basis) to the
		  <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> specified by the name test. For
		  example, <code>child::para</code>
		  selects the <code>para</code> element children of
		  the context node; if the context node has no
		  <code>para</code> children, it selects an empty set
		  of nodes. <code>attribute::abc:href</code> selects
		  the attribute of the context node with the QName
		  <code>abc:href</code>; if the context node has no
		  such attribute, it selects an empty set of
		  nodes.</p><p>A QName in a name test is resolved into an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> using the
		  <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> in the expression
		  context. It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XPST0008" href="#ERRXPST0008">err:XPST0008</a>] if the QName has a prefix that does not
		  correspond to any statically known namespace. An unprefixed QName, when used as a
		  name test on an axis whose <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a> is
		  element, has the namespace URI of the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> in
		  the expression context; otherwise, it has no namespace URI. </p><p>A name test is not satisfied by an element node whose name does not match the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of the name test, even if it is in a <a title="substitution group" href="#dt-substitution-group">substitution group</a> whose head is the named element.</p><p>A node test <code>*</code> is true for any node of the <a title="principal node kind" href="#dt-principal-node-kind">principal node kind</a> of the step axis. For example, <code>child::*</code> will select all element children of the context node, and <code>attribute::*</code> will select all attributes of the context node.</p><p>A node test can have the form
		  <code>NCName:*</code>. In this case, the prefix is
		  expanded in the same way as with a QName, using the
		  <a title="statically known namespaces" href="#dt-static-namespaces">statically known
		  namespaces</a> in the <a title="static context" href="#dt-static-context">static context</a>. If
		  the prefix is not found in the statically known namespaces,
		  a <a title="static error" href="#dt-static-error">static
		  error</a> is raised [<a title="err:XPST0008" href="#ERRXPST0008">err:XPST0008</a>].
		  The node test is true for any node of the <a title="principal node kind" href="#dt-principal-node-kind">principal
		  node kind</a> of the step axis whose <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> has the namespace URI
		  to which the prefix is bound, regardless of the
		  local part of the name.</p><p>A node test can also
		  have the form <code>*:NCName</code>. In this case,
		  the node test is true for any node of the <a title="principal node kind" href="#dt-principal-node-kind">principal
		  node kind</a> of the step axis whose local name matches the given NCName,
		  regardless of its namespace or lack of a namespace.</p><p>[<a title="kind test" id="dt-kind-test" name="dt-kind-test">Definition</a>: An alternative
		  form of a node test called a
		  <b>kind test</b> can select nodes based
		  on their kind, name, and <a title="type annotation" href="#dt-type-annotation">type annotation</a>.] The syntax
		  and semantics of a kind test are described in
		  <a href="#id-sequencetype-syntax"><b>2.5.3 SequenceType Syntax</b></a> and <a href="#id-sequencetype-matching"><b>2.5.4 SequenceType Matching</b></a>. When a kind test is used
		  in a <a title="node test" href="#dt-node-test">node test</a>, only those nodes on the designated
		  axis that match the kind test are selected. Shown
		  below are several examples of kind tests that might
		  be used in path
		  expressions:</p><ul><li><p><code>node()</code>
		  matches any
		  node.</p></li><li><p><code>text()</code> matches
		  any text
		  node.</p></li><li><p><code>comment()</code>
		  matches any comment
		  node.</p></li><li><p><code>element()</code>
		  matches any element
		  node.</p></li><li><p><code>schema-element(person)</code>
		  matches any element node whose name is
		  <code>person</code> (or is in the <a title="substitution group" href="#dt-substitution-group">substitution group</a>
		  headed by <code>person</code>), and whose type
		  annotation is the same as (or is derived from) the declared type of the <code>person</code>
		  element in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>.</p></li><li><p><code>element(person)</code> matches any element node whose name is
		  <code>person</code>, regardless of its type annotation.</p></li><li><p><code>element(person, surgeon)</code> matches any non-nilled element node whose name
		  is <code>person</code>, and whose type
		  annotation is
		  <code>surgeon</code> or is derived from <code>surgeon</code>.</p></li><li><p><code>element(*,
		  surgeon)</code> matches any non-nilled element node whose type
		  annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of
		  its
		  name.</p></li><li><p><code>attribute()</code> matches any
                  attribute node.</p></li><li><p><code>attribute(price)</code> matches
                  any attribute whose name is <code>price</code>,
                  regardless of its type annotation.</p></li><li><p><code>attribute(*,
                  xs:decimal)</code> matches any attribute whose type
                  annotation is <code>xs:decimal</code> (or is derived from <code>xs:decimal</code>), regardless of
                  its
                  name.</p></li><li><p><code>document-node()</code>
                  matches any document
                  node.</p></li><li><p><code>document-node(element(book))</code>
                  matches any document node whose content consists of
                  a single element node that satisfies the <a title="kind test" href="#dt-kind-test">kind test</a>
                  <code>element(book)</code>, interleaved with zero or more
                  comments and processing
                  instructions.</p></li></ul></div></div><div class="div3">
<h4><a id="id-predicates" name="id-predicates"></a>3.2.2 Predicates</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-Predicate" name="doc-xpath-Predicate"></a>[86]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Predicate">Predicate</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"["  <a href="#doc-xpath-Expr">Expr</a>  "]"</code></td></tr></tbody></table><p>[<a title="predicate" id="dt-predicate" name="dt-predicate">Definition</a>: A <b>predicate</b> consists of an expression, called a <b>predicate
		expression</b>, enclosed in square brackets. A predicate serves to filter a sequence, retaining some items and discarding others.] For each item in the sequence to be filtered, the predicate expression is evaluated using an
		<b>inner focus</b> derived from that item, as described in
		<a href="#eval_context"><b>2.1.2 Dynamic Context</b></a>. The result of the predicate expression is
		coerced to a <code>xs:boolean</code> value, called the <b>predicate truth value</b>, as
		described below. Those items for which the predicate truth value is <code>true</code> are retained, and those for which the predicate truth value is <code>false</code> are discarded.</p><p>The predicate truth value is derived by applying the following rules,
		in order:</p><ol class="enumar"><li><p>If the value of the predicate expression is a <a title="singleton" href="#dt-singleton">singleton</a> atomic value of a
			 <a title="numeric" href="#dt-numeric">numeric</a> type or derived from a <a title="numeric" href="#dt-numeric">numeric</a> type, the predicate truth value is <code>true</code> if the value of the predicate expression  is equal (by the <code>eq</code> operator) to the <b>context position</b>, and is <code>false</code> otherwise. [<a title="numeric predicate" id="dt-numeric-predicate" name="dt-numeric-predicate">Definition</a>: A predicate whose predicate expression returns a numeric type is called a <b>numeric predicate</b>.]</p><span class="xquery"><div class="note"><p class="prefix"><b>Note:</b></p><p>In a region of a query where <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>unordered</code>, the result of a numeric predicate is nondeterministic, as explained in <a href="#id-unordered-expressions"><b>3.10 Ordered and Unordered Expressions</b></a>.</p></div></span></li><li><p>Otherwise, the predicate truth value is the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the predicate
			 expression.</p></li></ol><p>Here are some examples of <a title="axis step" href="#dt-axis-step">axis steps</a> that contain predicates:</p><ul><li><p>This example selects the second <code>chapter</code> element that is a child
			 of the context node:</p><div class="parse-test"><div class="exampleInner"><pre>child::chapter[2]</pre></div></div></li><li><p>This example selects all the descendants of the
		  context node that are elements named
		  <code>"toy"</code> and whose <code>color</code>
		  attribute has the value <code>"red"</code>:</p><div class="parse-test"><div class="exampleInner"><pre>descendant::toy[attribute::color = "red"]</pre></div></div></li><li><p>This example selects all the <code>employee</code> children of the context node
		that have both a <code>secretary</code> child element and an <code>assistant</code> child element:</p><div class="parse-test"><div class="exampleInner"><pre>child::employee[secretary][assistant]</pre></div></div></li></ul><p>When using <a title="predicate" href="#dt-predicate">predicates</a> with a sequence of nodes selected using a
<b>reverse axis</b>, it is important to remember that the the
context positions for such a sequence are assigned in <a title="reverse document order" href="#dt-reverse-document-order">reverse
document order</a>. For example, <code>preceding::foo[1]</code>
returns the first qualifying <code>foo</code> element in <a title="reverse document order" href="#dt-reverse-document-order">reverse document order</a>, because the predicate is part of an <a title="axis step" href="#dt-axis-step">axis step</a> using a reverse axis. By
contrast, <code>(preceding::foo)[1]</code> returns the first qualifying <code>foo</code>
element in <a title="document order" href="#dt-document-order">document order</a>, because the parentheses cause  <code>(preceding::foo)</code> to be parsed as a <a title="primary expression" href="#dt-primary-expression">primary expression</a> in which context positions are assigned in document order. Similarly, <code>ancestor::*[1]</code>
returns the nearest ancestor element, because the <code>ancestor</code> axis is a
reverse axis, whereas <code>(ancestor::*)[1]</code> returns the root element (first ancestor in document order).</p></div><div class="div3">
<h4><a id="unabbrev" name="unabbrev"></a>3.2.3 Unabbreviated Syntax</h4><p>This section provides a number of examples of path expressions in which the
axis is explicitly specified in each <a title="step" href="#dt-step">step</a>. The syntax used in these examples is
called the <b>unabbreviated syntax</b>. In many common cases, it is
possible to write path expressions more concisely using an <b>abbreviated
syntax</b>, as explained in <a href="#abbrev"><b>3.2.4 Abbreviated Syntax</b></a>.</p><ul><li><p> <code>child::para</code> selects 
the <code>para</code> element children of the context node</p></li><li><p> <code>child::*</code> selects all element children of the context node</p></li><li><p> <code>child::text()</code> selects all text node children of the context node</p></li><li><p> <code>child::node()</code> selects all the children of the context node. Note that no attribute nodes are returned, because attributes are not children.</p></li><li><p> <code>attribute::name</code> selects the <code>name</code> attribute of the context node</p></li><li><p> <code>attribute::*</code> selects all the attributes of the context node</p></li><li><p><code>parent::node()</code> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</p></li><li><p> <code>descendant::para</code> selects the <code>para</code> element descendants of the context node</p></li><li><p> <code>ancestor::div</code> selects all <code>div</code> ancestors of the context node</p></li><li><p> <code>ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well</p></li><li><p> <code>descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well</p></li><li><p> <code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence</p></li><li><p> <code>child::chapter/descendant::para</code> selects the <code>para</code> element 
descendants of the <code>chapter</code> element children of the context node</p></li><li><p> <code>child::*/child::para</code> selects all <code>para</code> grandchildren of the context node</p></li><li><p> <code>/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node</p></li><li><p> <code>/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node</p></li><li><p> <code>/descendant::list/child::member</code> selects all 
the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node</p></li><li><p> <code>child::para[fn:position() = 1]</code> selects the first <code>para</code> child of the context node</p></li><li><p> <code>child::para[fn:position() = fn:last()]</code> selects the last <code>para</code> child of the context node</p></li><li><p> <code>child::para[fn:position() = fn:last()-1]</code> selects the last but one <code>para</code> child of the context node</p></li><li><p> <code>child::para[fn:position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node</p></li><li><p> <code>following-sibling::chapter[fn:position() = 1]</code>selects the next <code>chapter</code> sibling of the context node</p></li><li><p> <code>preceding-sibling::chapter[fn:position() = 1]</code>selects the previous <code>chapter</code> sibling of the context node</p></li><li><p> <code>/descendant::figure[fn:position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node</p></li><li><p> <code>/child::book/child::chapter[fn:position() = 5]/child::section[fn:position() = 2]</code> selects the 
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p></li><li><p> <code>child::para[attribute::type eq "warning"]</code>selects 
all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> </p></li><li><p> <code>child::para[attribute::type eq 'warning'][fn:position() = 5]</code>selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> </p></li><li><p> <code>child::para[fn:position() = 5][attribute::type eq "warning"]</code>selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> </p></li><li><p> <code>child::chapter[child::title = 'Introduction']</code>selects
the <code>chapter</code> children of the context node that have one or
more <code>title</code> children whose <a title="typed value" href="#dt-typed-value">typed value</a> is equal to the
string <code>Introduction</code> </p></li><li><p> <code>child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p></li><li><p> <code>child::*[self::chapter or self::appendix]</code> 
selects the <code>chapter</code> and <code>appendix</code> children of the context node</p></li><li><p> <code>child::*[self::chapter or
self::appendix][fn:position() = fn:last()]</code> selects the 
last <code>chapter</code> or <code>appendix</code> child of the context node</p></li></ul></div><div class="div3">
<h4><a id="abbrev" name="abbrev"></a>3.2.4 Abbreviated Syntax</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-AbbrevForwardStep" name="doc-xpath-AbbrevForwardStep"></a>[77]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"@"?  <a href="#doc-xpath-NodeTest">NodeTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-AbbrevReverseStep" name="doc-xpath-AbbrevReverseStep"></a>[80]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>".."</code></td></tr></tbody></table><p>The abbreviated syntax permits the following abbreviations:</p><ol class="enumar"><li><p>The attribute axis <code>attribute::</code> can be 
abbreviated by <code>@</code>. For example, a path expression <code>para[@type="warning"]</code> is short 
for <code>child::para[attribute::type="warning"]</code> and 
so selects <code>para</code> children with a <code>type</code> attribute with value 
equal to <code>warning</code>.</p></li><li><p>If the axis name is omitted from an <a title="axis step" href="#dt-axis-step">axis step</a>, the default axis is <code>child</code> unless the axis step contains an <a href="#doc-xpath-AttributeTest">AttributeTest</a>; in that case, the default axis is <code>attribute</code>.  For example, the path expression <code>section/para</code> is an abbreviation for <code>child::section/child::para</code>, and the path expression <code>section/@id</code> is an abbreviation for <code>child::section/attribute::id</code>.  Similarly, <code>section/attribute(id)</code> is an abbreviation for <code>child::section/attribute::attribute(id)</code>. Note that the latter expression contains both an axis specification and a <a title="node test" href="#dt-node-test">node test</a>.</p></li><li><p> Each non-initial occurrence of <code>//</code> is effectively replaced by  <code>/descendant-or-self::node()/</code> during processing of a path expression. For example, <code>div1//para</code> is 
short for <code>child::div1/descendant-or-self::node()/child::para</code> and so will select all <code>para</code> descendants of <code>div1</code> children.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The path expression <code>//para[1]</code> does <em>not</em> mean the same as the path 
expression <code>/descendant::para[1]</code>. The latter selects the first descendant <code>para</code> element; the former 
selects all descendant <code>para</code> elements that are the first <code>para</code> children of their respective parents.</p></div></li><li><p>A step consisting 
of <code>..</code> is short 
for <code>parent::node()</code>. For example, <code>../title</code> is short for <code>parent::node()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The expression <code>.</code>, known as a <b>context item
   expression</b>, is a <a title="primary expression" href="#dt-primary-expression">primary expression</a>,
   and is described in <a href="#id-context-item-expression"><b>3.1.4 Context Item Expression</b></a>.</p></div></li></ol><p>Here are some examples of path expressions that use the abbreviated
syntax:</p><ul><li><p> <code>para</code> selects the <code>para</code> element children of the context node</p></li><li><p> <code>*</code> selects all element children of the context node</p></li><li><p> <code>text()</code> selects all text node children of the context node</p></li><li><p> <code>@name</code> selects 
the <code>name</code> attribute of the context node</p></li><li><p> <code>@*</code> selects all the attributes of the context node</p></li><li><p> <code>para[1]</code> selects the first <code>para</code> child of the context node</p></li><li><p> <code>para[fn:last()]</code> selects the last <code>para</code> child of the context node</p></li><li><p> <code>*/para</code> selects 
all <code>para</code> grandchildren of the context node</p></li><li><p> <code>/book/chapter[5]/section[2]</code> selects the 
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node</p></li><li><p> <code>chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node</p></li><li><p> <code>//para</code> selects all 
the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node</p></li><li><p><code>//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node</p></li><li><p> <code>//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent</p></li><li><p> <code>.//para</code> selects 
the <code>para</code> element descendants of the context node</p></li><li><p> <code>..</code> selects the parent of the context node</p></li><li><p> <code>../@lang</code> selects 
the <code>lang</code> attribute of the parent of the context node</p></li><li><p> <code>para[@type="warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code> </p></li><li><p> <code>para[@type="warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code> </p></li><li><p> <code>para[5][@type="warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code> </p></li><li><p> <code>chapter[title="Introduction"]</code> selects the <code>chapter</code> children of the context node that have one 
or more <code>title</code> children whose <a title="typed value" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code> </p></li><li><p> <code>chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children</p></li><li><p> <code>employee[@secretary and @assistant]</code> selects all 
the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and 
an <code>assistant</code> attribute</p></li><li><p> <code>book/(chapter|appendix)/section</code> selects 
every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.</p></li><li><p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code>E/.</code> returns the same nodes in <a title="document order" href="#dt-document-order">document order</a>, with duplicates eliminated based on node identity.</p></li></ul></div></div><div class="div2">
<h3><a id="id-sequence-expressions" name="id-sequence-expressions"></a>3.3 Sequence Expressions</h3><p>[XPath/XQuery] supports operators to construct, filter,  and combine
<a title="sequence" href="#dt-sequence">sequences</a> of <a title="item" href="#dt-item">items</a>.
Sequences are never nested&mdash;for
example, combining the values <code>1</code>, <code>(2, 3)</code>, and <code>( )</code> into a single sequence results
in the sequence <code>(1, 2, 3)</code>.</p><div class="div3">
<h4><a id="construct_seq" name="construct_seq"></a>3.3.1 Constructing Sequences</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="noid_N12AB9.doc-xpath-Expr" name="noid_N12AB9.doc-xpath-Expr"></a>[32]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Expr">Expr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-RangeExpr" name="doc-xpath-RangeExpr"></a>[52]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-RangeExpr">RangeExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a> ( "to"  <a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a> )?</code></td></tr></tbody></table><p>[<a title="comma operator" id="dt-comma-operator" name="dt-comma-operator">Definition</a>: One way to construct a sequence is by using the <b>comma operator</b>, which evaluates each of its operands and concatenates the resulting sequences, in order, into a single result sequence.] Empty parentheses can be used to denote an empty sequence.</p><p>A sequence may contain duplicate
atomic values or nodes, but a sequence is never an item in another sequence. When a
new sequence is created by concatenating two or more input sequences, the new
sequence contains all the items of the input sequences and its length is the
sum of the lengths of the input sequences.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In places where the grammar calls for <a href="#doc-xpath-ExprSingle">ExprSingle</a>, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses.</p></div><p>Here are some examples of expressions that construct sequences:
</p><ul><li><p>The result of this expression is a sequence of five integers:</p><div class="parse-test"><div class="exampleInner"><pre>(10, 1, 2, 3, 4)</pre></div></div></li><li><p>This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence <code>10, 1, 2, 3, 4</code>.</p><div class="parse-test"><div class="exampleInner"><pre>(10, (1, 2), (), (3, 4))</pre></div></div></li><li><p>The result of this expression is a sequence containing 
all <code>salary</code> children of the context node followed by all <code>bonus</code> children.</p><div class="parse-test"><div class="exampleInner"><pre>(salary, bonus)</pre></div></div></li><li><p>Assuming that <code>$price</code> is bound to 
the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.</p><div class="parse-test"><div class="exampleInner"><pre>($price, $price)</pre></div></div></li></ul><p>A <b>range expression</b> can be used to construct a sequence of consecutive
integers. Each of the operands of the <code>to</code> operator is
converted as though it was an argument of a function with the expected
parameter type <code>xs:integer?</code>.
If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and
every integer between the two operands, in increasing order. </p><ul><li><p>This example uses a range expression as one operand in constructing a sequence. It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p><div class="parse-test"><div class="exampleInner"><pre>(10, 1 to 4)</pre></div></div></li><li><p>This example constructs a sequence of length one containing the single integer <code>10</code>.</p><div class="parse-test"><div class="exampleInner"><pre>10 to 10</pre></div></div></li><li><p>The result of this example is a sequence of length zero.</p><div class="parse-test"><div class="exampleInner"><pre>15 to 10</pre></div></div></li><li><p>This example uses the <code>fn:reverse</code> function to construct a sequence of six integers in decreasing order. It evaluates to the sequence <code>15, 14, 13, 12, 11, 10</code>.</p><div class="parse-test"><div class="exampleInner"><pre>fn:reverse(10 to 15)</pre></div></div></li></ul></div><div class="div3">
<h4><a id="id-filter-expr" name="id-filter-expr"></a>3.3.2 Filter Expressions</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-FilterExpr" name="doc-xpath-FilterExpr"></a>[84]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-FilterExpr">FilterExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-PrimaryExpr">PrimaryExpr</a>  <a href="#doc-xpath-PredicateList">PredicateList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="noid_N12B60.doc-xpath-PredicateList" name="noid_N12B60.doc-xpath-PredicateList"></a>[85]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PredicateList">PredicateList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Predicate">Predicate</a>*</code></td></tr></tbody></table><p>[<a title="filter expression" id="dt-filter-expression" name="dt-filter-expression">Definition</a>: A <b>filter
		expression</b> consists simply of a <b>primary
		expression</b> followed by zero or more
		<a title="predicate" href="#dt-predicate">predicates</a>. The result of the filter expression consists of
		all the items returned by the primary expression for
		which all the predicates are true.] If no predicates
		are specified, the result is simply the result of the
		primary expression.  The
		ordering of the items returned by a filter expression is the
		same as their order in the result of the primary
		expression. Context positions are assigned to items based on their ordinal position 
in the result sequence. The first context position is 1.</p><p>Here are some examples of filter expressions:</p><ul><li><p>Given a sequence of products in a variable, return only those products whose price is greater than 100.</p><div class="parse-test"><div class="exampleInner"><pre>$products[price gt 100]</pre></div></div></li><li><p>List all the integers from 1 to 100 that are divisible by 5. (See <a href="#construct_seq"><b>3.3.1 Constructing Sequences</b></a> for an explanation of the <code>to</code> operator.)</p><div class="parse-test"><div class="exampleInner"><pre>(1 to 100)[. mod 5 eq 0]</pre></div></div></li><li><p>The result of the following expression is the integer 25:</p><div class="parse-test"><div class="exampleInner"><pre>(21 to 29)[5]</pre></div></div></li><li><p>The following example illustrates the use of a filter expression as a <a title="step" href="#dt-step">step</a> in a <a title="path expression" href="#dt-path-expression">path expression</a>. It returns the last chapter or appendix within the book bound to variable <code>$book</code>:</p><div class="parse-test"><div class="exampleInner"><pre>$book/(chapter | appendix)[fn:last()]</pre></div></div></li><li><p>The following example also illustrates the use of a filter expression as a <a title="step" href="#dt-step">step</a> in a <a title="path expression" href="#dt-path-expression">path expression</a>. It returns the element node within the specified document whose ID value is <code>tiger</code>:</p><div class="parse-test"><div class="exampleInner"><pre>fn:doc("zoo.xml")/fn:id('tiger')</pre></div></div></li></ul></div><div class="div3">
<h4><a id="combining_seq" name="combining_seq"></a>3.3.3 Combining Node Sequences</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-UnionExpr" name="doc-xpath-UnionExpr"></a>[55]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-UnionExpr">UnionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"  |  "|")  <a href="#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-IntersectExceptExpr" name="doc-xpath-IntersectExceptExpr"></a>[56]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a> ( ("intersect"  |  "except")  <a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td></tr></tbody></table><p>[XPath/XQuery] provides the following operators for combining sequences of
nodes:</p><ul><li><p>The <code>union</code> and <code>|</code> operators are equivalent. They take two node sequences as operands and
return a sequence containing all the nodes that occur in either of the
operands.</p></li><li><p>The <code>intersect</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in both operands.</p></li><li><p>The <code>except</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in the first operand but not in the second
operand.</p></li></ul><p>   
 All these operators eliminate duplicate nodes from their result sequences based on node identity. <span class="xpath"><span class="xpath"><span class="xpath">The resulting sequence is returned in <a title="document order" href="#dt-document-order">document
	 order</a>.</span></span></span><span class="xquery"><span class="xquery"><span class="xquery">If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the resulting sequence is returned in <a title="document order" href="#dt-document-order">document
	 order</a>; otherwise it is returned in <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> order.</span></span></span></p><p>If an operand 
of <code>union</code>, <code>intersect</code>, or <code>except</code> contains an item that is not a node, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p><p>Here are some examples of expressions that combine sequences. Assume the existence of three element nodes that we will refer to by symbolic names A, B, and C. Assume that the variables <code>$seq1</code>,  <code>$seq2</code>  and <code>$seq3</code> are bound to the following sequences of these nodes:</p><ul><li><p><code>$seq1</code> is bound to (A, B)</p></li><li><p><code>$seq2</code> is bound to (A, B)</p></li><li><p><code>$seq3</code> is bound to (B, C)</p></li></ul><p>Then: </p><ul><li><p> <code>$seq1 union $seq2</code>  evaluates to the sequence (A, B). </p></li><li><p> <code>$seq2 union $seq3</code>   evaluates to the sequence (A, B, C). </p></li><li><p> <code>$seq1 intersect $seq2</code>  evaluates to the sequence (A, B). </p></li><li><p> <code>$seq2 intersect $seq3</code>  evaluates to the sequence containing B only.</p></li><li><p> <code>$seq1 except $seq2</code>   evaluates to the empty sequence.</p></li><li><p> <code>$seq2 except $seq3</code>  evaluates to the sequence containing A only.</p></li></ul><p>In addition to the sequence operators described here, <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a> includes functions for indexed access to items or
sub-sequences of a sequence, for indexed insertion or removal of items in a
sequence, and for removing duplicate items from a sequence.</p></div></div><div class="div2">
<h3><a id="id-arithmetic" name="id-arithmetic"></a>3.4 Arithmetic Expressions</h3><p>[XPath/XQuery] provides arithmetic operators for addition, subtraction,
multiplication, division, and modulus, in their usual binary and unary
forms.</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-AdditiveExpr" name="doc-xpath-AdditiveExpr"></a>[53]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+"  |  "-")  <a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-MultiplicativeExpr" name="doc-xpath-MultiplicativeExpr"></a>[54]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-UnionExpr">UnionExpr</a> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <a href="#doc-xpath-UnionExpr">UnionExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-UnaryExpr" name="doc-xpath-UnaryExpr"></a>[61]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-UnaryExpr">UnaryExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("-"  |  "+")* <a href="#doc-xpath-ValueExpr">ValueExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ValueExpr" name="doc-xpath-ValueExpr"></a>[62]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ValueExpr">ValueExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ValidateExpr" class="xquery">ValidateExpr</a>  |  <a href="#doc-xpath-PathExpr">PathExpr</a>  |  <a href="#doc-xpath-ExtensionExpr" class="xquery">ExtensionExpr</a></code></td></tr></tbody></table><p>A subtraction operator must be preceded by whitespace if
it could otherwise be interpreted as part of the previous token. For
example, <code>a-b</code> will be interpreted as a
name, but <code>a - b</code> and <code>a -b</code> will be interpreted as arithmetic expressions. (See <a href="#whitespace-rules"><b>A.2.4 Whitespace Rules</b></a> for further details on whitespace handling.)</p><p>The first step in evaluating an arithmetic expression is to evaluate its operands. The order in which the operands are evaluated is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p><span class="xpath"><div class="xpath"><p class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, each operand is evaluated by applying the following steps, in order:</p></div></span><span class="xpath"><div class="xpath"><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the operand. The result of this
    operation is called the <b>atomized operand</b>.</p></li><li><p>If the atomized operand is an empty sequence, the result of
    the arithmetic expression is the <code>xs:double</code> value <code>NaN</code>, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p></li><li><p>If the atomized operand is a sequence of length greater than one, any items after the first item in the sequence are discarded.</p></li><li><p>If the atomized operand is now an instance of type <code>xs:boolean</code>, <code>xs:string</code>,
<code>xs:decimal</code> (including <code>xs:integer</code>), <code>xs:float</code>, or <code>xdt:untypedAtomic</code>, then it
is converted to the type <code>xs:double</code> by applying the <code>fn:number</code> function. (Note that <code>fn:number</code> returns the value <code>NaN</code> if its operand cannot be converted to a number.)</p></li></ol></div></span><p><span class="xpath"><span class="xpath"><span class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>false</code>, each</span></span></span><span class="xquery"><span class="xquery"><span class="xquery">Each</span></span></span> operand is evaluated by applying the following steps, in order:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the operand. The result of this
    operation is called the <b>atomized operand</b>.</p></li><li><p>If the atomized operand is an empty sequence, the result of
    the arithmetic expression is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p></li><li><p> If the atomized operand is a sequence of
length greater than one, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized operand is of type <code>xdt:untypedAtomic</code>, it is cast to  <code>xs:double</code>. If
the cast fails, a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised. [err:FORG0001]</p></li></ol><p>After evaluation of the operands, if the types of the operands are a valid combination
for the given arithmetic operator, the operator is applied to the operands,
resulting in an atomic value or a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> (for example, an error
might result from dividing by zero.) The combinations of atomic types
that are accepted by the various arithmetic operators, and their
respective result types, are listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a>
together with the <a title="operator function" href="#dt-operator-function">operator functions</a>
that define the semantics of the operator for each
type combination, including the dynamic errors that can be raised by the operator. The definitions of the operator functions are found in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p><p>If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in <a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p><p>[XPath/XQuery] supports two division operators named <code>div</code> and <code>idiv</code>. Each of these operators accepts two operands of any <a title="numeric" href="#dt-numeric">numeric</a> type. As described in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>, <code>$arg1 idiv $arg2</code> is equivalent to <code>($arg1 div $arg2) cast as xs:integer?</code> except for error cases.</p><p>Here are some examples of arithmetic expressions:</p><ul><li><p>The first expression below returns the <code>xs:decimal</code> value <code>-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code>-1</code>:</p><div class="parse-test"><div class="exampleInner"><pre>-3 div 2
-3 idiv 2</pre></div></div></li><li><p>Subtraction of two date values results in a value of type <code>xdt:dayTimeDuration</code>:</p><div class="parse-test"><div class="exampleInner"><pre>$emp/hiredate - $emp/birthdate</pre></div></div></li><li><p>This example illustrates the difference between a subtraction operator and a
hyphen:</p><div class="parse-test"><div class="exampleInner"><pre>$unit-price - $unit-discount</pre></div></div></li><li><p>Unary operators have higher precedence than binary operators, subject of
course to the use of parentheses. Therefore, the following two examples have different meanings:</p><div class="exampleInner"><pre>-$bellcost + $whistlecost
-($bellcost + $whistlecost)</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p id="note-consecutive-unary-ops">Multiple consecutive unary arithmetic operators are permitted by [XPath/XQuery] for compatibility with <a href="#XPath">[XPath 1.0]</a>.</p></div></div><div class="div2">
<h3><a id="id-comparisons" name="id-comparisons"></a>3.5 Comparison Expressions</h3><p>Comparison expressions allow two values to be compared. [XPath/XQuery] provides
three kinds of comparison expressions, called value comparisons, general
comparisons, and node comparisons.</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-ComparisonExpr" name="doc-xpath-ComparisonExpr"></a>[51]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-RangeExpr">RangeExpr</a> ( (<a href="#doc-xpath-ValueComp">ValueComp</a><br>|  <a href="#doc-xpath-GeneralComp">GeneralComp</a><br>|  <a href="#doc-xpath-NodeComp">NodeComp</a>)  <a href="#doc-xpath-RangeExpr">RangeExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ValueComp" name="doc-xpath-ValueComp"></a>[64]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ValueComp">ValueComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-GeneralComp" name="doc-xpath-GeneralComp"></a>[63]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-GeneralComp">GeneralComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-NodeComp" name="doc-xpath-NodeComp"></a>[65]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-NodeComp">NodeComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</code></td></tr></tbody></table><span class="xpath"><div class="note"><p class="prefix"><b>Note:</b></p><span class="xpath"><div class="xpath"><p class="xpath">When an XPath expression is written
within an XML document, the XML escaping rules for special characters
must be followed; thus "<code>&lt;</code>" must be written as
"<code>&amp;lt;</code>".</p></div></span></div></span><div class="div3">
<h4><a id="id-value-comparisons" name="id-value-comparisons"></a>3.5.1 Value Comparisons</h4><p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single values.</p><p>The first step in evaluating a value comparison is to evaluate its operands. The order in which the operands are evaluated is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. Each operand is evaluated by applying the following steps, in order:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the operand. The result of this
    operation is called the <b>atomized operand</b>.</p></li><li><p>If the atomized operand is an empty sequence, the result of
    the value comparison is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p></li><li><p> If the atomized operand is a sequence of
length greater than one, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized operand is of type <code>xdt:untypedAtomic</code>, it is cast to  <code>xs:string</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The purpose of this rule is to make value comparisons transitive. Users should be aware that the general comparison operators have a different rule for casting of <code>xdt:untypedAtomic</code> operands. Users should also be aware that transitivity of value comparisons may be compromised by loss of precision during type conversion (for example, two <code>xs:integer</code> values that differ slightly may both be considered equal to the same <code>xs:float</code> value because <code>xs:float</code> has less precision than <code>xs:integer</code>).</p></div></li></ol><p>After evaluation of the operands, if the types of the operands are a valid combination
for the given operator, the operator is applied to the operands. The combinations of atomic types
that are accepted by the various value comparison operators, and their
respective result types, are listed in <a href="#mapping"><b>B.2 Operator Mapping</b></a>
together with the <a title="operator function" href="#dt-operator-function">operator functions</a>
that define the semantics of the operator for each
type combination. The definitions of the operator functions are found in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p><p>Informally, if both atomized operands consist of exactly one atomic
value, then the result of the comparison is <code>true</code> if the value of the
first operand is (equal, not equal, less than, less than or equal,
greater than, greater than or equal) to the value of the second
operand; otherwise the result of the comparison is <code>false</code>.</p><p>If the types of the operands, after evaluation, are not a valid combination for the given operator, according to the rules in <a href="#mapping"><b>B.2 Operator Mapping</b></a>, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p><p>Here are some examples of value comparisons:</p><ul><li><p>The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xdt:untypedAtomic</code>. If the result of atomization is an empty sequence, the result of the comparison is an empty sequence. If the result of atomization is a sequence containing more than one value, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p><div class="parse-test"><div class="exampleInner"><pre>$book1/author eq "Kennedy"</pre></div></div></li><li><p>The following <a title="path expression" href="#dt-path-expression">path expression</a> contains a predicate that selects products whose weight is greater than 100. For any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is not selected:</p><div class="parse-test"><div class="exampleInner"><pre>//product[weight gt 100]</pre></div></div></li><span class="xquery"><li class="xquery"><p>The following comparisons are true because, in each case, the two constructed nodes have the same value after atomization, even though they have different identities and/or names:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;</pre></div></div><div class="parse-test"><div class="exampleInner"><pre>&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;</pre></div></div></li></span><li><p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive <a title="numeric" href="#dt-numeric">numeric</a> type:</p><div class="parse-test"><div class="exampleInner"><pre>my:hatsize(5) eq my:shoesize(5)</pre></div></div></li></ul></div><div class="div3">
<h4><a id="id-general-comparisons" name="id-general-comparisons"></a>3.5.2 General Comparisons</h4><p>The general comparison operators are <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>. General comparisons are existentially quantified comparisons that may be applied to operand sequences of any length. The result of a general comparison that does not raise an error is 
always <code>true</code> or <code>false</code>.</p><span class="xpath"><div class="xpath"><p class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, a general comparison is evaluated by applying the following rules, in order:</p></div></span><span class="xpath"><div class="xpath"><ol class="enumar"><li><p>If either operand is a single atomic value that is an instance of
<code>xs:boolean</code>, then the other operand is converted to <code>xs:boolean</code> by taking its
<a title="effective boolean value" href="#dt-ebv">effective boolean value</a>.</p></li><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to each operand. After atomization, each operand is a sequence of atomic values.</p></li><li><p>If the comparison operator is <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>, then each item in both of the
operand sequences is converted to the type  <code>xs:double</code> by applying the
<code>fn:number</code> function. (Note that <code>fn:number</code> returns the value <code>NaN</code> if its operand cannot be converted to a number.)</p></li><li><p>The result of the comparison is <code>true</code> if and only if there is a pair of
atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required
<b>magnitude relationship</b>. Otherwise the result of the  comparison is
<code>false</code>. The <b>magnitude relationship</b> between two atomic values is determined by
applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a dynamic error is raised. [err:FORG0001]</p><ol class="enumla"><li><p>If at least one of the two atomic values is an instance of a <a title="numeric" href="#dt-numeric">numeric</a> type, then both atomic values are converted to the type <code>xs:double</code> by
applying the <code>fn:number</code> function.</p></li><li><p>If at least one of the two atomic values is an instance of <code>xs:string</code>,
or if both atomic values are instances of <code>xdt:untypedAtomic</code>, then both
atomic values are cast to the type <code>xs:string</code>.</p></li><li><p>If one of the atomic values is an instance of <code>xdt:untypedAtomic</code> and the other is not an instance of <code>xs:string</code>, <code>xdt:untypedAtomic</code>, or any <a title="numeric" href="#dt-numeric">numeric</a> type, then the <code>xdt:untypedAtomic</code> value is
cast to the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of the other value.</p></li><li><p>After performing the conversions described above, the atomic values are
compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
<code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>. The values have the required <b>magnitude relationship</b> if and only if the result
of this value comparison is <code>true</code>.</p></li></ol></li></ol></div></span><p><span class="xpath"><span class="xpath"><span class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>false</code>, a</span></span></span><span class="xquery"><span class="xquery"><span class="xquery">A</span></span></span> general comparison is evaluated by applying the following rules, in order:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to each operand. After atomization, each operand is a sequence of atomic values.</p></li><li><p>The result of the comparison is <code>true</code> if and only if there is a pair of
atomic values, one in the first operand sequence and the other in the second operand sequence, that have the required
<b>magnitude relationship</b>. Otherwise the result of the  comparison is
<code>false</code>. The <b>magnitude relationship</b> between two atomic values is determined by
applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a dynamic error is raised. [err:FORG0001]</p><span class="xquery"><div class="note"><p class="prefix"><b>Note:</b></p><p>The purpose of these rules is to preserve compatibility with XPath 1.0, in which (for example) <code>x &lt; 17</code> is a numeric comparison if <code>x</code> is an untyped value. Users should be aware that the value comparison operators have different rules for casting of <code>xdt:untypedAtomic</code> operands.</p></div></span><ol class="enumla"><li><p>If one of the atomic values is an instance of <code>xdt:untypedAtomic</code> and the other is an instance of a <a title="numeric" href="#dt-numeric">numeric</a> type, then the <code>xdt:untypedAtomic</code> value is cast to the type <code>xs:double</code>.</p></li><li><p>If one of the atomic values is an instance of <code>xdt:untypedAtomic</code> and the other is an instance of <code>xdt:untypedAtomic</code> or <code>xs:string</code>, then the <code>xdt:untypedAtomic</code> value (or values) is (are) cast to the type <code>xs:string</code>.</p></li><li><p>If one of the atomic values is an instance of <code>xdt:untypedAtomic</code> and the other is not an instance of <code>xs:string</code>, <code>xdt:untypedAtomic</code>, or any <a title="numeric" href="#dt-numeric">numeric</a> type, then the <code>xdt:untypedAtomic</code> value is
cast to the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of the other value.</p></li><li><p>After performing the conversions described above, the atomic values are
compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
<code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>. The values have the required <b>magnitude relationship</b> if and only if the result
of this value comparison is <code>true</code>.</p></li></ol></li></ol><p>When evaluating a general comparison in which either operand is a sequence of items, an implementation may return <code>true</code> as soon as it finds an item in the first operand and an item in the second operand that have the required <b>magnitude relationship</b>. Similarly, a general comparison may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon as it encounters an error in evaluating either operand, or in comparing a pair of items from the two operands. As a result of these rules, the result of a general comparison is not deterministic in the presence of errors.</p><p>Here are some examples of  general comparisons:</p><ul><li><p>The following comparison is true if the <a title="typed value" href="#dt-typed-value">typed value</a> of any
<code>author</code> subelement of <code>$book1</code> is "Kennedy" as an instance of <code>xs:string</code> or <code>xdt:untypedAtomic</code>:</p><div class="parse-test"><div class="exampleInner"><pre>$book1/author = "Kennedy"</pre></div></div></li><li><p>The following example contains three general comparisons. The value of the first two comparisons is <code>true</code>, and the value of the third comparison is <code>false</code>. This example illustrates the fact that general comparisons are not transitive.</p><div class="exampleInner"><pre>(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)</pre></div></li><li><p>The following example contains two general comparisons, both of which are <code>true</code>. This example illustrates the fact that the <code>=</code> and <code>!=</code> operators are not inverses of each other.</p><div class="exampleInner"><pre>(1, 2) = (2, 3)
(1, 2) != (2, 3)</pre></div></li><li><p>Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xdt:untypedAtomic</code>, with <a title="string value" href="#dt-string-value">string values</a> "<code>1</code>", "<code>2</code>", and "<code>2.0</code>" respectively. Then <code>($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code>($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as numbers.</p></li></ul></div><div class="div3">
<h4><a id="id-node-comparisons" name="id-node-comparisons"></a>3.5.3 Node Comparisons</h4><p>Node comparisons are used to compare two nodes, by their identity or by their <a title="document order" href="#dt-document-order">document order</a>. The result of a node comparison is defined by the following rules:</p><ol class="enumar"><li><p>The operands of a node comparison are evaluated in <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> order.</p></li><li><p> Each operand must be either a single node or an empty sequence; otherwise
a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li><li><p>If either operand is an empty sequence, the result of the
    comparison is an empty sequence, and the implementation need not
    evaluate the other operand or apply the operator. However, an
    implementation may choose to evaluate the other operand in order to
    determine whether it raises an error.</p></li><li><p>A comparison with the <code>is</code> operator is <code>true</code> if the two operand nodes have the same identity, and are thus the same node; otherwise it
is <code>false</code>. See <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> for a definition of node identity.</p></li><li><p>A comparison with the <code>&lt;&lt;</code> operator returns <code>true</code> if the left operand node precedes the right operand node in
<a title="document order" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p></li><li><p>A comparison with the <code>&gt;&gt;</code> operator returns <code>true</code> if the left operand node follows the right operand node in
<a title="document order" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p></li></ol><p>Here are some examples of node comparisons:</p><ul><li><p>The following comparison is true only if the left and right sides each
evaluate to exactly the same single node:</p><div class="parse-test"><div class="exampleInner"><pre>/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]</pre></div></div></li><span class="xquery"><li class="xquery"><p>The following comparison is false because each constructed node has its own identity:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;</pre></div></div></li></span><li><p>The following comparison is true only if the node identified by the left
side occurs before the node identified by the right side in document order:</p><div class="parse-test"><div class="exampleInner"><pre>/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]</pre></div></div></li></ul></div></div><div class="div2">
<h3><a id="id-logical-expressions" name="id-logical-expressions"></a>3.6 Logical Expressions</h3><p>A <b>logical expression</b> is either an <b>and-expression</b> or
an <b>or-expression</b>. If a logical expression does not raise an error, its value is always one
of the boolean values <code>true</code> or <code>false</code>.</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-OrExpr" name="doc-xpath-OrExpr"></a>[49]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-OrExpr">OrExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AndExpr">AndExpr</a> ( "or"  <a href="#doc-xpath-AndExpr">AndExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-AndExpr" name="doc-xpath-AndExpr"></a>[50]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AndExpr">AndExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a> ( "and"  <a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a> )*</code></td></tr></tbody></table><p>The first step in evaluating a logical expression is to find the  <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of each of its operands (see <a href="#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>).</p><p>The value of an and-expression is determined by the effective
boolean values (EBV's) of its operands, as shown in the following table:</p><table border="1" cellpadding="4" cellspacing="1" width="80%" summary="AND EBV"><tbody><tr><td>AND:</td><td>EBV<sub>2</sub> =
<code>true</code></td><td>EBV<sub>2</sub> = <code>false</code></td><td>error in EBV<sub>2</sub>
</td></tr><tr><td>EBV<sub>1</sub> =
<code>true</code></td><td><code>true</code></td><td><code>false</code></td><td>error</td></tr><tr><td>EBV<sub>1</sub>
= <code>false</code></td><td><code>false</code></td><td><code>false</code></td><td><span class="xquery"><span class="xquery"><span class="xquery">either <code>false</code> or
error</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">if <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, then <code>false</code>; otherwise either <code>false</code> or error.</span></span></span></td></tr><tr><td>error in EBV<sub>1</sub>
</td><td>error</td><td><span class="xquery"><span class="xquery"><span class="xquery">either <code>false</code> or
error</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">if <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, then error; otherwise either <code>false</code> or error.</span></span></span></td><td>error</td></tr></tbody></table><p>The value of an
or-expression is determined by the effective boolean values (EBV's) of
its operands, as shown in
the following table:</p><table border="1" cellpadding="4" cellspacing="1" width="80%" summary="OR EBV"><tbody><tr><td>OR:</td><td>EBV<sub>2</sub> =
<code>true</code></td><td>EBV<sub>2</sub> = <code>false</code></td><td>error in
EBV<sub>2</sub></td></tr><tr><td>EBV<sub>1</sub> =
<code>true</code></td><td><code>true</code></td><td><code>true</code></td><td><span class="xquery"><span class="xquery"><span class="xquery">either <code>true</code> or
error</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">if <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, then <code>true</code>; otherwise either <code>true</code> or error.</span></span></span></td></tr><tr><td>EBV<sub>1</sub> =
<code>false</code></td><td><code>true</code></td><td><code>false</code></td><td>error</td></tr><tr><td>error
in EBV<sub>1</sub></td><td><span class="xquery"><span class="xquery"><span class="xquery">either <code>true</code> or
error</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">if <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, then error; otherwise either <code>true</code> or error.</span></span></span></td><td>error</td><td>error</td></tr></tbody></table><span class="xpath"><div class="xpath"><p class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, the order in which the operands of a logical expression are evaluated is effectively prescribed. Specifically, it is defined that when there is no
need to evaluate the second operand in order to determine the result, then
no error can occur as a result of evaluating the second operand.</p></div></span><p><span class="xpath"><span class="xpath"><span class="xpath">If <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>false</code>, the
order in which the operands of a logical expression are evaluated is
<a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. In this case,</span></span></span><span class="xquery"><span class="xquery"><span class="xquery">The
order in which the operands of a logical expression are evaluated is
<a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. The tables above are defined in such a way
that</span></span></span> an or-expression can return <code>true</code> if the first
expression evaluated is true, and it can raise an error if evaluation
of the first expression raises an error. Similarly, an and-expression
can return <code>false</code> if the first expression evaluated is
false, and it can raise an error if evaluation of the first expression
raises an error. As a result of these rules, a logical expression is
not deterministic in the presence of errors, as illustrated in the examples
below.</p><p>Here are some examples of logical expressions:</p><ul><li><p>The following expressions return
<code>true</code>:</p><div class="parse-test"><div class="exampleInner"><pre>1 eq 1 and 2 eq 2</pre></div></div><div class="parse-test"><div class="exampleInner"><pre>1 eq 1 or 2 eq 3</pre></div></div></li><li><p>The following
expression may return either <code>false</code> or raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a><span class="xpath"><span class="xpath"><span class="xpath"> (in <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a>, the result must be <code>false</code>)</span></span></span>:</p><div class="parse-test"><div class="exampleInner"><pre>1 eq 2 and 3 idiv 0 = 1</pre></div></div></li><li><p>The
following expression may return either <code>true</code> or raise a
<a title="dynamic error" href="#dt-dynamic-error">dynamic error</a><span class="xpath"><span class="xpath"><span class="xpath"> (in <a title="XPath 1.0 compatibility     mode" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a>, the result must be <code>true</code>)</span></span></span>:</p><div class="parse-test"><div class="exampleInner"><pre>1 eq 1 or 3 idiv 0 = 1</pre></div></div></li><li><p>The
following expression must raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>:</p><div class="parse-test"><div class="exampleInner"><pre>1 eq 1 and 3 idiv 0 = 1</pre></div></div></li></ul><p>In addition to and- and or-expressions, [XPath/XQuery] provides a
function named <code>fn:not</code> that takes a general sequence as
parameter and returns a boolean value.  The <code>fn:not</code> function
is defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. The
<code>fn:not</code> function reduces its parameter to an <a title="effective boolean value" href="#dt-ebv">effective boolean value</a>. It then returns
<code>true</code> if the effective boolean value of its parameter is
<code>false</code>, and <code>false</code> if the effective boolean
value of its parameter is <code>true</code>. If an error is
encountered in finding the effective boolean value of its operand,
<code>fn:not</code> raises the same error.</p></div><span class="xquery"><div class="xquery"><div class="div2"><span class="xquery"><div class="xquery">
<h3><a id="id-constructors" name="id-constructors"></a>3.7 Constructors</h3></div></span><p>XQuery provides constructors that can create XML structures within a query.
Constructors are provided for element, attribute, document, text, comment, and processing instruction nodes. Two kinds of constructors are provided: <b>direct constructors</b>, which use an XML-like notation, and <b>computed constructors</b>, which use a notation based on enclosed expressions.</p><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-Constructor" name="doc-xpath-Constructor"></a>[97]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Constructor" class="xquery">Constructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-DirectConstructor" class="xquery">DirectConstructor</a><br>|  <a href="#doc-xpath-ComputedConstructor" class="xquery">ComputedConstructor</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DirectConstructor" name="doc-xpath-DirectConstructor"></a>[98]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DirectConstructor" class="xquery">DirectConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-DirElemConstructor" class="xquery">DirElemConstructor</a><br>|  <a href="#doc-xpath-DirCommentConstructor" class="xquery">DirCommentConstructor</a><br>|  <a href="#doc-xpath-DirPIConstructor" class="xquery">DirPIConstructor</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DirElemConstructor" name="doc-xpath-DirElemConstructor"></a>[99]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DirElemConstructor" class="xquery">DirElemConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"&lt;"</span>  <span class="xquery"><a href="#prod-xpath-QName" class="xquery">QName</a></span>  <a href="#doc-xpath-DirAttributeList" class="xquery">DirAttributeList</a>  (<span class="xquery"><span class="xquery">"/&gt;"</span></span>  |  (<span class="xquery"><span class="xquery">"&gt;"</span></span>  <a href="#doc-xpath-DirElemContent" class="xquery">DirElemContent</a>*  <span class="xquery"><span class="xquery">"&lt;/"</span></span>  <span class="xquery"><a href="#prod-xpath-QName" class="xquery">QName</a></span>  <a href="#prod-xpath-S" class="xquery">S</a>?  <span class="xquery"><span class="xquery">"&gt;"</span></span>))</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DirElemContent" name="doc-xpath-DirElemContent"></a>[104]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DirElemContent" class="xquery">DirElemContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-DirectConstructor" class="xquery">DirectConstructor</a><br>|  <a href="#doc-xpath-CDataSection" class="xquery">CDataSection</a><br>|  <a href="#doc-xpath-CommonContent" class="xquery">CommonContent</a><br>|  <a href="#doc-xpath-ElementContentChar" class="xquery">ElementContentChar</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ElementContentChar" name="doc-xpath-ElementContentChar"></a>[151]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ElementContentChar" class="xquery">ElementContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Char" class="xquery">Char</a> - [{}&lt;&amp;]</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CommonContent" name="doc-xpath-CommonContent"></a>[105]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CommonContent" class="xquery">CommonContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-PredefinedEntityRef" class="xquery">PredefinedEntityRef</a>  |  <a href="#prod-xpath-CharRef" class="xquery">CharRef</a>  |  <span class="xquery"><span class="xquery">"{{"</span></span>  |  <span class="xquery"><span class="xquery">"}}"</span></span>  |  <a href="#doc-xpath-EnclosedExpr" class="xquery">EnclosedExpr</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CDataSection" name="doc-xpath-CDataSection"></a>[110]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CDataSection" class="xquery">CDataSection</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"&lt;![CDATA["</span></span>  <a href="#doc-xpath-CDataSectionContents" class="xquery">CDataSectionContents</a>  <span class="xquery"><span class="xquery">"]]&gt;"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CDataSectionContents" name="doc-xpath-CDataSectionContents"></a>[111]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CDataSectionContents" class="xquery">CDataSectionContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<a href="#prod-xpath-Char" class="xquery">Char</a>* - (Char* ']]&gt;' Char*))</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DirAttributeList" name="doc-xpath-DirAttributeList"></a>[100]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DirAttributeList" class="xquery">DirAttributeList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<a href="#prod-xpath-S" class="xquery">S</a>  (<span class="xquery"><a href="#prod-xpath-QName" class="xquery">QName</a></span>  <a href="#prod-xpath-S" class="xquery">S</a>?  <span class="xquery"><span class="xquery">"="</span></span>  <a href="#prod-xpath-S" class="xquery">S</a>?  <a href="#doc-xpath-DirAttributeValue" class="xquery">DirAttributeValue</a>)?)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DirAttributeValue" name="doc-xpath-DirAttributeValue"></a>[101]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DirAttributeValue" class="xquery">DirAttributeValue</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery"><span class="xquery">'"'</span></span>  (<a href="#doc-xpath-EscapeQuot" class="xquery">EscapeQuot</a>  |  <a href="#doc-xpath-QuotAttrValueContent" class="xquery">QuotAttrValueContent</a>)*  <span class="xquery"><span class="xquery">'"'</span></span>)<br>|  (<span class="xquery"><span class="xquery">"'"</span></span>  (<a href="#doc-xpath-EscapeApos" class="xquery">EscapeApos</a>  |  <a href="#doc-xpath-AposAttrValueContent" class="xquery">AposAttrValueContent</a>)*  <span class="xquery"><span class="xquery">"'"</span></span>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-QuotAttrValueContent" name="doc-xpath-QuotAttrValueContent"></a>[102]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QuotAttrValueContent" class="xquery">QuotAttrValueContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-QuotAttrContentChar" class="xquery">QuotAttrContentChar</a><br>|  <a href="#doc-xpath-CommonContent" class="xquery">CommonContent</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-AposAttrValueContent" name="doc-xpath-AposAttrValueContent"></a>[103]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AposAttrValueContent" class="xquery">AposAttrValueContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-AposAttrContentChar" class="xquery">AposAttrContentChar</a><br>|  <a href="#doc-xpath-CommonContent" class="xquery">CommonContent</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-QuotAttrContentChar" name="doc-xpath-QuotAttrContentChar"></a>[152]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QuotAttrContentChar" class="xquery">QuotAttrContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Char" class="xquery">Char</a> - ["{}&lt;&amp;]</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-AposAttrContentChar" name="doc-xpath-AposAttrContentChar"></a>[153]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AposAttrContentChar" class="xquery">AposAttrContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Char" class="xquery">Char</a> - ['{}&lt;&amp;]</span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="doc-xpath-EscapeQuot" name="doc-xpath-EscapeQuot"></a>[149]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-EscapeQuot" class="xquery">EscapeQuot</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>'""'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-EscapeApos" name="doc-xpath-EscapeApos"></a>[150]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-EscapeApos" class="xquery">EscapeApos</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"''"</code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-EnclosedExpr" name="doc-xpath-EnclosedExpr"></a>[30]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-EnclosedExpr" class="xquery">EnclosedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span></table><p>This section contains a conceptual description of the semantics of various kinds of constructor expressions. An XQuery implementation is free to use any implementation technique that produces the same result as the processing steps described in this section.</p><div class="div3">
<h4><a id="id-element-constructor" name="id-element-constructor"></a>3.7.1 Direct Element Constructors</h4><p>An <b>element constructor</b> creates an element node. [<a title="direct element constructor" id="dt-direct-elem-const" name="dt-direct-elem-const">Definition</a>: A <b>direct element constructor</b> is a form of element constructor in which the name of the constructed element is a constant.] Direct element constructors are based on standard XML notation. For example, the following expression is a direct element constructor
that creates a <code>book</code> element containing an attribute and some nested elements:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;</pre></div></div><p>If the element name in a direct element constructor has a namespace prefix, the namespace prefix is resolved to a namespace URI using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. If the element name  has no namespace prefix, it is implicitly qualified by the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>. Note that both the statically known namespaces and the default element/type namespace may be affected by <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attributes</a> found inside the element constructor. The namespace prefix of the element name is retained after expansion of the QName, as described in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. The resulting <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed element node.</p><p>In a direct element constructor, the name used in the end tag must exactly match the name
used in the corresponding start tag, including its prefix or absence of a prefix.</p><p>In a direct element constructor, curly braces { } delimit <b>enclosed
expressions</b>, distinguishing them from literal text. Enclosed expressions
are evaluated and replaced by their value, as illustrated by the following
example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;example&gt;
   &lt;p&gt; Here is a query. &lt;/p&gt;
   &lt;eg&gt; $b/title &lt;/eg&gt;
   &lt;p&gt; Here is the result of the query. &lt;/p&gt;
   &lt;eg&gt;{ $b/title }&lt;/eg&gt;
&lt;/example&gt;</pre></div></div><p>The above query might generate the following result (whitespace has been added for readability to this result and other result examples in this document):</p><div class="parse-test"><div class="exampleInner"><pre>
&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;&lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;&lt;/eg&gt;
&lt;/example&gt;</pre></div></div><p>Since XQuery uses curly braces to denote enclosed expressions, some
convention is needed to denote a curly brace used as an ordinary character. For
this purpose, a pair of identical curly brace characters within the content of an element or attribute are interpreted by XQuery  as a single curly brace
character (that is, the pair "<code>{{</code>" represents the
  character "<code>{</code>" and the pair "<code>}}</code>" represents
  the character "<code>}</code>".) Alternatively, the <a title="character reference" href="#dt-character-reference">character references</a> <code>&amp;#x7b;</code> and <code>&amp;#x7d;</code> can be used to denote curly brace characters.  A single left curly brace
  ("<code>{</code>") is interpreted as the beginning delimiter for an
  enclosed expression. A single right curly brace ("<code>}</code>")
  without a matching left curly brace is treated as a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XPST0003" href="#ERRXPST0003">err:XPST0003</a>].</p><p>The result of an element constructor is a new element node, with its own node identity. All the attribute and descendant nodes of the new element node are also new nodes with their own identities, even if they are copies of existing nodes.</p><div class="div4">
<h5><a id="id-attributes" name="id-attributes"></a>3.7.1.1 Attributes</h5><p>The start tag of a direct element constructor may contain one or more attributes. As in XML, each attribute is specified by a name and a value. In a direct element constructor, the name of each attribute is specified by a constant QName, and the value of the attribute is specified by a string of characters enclosed in single or double quotes. As in the main content of the element constructor, an attribute value may contain expressions enclosed in curly braces, which are evaluated and replaced by their value during processing of the element constructor.</p><p>Each attribute in a direct element constructor creates a new attribute node, with its own node identity, whose parent is the constructed element node. However, note that <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attributes</a> (see <a href="#id-namespaces"><b>3.7.1.2 Namespace Declaration Attributes</b></a>) do not create attribute nodes.</p><p>If an attribute name has a namespace prefix, the prefix is resolved to a namespace URI using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. If the attribute name  has no namespace prefix, the attribute is in no namespace. Note that the statically known namespaces used in  resolving an attribute name may be affected by <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attributes</a> that are found inside the same element constructor. The namespace prefix of the attribute name is retained after expansion of the QName, as described in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. The resulting <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed attribute node.</p><p>If the attributes in a direct element constructor do not have distinct <a title="expanded QName" href="#dt-expanded-qname">expanded
			        QNames</a> as their respective <code>node-name</code> properties, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0040" href="#ERRXQST0040">err:XQST0040</a>].</p><p>Conceptually, an attribute (other than a namespace declaration attribute) in a direct element constructor is processed by the following steps:</p><ol class="enumar"><li><p>Each consecutive sequence of literal characters in the attribute
content is treated as a string containing those characters.  Attribute
value normalization is  then applied to normalize whitespace and
expand <a title="character reference" href="#dt-character-reference">character references</a> and <a title="predefined entity reference" href="#dt-predefined-entity-reference">predefined entity references</a>. An XQuery processor
that supports XML 1.0 uses the rules for attribute value normalization
in Section 3.3.3 of <a href="#XML">[XML 1.0]</a>; an XQuery processor that supports XML
1.1 uses the rules for attribute value normalization in Section 3.3.3
of <a href="#XML1.1">[XML 1.1]</a>. In either case, the normalization rules are applied as though the type of the attribute were CDATA (leading and trailing whitespace characters are not stripped.) The choice between XML 1.0 and XML 1.1 rules is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></li><li><p>Each enclosed expression is converted to a string as follows:</p><ol class="enumla"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the value of the enclosed expression, converting it to a sequence of atomic values.</p></li><li><p>If the result of atomization is an empty sequence, the result is the zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</p></li></ol></li><li><p>Adjacent strings resulting from the above steps are concatenated with no intervening blanks. The resulting string becomes the <code>string-value</code> property of the attribute node. The attribute node is given a <a title="type annotation" href="#dt-type-annotation">type annotation</a> (<code>type-name</code> property) of <code>xdt:untypedAtomic</code> (this type annotation may change if the parent element is validated). The <code>typed-value</code> property of the attribute node is the same as its <code>string-value</code>, as an instance of <code>xdt:untypedAtomic</code>.</p></li><li><p>The <code>parent</code> property of the attribute node is set to the element node constructed by the direct element constructor that contains this attribute.</p></li><li><p>If the attribute name is <code>xml:id</code>, the string value and typed value of the attribute are further normalized by discarding any leading and 
trailing space (#x20) characters, and by replacing sequences of 
space (#x20) characters by a single space (#x20) character.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This step accomplishes <code>xml:id</code> processing as defined in <a href="#XMLID">[XML ID]</a>.</p></div></li><li><p>If the attribute name is <code>xml:id</code>, the <code>is-id</code> property of the resulting attribute node is set to <code>true</code>; otherwise the <code>is-id</code> property is set to <code>false</code>. The <code>is-idrefs</code> property of the attribute node is unconditionally set to <code>false</code>.</p></li></ol><ul><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;shoe size="7"/&gt;</pre></div></div><p>The string value of the <code>size</code> attribute is "<code>7</code>".</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;shoe size="{7}"/&gt;</pre></div></div><p>The string value of the <code>size</code> attribute is "<code>7</code>".</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;shoe size="{()}"/&gt;</pre></div></div><p>The string value of the <code>size</code> attribute is the zero-length string.</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;chapter ref="[{1, 5 to 7, 9}]"/&gt;</pre></div></div><p>The string value of the <code>ref</code> attribute is "<code>[1 5 6 7 9]</code>".</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;shoe size="As big as {$hat/@size}"/&gt;</pre></div></div><p>The string value of the <code>size</code> attribute is the 
string "<code>As big as </code>", concatenated with the string value of the 
node denoted by the expression
  <code>$hat/@size</code>.</p></li></ul></div><div class="div4">
<h5><a id="id-namespaces" name="id-namespaces"></a>3.7.1.2 Namespace Declaration Attributes</h5><p>The names of
  a constructed element and its attributes may be <a title="QName" href="#dt-qname">QNames</a> that
  include <b>namespace prefixes</b>. Namespace prefixes can be
  bound to namespaces in the <a title="Prolog" href="#dt-prolog">Prolog</a> or by  <b>namespace
  declaration attributes</b>. It is a
  <a title="static error" href="#dt-static-error">static error</a> to use a
  namespace prefix that has not been bound to a namespace [<a title="err:XPST0008" href="#ERRXPST0008">err:XPST0008</a>].</p><p>[<a title="namespace declaration attribute" id="dt-namespace-decl-attr" name="dt-namespace-decl-attr">Definition</a>: A
  <b>namespace declaration attribute</b>  is used inside a direct element constructor. Its purpose is to bind a namespace prefix or to set the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> for the constructed element node, including its attributes.] Syntactically, a namespace declaration attribute has the form of an attribute with namespace prefix <code>xmlns</code>, or with name <code>xmlns</code> and no namespace prefix. The value of a namespace declaration attribute must be a <a href="#doc-xpath-URILiteral">URILiteral</a>; otherwise a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0022" href="#ERRXQST0022">err:XQST0022</a>]. All the namespace declaration attributes of a given element must have distinct names [<a title="err:XQST0071" href="#ERRXQST0071">err:XQST0071</a>]. Each namespace declaration attribute is processed as follows:</p><ul><li><p>The local part of the attribute name is interpreted as a namespace prefix and the value of the attribute is interpreted as a namespace URI.  This prefix and URI are added to the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> of the constructor expression (overriding any existing binding of the given prefix), and are also added as a namespace binding to the <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a> of the constructed element. If the namespace URI is a zero-length string and the implementation supports <a href="#XMLNAMES11">[XML Names 1.1]</a>, any 
existing namespace binding for the given prefix is removed from the 
<a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a> of the constructed element and from the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> of the constructor expression. If the namespace URI is a zero-length string and the implementation does not support <a href="#XMLNAMES11">[XML Names 1.1]</a>, a static error is raised [<a title="err:XQST0085" href="#ERRXQST0085">err:XQST0085</a>]. It is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> whether an implementation supports <a href="#XMLNAMES">[XML Names]</a> or <a href="#XMLNAMES11">[XML Names 1.1]</a>.</p></li><li><p>If the name of the namespace declaration attribute is <code>xmlns</code> with no prefix, the value of the attribute is interpreted as a namespace URI. This URI specifies the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> of the constructor expression (overriding any existing default), and is added (with no prefix) to the <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a> of the constructed element (overriding any existing namespace binding with no prefix). If the namespace URI is a zero-length string, the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> of the constructor expression is set to "none," and any no-prefix namespace binding is removed from the <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a> of the constructed element.</p></li><li><p>It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0070" href="#ERRXQST0070">err:XQST0070</a>] 
if a namespace declaration attribute binds a namespace URI to the predefined prefix <code>xml</code> or <code>xmlns</code>, or binds a prefix other than <code>xml</code>  to the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>.</p></li></ul><p> A namespace declaration attribute does not cause an attribute node to be created. </p><p>The following examples illustrate namespace declaration attributes:</p><ul><li><p>In this element constructor, a namespace declaration attribute is used to set the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> to <code>http://example.org/animals</code>:<div class="parse-test"><div class="exampleInner"><pre>&lt;cat xmlns = "http://example.org/animals"&gt;
  &lt;breed&gt;Persian&lt;/breed&gt;
&lt;/cat&gt;</pre></div></div></p></li><li><p>In this element constructor, namespace declaration attributes are used to bind the namespace prefixes <code>metric</code> and <code>english</code>:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;box xmlns:metric = "http://example.org/metric/units"
     xmlns:english = "http://example.org/english/units"&gt;
  &lt;height&gt; &lt;metric:meters&gt;3&lt;/metric:meters&gt; &lt;/height&gt;
  &lt;width&gt; &lt;english:feet&gt;6&lt;/english:feet&gt; &lt;/width&gt;
  &lt;depth&gt; &lt;english:inches&gt;18&lt;/english:inches&gt; &lt;/depth&gt;
&lt;/box&gt;</pre></div></div></li></ul></div><div class="div4">
<h5><a id="id-content" name="id-content"></a>3.7.1.3 Content</h5><p>The part of a direct element constructor between the start tag and the end tag is called the <b>content</b> of the element constructor. This content may consist of text characters (parsed as <a href="#doc-xpath-ElementContentChar">ElementContentChar</a>), nested direct constructors, <a href="#doc-xpath-CDataSection">CdataSections</a>, character and <a title="predefined entity reference" href="#dt-predefined-entity-reference">predefined entity references</a>, and expressions enclosed in curly braces. In general, the value of an enclosed expression may be any sequence of nodes and/or atomic values. Enclosed expressions can be used in the content of an element  constructor to compute both the content and the attributes of the constructed node.</p><p>Conceptually, the content of an element constructor is processed as
follows:</p><ol class="enumar"><li><p>The content is evaluated to produce a
sequence of nodes called the <b>content sequence</b>, as
follows:</p><ol class="enumla"><li><p>If the <a title="boundary-space policy" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" href="#dt-static-context">static context</a> is <code>strip</code>, <a title="boundary whitespace" href="#dt-boundary-whitespace">boundary whitespace</a> is identified and deleted (see <a href="#id-whitespace"><b>3.7.1.4 Boundary Whitespace</b></a> for a definition of boundary whitespace.)</p></li><li><p><a title="predefined entity reference" href="#dt-predefined-entity-reference">Predefined entity references</a>
and <a title="character reference" href="#dt-character-reference">character references</a> are expanded into their
referenced strings, as described in <a href="#id-literals"><b>3.1.1 Literals</b></a>. Characters inside a <a href="#doc-xpath-CDataSection">CDataSection</a>, including special characters such as <code>&lt;</code> and <code>&amp;</code>, are treated as literal characters rather than as markup characters (except for the sequence <code>]]&gt;</code>, which terminates the CDataSection).</p></li><li><p>Each consecutive sequence of
literal characters evaluates to a single text node containing the
characters.</p></li><li><p>Each nested direct constructor is evaluated according to the rules in <a href="#id-element-constructor"><b>3.7.1 Direct Element Constructors</b></a> or <a href="#id-otherConstructors"><b>3.7.2 Other Direct Constructors</b></a>, resulting in a new element, comment, or processing instruction node. The <code>parent</code> property of the resulting node is then set to the newly constructed element node.</p></li><li><p>Enclosed expressions are evaluated as follows: </p><ol class="enumlr"><li><p>For each adjacent sequence of one or more atomic values returned by an enclosed expression, a new text node is constructed, containing the result of casting each atomic value to a string, with a single space character inserted between adjacent values.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The insertion of blank characters between adjacent values applies even if one or both of the values is a zero-length string.</p></div></li><li><p>For each node returned by an enclosed expression, a new copy is made of the given node and all nodes that have the given node as an ancestor,  collectively referred to as <b>copied nodes</b>. The properties of the copied nodes are as follows:</p><ol class="enumua"><li><p>Each copied node receives a new node identity.</p></li><li><p>The <code>parent</code>, <code>children</code>, and <code>attributes</code> properties of the copied nodes are set so as to preserve their inter-node relationships. For the topmost node (the node directly returned by the enclosed expression), the <code>parent</code> property is set to the node constructed by this constructor.</p></li><li><p>If <a title="construction mode" href="#dt-construction-mode">construction mode</a> in the <a title="static context" href="#dt-static-context">static context</a> is <code>strip</code>:</p><ol class="enumur"><li><p>If the copied node is an element node, its <code>type-name</code> property is set to  <code>xdt:untyped</code>. Its <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> properties are set to <code>false</code>.</p></li><li><p>If the copied node is an attribute node, its <code>type-name</code> property  is set to <code>xdt:untypedAtomic</code>. Its <code>is-idrefs</code> property is set to <code>false</code>. Its <code>is-id</code> property is set to <code>true</code> if the qualified name of the attribute node is <code>xml:id</code>; otherwise it is set to <code>false</code>.</p></li><li><p>The <code>string-value</code> of each copied element and attribute node remains unchanged, and its <code>typed-value</code> becomes equal to its <code>string-value</code> as an instance of <code>xdt:untypedAtomic</code>.<div class="note"><p class="prefix"><b>Note:</b></p><p> Implementations that store only the <a title="typed value" href="#dt-typed-value">typed value</a> of a node are required at this point to convert the typed value to a string form.</p></div></p></li></ol><p>On the other hand, if <a title="construction mode" href="#dt-construction-mode">construction mode</a> in the <a title="static context" href="#dt-static-context">static context</a> is <code>preserve</code>, the <code>type-name</code>, <code>nilled</code>, <code>string-value</code>, <code>typed-value</code>, <code>is-id</code>, and <code>is-idrefs</code> properties of the copied nodes are preserved.</p></li><li><p>The <code>in-scope-namespaces</code> property of a copied element node is 
determined by the following rules. In applying these rules, the default 
namespace or absence of a default namespace is treated like any other 
namespace binding:</p><ol class="enumur"><li><p>If <a title="copy-namespaces mode" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies <code>preserve</code>, all in-scope-namespaces of the original element are
retained in the new copy. If <a title="copy-namespaces mode" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies <code>no-preserve</code>, the new copy retains only those in-scope namespaces of the original element that are used in the names of the element and its
     attributes.  It is a
<a title="type error" href="#dt-type-error">type error</a> [<a title="err:XQTY0086" href="#ERRXQTY0086">err:XQTY0086</a>] in this case if the <a title="typed value" href="#dt-typed-value">typed value</a> of the copied element or of any of
its attributes is <a title="namespace-sensitive" href="#dt-namespace-sensitive">namespace-sensitive</a>. [<a title="namespace-sensitive" id="dt-namespace-sensitive" name="dt-namespace-sensitive">Definition</a>: A value is <b>namespace-sensitive</b> if it
includes an item that has a <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of <code>xs:QName</code> or <code>xs:NOTATION</code> or a type
derived by restriction therefrom.]</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Error [<a title="err:XQTY0086" href="#ERRXQTY0086">err:XQTY0086</a>] can occur only if <a title="construction mode" href="#dt-construction-mode">construction mode</a> is <code>preserve</code>,
since otherwise the typed value of the copied node is never namespace-sensitive.</p></div></li><li><p>If <a title="copy-namespaces mode" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies <code>inherit</code>, the copied node inherits all the in-scope namespaces of the constructed node, augmented and overridden by the in-scope namespaces of the original element that were preserved by the preceding rule. If <a title="copy-namespaces mode" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> specifies <code>no-inherit</code>, the copied node does not inherit any in-scope namespaces from the constructed node.</p></li></ol></li><li><p>When an element or processing instruction node is copied, its <code>base-uri</code>
property is set to be the same as that of its new parent,
with the following exception: if a copied element node has an <code>xml:base</code> attribute, its <code>base-uri</code> property is set to
the value of that attribute, resolved (if it is relative) against
the <code>base-uri</code> property of the new parent node.</p></li><li><p>All other properties of the copied nodes are preserved.</p></li></ol></li></ol></li></ol></li><li><p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p></li><li><p> If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p></li><li><p> If the content
   sequence contains an attribute node following a node that is not an
   attribute node, a <a title="type error" href="#dt-type-error">type error</a>
   is raised [<a title="err:XQTY0024" href="#ERRXQTY0024">err:XQTY0024</a>].</p></li><li><p>The properties of the newly constructed element node are determined as follows:</p><ol class="enumla"><li><p><code>node-name</code> is the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> resulting from resolving the element name in the start tag, including its original namespace prefix (if any), as described in <a href="#id-element-constructor"><b>3.7.1 Direct Element Constructors</b></a>.</p></li><li><p><code>base-uri</code> is taken from  the first of the following sources that exists:<ol class="enumlr"><li><p>the value of the constructed node's attribute with namespace URI <code>http://www.w3.org/XML/1998/namespace</code> and local name <code>base</code> (informally, from the <code>xml:base</code> attribute), if this attribute exists;</p></li><li><p>the <code>base-uri</code> property of the node constructed by the nearest containing element or document node constructor, either direct or computed, if such a constructor exists;</p></li><li><p><a title="base URI" href="#dt-base-uri">base URI</a> in the <a title="base URI" href="#dt-base-uri">static context</a>.</p></li></ol></p></li><li><p><code>parent</code> is set to empty.</p></li><li><p><code>attributes</code> consist of all the attributes specified in the start tag as described in <a href="#id-attributes"><b>3.7.1.1 Attributes</b></a>, together with all the attribute nodes in the content sequence, in <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> order. If two or more of these attributes have the same <code>node-name</code>,  a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised [<a title="err:XQDY0025" href="#ERRXQDY0025">err:XQDY0025</a>]. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node.</p></li><li><p><code>children</code> consist of all the element, text, comment, and processing
   instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed element node.</p></li><li><p><code>in-scope-namespaces</code> consist of all the namespace bindings resulting from namespace declaration attributes as described in <a href="#id-namespaces"><b>3.7.1.2 Namespace Declaration Attributes</b></a>, and possibly additional namespace bindings as described in <a href="#id-ns-nodes-on-elements"><b>3.7.4 In-scope Namespaces of a Constructed Element</b></a>.</p></li><li><p>The <code>nilled</code> property is <code>false</code>.</p></li><li><p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order. If there are no text-node descendants, the <code>string-value</code> property is a zero-length string.</p></li><li><p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xdt:untypedAtomic</code>.</p></li><li><p>If <a title="construction mode" href="#dt-construction-mode">construction mode</a> in the <a title="static context" href="#dt-static-context">static context</a> is <code>strip</code>, the <code>type-name</code> property is <code>xdt:untyped</code>. On the other hand, if construction mode is <code>preserve</code>, the <code>type-name</code> property is <code>xs:anyType</code>.</p></li><li><p>The <code>is-id</code> and <code>is-idrefs</code> properties are set to <code>false</code>.</p></li></ol></li></ol><ul><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;a&gt;{1}&lt;/a&gt;</pre></div></div><p>The constructed element node has one child, a text node containing the value "<code>1</code>".</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;a&gt;{1, 2, 3}&lt;/a&gt;</pre></div></div><p>The constructed element node has one child, a text node containing the value "<code>1 2 3</code>".</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;c&gt;{1}{2}{3}&lt;/c&gt;</pre></div></div><p>The constructed element node has one child, a text node containing the value "<code>123</code>".</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;b&gt;{1, "2", "3"}&lt;/b&gt;</pre></div></div><p>The constructed element node has one child, a text node containing the value "<code>1 2 3</code>".</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;fact&gt;I saw 8 cats.&lt;/fact&gt;</pre></div></div><p>The constructed element node has one child, a text node containing the value "<code>I saw 8 cats.</code>".</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;fact&gt;I saw {5 + 3} cats.&lt;/fact&gt;</pre></div></div><p>The constructed element node has one child, a text node containing the value "<code>I saw 8 cats.</code>".</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;fact&gt;I saw &lt;howmany&gt;{5 + 3}&lt;/howmany&gt; cats.&lt;/fact&gt;</pre></div></div><p>The constructed element node has three children: a text node containing "<code>I saw </code> ", a child element node named <code>howmany</code>, and a text node containing "<code> cats.</code>". The child element node in turn has a single text node child containing the value "<code>8</code>".</p></li></ul></div><div class="div4">
<h5><a id="id-whitespace" name="id-whitespace"></a>3.7.1.4 Boundary Whitespace</h5><p>In a direct element constructor, whitespace characters may appear in the content of the constructed element. In some cases, enclosed expressions and/or nested elements may be separated only by whitespace characters.   For 
example, in the expression below, the end-tag 
<code>&lt;/title&gt;</code> and the start-tag <code>&lt;author&gt;</code> are separated by a newline character and four space 
characters:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;</pre></div></div><p>[<a title="boundary whitespace" id="dt-boundary-whitespace" name="dt-boundary-whitespace">Definition</a>: <b>Boundary whitespace</b> is a
sequence of consecutive whitespace characters within the content of a <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructor</a>, that is delimited at each end either by the start or
end of the content, or by a <a href="#doc-xpath-DirectConstructor">DirectConstructor</a>, or by an <a href="#doc-xpath-EnclosedExpr">EnclosedExpr</a>. For this purpose, characters generated by
   <a title="character reference" href="#dt-character-reference">character references</a> such as <code>&amp;#x20;</code> or by <a href="#doc-xpath-CDataSection">CdataSections</a> are not
   considered to be whitespace characters.]</p><p>The <a title="boundary-space policy" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" href="#dt-static-context">static context</a> controls whether boundary whitespace is
   preserved by element constructors. If boundary-space policy is <code>strip</code>, boundary whitespace is not considered significant and
   is discarded. On the other hand, if boundary-space policy is <code>preserve</code>, boundary whitespace is
   considered significant and is
   preserved.</p><ul><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;cat&gt; 
   &lt;breed&gt;{$b}&lt;/breed&gt;
   &lt;color&gt;{$c}&lt;/color&gt; 
&lt;/cat&gt;</pre></div></div><p>The constructed
   <code>cat</code> element node has two child element nodes named
   <code>breed</code> and <code>color</code>. Whitespace surrounding
   the child elements will be stripped away by the element
   constructor if boundary-space policy is
   <code>strip</code>.</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;a&gt;  {"abc"}  &lt;/a&gt;</pre></div></div><p>If
   boundary-space policy is <code>strip</code>, this example is equivalent to <code>&lt;a&gt;abc&lt;/a&gt;</code>. However, if
   boundary-space policy is <code>preserve</code>, this example is
   equivalent to <code>&lt;a&gt;&nbsp;&nbsp;abc&nbsp;&nbsp;&lt;/a&gt;</code>.</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;a&gt; z {"abc"}&lt;/a&gt;</pre></div></div><p>Since the
   whitespace surrounding the <code>z</code> is not boundary
   whitespace, it is always preserved. This example is equivalent to
   <code>&lt;a&gt;&nbsp;z&nbsp;abc&lt;/a&gt;</code>.</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;a&gt;&amp;#x20;{"abc"}&lt;/a&gt;</pre></div></div><p>This
   example is equivalent to <code>&lt;a&gt;&nbsp;abc&lt;/a&gt;</code>, regardless
   of the boundary-space policy, because the space generated by the <a title="character reference" href="#dt-character-reference">character reference</a> is not treated as a whitespace character.</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;a&gt;{"  "}&lt;/a&gt;</pre></div></div><p>This example constructs an element containing two space characters,
   regardless of the boundary-space policy, because whitespace inside an enclosed expression is never considered to be boundary whitespace.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Element constructors treat attributes named <code>xml:space</code> as ordinary attributes. An <code>xml:space</code> attribute does not affect the handling of whitespace by an element constructor.</p></div></div></div><div class="div3">
<h4><a id="id-otherConstructors" name="id-otherConstructors"></a>3.7.2 Other Direct Constructors</h4><p>XQuery allows an expression to generate a processing instruction node or a comment node. This can be accomplished by using a <b>direct processing instruction constructor</b> or a <b>direct comment constructor</b>. In each case, the syntax of the constructor expression is
based on the syntax of a similar construct in XML.</p><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DirPIConstructor" name="doc-xpath-DirPIConstructor"></a>[108]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DirPIConstructor" class="xquery">DirPIConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"&lt;?"</span></span>  <a href="#prod-xpath-PITarget" class="xquery">PITarget</a>  (<a href="#prod-xpath-S" class="xquery">S</a>  <a href="#doc-xpath-DirPIContents" class="xquery">DirPIContents</a>)?  <span class="xquery"><span class="xquery">"?&gt;"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DirPIContents" name="doc-xpath-DirPIContents"></a>[109]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DirPIContents" class="xquery">DirPIContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<a href="#prod-xpath-Char" class="xquery">Char</a>* - (Char* '?&gt;' Char*))</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DirCommentConstructor" name="doc-xpath-DirCommentConstructor"></a>[106]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DirCommentConstructor" class="xquery">DirCommentConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"&lt;!--"</span></span>  <a href="#doc-xpath-DirCommentContents" class="xquery">DirCommentContents</a>  <span class="xquery"><span class="xquery">"--&gt;"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DirCommentContents" name="doc-xpath-DirCommentContents"></a>[107]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DirCommentContents" class="xquery">DirCommentContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery">(<a href="#prod-xpath-Char" class="xquery">Char</a> - '-')</span>  |  <span class="xquery">('-'  (<a href="#prod-xpath-Char" class="xquery">Char</a> - '-'))</span>)*</span></code></td></tr></span></tbody></span></table><p>A direct processing instruction constructor creates a processing instruction node whose <code>target</code> property is <a href="#prod-xpath-PITarget">PITarget</a> and whose <code>content</code> property is <a href="#doc-xpath-DirPIContents">DirPIContents</a>. The <code>base-uri</code> property of the node is empty.  The <code>parent</code> property of the node is empty.</p><p>The <a href="#prod-xpath-PITarget">PITarget</a> of a processing instruction may not consist of the characters "XML" in any combination of upper and lower case. The <a href="#doc-xpath-DirPIContents">DirPIContents</a> of a processing instruction may not contain the string "<code>?&gt;</code>".</p><p>The following example illustrates a direct processing instruction constructor:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;?format role="output" ?&gt;</pre></div></div><p>A direct comment constructor creates a comment node whose  <code>content</code> property is <a href="#doc-xpath-DirCommentContents">DirCommentContents</a>. Its <code>parent</code> property is empty.</p><p>The <a href="#doc-xpath-DirCommentContents">DirCommentContents</a> of a comment may not contain two consecutive hyphens or end with a hyphen. These rules are syntactically enforced by the grammar shown above.</p><p>The following example illustrates a direct comment constructor:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;!-- Tags are ignored in the following section --&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A direct comment constructor is different from a <a href="#doc-xpath-Comment">comment</a>, since a direct comment constructor actually constructs a comment node, whereas a <a href="#doc-xpath-Comment">comment</a> is simply used in documenting a query and is not evaluated.</p></div></div><div class="div3">
<h4><a id="id-computedConstructors" name="id-computedConstructors"></a>3.7.3 Computed
   Constructors</h4><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ComputedConstructor" name="doc-xpath-ComputedConstructor"></a>[112]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ComputedConstructor" class="xquery">ComputedConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-CompDocConstructor" class="xquery">CompDocConstructor</a><br>|  <a href="#doc-xpath-CompElemConstructor" class="xquery">CompElemConstructor</a><br>|  <a href="#doc-xpath-CompAttrConstructor" class="xquery">CompAttrConstructor</a><br>|  <a href="#doc-xpath-CompTextConstructor" class="xquery">CompTextConstructor</a><br>|  <a href="#doc-xpath-CompCommentConstructor" class="xquery">CompCommentConstructor</a><br>|  <a href="#doc-xpath-CompPIConstructor" class="xquery">CompPIConstructor</a></span></code></td></tr></span></tbody></span></table><p>An alternative way to create nodes is by
   using a <b>computed constructor</b>. A
   computed constructor begins with a keyword that identifies the type
   of node to be created: <code>element</code>,
   <code>attribute</code>, <code>document</code>, <code>text</code>, <code>processing-instruction</code>, or <code>comment</code>. </p><p>For those kinds of nodes that have names (element, attribute, and processing instruction nodes), the keyword that specifies the node kind is followed by the name of the node to be
   created. This name may be specified either as a QName or as an expression enclosed in braces. [<a title="name expression" id="dt-name-expression" name="dt-name-expression">Definition</a>: When an expression is used to specify the name of a constructed node, that expression is called the <b>name expression</b> of the constructor.]</p><p>[<a title="content expression" id="dt-content-expression" name="dt-content-expression">Definition</a>: The final part of a
   computed constructor is an expression enclosed in braces, called
   the <b>content expression</b> of the constructor, that generates the content of
   the node.]</p><p>The following example illustrates the use of computed
   element and attribute constructors in a simple case where the names
   of the constructed nodes are constants. This example generates
   exactly the same result as the first example in <a href="#id-element-constructor"><b>3.7.1 Direct Element Constructors</b></a>:</p><div class="parse-test"><div class="exampleInner"><pre>element book { 
   attribute isbn {"isbn-0060229357" }, 
   element title { "Harold and the Purple Crayon"},
   element author { 
      element first { "Crockett" }, 
      element last {"Johnson" }
   }
}</pre></div></div><div class="div4">
<h5><a id="id-computedElements" name="id-computedElements"></a>3.7.3.1 Computed Element
   Constructors</h5><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CompElemConstructor" name="doc-xpath-CompElemConstructor"></a>[114]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CompElemConstructor" class="xquery">CompElemConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"element"</span>  (<a href="#prod-xpath-QName" class="xquery">QName</a>  |  (<span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span>))  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-ContentExpr" class="xquery">ContentExpr</a>?  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ContentExpr" name="doc-xpath-ContentExpr"></a>[115]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ContentExpr" class="xquery">ContentExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-Expr" class="xquery">Expr</a></span></code></td></tr></span></tbody></span></table><p>[<a title="computed element constructor" id="dt-computed-elem-const" name="dt-computed-elem-const">Definition</a>: A <b>computed element constructor</b> creates an element node, allowing both the name and the content of the node to be computed.]</p><p>If the keyword <code>element</code> is followed by a QName, it is expanded using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, and the resulting <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is used as the <code>node-name</code> property of the constructed element node. If expansion of the QName is not successful, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XPST0081" href="#ERRXPST0081">err:XPST0081</a>].</p><p>If the keyword <code>element</code> is followed by a <a title="name expression" href="#dt-name-expression">name expression</a>, the name expression is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="name expression" href="#dt-name-expression">name expression</a>. If the result of atomization is not a single atomic value of type <code>xs:QName</code>, <code>xs:string</code>, or <code>xdt:untypedAtomic</code>, a <a title="type error" href="#dt-type-error">type
   error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized value of the <a title="name expression" href="#dt-name-expression">name expression</a> is of type
   <code>xs:QName</code>, that <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is used as the <code>node-name</code> property of the constructed
   element, retaining the prefix part of the QName.</p></li><li><p>If the atomized value of the <a title="name expression" href="#dt-name-expression">name expression</a> is of type <code>xs:string</code> or <code>xdt:untypedAtomic</code>, that value is converted to an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a>. If the string value contains a namespace prefix, that prefix is resolved to a namespace URI using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. If the string value contains  no namespace prefix, it is treated as a local name in  the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>. The resulting <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is used as the <code>node-name</code> property of the constructed
   element, retaining the prefix part of the QName. If conversion of the atomized <a title="name expression" href="#dt-name-expression">name expression</a> to an expanded QName is not successful, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised [<a title="err:XQDY0074" href="#ERRXQDY0074">err:XQDY0074</a>].</p></li></ol><p>The <a title="content expression" href="#dt-content-expression">content expression</a> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><b>3.7.1.3 Content</b></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. If the <a title="content expression" href="#dt-content-expression">content expression</a> is absent, the content sequence is an empty sequence.</p><p>Processing of the computed element constructor proceeds as follows:</p><ol class="enumar"><li><p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p></li><li><p> If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p></li><li><p> If the content
   sequence contains an attribute node following a node that is not an
   attribute node, a <a title="type error" href="#dt-type-error">type error</a>
   is raised [<a title="err:XQTY0024" href="#ERRXQTY0024">err:XQTY0024</a>].</p></li><li><p>The properties of the newly constructed element node are determined as follows:</p><ol class="enumla"><li><p><code>node-name</code> is the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> resulting from processing the specified QName or <a title="name expression" href="#dt-name-expression">name expression</a>, as described above.</p></li><li><p><code>base-uri</code> is taken from  the first of the following sources that exists:<ol class="enumlr"><li><p>the value of the constructed node's attribute with namespace URI <code>http://www.w3.org/XML/1998/namespace</code> and local name <code>base</code> (informally, from the <code>xml:base</code> attribute), if this attribute exists;</p></li><li><p>the <code>base-uri</code> property of the node constructed by the nearest containing element or document node constructor, either direct or computed, if such a constructor exists;</p></li><li><p><a title="base URI" href="#dt-base-uri">base URI</a> in the <a title="base URI" href="#dt-base-uri">static context</a>.</p></li></ol></p></li><li><p><code>parent</code> is empty.</p></li><li><p><code>attributes</code> consist of all the attribute nodes in the content sequence, in <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> order. If two or more of these attributes have the same <code>node-name</code>,  a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised [<a title="err:XQDY0025" href="#ERRXQDY0025">err:XQDY0025</a>]. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node.</p></li><li><p><code>children</code> consist of all the element, text, comment, and processing
   instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed element node.</p></li><li><p><code>in-scope-namespaces</code> are computed as described in <a href="#id-ns-nodes-on-elements"><b>3.7.4 In-scope Namespaces of a Constructed Element</b></a>.</p></li><li><p>The <code>nilled</code> property is <code>false</code>.</p></li><li><p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order.</p></li><li><p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xdt:untypedAtomic</code>.</p></li><li><p>If <a title="construction mode" href="#dt-construction-mode">construction mode</a> in the <a title="static context" href="#dt-static-context">static context</a> is <code>strip</code>, the <code>type-name</code> property is <code>xdt:untyped</code>. On the other hand, if construction mode is <code>preserve</code>, the <code>type-name</code> property is <code>xs:anyType</code>.</p></li><li><p>The <code>is-id</code> and <code>is-idrefs</code> properties are set to <code>false</code>.</p></li></ol></li></ol><p>A computed element constructor might be
   used to make a modified copy of an existing element. For example,
   if the variable <code>$e</code> is bound to an element with <a title="numeric" href="#dt-numeric">numeric</a>
   content, the following constructor might be used to create a new
   element with the same name and attributes as <code>$e</code> and
   with numeric content equal to twice the value of
   <code>$e</code>:</p><div class="parse-test"><div class="exampleInner"><pre>element {fn:node-name($e)}
   {$e/@*, 2 * fn:data($e)}</pre></div></div><p>In this example, if <code>$e</code> is
   bound by the expression <code>let $e := &lt;length
   units="inches"&gt;{5}&lt;/length&gt;</code>, then the result of the
   example expression is the element <code>&lt;length
   units="inches"&gt;10&lt;/length&gt;</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="static type" href="#dt-static-type">static type</a> of the expression <code>fn:node-name($e)</code> is <code>xs:QName?</code>, denoting zero or one QName. Therefore, if the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, the above example raises a static type error, since the name expression in a computed element constructor is required to return exactly one string or QName. In order to avoid the static type error, the name expression <code>fn:node-name($e)</code> could be rewritten as <code>fn:exactly-one(fn:node-name($e))</code>. If the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a> is not in effect, the example can be successfully evaluated as written, provided that <code>$e</code> is bound to exactly one element node with numeric content.</p></div><p>One important
   purpose of computed constructors is to allow the name of a node to
   be computed. We will illustrate this feature by an expression that
   translates the name of an element from one language to
   another. Suppose that the variable <code>$dict</code> is bound to a
   <code>dictionary</code> element containing a sequence of <code>entry</code> elements, each of which encodes translations for a specific word.  Here is an example
   entry that encodes the German and Italian variants of the word "address":</p><div class="parse-test"><div class="exampleInner"><pre>
&lt;entry word="address"&gt;
   &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt;
   &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt;
&lt;/entry&gt; 
</pre></div></div><p>Suppose further that the variable <code>$e</code> is bound to the following element:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;address&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/address&gt;</pre></div></div><p>Then the following expression generates a new element in which the name of <code>$e</code> has been translated into Italian and the content of <code>$e</code> (including its attributes, if any) has been preserved. The first enclosed expression after the <code>element</code> keyword generates the name of the element, and the second enclosed
expression generates the content and attributes:</p><div class="parse-test"><div class="exampleInner"><pre>
  element 
    {$dict/entry[@word=name($e)]/variant[@xml:lang="it"]}
    {$e/@*, $e/node()}</pre></div></div><p>The result of this expression is as follows:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;indirizzo&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/indirizzo&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>As in the previous example, if the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect, the enclosed expression that computes the element name in the above computed element constructor must be wrapped in a call to the <code>fn:exactly-one</code> function in order to avoid a static type error.</p></div><p>Additional examples of computed element constructors can be found
   in <a href="#id-recursive-transformations"><b>K.4 Recursive Transformations</b></a>.</p></div><div class="div4">
<h5><a id="id-computedAttributes" name="id-computedAttributes"></a>3.7.3.2 Computed Attribute
   Constructors</h5><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CompAttrConstructor" name="doc-xpath-CompAttrConstructor"></a>[116]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CompAttrConstructor" class="xquery">CompAttrConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"attribute"</span>  (<a href="#prod-xpath-QName" class="xquery">QName</a>  |  (<span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span>))  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>?  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span></table><p>A computed attribute constructor creates a new attribute node, with its own node identity.</p><p>If the keyword <code>attribute</code> is followed by a QName, that QName is expanded using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, and the resulting <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (including its prefix) is used as the <code>node-name</code> property of the constructed attribute node. If expansion of the QName is not successful, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XPST0081" href="#ERRXPST0081">err:XPST0081</a>].</p><p>If the keyword <code>attribute</code> is followed by a <a title="name expression" href="#dt-name-expression">name expression</a>, the name expression is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the result of the <a title="name expression" href="#dt-name-expression">name expression</a>. If the result of <a title="atomization" href="#dt-atomization">atomization</a> is not a single atomic value of type <code>xs:QName</code>, <code>xs:string</code>, or <code>xdt:untypedAtomic</code>, a <a title="type error" href="#dt-type-error">type
   error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized value of the <a title="name expression" href="#dt-name-expression">name expression</a> is of type
   <code>xs:QName</code>, that <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (including its prefix) is used as the <code>node-name</code> property of the constructed
   attribute node.</p></li><li><p>If the atomized value of the <a title="name expression" href="#dt-name-expression">name expression</a> is of type <code>xs:string</code> or <code>xdt:untypedAtomic</code>, that value is converted to an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a>. If the string value contains a namespace prefix, that prefix is resolved to a namespace URI using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. If the string value contains  no namespace prefix, it is treated as a local name in no namespace. The resulting <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (including its prefix) is used as the <code>node-name</code> property of the constructed
   attribute. If conversion of the atomized <a title="name expression" href="#dt-name-expression">name expression</a> to an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is not successful, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised [<a title="err:XQDY0074" href="#ERRXQDY0074">err:XQDY0074</a>].</p></li></ol><p>The <code>node-name</code> property of the constructed attribute (an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a>) is checked as follows: If its URI part is <code>http://www.w3.org/2000/xmlns/</code> (corresponding to namespace prefix <code>xmlns</code>) or if it is in no namespace and its local name is <code>xmlns</code>, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> [<a title="err:XQDY0044" href="#ERRXQDY0044">err:XQDY0044</a>]  is raised.</p><p>The <a title="content expression" href="#dt-content-expression">content expression</a> of a computed attribute constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the result of the <a title="content expression" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic values. (If the <a title="content expression" href="#dt-content-expression">content expression</a> is absent, the result of this step is an empty sequence.)</p></li><li><p>If the result of atomization is an empty sequence, the value of the attribute is the zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>string-value</code> property of the new attribute node. The <a title="type annotation" href="#dt-type-annotation">type annotation</a> (<code>type-name</code> property) of the new attribute node is  <code>xdt:untypedAtomic</code>. The <code>typed-value</code> property of the attribute node is the same as its <code>string-value</code>, as an instance of <code>xdt:untypedAtomic</code>.</p></li><li><p>The <code>parent</code> property of the attribute node is set to empty.</p></li><li><p>If the attribute name is <code>xml:id</code>, the string value and typed value of the attribute are further normalized by discarding any leading and 
trailing space whitespace characters, and by replacing sequences of 
whitespace characters by a single space (#x20) character.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This step accomplishes <code>xml:id</code> processing as defined in <a href="#XMLID">[XML ID]</a>.</p></div></li><li><p>If the attribute name is <code>xml:id</code>, the <code>is-id</code> property of the resulting attribute node is set to <code>true</code>; otherwise the <code>is-id</code> property is set to <code>false</code>. The <code>is-idrefs</code> property of the attribute node is unconditionally set to <code>false</code>.</p></li></ol><ul><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>attribute size {4 + 3}</pre></div></div><p>The <a title="string value" href="#dt-string-value">string value</a> of the <code>size</code> attribute is "<code>7</code>" and its type is <code>xdt:untypedAtomic</code>.</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>attribute
   { if ($sex = "M") then "husband" else "wife" }
   { &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt; }</pre></div></div><p>The name of the constructed attribute is either <code>husband</code> or <code>wife</code>. Its <a title="string value" href="#dt-string-value">string value</a> is "<code>Hello 1 2 3 Goodbye</code>".</p></li></ul></div><div class="div4">
<h5><a id="id-documentConstructors" name="id-documentConstructors"></a>3.7.3.3 Document Node Constructors</h5><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CompDocConstructor" name="doc-xpath-CompDocConstructor"></a>[113]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CompDocConstructor" class="xquery">CompDocConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"document"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span></table><p>All document node constructors are computed constructors. The result of a document node constructor is a new document node, with its own node identity.</p><p>A document node constructor is useful when the result of a query is to be a document in its own right. The following example illustrates a query that returns an XML document containing a root element named <code>author-list</code>:</p><div class="parse-test"><div class="exampleInner"><pre>document
   {
      &lt;author-list&gt;
         {fn:doc("bib.xml")/bib/book/author}
      &lt;/author-list&gt;
   }</pre></div></div><p>The <a title="content expression" href="#dt-content-expression">content expression</a> of a document node constructor is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><b>3.7.1.3 Content</b></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. Processing of the document node constructor then proceeds as follows:</p><ol class="enumar"><li><p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p></li><li><p> If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p></li><li><p> If the content sequence contains an attribute node, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li><li><p>The properties of the newly constructed document node are determined as follows:</p><ol class="enumla"><li><p><code>base-uri</code> is taken from <a title="base URI" href="#dt-base-uri">base URI</a> in the <a title="base URI" href="#dt-base-uri">static context</a>. If no base URI is defined in the static context, the <code>base-uri</code> property is empty.</p></li><li><p><code>children</code> consist of all the element, text, comment, and processing
   instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed document node.</p></li><li><p>The <code>unparsed-entities</code> and <code>document-uri</code> properties are empty.</p></li><li><p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order.</p></li><li><p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xdt:untypedAtomic</code>.</p></li></ol></li></ol><p>No validation is performed on the constructed document node. The <a href="#XML">[XML 1.0]</a> rules that govern the structure of an XML document (for example, the document node must have exactly one child that is an element node)  are not enforced by the XQuery document node constructor.</p></div><div class="div4">
<h5><a id="id-textConstructors" name="id-textConstructors"></a>3.7.3.4 Text Node Constructors</h5><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CompTextConstructor" name="doc-xpath-CompTextConstructor"></a>[117]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CompTextConstructor" class="xquery">CompTextConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"text"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span></table><p>All text node constructors are computed constructors. The result of a text node constructor is a new text node, with its own node identity.</p><p>The <a title="content expression" href="#dt-content-expression">content expression</a> of a text node constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="content expression" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic values.</p></li><li><p>If the result of atomization is an empty sequence, no text node is constructed. Otherwise, each atomic value in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed text node.</p></li></ol><p>The <code>parent</code> property of the constructed text node is set to empty.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is possible for a text node constructor to construct a text node containing a zero-length string. However, if used in the content of a constructed element or document node, such a text node will be deleted or merged with another text node.</p></div><p>The following example illustrates a text node constructor:</p><div class="parse-test"><div class="exampleInner"><pre>text {"Hello"}</pre></div></div></div><div class="div4">
<h5><a id="id-computed-pis" name="id-computed-pis"></a>3.7.3.5 Computed Processing Instruction Constructors</h5><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CompPIConstructor" name="doc-xpath-CompPIConstructor"></a>[119]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CompPIConstructor" class="xquery">CompPIConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"processing-instruction"</span>  (<a href="#prod-xpath-NCName" class="xquery">NCName</a>  |  (<span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span>))  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>?  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span></table><p>A computed processing instruction constructor (<a href="#doc-xpath-CompPIConstructor">CompPIConstructor</a>) constructs a new processing instruction node with its own node identity.
   </p><p>If the keyword <code>processing-instruction</code> is followed by an NCName, that NCName is used as the <code>target</code> property of the constructed  node. If the keyword <code>processing-instruction</code> is followed by a <a title="name expression" href="#dt-name-expression">name expression</a>, the name expression is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="name expression" href="#dt-name-expression">name expression</a>. If the result of <a title="atomization" href="#dt-atomization">atomization</a> is not a single atomic value of type <code>xs:NCName</code>, <code>xs:string</code>, or <code>xdt:untypedAtomic</code>, a <a title="type error" href="#dt-type-error">type
   error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized value of the <a title="name expression" href="#dt-name-expression">name expression</a> is of type <code>xs:string</code> or <code>xdt:untypedAtomic</code>, that value is cast to the type <code>xs:NCName</code>. If the value cannot be cast to <code>xs:NCName</code>, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised [<a title="err:XQDY0041" href="#ERRXQDY0041">err:XQDY0041</a>].</p></li><li><p>The resulting NCName is then used as the <code>target</code> property of the newly constructed processing instruction node. However, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>   is raised if the  NCName is equal to "<code>XML</code>" (in any combination of upper and lower case) [<a title="err:XQDY0064" href="#ERRXQDY0064">err:XQDY0064</a>].</p></li></ol><p>The
   <a title="content expression" href="#dt-content-expression">content expression</a> of a computed processing instruction constructor
   is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="content expression" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic values. (If the <a title="content expression" href="#dt-content-expression">content expression</a> is absent, the result of this step is an empty sequence.)</p></li><li><p>If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string. If any of the resulting strings contains the string "<code>?&gt;</code>", a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> [<a title="err:XQDY0026" href="#ERRXQDY0026">err:XQDY0026</a>] is raised.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. Leading whitespace is removed from the resulting string. The resulting string then becomes the <code>content</code> property of the constructed processing instruction node.</p></li></ol><p>The remaining properties of the new processing instruction node are determined as follows:</p><ol class="enumar"><li><p>The <code>parent</code> property is empty.</p></li><li><p>The <code>base-uri</code> property is empty.</p></li></ol><p>The following example illustrates a computed processing instruction constructor:</p><div class="parse-test"><div class="exampleInner"><pre>let $target := "audio-output",
    $content := "beep" 
return processing-instruction {$target} {$content}</pre></div></div><p>The processing instruction node constructed by this example might be serialized as follows:</p><div class="exampleInner"><pre>&lt;?audio-output beep?&gt;</pre></div></div><div class="div4">
<h5><a id="id-computed-comments" name="id-computed-comments"></a>3.7.3.6 Computed Comment Constructors</h5><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CompCommentConstructor" name="doc-xpath-CompCommentConstructor"></a>[118]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CompCommentConstructor" class="xquery">CompCommentConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"comment"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span></table><p>A computed comment constructor (<a href="#doc-xpath-CompCommentConstructor">CompCommentConstructor</a>) constructs a new comment node with its own node identity.
   The <a title="content expression" href="#dt-content-expression">content expression</a> of a computed comment constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="content expression" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic values.</p></li><li><p>If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic value in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed comment node.</p></li><li><p>It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
 error</a> [<a title="err:XQDY0072" href="#ERRXQDY0072">err:XQDY0072</a>] if the result of the <a title="content expression" href="#dt-content-expression">content expression</a> of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</p></li></ol><p>The <code>parent</code> property of the constructed comment node is set to empty.</p><p>The following example illustrates a computed comment constructor:</p><div class="parse-test"><div class="exampleInner"><pre>let $homebase := "Houston" 
return comment {fn:concat($homebase, ", we have a problem.")}</pre></div></div><p>The comment node constructed by this example might be serialized as follows:</p><div class="exampleInner"><pre>&lt;!--Houston, we have a problem.--&gt;</pre></div></div></div><div class="div3">
<h4><a id="id-ns-nodes-on-elements" name="id-ns-nodes-on-elements"></a>3.7.4 In-scope Namespaces of a Constructed Element</h4><p>An element node constructed by a direct or computed element constructor has an <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a> property that consists of a set of <a title="in-scope namespaces" href="#dt-in-scope-namespaces">namespace bindings</a>.  The in-scope namespaces of an element node may affect the way the node is serialized (see <a href="#id-serialization"><b>2.2.4 Serialization</b></a>), and  may also affect the behavior of certain functions that operate on nodes, such as <code>fn:name</code>. Note the difference between <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a>, which is a dynamic property of an element node, and <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>, which is a static property of an expression.  Also note that one of the namespace bindings in the in-scope namespaces may have no prefix (denoting the default namespace for the given element). The in-scope namespaces of a constructed element node consist of the following namespace bindings:</p><ul><li><p>A namespace binding is created for each namespace declared in the current element constructor by a <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration
attribute</a>.</p></li><li><p>A namespace binding is created for each namespace that is declared in a <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration
attribute</a> of an enclosing <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructor</a> and not overridden by  the current element constructor or an intermediate constructor.</p></li><li><p>A namespace binding is always created to bind the prefix <code>xml</code> to the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>.</p></li><li><p>For each namespace used in the name of the constructed element or in the names of its attributes, a namespace binding must exist. If a namespace binding does not already exist for one of these namespaces, a new namespace binding is created for it.  If the name of the node includes a prefix, that
prefix is used in the namespace binding; if the name has no prefix, then a
binding is created for the empty prefix. If this would result in a conflict,
because it would require two different bindings of the same prefix, then the
prefix used in the node name is changed to an arbitrary <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> prefix that does not cause such a conflict, and a
namespace binding is created for this new prefix.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><a title="copy-namespaces mode" href="#dt-copy-namespaces-mode">Copy-namespaces mode</a> does not affect the namespace bindings of a newly constructed element node. It applies only to existing nodes that are copied by a constructor expression.</p></div><p>The following query serves as an example:</p><div class="parse-test"><div class="exampleInner"><pre>declare namespace p="http://example.com/ns/p";
declare namespace q="http://example.com/ns/q";
declare namespace f="http://example.com/ns/f";

&lt;p:a q:b="{f:func(2)}" xmlns:r="http://example.com/ns/r"/&gt;
</pre></div></div><p>The <a title="in-scope namespaces" href="#dt-in-scope-namespaces">in-scope namespaces</a> of the resulting <code>p:a</code> element consists of the following <a title="in-scope namespaces" href="#dt-in-scope-namespaces">namespace bindings</a>:</p><ul><li><p><code>p = "http://example.com/ns/p"</code></p></li><li><p><code>q = "http://example.com/ns/q"</code></p></li><li><p><code>r = "http://example.com/ns/r"
</code></p></li><li><p><code>xml = "http://www.w3.org/XML/1998/namespace"</code></p></li></ul><p>The
namespace bindings for <code>p</code> and <code>q</code> are added to the result element because their respective namespaces
are used in the names of the element and its attributes. The namespace binding <code>r="http://example.com/ns/r"</code> is added to the in-scope namespaces of the constructed
element because it is defined by a <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attribute</a>, even though it is not used in a name.</p><p>No  namespace binding corresponding to <code>f="http://example.com/ns/f"</code> is created, because the namespace prefix <code>f</code> appears only in the query prolog and is not used in an element or attribute name of the constructed node. This namespace binding does not appear in the query result, even though it is present in the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> and is available for use during processing of the query.</p><p>Note that the following constructed element, if nested within a <code>validate</code> expression, cannot be validated:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;</pre></div></div><p>The constructed element will have namespace bindings for the prefixes <code>xsi</code> (because it is used in a name) and <code>xml</code> (because it is defined for every constructed element node). During validation of the constructed element, the validator will be unable to interpret the namespace prefix <code>xs</code> because it is has no namespace binding. Validation of this constructed element could be made possible by providing a <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attribute</a>, as in the following example:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;p xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xsi:type="xs:integer"&gt;3&lt;/p&gt;</pre></div></div></div></div></div></span><span class="xpath"><div class="xpath"><div class="div2">
<h3><a id="id-for-expressions" name="id-for-expressions"></a>3.8 For Expressions</h3><p>XPath provides an iteration facility called a <b>for expression</b>.</p><table summary="Scrap" class="scrap"><span class="xpath"><tbody><span class="xpath"><tr class="xpath" valign="baseline"><td><a id="doc-xpath-ForExpr" name="doc-xpath-ForExpr"></a>[35]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ForExpr" class="xpath">ForExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xpath"><a href="#doc-xpath-SimpleForClause" class="xpath">SimpleForClause</a>  <span class="xpath">"return"</span>  <a href="#doc-xpath-ExprSingle" class="xpath">ExprSingle</a></span></code></td></tr></span></tbody></span><span class="xpath"><tbody><span class="xpath"><tr class="xpath" valign="baseline"><td><a id="doc-xpath-SimpleForClause" name="doc-xpath-SimpleForClause"></a>[38]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-SimpleForClause" class="xpath">SimpleForClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xpath"><span class="xpath">"for"</span>  <span class="xpath">"$"</span>  <a href="#doc-xpath-VarName" class="xpath">VarName</a>  <span class="xpath">"in"</span>  <a href="#doc-xpath-ExprSingle" class="xpath">ExprSingle</a>  (<span class="xpath">","</span>  <span class="xpath">"$"</span>  <a href="#doc-xpath-VarName" class="xpath">VarName</a>  <span class="xpath">"in"</span>  <a href="#doc-xpath-ExprSingle" class="xpath">ExprSingle</a>)*</span></code></td></tr></span></tbody></span></table><p>A <code>for</code> expression is evaluated as follows:</p><ol class="enumar"><li><p>If the <code>for</code> expression uses multiple variables, it is first expanded to a set of nested <code>for</code> expressions, each of which uses only one variable. For example, the expression
<code>for $x in X, $y in Y return $x + $y</code>
is expanded to
<code>for $x in X return 
    for $y in Y return $x + $y</code>.</p></li><li><p>In a single-variable <code>for</code> expression, the variable is called the <b>range variable</b>, the value of the expression that follows the <code>in</code> keyword is called the <b>binding sequence</b>, and the expression that follows the <code>return</code> keyword is called the <b>return expression</b>. The result of the <code>for</code> expression is obtained by evaluating the <code>return</code> expression once for each item in the binding sequence, with the range variable bound to that item. The resulting sequences  are concatenated (as if by the <a title="comma operator" href="#dt-comma-operator">comma operator</a>) in the order of the items in the binding sequence from which they were derived. 
</p></li></ol><span class="xpath"><div class="xpath"><p class="xpath">The following example illustrates the use of a <code>for</code> expression in restructuring an input document. The example is based on the following
input:</p></div></span><div class="exampleInner"><pre>&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming
           in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;</pre></div><p>The following example transforms the input document into a list in
which each author's name appears only once, followed by a list of
titles of books written by that author. This example assumes that the
context item is the <code>bib</code> element in the input
document.</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">for $a in fn:distinct-values(/bib/book/author)
return (/bib/book/author[. = $a], /bib/book[author = $a]/title)</span></span></pre></div></div><p>The result of the above
	expression consists of the following sequence of elements. The
	titles of books written by a given author are listed after the
	name of the author.

The ordering of <code>author</code> elements in the result is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> due to the semantics of the <code>fn:distinct-values</code> function.</p><div class="exampleInner"><pre>&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;</pre></div><p>The following example illustrates a <code>for</code> expression containing more than one variable:</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</span></span></pre></div></div><p>The result of the above expression, expressed as a sequence of numbers, is as follows: <code>11, 12, 21, 22</code></p><p>The scope of a variable bound in a <code>for</code> expression comprises all subexpressions of the <code>for</code> expression
that appear after the variable binding. The scope does not
include the expression to which the variable is bound. The following example illustrates how a variable binding may reference another variable bound earlier in the same  <code>for</code> expression:</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</span></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The focus for evaluation of the <code>return</code> clause of a <code>for</code> expression
is the same as the focus for evaluation of the <code>for</code> expression itself. The
following example, which attempts to find the total value of a set of
order-items, is therefore incorrect:

</p><div class="error"><div class="exampleInner"><pre>fn:sum(for $i in order-item return @price *
@qty)</pre></div></div><p> 

Instead, the expression must be written to use the variable bound in the <code>for</code> clause:</p><div class="parse-test"><div class="exampleInner"><pre>fn:sum(for $i in order-item
    return $i/@price * $i/@qty)</pre></div></div></div></div></div></span><span class="xquery"><div class="xquery"><div class="div2">
<h3><a id="id-flwor-expressions" name="id-flwor-expressions"></a>3.9 FLWOR Expressions</h3><p>XQuery provides a feature called a FLWOR  expression that supports iteration and binding of variables to intermediate results. This
kind of expression is often useful for computing joins between two or more
documents and for restructuring data. The name FLWOR,
pronounced "flower", is suggested by the keywords <code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, and <code>return</code>.</p><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-FLWORExpr" name="doc-xpath-FLWORExpr"></a>[34]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-FLWORExpr" class="xquery">FLWORExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<a href="#doc-xpath-ForClause" class="xquery">ForClause</a>  |  <a href="#doc-xpath-LetClause" class="xquery">LetClause</a>)+  <a href="#doc-xpath-WhereClause" class="xquery">WhereClause</a>?  <a href="#doc-xpath-OrderByClause" class="xquery">OrderByClause</a>?  <span class="xquery">"return"</span>  <a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ForClause" name="doc-xpath-ForClause"></a>[36]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ForClause" class="xquery">ForClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"for"</span>  <span class="xquery">"$"</span>  <a href="#doc-xpath-VarName" class="xquery">VarName</a>  <a href="#doc-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  <a href="#doc-xpath-PositionalVar" class="xquery">PositionalVar</a>?  <span class="xquery">"in"</span>  <a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a>  (<span class="xquery">","</span>  <span class="xquery">"$"</span>  <a href="#doc-xpath-VarName" class="xquery">VarName</a>  <a href="#doc-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  <a href="#doc-xpath-PositionalVar" class="xquery">PositionalVar</a>?  <span class="xquery">"in"</span>  <a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-LetClause" name="doc-xpath-LetClause"></a>[39]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-LetClause" class="xquery">LetClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"let"</span>  <span class="xquery">"$"</span>  <a href="#doc-xpath-VarName" class="xquery">VarName</a>  <a href="#doc-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  <span class="xquery">":="</span>  <a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a>  (<span class="xquery">","</span>  <span class="xquery">"$"</span>  <a href="#doc-xpath-VarName" class="xquery">VarName</a>  <a href="#doc-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  <span class="xquery">":="</span>  <a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-TypeDeclaration" name="doc-xpath-TypeDeclaration"></a>[121]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"as"</span>  <a href="#doc-xpath-SequenceType" class="xquery">SequenceType</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-PositionalVar" name="doc-xpath-PositionalVar"></a>[37]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PositionalVar" class="xquery">PositionalVar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"at"</span>  <span class="xquery">"$"</span>  <a href="#doc-xpath-VarName" class="xquery">VarName</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-WhereClause" name="doc-xpath-WhereClause"></a>[40]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-WhereClause" class="xquery">WhereClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"where"</span>  <a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-OrderByClause" name="doc-xpath-OrderByClause"></a>[41]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-OrderByClause" class="xquery">OrderByClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">((<span class="xquery">"order"</span>  <span class="xquery">"by"</span>)  |  (<span class="xquery">"stable"</span>  <span class="xquery">"order"</span>  <span class="xquery">"by"</span>))  <a href="#doc-xpath-OrderSpecList" class="xquery">OrderSpecList</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-OrderSpecList" name="doc-xpath-OrderSpecList"></a>[42]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-OrderSpecList" class="xquery">OrderSpecList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-OrderSpec" class="xquery">OrderSpec</a>  (<span class="xquery">","</span>  <a href="#doc-xpath-OrderSpec" class="xquery">OrderSpec</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-OrderSpec" name="doc-xpath-OrderSpec"></a>[43]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-OrderSpec" class="xquery">OrderSpec</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a>  <a href="#doc-xpath-OrderModifier" class="xquery">OrderModifier</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-OrderModifier" name="doc-xpath-OrderModifier"></a>[44]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-OrderModifier" class="xquery">OrderModifier</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery">"ascending"</span>  |  <span class="xquery">"descending"</span>)?  (<span class="xquery">"empty"</span>  (<span class="xquery">"greatest"</span>  |  <span class="xquery">"least"</span>))?  (<span class="xquery">"collation"</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a>)?</span></code></td></tr></span></tbody></span></table><p>The <code>for</code> and <code>let</code> clauses in a FLWOR expression generate an ordered sequence of tuples of bound variables, called the <b>tuple stream</b>. The optional <code>where</code> clause serves to filter the tuple stream, retaining some tuples and discarding others. The optional <code>order by</code> clause can be used to reorder the tuple stream. The <code>return</code> clause constructs the result of the FLWOR expression. The <code>return</code> clause is evaluated once for every tuple in the tuple stream, after filtering by the <code>where</code> clause, using the variable bindings in the respective tuples. The result of the FLWOR
expression is an ordered sequence containing the results of these
evaluations, concatenated as if by the <a title="comma operator" href="#dt-comma-operator">comma operator</a>.</p><p>The following example of a FLWOR expression includes all of the possible clauses. The <code>for</code> clause iterates over all the departments in an input document, binding the variable <code>$d</code> to each department number in turn. For each binding of <code>$d</code>, the <code>let</code> clause binds variable <code>$e</code> to all the employees in the given department, selected from another input document. The result of the <code>for</code> and <code>let</code> clauses is a tuple stream in which each tuple contains a pair of bindings for <code>$d</code> and <code>$e</code> (<code>$d</code> is bound to a department number and <code>$e</code> is bound to a set of employees in that department). The <code>where</code> clause filters the tuple stream by keeping only those binding-pairs that represent departments having at least ten employees. The <code>order by</code> clause orders the surviving tuples in descending order by the average salary of the employees in the department. The <code>return</code> clause constructs a new <code>big-dept</code> element for each surviving tuple, containing the department number, headcount, and average salary.</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">for $d in fn:doc("depts.xml")/depts/deptno
let $e := fn:doc("emps.xml")/emps/emp[deptno = $d]
where fn:count($e) &gt;= 10
order by fn:avg($e/salary) descending
return
   &lt;big-dept&gt;
      {
      $d,
      &lt;headcount&gt;{fn:count($e)}&lt;/headcount&gt;,
      &lt;avgsal&gt;{fn:avg($e/salary)}&lt;/avgsal&gt;
      }
   &lt;/big-dept&gt;</span></span></pre></div></div><p>The clauses in a FLWOR expression are described in more detail below.</p><div class="div3">
<h4><a id="id-for-let" name="id-for-let"></a>3.9.1 For and Let Clauses</h4><p>The purpose of the <code>for</code> and <code>let</code> clauses in a FLWOR expression is to produce a tuple stream in which each tuple consists of one or more bound variables.</p><p>The simplest example of a <code>for</code> clause contains one variable and an associated expression. [<a title="binding sequence" id="dt-binding-sequence" name="dt-binding-sequence">Definition</a>: The value of the expression associated with a variable in a <code>for</code> clause is called the <b>binding sequence</b> for that variable.] The <code>for</code> clause iterates over the items in the binding sequence, binding the variable to each item in turn. If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the resulting sequence of variable bindings is ordered according to the order of values in the binding sequence; otherwise the ordering of the variable bindings is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>A <code>for</code> clause may also contain multiple variables, each with an associated expression whose value is the binding sequence for that variable. In this case, the <code>for</code> clause iterates each variable over its binding sequence. The resulting tuple stream contains one tuple for each combination of values in the respective binding sequences. If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the order of the tuple stream is determined primarily by the order of the binding sequence of the leftmost variable, and secondarily by the binding sequences of the other variables, working from left to right. Otherwise, the ordering of the variable bindings is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>A <code>let</code> clause may also contain one or more variables, each with an associated expression. Unlike a <code>for</code> clause, however, a <code>let</code> clause binds each variable to the result of its associated expression, without iteration. The variable bindings generated by <code>let</code> clauses are added to the binding tuples generated by the <code>for</code> clauses. If there are no <code>for</code> clauses, the <code>let</code> clauses generate one tuple containing all the variable bindings.</p><p>Although <code>for</code> and <code>let</code> clauses both bind variables, the manner in which variables are bound is quite
different, as illustrated by the following examples. The first example uses a <code>let</code> clause: </p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">let $s := (&lt;one/&gt;, &lt;two/&gt;, &lt;three/&gt;)
return &lt;out&gt;{$s}&lt;/out&gt;</span></span></pre></div></div><p>The variable <code>$s</code> is bound to the result of the expression <code>(&lt;one/&gt;,
    &lt;two/&gt;, &lt;three/&gt;)</code>. Since there are no <code>for</code> clauses, the <code>let</code> clause generates one tuple that contains the binding of <code>$s</code>.
The <code>return</code> clause is invoked for this tuple, creating the following output:</p><div class="exampleInner"><pre>&lt;out&gt;
   &lt;one/&gt;
   &lt;two/&gt;
   &lt;three/&gt;
&lt;/out&gt;</pre></div><p>The next example is a similar query that contains a <code>for</code> clause instead of a <code>let</code> clause:</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">for $s in (&lt;one/&gt;, &lt;two/&gt;, &lt;three/&gt;)
return &lt;out&gt;{$s}&lt;/out&gt;</span></span></pre></div></div><p>In this example, the variable <code>$s</code> iterates over the given expression. If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, <code>$s</code> is first bound to <code>&lt;one/&gt;</code>, then to <code>&lt;two/&gt;</code>, and finally to <code>&lt;three/&gt;</code>. One tuple is generated for each of these bindings, and the <code>return</code> clause is invoked for each tuple, creating the following output:</p><div class="exampleInner"><pre>&lt;out&gt;
   &lt;one/&gt;
&lt;/out&gt;
&lt;out&gt;
   &lt;two/&gt;
&lt;/out&gt;
&lt;out&gt;
   &lt;three/&gt;
&lt;/out&gt;</pre></div><p>The following example illustrates how binding tuples are generated by a <code>for</code> clause that contains multiple variables when <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>.</p><div class="exampleInner"><pre>for $i in (1, 2), $j in (3, 4)</pre></div><p>The tuple stream generated by the above <code>for</code> clause is as follows:</p><div class="exampleInner"><pre>($i = 1, $j = 3)
($i = 1, $j = 4)
($i = 2, $j = 3)
($i = 2, $j = 4)</pre></div><p>If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> were <code>unordered</code>, the <code>for</code> clause in the above example would generate the same tuple stream but the order of the tuples would be <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>The scope of a variable bound in a <code>for</code> or <code>let</code> clause comprises all subexpressions of the containing FLWOR expression
that appear after the variable binding. The scope does not
include the expression to which the variable is bound. The following example illustrates how bindings in <code>for</code> and <code>let</code> clauses may reference variables that were bound in earlier clauses, or in earlier bindings in the same clause of the FLWOR expression:</p><div class="parse-test"><div class="exampleInner"><pre>for $x in $w, $a in f($x)
let $y := g($a)
for $z in p($x, $y)
return q($x, $y, $z)</pre></div></div><p>The <code>for</code> and <code>let</code> clauses of a given FLWOR expression may bind the same variable name more than once. In this case, each new binding occludes the previous one, which becomes inaccessible in the remainder of the FLWOR expression.</p><p>Each variable bound in a
<code>for</code> or <code>let</code> clause may have an optional
<b>type declaration</b>, which is a type declared using the
syntax in <a href="#id-sequencetype-syntax"><b>2.5.3 SequenceType Syntax</b></a>. If the type of a value bound to the variable does not match the declared type according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a>, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>]. For example, the following expression raises a <a title="type error" href="#dt-type-error">type error</a> because the variable <code>$salary</code> has a type declaration that is not satisfied by the value that is bound to the variable:</p><div class="parse-test"><div class="exampleInner"><pre>let $salary as xs:decimal :=  "cat"
return $salary * 2</pre></div></div><p>Each variable bound in a <code>for</code> clause may have an associated <b>positional variable</b> that is bound at the same time. The name of the positional variable is preceded by the keyword <code>at</code>. The positional variable always has an implied type of <code>xs:integer</code>. As a variable iterates over the items in its <a title="binding sequence" href="#dt-binding-sequence">binding sequence</a>, its positional variable iterates over the integers that represent the ordinal positions of those items in the binding sequence, starting with 1.</p><p>Positional variables are illustrated by the following <code>for</code> clause:</p><div class="exampleInner"><pre>for $car at $i in ("Ford", "Chevy"),
    $pet at $j in ("Cat", "Dog")</pre></div><p>If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>ordered</code>, the tuple stream generated by the above <code>for</code> clause is as follows:</p><div class="exampleInner"><pre>($i = 1, $car = "Ford", $j = 1, $pet = "Cat")
($i = 1, $car = "Ford", $j = 2, $pet = "Dog")
($i = 2, $car = "Chevy", $j = 1, $pet = "Cat")
($i = 2, $car = "Chevy", $j = 2, $pet = "Dog")</pre></div><p>If <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>unordered</code>, the order of the tuple stream is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. In addition, if a <code>for</code> clause contains subexpressions that are affected by <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a>, the association of positional variables with items returned by these subexpressions is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> if <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> is <code>unordered</code>.</p></div><div class="div3">
<h4><a id="id-where" name="id-where"></a>3.9.2 Where Clause</h4><p>The optional <code>where</code> clause serves as a filter for the tuples of variable bindings
generated by the <code>for</code> and <code>let</code> clauses. The expression in the <code>where</code> clause, called the <b>where-expression</b>, is evaluated once for
each of these tuples. If the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the
where-expression is <code>true</code>, the tuple is retained and its variable bindings are used in an
execution of the <code>return</code> clause. If the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the where-expression is <code>false</code>, the tuple is discarded. The <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of an expression is defined in <a href="#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>.</p><p>The following expression illustrates how a <code>where</code> clause might be applied to a <b>positional variable</b> in order to perform sampling on an input sequence. This expression approximates the average value in a sequence by sampling one value out of each one hundred input values.</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">fn:avg(for $x at $i in $inputvalues
    where $i mod 100 = 0   
    return $x)</span></span></pre></div></div></div><div class="div3">
<h4><a id="id-orderby-return" name="id-orderby-return"></a>3.9.3 Order By and Return Clauses</h4><p>The <code>return</code> clause of a FLWOR expression is evaluated once for each tuple in the tuple stream,  and the results of these evaluations are concatenated, as if by the <a title="comma operator" href="#dt-comma-operator">comma operator</a>, to form the result of the FLWOR expression.</p><p>If no <code>order by</code> clause is present, the order of the tuple stream is determined by the <code>for</code> and <code>let</code> clauses and by <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a>. If an <code>order by</code> clause is present, it reorders the tuples in the tuple stream into a new, value-based order. In either case, the resulting order determines the order in which the <code>return</code> clause is evaluated, once for each tuple, using the variable bindings in the respective tuples. Note that <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> has no effect on a FLWOR expression if an <code>order by</code> clause is present, since <code>order by</code> takes precedence over <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a>.</p><p>An <code>order by</code> clause contains one or more ordering specifications, called <a href="#doc-xpath-OrderSpec">orderspecs</a>, as shown in the grammar above. For each tuple in the tuple stream, after filtering by the <code>where</code> clause, the orderspecs are evaluated, using the variable bindings in that tuple. The relative order of two tuples is determined by comparing the values of their orderspecs, working from left to right until a pair of unequal values is encountered. If an orderspec specifies a <a title="collation" href="#dt-collation">collation</a>, that collation is used in comparing values of type <code>xs:string</code>, <code>xs:anyURI</code>, or types derived from them (otherwise, the <a title="default collation" href="#dt-def-collation">default collation</a> is used). If an orderspec specifies a collation that is not found in <a title="statically known collations" href="#dt-static-collations">statically known collations</a>, an error is raised [<a title="err:XQST0076" href="#ERRXQST0076">err:XQST0076</a>].</p><p>The process of evaluating and comparing the orderspecs is based on
the following rules:</p><ul><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is applied to the result of the expression
in each orderspec.  If the result of atomization is neither a single atomic value nor an empty sequence, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li><li><p>If the value of an orderspec has the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> <code>xdt:untypedAtomic</code> (such as character
data in a schemaless document), it is cast to the type <code>xs:string</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Consistently treating untyped values as strings enables the sorting process to begin without complete knowledge of the types of all the values to be sorted.</p></div></li><li><p>All the non-empty orderspec values must be convertible to a common type by  <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a> and/or <a title="type promotion" href="#dt-type-promotion">type promotion</a>. The ordering is performed in the least common type that has a <code>gt</code> operator. If two or more non-empty orderspec values are not convertible to a common type that has a <code>gt</code> operator, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p><ul><li><p>Example: The orderspec values include a value of type <code>hatsize</code>, which is derived from <code>xs:integer</code>, and a value of type <code>shoesize</code>, which is derived from <code>xs:decimal</code>. The least common type reachable by subtype substitution and type promotion is <code>xs:decimal</code>.</p></li><li><p>Example: The orderspec values include a value of type <code>xs:string</code> and a value of type <code>xs:anyURI</code>. The least common type reachable by subtype substitution and type promotion is <code>xs:string</code>.</p></li></ul></li></ul><p>When two orderspec values are compared to determine their relative position in the ordering sequence, the <em>greater-than</em> relationship is defined as follows:</p><ul><li><p>When the orderspec specifies <code>empty least</code>, a value W is considered to be <em>greater-than</em> a value V if one of the following is true:</p><ul><li><p>V is an empty sequence and W is not an empty sequence.</p></li><li><p>V is <code>NaN</code>, and W is neither <code>NaN</code> nor an empty sequence.</p></li><li><p>No collation is specified, and W <code>gt</code> V is true.</p></li><li><p>A specific collation C is specified, and <code>fn:compare(V, W, C)</code> is less than zero.</p></li></ul></li><li><p>When the orderspec specifies <code>empty greatest</code>, a value W is considered to be <em>greater-than</em> a value V if one of the following is true:</p><ul><li><p>W is an empty sequence and V is not an empty sequence.</p></li><li><p>W is <code>NaN</code>, and V is neither <code>NaN</code> nor an empty sequence.</p></li><li><p>No collation is specified, and W <code>gt</code> V is true.</p></li><li><p>A specific collation C is specified, and <code>fn:compare(V, W, C)</code> is less than zero.</p></li></ul></li><li><p>When the orderspec specifies neither <code>empty least</code> nor <code>empty greatest</code>, the <a title="default order for empty sequences" href="#dt-default-empty-order">default order for empty sequences</a> in the <a title="static context" href="#dt-static-context">static context</a> determines whether the rules for <code>empty least</code> or <code>empty greatest</code> are used.</p></li></ul><p>If T1 and T2 are two tuples in the tuple stream, and V1 and V2 are the first pair of  values encountered when evaluating their orderspecs  from left to right for which one value is <em>greater-than</em> the other (as defined above), then:</p><ol class="enumar"><li><p>If V1 is <em>greater-than</em> V2: If the orderspec specifies <code>descending</code>, then T1 precedes T2 in the tuple stream; otherwise, T2 precedes T1 in the tuple stream.</p></li><li><p>If V2 is <em>greater-than</em> V1: If the orderspec specifies <code>descending</code>, then T2 precedes T1 in the tuple stream; otherwise, T1 precedes T2 in the tuple stream.</p></li></ol><p>If neither V1 nor V2 is <em>greater-than</em> the other for any pair of orderspecs for tuples T1 and T2, the following rules apply.</p><ol class="enumar"><li><p>If <code>stable</code> is specified, the original order of T1 and T2 is preserved in the tuple stream.</p></li><li><p>If <code>stable</code> is not specified, the order of T1 and T2 in the tuple stream is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>If two orderspecs return the special floating-point values positive and negative zero, neither of these values is <em>greater-than</em> the other, since <code>+0.0 gt -0.0</code> and <code>-0.0 gt +0.0</code> are both <code>false</code>.</p></div><p>An <code>order by</code> clause makes it easy to sort the result of a FLWOR expression, even if the sort key is not included in the result of the expression. For example, the following expression returns employee names in descending order by salary, without returning the actual salaries:</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">for $e in $employees 
order by $e/salary descending 
return $e/name</span></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Since the <code>order by</code> clause in a FLWOR expression is the only facility provided by XQuery for specifying a value ordering, a FLWOR expression must be used in some queries where iteration would not otherwise be necessary. For example, a list of books with price less than 100 might be obtained by a simple <a title="path expression" href="#dt-path-expression">path expression</a> such as <code>$books/book[price &lt; 100]</code>. But if these books are to be returned in alphabetic order by title, the query must be expressed as follows:</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">for $b in $books/book[price &lt; 100]
order by $b/title
return $b</span></span></pre></div></div></div><p>The following example illustrates an <code>order by</code> clause that uses several options. It causes a collection of books to be sorted in primary order by title, and in secondary descending order by price. A specific <a title="collation" href="#dt-collation">collation</a> is specified for the title ordering, and in the ordering by price, books with no price are specified to occur last (as though they have the least possible price). Whenever two books with the same title and price occur, the keyword <code>stable</code> indicates that their input order is preserved.</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">for $b in $books/book
stable order by $b/title 
      collation "http://www.example.org/collations/fr-ca",
   $b/price descending empty least
return $b</span></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Parentheses are helpful in <code>return</code> clauses that contain comma operators, 
since FLWOR expressions have a higher precedence than the comma 
operator. For instance, the following query raises an error because 
after the comma, <code>$j</code> is no longer within the FLWOR expression, and is an 
undefined variable:</p><div class="parse-test"><div class="exampleInner"><pre>let $i := 5,
    $j := 20 * i
return $i, $j</pre></div></div><p>Parentheses can be used to bring <code>$j</code> into the <code>return</code> clause of the FLWOR expression, as the 
programmer probably intended:</p><div class="parse-test"><div class="exampleInner"><pre>let $i := 5,
    $j := 20 * i
return ($i, $j)</pre></div></div></div></div><div class="div3">
<h4><a id="N148C2" name="N148C2"></a>3.9.4 Example</h4><p>The following example illustrates how FLWOR expressions can be nested, and how ordering can be specified at multiple levels of an element hierarchy. The example query inverts a document hierarchy to
transform a bibliography into an author list. The input (bound to the variable <code>$bib</code>) is a <code>bib</code> element containing a list of
books, each of which in turn contains a list of authors. The example is based on
the following input:</p><div class="exampleInner"><pre>&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming
           in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;</pre></div><p>The following query transforms the input document into a list in which each author's name appears only once, followed by a list of titles of books written by that author. The <code>fn:distinct-values</code> function is used to eliminate duplicates (by value) from a list of author nodes. The author list, and the lists of books published by each author, are returned in alphabetic order using the <a title="default collation" href="#dt-def-collation">default collation</a>.</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">&lt;authlist&gt;
 {
   for $a in fn:distinct-values($bib/book/author)
   order by $a
   return
     &lt;author&gt;
        &lt;name&gt; {$a} &lt;/name&gt;
        &lt;books&gt;
          {
            for $b in $bib/book[author = $a]
            order by $b/title
            return $b/title 
          }
        &lt;/books&gt;
     &lt;/author&gt;
 }
&lt;/authlist&gt;</span></span></pre></div></div><p>The result of the above expression is as follows:</p><div class="exampleInner"><pre>&lt;authlist&gt;
   &lt;author&gt;
      &lt;name&gt;Abiteboul&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Buneman&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Stevens&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Advanced Programming
                in the Unix Environment&lt;/title&gt;
         &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Suciu&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
&lt;/authlist&gt;</pre></div></div></div></div></span><span class="xquery"><div class="xquery"><div class="div2">
<h3><a id="id-unordered-expressions" name="id-unordered-expressions"></a>3.10 Ordered and Unordered Expressions</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-OrderedExpr" name="doc-xpath-OrderedExpr"></a>[94]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-OrderedExpr" class="xquery">OrderedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"ordered"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-UnorderedExpr" name="doc-xpath-UnorderedExpr"></a>[95]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-UnorderedExpr" class="xquery">UnorderedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"unordered"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span></table><p>The purpose of <code>ordered</code> and <code>unordered</code> expressions is to set the <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> in the <a title="static context" href="#dt-static-context">static context</a> to <code>ordered</code> or <code>unordered</code> for a certain region in a query. The specified ordering mode applies to the expression nested inside the curly braces. For expressions where the ordering of the result is not significant,  a  performance advantage may be realized by setting the ordering mode to <code>unordered</code>, thereby granting the system flexibility to return the result in the order that it finds most efficient.</p><p> <a title="ordering mode" href="#dt-ordering-mode">Ordering mode</a> affects the behavior of <a title="path expression" href="#dt-path-expression">path expressions</a> that include a "<code>/</code>" or "<code>//</code>" operator or an <a title="axis step" href="#dt-axis-step">axis step</a>; <code>union</code>, <code>intersect</code>, and <code>except</code> expressions; and FLWOR expressions that have no <code>order by</code> clause. If ordering mode is <code>ordered</code>, node sequences returned by path,  <code>union</code>, <code>intersect</code>, and <code>except</code> expressions are in <a title="document order" href="#dt-document-order">document order</a>; otherwise the order of these return sequences is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. The effect of ordering mode on FLWOR expressions is described in <a href="#id-flwor-expressions"><b>3.9 FLWOR Expressions</b></a>. Ordering mode has no effect on duplicate elimination.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In a region of the query where ordering mode is <code>unordered</code>, certain functions that depend on the ordering of node sequences may return nondeterministic results. These functions include <code>fn:position</code>, <code>fn:last</code>, <code>fn:index-of</code>, <code>fn:insert-before</code>, <code>fn:remove</code>, <code>fn:reverse</code>, and <code>fn:subsequence</code>. Also, within a <a title="path expression" href="#dt-path-expression">path expression</a> in an  unordered region, <a title="numeric predicate" href="#dt-numeric-predicate">numeric predicates</a> are nondeterministic. For example, in an ordered region, the path expression <code>(//a/b)[5]</code> will return the fifth qualifying <code>b</code>-element in <a title="document order" href="#dt-document-order">document order</a>. In an unordered region, the same expression will return an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> qualifying <code>b</code>-element.</p></div><p>The use of an <code>unordered</code> expression is illustrated by the following example, which joins together two documents named <code>parts.xml</code> and <code>suppliers.xml</code>. The example returns the part numbers of red parts, paired with the supplier numbers of suppliers who supply these parts. If an <code>unordered</code> expression were not used, the resulting list of (part number, supplier number) pairs would be required to have an ordering that is controlled primarily by the <a title="document order" href="#dt-document-order">document order</a> of <code>parts.xml</code> and secondarily by the <a title="document order" href="#dt-document-order">document order</a> of <code>suppliers.xml</code>. However, this might not be the most efficient way to process the query if the ordering of the result is not important. An XQuery implementation might be able to process the query more efficiently by using an index to find the red parts, or by using <code>suppliers.xml</code> rather than <code>parts.xml</code> to control the primary ordering of the result. The <code>unordered</code> expression gives the query evaluator freedom to make these kinds of optimizations.</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">unordered {
  for $p in fn:doc("parts.xml")/parts/part[color = "Red"],
      $s in fn:doc("suppliers.xml")/suppliers/supplier
  where $p/suppno = $s/suppno  
  return
    &lt;ps&gt;
       { $p/partno, $s/suppno }
    &lt;/ps&gt;
}</span></span></pre></div></div><p>In addition to <code>ordered</code> and <code>unordered</code> expressions, XQuery provides a function named <code>fn:unordered</code> that operates on any sequence of items and returns the same sequence in a nondeterministic order. A call to the <code>fn:unordered</code> function may be thought of as giving permission for the argument expression to be materialized in whatever order the system finds most efficient. The <code>fn:unordered</code> function relaxes ordering only for the sequence that is its immediate operand, whereas an <code>unordered</code> expression sets the <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> for its operand expression and all nested expressions.</p></div></div></span><div class="div2">
<h3><a id="id-conditionals" name="id-conditionals"></a>3.11 Conditional Expressions</h3><p>[XPath/XQuery] supports a conditional expression based on the keywords <code>if</code>, <code>then</code>, and <code>else</code>.</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-IfExpr" name="doc-xpath-IfExpr"></a>[48]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-IfExpr">IfExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"if"  "("  <a href="#doc-xpath-Expr">Expr</a>  ")"  "then"  <a href="#doc-xpath-ExprSingle">ExprSingle</a>  "else"  <a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p>The expression following the <code>if</code> keyword is called the <b>test expression</b>, and the expressions
following the <code>then</code> and <code>else</code> keywords are called the <b>then-expression</b> and <b>else-expression</b>, respectively.</p><p>The first step in processing a conditional expression is to find
the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the test expression, as defined in <a href="#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>.</p><p>The value of a conditional expression is defined as follows: If the
effective boolean value of the test expression is <code>true</code>, the value of the then-expression is returned. If the
effective boolean value of the test expression is <code>false</code>,
the value of the else-expression is returned.</p><p>Conditional expressions have a special rule for propagating <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>. If the effective value of the test expression is <code>true</code>, the conditional expression ignores (does not raise) any dynamic errors encountered in the else-expression. In this case, since the else-expression can have no observable effect, it need not be evaluated. Similarly, if the effective value of the test expression is <code>false</code>, the conditional expression ignores any <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a> encountered in the then-expression, and the then-expression need not be evaluated.</p><p>Here are some examples of conditional expressions:</p><ul><li><p>In this example, the test expression is a comparison expression:</p><div class="parse-test"><div class="exampleInner"><pre>if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2</pre></div></div></li><li><p>In this example, the test expression tests for the existence of an attribute
named <code>discounted</code>, independently of its value:</p><div class="parse-test"><div class="exampleInner"><pre>if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail</pre></div></div></li></ul></div><div class="div2">
<h3><a id="id-quantified-expressions" name="id-quantified-expressions"></a>3.12 Quantified Expressions</h3><p>Quantified expressions support existential and universal quantification. The
value of a quantified expression is always <code>true</code> or <code>false</code>.</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-QuantifiedExpr" name="doc-xpath-QuantifiedExpr"></a>[45]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QuantifiedExpr">QuantifiedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("some"  |  "every")  "$"  <a href="#doc-xpath-VarName">VarName</a>  <a href="#doc-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  "in"  <a href="#doc-xpath-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#doc-xpath-VarName">VarName</a>  <a href="#doc-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  "in"  <a href="#doc-xpath-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="noid_N144AC.doc-xpath-TypeDeclaration" name="noid_N144AC.doc-xpath-TypeDeclaration"></a>[121]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"as"</span>  <a href="#doc-xpath-SequenceType" class="xquery">SequenceType</a></span></code></td></tr></span></tbody></span></table><p>A <b>quantified expression</b> begins with
a <b>quantifier</b>, which is the keyword <code>some</code> or <code>every</code>, followed by one or more in-clauses that are used to bind variables,
followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an
expression that returns a sequence of items, called the <b>binding sequence</b> for that variable. The in-clauses generate tuples of variable bindings, including a tuple for each combination of items in the binding sequences of the respective variables. Conceptually, the test expression is evaluated for each
tuple of variable bindings. Results depend on the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of the test expressions, as defined in <a href="#id-ebv"><b>2.4.3 Effective Boolean Value</b></a>. The value of the quantified expression is defined
by the following rules:</p><ol class="enumar"><li><p>If the quantifier is <code>some</code>, the quantified expression is <code>true</code> if at least one evaluation of the test expression has the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
tuples, the value of the quantified expression is <code>false</code>.</p></li><li><p>If the quantifier is <code>every</code>, the quantified expression is <code>true</code> if every evaluation of the test expression has the <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> <code>true</code>; otherwise the quantified expression is <code>false</code>. This rule implies that, if the in-clauses generate zero binding
tuples, the value of the quantified 
expression is <code>true</code>.</p></li></ol><p>The scope of a variable bound in a quantified expression comprises all
subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound.
</p><span class="xquery"><div class="xquery"><p class="xquery">Each variable bound in an in-clause of a quantified expression may have an optional <a href="#doc-xpath-TypeDeclaration">type declaration</a>. If the type of a value bound to the variable does not match the declared type according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a>, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></div></span><p>The order in which test expressions are evaluated for the various binding
tuples is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. If the quantifier 
is <code>some</code>, an implementation may 
return <code>true</code> as soon as it finds one binding tuple for which the test expression has
an <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of <code>true</code>, and it may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one binding tuple for
which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one binding tuple for which the test expression has
an <a title="effective boolean value" href="#dt-ebv">effective boolean value</a> of <code>false</code>, and it may raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one binding tuple for
which the test expression raises an error. As a result of these rules, the
value of a quantified expression is not deterministic in the presence of
errors, as illustrated in the examples below.</p><p>Here are some examples of quantified expressions:</p><ul><li><p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):</p><div class="parse-test"><div class="exampleInner"><pre>every $part in /parts/part satisfies $part/@discounted</pre></div></div></li><li><p>This expression is <code>true</code> if at least 
one <code>employee</code> element satisfies the given comparison expression:</p><div class="parse-test"><div class="exampleInner"><pre>some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)</pre></div></div></li><li><p>In the following examples, each quantified expression evaluates its test
expression over nine tuples of variable bindings, formed from the Cartesian
product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</p><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span></pre></div></div><div class="parse-test"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</span></span></pre></div></div></li><li><p>This quantified expression may either return  <code>true</code> or raise a <a title="type error" href="#dt-type-error">type error</a>, since its test expression returns <code>true</code> for one variable binding 
and raises a <a title="type error" href="#dt-type-error">type error</a> for another:</p><div class="parse-test"><div class="exampleInner"><pre>some $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></div></li><li><p>This quantified expression may either return <code>false</code> or raise a <a title="type error" href="#dt-type-error">type error</a>, since its test expression returns <code>false</code> for one variable binding and raises a <a title="type error" href="#dt-type-error">type error</a> for another:</p><div class="parse-test"><div class="exampleInner"><pre>every $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></div></li><span class="xquery"><li class="xquery"><p>This quantified expression  contains a <a href="#doc-xpath-TypeDeclaration">type declaration</a> that is not satisfied by every item in the  test expression. If the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a> is implemented, this expression raises a <a title="type error" href="#dt-type-error">type error</a> during the <a title="static analysis phase" href="#dt-static-analysis">static analysis
phase</a>. Otherwise, the expression may either return <code>true</code> or raise a <a title="type error" href="#dt-type-error">type error</a> during the <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
phase</a>.</p><div class="parse-test"><div class="exampleInner"><pre>some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></div></li></span></ul></div><div class="div2">
<h3><a id="id-expressions-on-datatypes" name="id-expressions-on-datatypes"></a>3.13 Expressions on SequenceTypes</h3><p><span class="xquery"><span class="xquery"><span class="xquery">In addition to their use in function parameters and results, </span></span></span><a title="sequence type" href="#dt-sequence-type">sequence types</a> are used in <code>instance of</code>, <span class="xquery"><span class="xquery"><span class="xquery"><code>typeswitch</code>,</span></span></span> <code>cast</code>, <code>castable</code>, and <code>treat</code> expressions.</p><div class="div3">
<h4><a id="id-instance-of" name="id-instance-of"></a>3.13.1 Instance Of</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-InstanceofExpr" name="doc-xpath-InstanceofExpr"></a>[57]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-TreatExpr">TreatExpr</a> ( "instance"  "of"  <a href="#doc-xpath-SequenceType">SequenceType</a> )?</code></td></tr></tbody></table><p>The boolean 
operator <code>instance of</code> 
returns <code>true</code> if the value of its first operand matches
the <a href="#doc-xpath-SequenceType">SequenceType</a> in its second
operand, according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a>; otherwise it returns <code>false</code>. For example:</p><ul><li><p><code>5 instance of xs:integer</code></p><p>This example returns <code>true</code> because the given value is an instance of the given type.</p></li><li><p><code>5 instance of xs:decimal</code></p><p>This example returns <code>true</code> because the given value is an integer literal, and <code>xs:integer</code> is derived by restriction from <code>xs:decimal</code>.</p></li><span class="xquery"><li class="xquery"><p><code>&lt;a&gt;{5}&lt;/a&gt; instance of xs:integer</code></p><p>This example returns <code>false</code> because the given value is an element rather than an integer.</p></li></span><li><p><code>(5, 6) instance of xs:integer+</code></p><p>This example returns <code>true</code> because the given sequence contains two integers, and is a valid instance of the specified type.</p></li><li><p><code>. instance of element()</code></p><p>This example returns <code>true</code> if the context item is an element node or <code>false</code> if the context item is defined but is not an element node. If the context item is undefined, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised [<a title="err:XPDY0002" href="#ERRXPDY0002">err:XPDY0002</a>].</p></li></ul></div><span class="xquery"><div class="xquery"><div class="div3">
<h4><a id="id-typeswitch" name="id-typeswitch"></a>3.13.2 Typeswitch</h4><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-TypeswitchExpr" name="doc-xpath-TypeswitchExpr"></a>[46]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-TypeswitchExpr" class="xquery">TypeswitchExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"typeswitch"</span>  <span class="xquery">"("</span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery">")"</span>  <a href="#doc-xpath-CaseClause" class="xquery">CaseClause</a>+  <span class="xquery">"default"</span>  (<span class="xquery">"$"</span>  <a href="#doc-xpath-VarName" class="xquery">VarName</a>)?  <span class="xquery">"return"</span>  <a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CaseClause" name="doc-xpath-CaseClause"></a>[47]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CaseClause" class="xquery">CaseClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"case"</span>  (<span class="xquery">"$"</span>  <a href="#doc-xpath-VarName" class="xquery">VarName</a>  <span class="xquery">"as"</span>)?  <a href="#doc-xpath-SequenceType" class="xquery">SequenceType</a>  <span class="xquery">"return"</span>  <a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a></span></code></td></tr></span></tbody></span></table><span class="xquery"><div class="xquery"><p class="xquery">The <b>typeswitch</b> expression chooses one of several expressions to evaluate based on the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of an input value.</p></div></span><span class="xquery"><div class="xquery"><p class="xquery">In a <code>typeswitch</code> expression, the <code>typeswitch</code> keyword is followed by an expression enclosed in parentheses, called
the <b>operand expression</b>. This is the expression whose type is being
tested. The
remainder of the <code>typeswitch</code> expression consists of one or more <code>case</code> clauses and a <code>default</code> clause.</p></div></span><span class="xquery"><div class="xquery"><p class="xquery">Each <code>case</code> clause specifies a <a href="#doc-xpath-SequenceType">SequenceType</a> followed by a <code>return</code> expression. [<a title="effective case" id="dt-effective-case" name="dt-effective-case">Definition</a>: The <b>effective case</b> in a <code>typeswitch</code> expression is the first <code>case</code> clause such that the value of the operand expression matches the <a href="#doc-xpath-SequenceType">SequenceType</a> in the <code>case</code> clause, using the rules of <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a>.] The value of the <code>typeswitch</code> expression is the value of the <code>return</code> expression in the effective case. If the value of the operand
expression does not match any <a href="#doc-xpath-SequenceType">SequenceType</a> named in a <code>case</code> clause, the value of the <code>typeswitch</code> expression is the value of the <code>return</code> expression in the <code>default</code> clause.</p></div></span><p>In a <code>case</code> or <code>default</code> clause, if the value to be returned depends on the value of the operand expression, the clause must specify a variable name. Within the <code>return</code> expression of the <code>case</code> or <code>default</code> clause, this variable name is bound to the value of the operand expression. Inside a <code>case</code> clause, the <a title="static type" href="#dt-static-type">static type</a> of the variable is the <a href="#doc-xpath-SequenceType">SequenceType</a> named in the <code>case</code> clause. Inside a <code>default</code> clause, the static type of the variable is the same as the static type of the operand expression. If the value to be returned by a <code>case</code> or <code>default</code> clause does not depend on the value of the operand expression, the clause need not specify a variable.</p><p>The scope of a variable binding in a <code>case</code> or <code>default</code> clause  comprises that clause. It is not an error for more than one <code>case</code> or <code>default</code> clause in the same <code>typeswitch</code> expression to bind variables
with the same name.
</p><p>A special rule applies to propagation of <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a> by <code>typeswitch</code> expressions. A <code>typeswitch</code> expression ignores (does not raise) any dynamic errors encountered in <code>case</code> clauses other than the <a title="effective case" href="#dt-effective-case">effective case</a>. Dynamic errors encountered in the <code>default</code> clause are raised only if there is no <a title="effective case" href="#dt-effective-case">effective case</a>.</p><span class="xquery"><div class="xquery"><p class="xquery">The following example shows how a <code>typeswitch</code> expression might
be used to process an expression in a way that depends on its <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>.</p></div></span><span class="xquery"><div class="xquery"><div class="exampleInner"><pre><span class="parse-test"><span class="parse-test">typeswitch($customer/billing-address)
   case $a as element(*, USAddress) return $a/state
   case $a as element(*, CanadaAddress) return $a/province
   case $a as element(*, JapanAddress) return $a/prefecture
   default return "unknown"</span></span>
</pre></div></div></span></div></div></span><div class="div3">
<h4><a id="id-cast" name="id-cast"></a>3.13.3 Cast</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-CastExpr" name="doc-xpath-CastExpr"></a>[60]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CastExpr">CastExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-UnaryExpr">UnaryExpr</a> ( "cast"  "as"  <a href="#doc-xpath-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-SingleType" name="doc-xpath-SingleType"></a>[120]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-SingleType">SingleType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AtomicType">AtomicType</a>  "?"?</code></td></tr></tbody></table><p>Occasionally
it is necessary to convert a value to a specific datatype. For this
purpose, [XPath/XQuery] provides a <code>cast</code> expression that
creates a new value of a specific type based on an existing value. A
<code>cast</code> expression takes two operands: an <b>input
expression</b> and a <b>target type</b>. The type of the
input expression is called the <b>input type</b>. The target
type must be an atomic type that is in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> and is not <code>xs:NOTATION</code> or <code>xdt:anyAtomicType</code>, optionally
followed by the occurrence indicator "<code>?</code>" to denote that an empty
sequence is permitted [<a title="err:XPST0080" href="#ERRXPST0080">err:XPST0080</a>]. If the target type has no namespace prefix, it
is considered to be in the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type
namespace</a>. The semantics of the <code>cast</code> expression
are as follows:</p><ol class="enumar"><li><p><a title="atomization" href="#dt-atomization">Atomization</a> is performed on the input
expression.</p></li><li><p> If the result of atomization is a
sequence of more than one atomic value, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li><li><p>If the result
of atomization is an empty sequence:</p><ol class="enumla"><li><p>If
<code>?</code> is specified after the target type, the result of the
<code>cast</code> expression is an empty sequence.</p></li><li><p>
If <code>?</code> is not specified after the target type, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li></ol></li><li><p>If the result of atomization is a single atomic value, the result
of the cast expression depends on the input type and the target
type. In general, the cast expression attempts to create a new value
of the target type based on the input value. Only certain combinations
of input type and target type are supported. A summary of the rules
are listed below&mdash; the normative definition of these rules is
given in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. For the purpose of
these rules, an implementation may determine
that one type is derived by restriction from another type either by examining the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> or by using an
alternative, <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> mechanism such as a data
dictionary.</p><ol class="enumla"><li><p><code>cast</code> is supported for the combinations of
input type and target type listed in <a href="http://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">Section 
17.1 Casting from primitive types to primitive types</a><sup><small>FO</small></sup>. For each of these combinations, both
the input type and the target type are primitive <a title="schema type" href="#dt-schema-type">schema types</a>. For
example, a value of type <code>xs:string</code> can be cast into the
schema type <code>xs:decimal</code>. For each of these built-in combinations,
the semantics of casting are specified in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p><p>If the target type of a <code>cast</code> expression is <code>xs:QName</code>, or is a type that is derived from <code>xs:QName</code> or <code>xs:NOTATION</code>, the input expression must be a string literal; otherwise a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XPST0083" href="#ERRXPST0083">err:XPST0083</a>] is raised.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The reason for this rule is that construction of an instance of one of these target types requires knowledge about namespace bindings. If the input expression is not a literal, it might be derived from an input document whose namespace bindings are different from the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>.</p></div></li><li><p><code>cast</code> is
supported if the input type is a non-primitive atomic type that is derived by restriction from the target
type. In this case, the input value
is mapped into the value space of the target type, unchanged except
for its type. For example, if <code>shoesize</code> is derived by
restriction from <code>xs:integer</code>, a value of type
<code>shoesize</code> can be cast into the schema type
<code>xs:integer</code>.</p></li><li><p><code>cast</code> is
supported if the target type is a non-primitive atomic type and the input
type is <code>xs:string</code> or <code>xdt:untypedAtomic</code>. The
input value is first converted to a value in the lexical space of the
target type by applying the whitespace normalization rules for the
target type (as defined in <a href="#XMLSchema">[XML Schema]</a>); a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> [err:FORG0001]
is raised if the resulting lexical value does not satisfy the pattern
facet of the target type. The lexical value is then converted to the
value space of the target type using the schema-defined rules for the
target type; a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> [err:FORG0001]
is raised if the resulting value does not satisfy all the facets of
the target type.</p></li><li><p><code>cast</code> is supported if
the target type is a non-primitive atomic type that is derived by restriction from the input type. The input value must satisfy all the
facets of the target type (in the case of the pattern facet, this is
checked by generating a string representation of the input value,
using the rules for casting to <code>xs:string</code>). The resulting
value is the same as the input value, but with a different <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>.</p></li><li><p>If a primitive type P1 can be cast into a
primitive type P2, then any type derived by restriction from P1 can be cast into any type derived by restriction from P2, provided that the facets of the target type are
satisfied. First the input value is cast to P1 using rule (b)
above. Next, the value of type P1 is cast to the type P2, using rule
(a) above. Finally, the value of type P2 is cast to the target type,
using rule (d) above.</p></li><li><p> For any combination of input
type and target type that is not in the above list, a
<code>cast</code> expression raises a <a title="type error" href="#dt-type-error">type error</a> [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p></li></ol></li></ol><p> If casting from the input type to the target type is supported but nevertheless it is not possible to cast the input value into the value space of the target type, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is raised. [err:FORG0001] This includes the case when any facet of the target type is not satisfied. For example, the expression <code>"2003-02-31" cast as xs:date</code> would raise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>.</p></div><div class="div3">
<h4><a id="id-castable" name="id-castable"></a>3.13.4 Castable</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-CastableExpr" name="doc-xpath-CastableExpr"></a>[59]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CastableExpr">CastableExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#doc-xpath-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="noid_N1485B.doc-xpath-SingleType" name="noid_N1485B.doc-xpath-SingleType"></a>[120]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-SingleType">SingleType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AtomicType">AtomicType</a>  "?"?</code></td></tr></tbody></table><p>[XPath/XQuery]
provides an expression that tests whether a given value
is castable into a given target type. The target
type must be an atomic type that is in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> and is not <code>xs:NOTATION</code> or <code>xdt:anyAtomicType</code>, optionally
followed by the occurrence indicator "<code>?</code>" to denote that an empty
sequence is permitted [<a title="err:XPST0080" href="#ERRXPST0080">err:XPST0080</a>]. The expression <code>V castable
as T</code> returns <code>true</code> if the value <code>V</code> can
be successfully cast into the target type <code>T</code> by using a
<code>cast</code> expression; otherwise it returns
<code>false</code>. The <code>castable</code> expression can be used as a <a title="predicate" href="#dt-predicate">predicate</a>  to
avoid errors at evaluation time. It can also be used to select an
appropriate type for processing of a given value, as illustrated in
the following example:</p><div class="parse-test"><div class="exampleInner"><pre>
if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string</pre></div></div></div><div class="div3">
<h4><a id="id-constructor-functions" name="id-constructor-functions"></a>3.13.5 Constructor
Functions</h4><p>For every atomic type in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> that is in a namespace (except <code>xs:NOTATION</code> and <code>xdt:anyAtomicType</code>, which are not instantiable), a <b>constructor function</b> is implicitly defined. In each case, the name of the constructor function is the same as the name of its target type (including namespace). The signature of the constructor function for type
<em>T</em> is as follows:</p><div class="exampleInner"><pre><em>T</em>($arg as xdt:anyAtomicType?) as <em>T?</em></pre></div><p> [<a title="constructor function" id="dt-constructor-function" name="dt-constructor-function">Definition</a>: The <b>constructor function</b> for a given type is used to convert instances of other atomic types into the given type. The semantics of the constructor function <code>T($arg)</code> are defined to be equivalent to the expression <code>($arg cast as T?)</code>.]</p><p>The constructor functions for <code>xs:QName</code> and for types derived from <code>xs:QName</code> and <code>xs:NOTATION</code> require their arguments to be string literals; otherwise a static error [<a title="err:XPST0083" href="#ERRXPST0083">err:XPST0083</a>] is raised. This rule is consistent with the semantics of <code>cast</code> expressions for these types, as defined in <a href="#id-cast"><b>3.13.3 Cast</b></a>.</p><p>The following examples illustrate the use of constructor functions:</p><ul><li><p>This
example is equivalent to <code>("2000-01-01" cast as
xs:date?)</code>.</p><div class="parse-test"><div class="exampleInner"><pre>xs:date("2000-01-01")</pre></div></div></li><li><p>This
example is equivalent to 

<code>(($floatvalue * 0.2E-5) cast as xs:decimal?)</code>.</p><div class="parse-test"><div class="exampleInner"><pre>xs:decimal($floatvalue * 0.2E-5)</pre></div></div></li><li><p>This example returns a
<code>xdt:dayTimeDuration</code> value equal to 21 days. It is
equivalent to <code>("P21D" cast as xdt:dayTimeDuration?)</code>.</p><div class="parse-test"><div class="exampleInner"><pre>xdt:dayTimeDuration("P21D")</pre></div></div></li><li><p>If
<code>usa:zipcode</code> is a user-defined  atomic type
in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>, then the
following expression is equivalent to the
expression <code>("12345" cast as
usa:zipcode?)</code>.</p><div class="parse-test"><div class="exampleInner"><pre>usa:zipcode("12345")</pre></div></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>An instance of an atomic type that is not in a namespace can be constructed in either of the following ways:</p><ul><li><p>By using a <code>cast</code> expression, if the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type
		  namespace</a> is "none". <span class="xquery"><span class="xquery"><span class="xquery">(See <a href="#id-default-namespace"><b>4.13 Default Namespace Declaration</b></a> for how to undeclare the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type
		  namespace</a>).</span></span></span></p><div class="parse-test"><div class="exampleInner"><pre>17 cast as apple</pre></div></div></li><li><p>By using a constructor function, if the <a title="default function namespace" href="#dt-def-fn-ns">default function
		namespace</a> is "none". <span class="xquery"><span class="xquery"><span class="xquery">(See <a href="#id-default-namespace"><b>4.13 Default Namespace Declaration</b></a> for how to undeclare the <a title="default function namespace" href="#dt-def-fn-ns">default function
		namespace</a>).</span></span></span></p><div class="parse-test"><div class="exampleInner"><pre>apple(17)
</pre></div></div></li></ul></div></div><div class="div3">
<h4><a id="id-treat" name="id-treat"></a>3.13.6 Treat</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xpath-TreatExpr" name="doc-xpath-TreatExpr"></a>[58]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-TreatExpr">TreatExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CastableExpr">CastableExpr</a> ( "treat"  "as"  <a href="#doc-xpath-SequenceType">SequenceType</a> )?</code></td></tr></tbody></table><p>[XPath/XQuery] provides an
expression called <code>treat</code> that can be used to modify the
<a title="static type" href="#dt-static-type">static type</a> of its
operand.</p><p>Like <code>cast</code>, the <code>treat</code>
expression takes two operands: an expression and a <a href="#doc-xpath-SequenceType">SequenceType</a>. Unlike
<code>cast</code>, however, <code>treat</code> does not change the
<a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> or value of its operand. Instead, the purpose of
<code>treat</code> is to ensure that an expression has an expected
dynamic type at evaluation time.</p><p>The semantics of <em><code>expr1</code></em><code> treat as </code><em><code>type1</code></em> are as
follows:</p><ul><li><p>During static analysis:</p><p> The
<a title="static type" href="#dt-static-type">static type</a> of the
<code>treat</code> expression is <em><code>type1</code></em>. This enables the
expression to be used as an argument of a function that requires a
parameter of <em><code>type1</code></em>.</p></li><li><p>During expression
evaluation:</p><p>If <em><code>expr1</code></em> matches <em><code>type1</code></em>,
using the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a>,
the <code>treat</code> expression returns the value of
<em><code>expr1</code></em>; otherwise, it raises a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> [<a title="err:XPDY0050" href="#ERRXPDY0050">err:XPDY0050</a>].
If the value of <em><code>expr1</code></em> is returned, its identity is
preserved. The <code>treat</code> expression ensures that the value of
its expression operand conforms to the expected type at
run-time.</p></li><li><p>Example:</p><div class="parse-test"><div class="exampleInner"><pre>$myaddress treat as element(*, USAddress)</pre></div></div><p>The
<a title="static type" href="#dt-static-type">static type</a> of
<code>$myaddress</code> may be <code>element(*, Address)</code>, a
less specific type than <code>element(*, USAddress)</code>. However,
at run-time, the value of <code>$myaddress</code> must match the type
<code>element(*, USAddress)</code> using rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a>;
otherwise a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is
raised [<a title="err:XPDY0050" href="#ERRXPDY0050">err:XPDY0050</a>].</p></li></ul></div></div><span class="xquery"><div class="xquery"><div class="div2">
<h3><a id="id-validate" name="id-validate"></a>3.14 Validate Expressions</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ValidateExpr" name="doc-xpath-ValidateExpr"></a>[66]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ValidateExpr" class="xquery">ValidateExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"validate"</span>  <a href="#doc-xpath-ValidationMode" class="xquery">ValidationMode</a>?  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ValidationMode" name="doc-xpath-ValidationMode"></a>[67]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ValidationMode" class="xquery">ValidationMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"lax"</span>  |  <span class="xquery">"strict"</span></span></code></td></tr></span></tbody></span></table><p>A <code>validate</code> expression can be used to validate a document node or an element node with respect to the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a>, using the schema validation process defined in <a href="#XMLSchema">[XML Schema]</a>. If the operand of a <code>validate</code> expression does not evaluate to exactly one document or element node, a <a title="type error" href="#dt-type-error">type error</a> is raised [<a title="err:XQTY0030" href="#ERRXQTY0030">err:XQTY0030</a>]. In this specification, the node that is the operand of a <code>validate</code> expression is called the <b>operand node</b>.</p><p>A <code>validate</code> expression returns a new node with its own identity and with no parent. The new node and its descendants are given <a title="type annotation" href="#dt-type-annotation">type annotations</a> that are generated by applying a validation process to the operand node. In some cases, default values may also be generated by the validation process.</p><p>A <code>validate</code> expression may optionally specify a <a href="#doc-xpath-ValidationMode">validation mode</a>. The default <a href="#doc-xpath-ValidationMode">validation mode</a> is <code>strict</code>. The result of a <code>validate</code> expression is defined by the following rules.</p><ol class="enumar"><li><p> If the operand node is a document node, its children must consist of exactly one element node and zero or more comment and processing instruction nodes, in any order; otherwise, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> [<a title="err:XQDY0061" href="#ERRXQDY0061">err:XQDY0061</a>] is raised.</p></li><li><p>The operand node is converted to an XML Information Set (<a href="#XINFO">[XML Infoset]</a>) according to the "Infoset Mapping" rules defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>. Note that this process discards any existing <a title="type annotation" href="#dt-type-annotation">type annotations</a>.</p></li><li><p>Validity assessment is carried out on the root element information item of the resulting Infoset, using the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> as the effective schema.  The process of validation applies recursively to contained elements and attributes to the extent required by the effective schema. During validity assessment, the following special rules are in effect:</p><ol class="enumla"><li><p>If <a href="#doc-xpath-ValidationMode">validation mode</a> is <code>strict</code>, then there must be a
            top-level element declaration in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a> that matches the root element information
            item in the Infoset, and schema-validity assessment is
            carried out using that declaration in accordance with item
            2 of <a href="#XMLSchema">[XML Schema]</a> Part 1, section 5.2, "Assessing Schema-Validity."

            If there is no such element declaration, a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> is
            raised [<a title="err:XQDY0084" href="#ERRXQDY0084">err:XQDY0084</a>].</p></li><li><p>If <a href="#doc-xpath-ValidationMode">validation mode</a> is <code>lax</code>, then schema-validity 
            assessment is carried out in accordance with item
            3 of <a href="#XMLSchema">[XML Schema]</a> Part 1, section 5.2, "Assessing Schema-Validity."</p><p>If <a href="#doc-xpath-ValidationMode">validation mode</a> is <code>lax</code> and the root element
            information item has neither a top-level element
            declaration nor an <code>xsi:type</code> attribute, <a href="#XMLSchema">[XML Schema]</a> defines the recursive checking of children
            and attributes as optional. During processing of an XQuery <code>validate</code> expression, this
            recursive checking is required.</p></li><li><p>If the operand node is an element node, the validation rules named  "Validation Root Valid (ID/IDREF)" and "Identity-constraint Satisfied" are not applied. This means that document-level constraints relating to uniqueness and referential integrity are not enforced.</p></li><li><p>There is no check that the document contains unparsed entities whose names match the values of nodes of type <code>xs:ENTITY</code> or <code>xs:ENTITIES</code>.</p></li><li><p>There is no check that the document contains notations whose names match the values of nodes of type <code>xs:NOTATION</code>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Validity assessment is affected by the presence or absence of <code>xsi:type</code> attributes on the elements being validated, and may generate new information items such as default attributes.</p></div></li><li><p>The next step depends on <a href="#doc-xpath-ValidationMode">validation mode</a> and on the <code>validity</code> property of the root element information item in the PSVI that results from the validation process.</p><ol class="enumla"><li><p>If the <code>validity</code> property of the root element information item is <code>valid</code> (for any <a href="#doc-xpath-ValidationMode">validation mode</a>), or if <a href="#doc-xpath-ValidationMode">validation mode</a> is <code>lax</code> and the <code>validity</code> property of the root element information item is  <code>notKnown</code>, the PSVI is converted back into the <a title="data model" href="#dt-datamodel">Data Model</a> as described in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> Section 3.3, "Construction from a PSVI". The resulting node (a new node of the same kind as the operand node) is returned as the result of the <code>validate</code> expression.</p></li><li><p>Otherwise, a <a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a> is raised  [<a title="err:XQDY0027" href="#ERRXQDY0027">err:XQDY0027</a>].</p></li></ol></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of these rules is as follows:  If <a href="#doc-xpath-ValidationMode">validation mode</a> is <code>strict</code>, the validated element must have a top-level element  declaration in the effective schema, and must conform to this declaration. If <a href="#doc-xpath-ValidationMode">validation mode</a> is <code>lax</code>, the validated element must conform to its top-level element declaration if such a declaration exists in the effective schema. If <a href="#doc-xpath-ValidationMode">validation mode</a>
      is <code>lax</code> and there is no top-level element declaration for the
      element, and the element has an <code>xsi:type</code> attribute, then the
      <code>xsi:type</code> attribute must name a top-level type definition in the
      effective schema, and the element must conform to that type. The validated element corresponds either to the operand node or (if the operand node is a document node) to its element child.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>During conversion of the PSVI into the <a title="data model" href="#dt-datamodel">Data Model</a> after validation, any element information items whose validity property is <code>notKnown</code> are converted into element nodes with <a title="type annotation" href="#dt-type-annotation">type annotation</a> <code>xs:anyType</code>, and any attribute information items whose validity property is <code>notKnown</code> are converted into attribute nodes with <a title="type annotation" href="#dt-type-annotation">type annotation</a> <code>xdt:untypedAtomic</code>, as described in <a href="http://www.w3.org/TR/xpath-datamodel/#PSVI2NodeTypes">Section 
3.3.1.1 Element and Attribute Node Type Names</a><sup><small>DM</small></sup>.</p></div></div></div></span><span class="xquery"><div class="xquery"><div class="div2">
<h3><a id="id-extension-expressions" name="id-extension-expressions"></a>3.15 Extension Expressions</h3><p>[<a title="extension expression" id="dt-extension-expression" name="dt-extension-expression">Definition</a>: An <b>extension expression</b> is an expression whose semantics are
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.] Typically a particular extension will be recognized
by some implementations and not by others. The syntax is designed so that
extension expressions can be successfully parsed by all implementations, and
so that fallback behavior can be defined for implementations that do not
recognize a particular extension.</p><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ExtensionExpr" name="doc-xpath-ExtensionExpr"></a>[68]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ExtensionExpr" class="xquery">ExtensionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-Pragma" class="xquery">Pragma</a>+  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#doc-xpath-Expr" class="xquery">Expr</a>?  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-Pragma" name="doc-xpath-Pragma"></a>[69]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Pragma" class="xquery">Pragma</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"(#"</span></span>  <a href="#prod-xpath-S" class="xquery">S</a>?  <span class="xquery"><a href="#prod-xpath-QName" class="xquery">QName</a></span>  <a href="#doc-xpath-PragmaContents" class="xquery">PragmaContents</a>  <span class="xquery"><span class="xquery">"#)"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-PragmaContents" name="doc-xpath-PragmaContents"></a>[70]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PragmaContents" class="xquery">PragmaContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery"><a href="#prod-xpath-Char" class="xquery">Char</a></span>* - (Char* '#)' Char*))</span></code></td></tr></span></tbody></span></table><p>An extension expression consists of one or more <b>pragmas</b>, followed by an expression enclosed in curly braces. [<a title="pragma" id="dt-pragma" name="dt-pragma">Definition</a>: A <b>pragma</b> is denoted by the delimiters <code>(#</code> and <code>#)</code>, and consists of an identifying QName followed by <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> content.] The content of a pragma may consist of any string of characters that does not contain the ending delimiter <code>#)</code>.  The QName of a 
pragma must resolve to a namespace URI and local name, using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> [<a title="err:XPST0081" href="#ERRXPST0081">err:XPST0081</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no default namespace for
pragmas.</p></div><p>Each implementation recognizes an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> set of namespace
URIs used to denote pragmas.</p><p>If the namespace part of a pragma QName is not recognized by the
implementation as a pragma namespace, then the pragma
is ignored. If all the pragmas in an <a href="#doc-xpath-ExtensionExpr">ExtensionExpr</a> are ignored, then the
value of the <a href="#doc-xpath-ExtensionExpr">ExtensionExpr</a> is the value of the expression enclosed in curly braces; if this expression is absent, then a <a title="static error" href="#dt-static-error">static error</a> is
raised [<a title="err:XQST0079" href="#ERRXQST0079">err:XQST0079</a>].</p><p>If an implementation recognizes the namespace of one or more pragmas in an <a href="#doc-xpath-ExtensionExpr">ExtensionExpr</a>, then the value
of the <a href="#doc-xpath-ExtensionExpr">ExtensionExpr</a>, including its error behavior, is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. For example, an implementation that recognizes the namespace of
a pragma QName, but does not recognize the local part of the QName, might choose
either to raise an error or to ignore the pragma.</p><p>It is a  <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0013" href="#ERRXQST0013">err:XQST0013</a>] 
if an implementation recognizes a pragma but
determines that its content is  invalid.</p><p>If an implementation recognizes a pragma, it must report any static
errors in the following expression even if it will not evaluate that
expression (however, static type errors are raised only if the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a> is in effect.)</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The following examples illustrate three ways in which extension expressions might be
used.</p><ul><li><p>A pragma can be used to furnish a hint for how to evaluate the
following expression, without actually changing the result.
For example:</p><div class="parse-test"><div class="exampleInner"><pre>declare namespace exq = "http://example.org/XQueryImplementation";
   (# exq:use-index #)
      { $bib/book/author[name='Berners-Lee'] }
</pre></div></div><p>An implementation that recognizes the <code>exq:use-index</code> pragma might use an
index to evaluate the  expression that follows. An implementation that
does not recognize this pragma would evaluate the expression in its normal
way.</p></li><li><p>A pragma might be used to modify the semantics of the following
expression in ways that would not (in the absence of the pragma) be
conformant with this specification. For example, a pragma might be used to
permit comparison of <code>xs:duration</code> values using implementation-defined
semantics (this would normally be an error). Such changes to the language
semantics must be scoped to the expression contained within the curly
braces following the pragma.</p></li><li><p>A pragma might contain syntactic constructs that are
evaluated in place of the following expression. In this case, the
following expression itself (if it is present) provides a fallback for use by
implementations that do not recognize the pragma. For example:</p><div class="parse-test"><div class="exampleInner"><pre>declare namespace exq = "http://example.org/XQueryImplementation";
   for $x in
      (# exq:distinct //city by @country #)
      { //city[not(@country = preceding::city/@country)] }
   return f:show-city($x)
</pre></div></div><p>Here an implementation that recognizes the pragma will return the result of
evaluating the proprietary syntax <code>exq:distinct //city by
@country</code>,
while an implementation that does not recognize the pragma will instead
return the result of the expression <code>//city[not(@country =
preceding::city/@country)]</code>. If no fallback expression is required, or
if none is feasible, then the expression between the curly braces may be
omitted, in which case implementations that do not recognize the pragma will
raise a <a title="static error" href="#dt-static-error">static error</a>.</p></li></ul></div></div></div></span></div><span class="xquery"><div class="xquery"><div class="div1"><span class="xquery"><div class="xquery">
<h2><a id="id-query-prolog" name="id-query-prolog"></a>4 Modules and Prologs</h2></div></span><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-Module" name="doc-xpath-Module"></a>[2]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Module" class="xquery">Module</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-VersionDecl" class="xquery">VersionDecl</a>?  (<a href="#doc-xpath-LibraryModule" class="xquery">LibraryModule</a>  |  <a href="#doc-xpath-MainModule" class="xquery">MainModule</a>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-MainModule" name="doc-xpath-MainModule"></a>[4]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-MainModule" class="xquery">MainModule</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-Prolog" class="xquery">Prolog</a>  <a href="#doc-xpath-QueryBody" class="xquery">QueryBody</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-LibraryModule" name="doc-xpath-LibraryModule"></a>[5]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-LibraryModule" class="xquery">LibraryModule</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-ModuleDecl" class="xquery">ModuleDecl</a>  <a href="#doc-xpath-Prolog" class="xquery">Prolog</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-Prolog" name="doc-xpath-Prolog"></a>[7]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Prolog" class="xquery">Prolog</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">((<a href="#doc-xpath-DefaultNamespaceDecl" class="xquery">DefaultNamespaceDecl</a>  |  <a href="#doc-xpath-Setter" class="xquery">Setter</a>  |  <a href="#doc-xpath-NamespaceDecl" class="xquery">NamespaceDecl</a>  |  <a href="#doc-xpath-Import" class="xquery">Import</a>)  <a href="#doc-xpath-Separator" class="xquery">Separator</a>)*  ((<a href="#doc-xpath-VarDecl" class="xquery">VarDecl</a>  |  <a href="#doc-xpath-FunctionDecl" class="xquery">FunctionDecl</a>  |  <a href="#doc-xpath-OptionDecl" class="xquery">OptionDecl</a>)  <a href="#doc-xpath-Separator" class="xquery">Separator</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-Setter" name="doc-xpath-Setter"></a>[8]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Setter" class="xquery">Setter</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-BoundarySpaceDecl" class="xquery">BoundarySpaceDecl</a>  |  <a href="#doc-xpath-DefaultCollationDecl" class="xquery">DefaultCollationDecl</a>  |  <a href="#doc-xpath-BaseURIDecl" class="xquery">BaseURIDecl</a>  |  <a href="#doc-xpath-ConstructionDecl" class="xquery">ConstructionDecl</a>  |  <a href="#doc-xpath-OrderingModeDecl" class="xquery">OrderingModeDecl</a>  |  <a href="#doc-xpath-EmptyOrderDecl" class="xquery">EmptyOrderDecl</a>  |  <a href="#doc-xpath-CopyNamespacesDecl" class="xquery">CopyNamespacesDecl</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-Import" name="doc-xpath-Import"></a>[9]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Import" class="xquery">Import</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-SchemaImport" class="xquery">SchemaImport</a>  |  <a href="#doc-xpath-ModuleImport" class="xquery">ModuleImport</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-Separator" name="doc-xpath-Separator"></a>[10]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Separator" class="xquery">Separator</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">";"</span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-QueryBody" name="doc-xpath-QueryBody"></a>[31]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QueryBody" class="xquery">QueryBody</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-Expr" class="xquery">Expr</a></span></code></td></tr></span></tbody></span></table><p>A query can be assembled from one or more fragments called <b>modules</b>. [<a title="module" id="dt-module" name="dt-module">Definition</a>: A <b>module</b> is a fragment of XQuery code that conforms to the <a href="#doc-xpath-Module">Module</a> grammar and can independently undergo the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a> described in <a href="#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>. Each module is either a <a title="main module" href="#dt-main-module">main module</a> or a <a title="library module" href="#dt-library-module">library module</a>.]</p><p> [<a title="main module" id="dt-main-module" name="dt-main-module">Definition</a>: A <b>main module</b> consists of a
<a title="Prolog" href="#dt-prolog">Prolog</a> followed by a <a title="query body" href="#dt-queryBody">Query Body</a>.] A query has exactly one
main module. In a main module, the <a title="query body" href="#dt-queryBody">Query Body</a> can be evaluated, and
its value is the result of the query.</p><p>[<a title="library module" id="dt-library-module" name="dt-library-module">Definition</a>: A module that does not contain a <a title="query body" href="#dt-queryBody">Query Body</a> is called a <b>library module</b>. A library module consists of a <a title="module declaration" href="#dt-module-declaration">module declaration</a> followed by  a <a title="Prolog" href="#dt-prolog">Prolog</a>.] A library module cannot be evaluated directly; instead, it provides function and variable declarations that can be imported into other modules.</p><p>The XQuery syntax does not allow a <a title="module" href="#dt-module">module</a> to contain both a <a title="module declaration" href="#dt-module-declaration">module declaration</a> and a <a title="query body" href="#dt-queryBody">Query Body</a>.</p><p>[<a title="Prolog" id="dt-prolog" name="dt-prolog">Definition</a>: A <b>Prolog</b> is a series of declarations and imports that define the processing environment for the <a title="module" href="#dt-module">module</a> that contains the Prolog.] Each declaration or import is followed by a semicolon. A Prolog is organized into two parts. </p><p>The first part of the Prolog consists of setters, imports, namespace declarations, and default namespace declarations. [<a title="setter" id="dt-setter" name="dt-setter">Definition</a>: <b>Setters</b> are declarations that set the value of some property that affects query processing, such as construction mode, ordering mode, or default collation.] Namespace declarations and default namespace declarations affect the interpretation of QNames within the query.  Imports are used to  import definitions from schemas and modules. [<a title="target namespace" id="dt-target-namespace" name="dt-target-namespace">Definition</a>: Each imported schema or module is identified by its <b>target namespace</b>, which is the namespace of the objects (such as elements or functions) that are defined by the schema or module.] </p><p>The second part of the Prolog consists of declarations of variables, functions, and options. These declarations appear at the end of the Prolog because they may be affected by declarations and imports in the first part of the Prolog.</p><p>[<a title="query body" id="dt-queryBody" name="dt-queryBody">Definition</a>: The <b>Query Body</b>, if present, consists of an expression that defines the result of the query.] Evaluation of expressions is described in <a href="#id-expressions"><b>3 Expressions</b></a>. A module can be evaluated only if it has a Query Body.</p><div class="div2">
<h3><a id="id-version-declaration" name="id-version-declaration"></a>4.1 Version Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-VersionDecl" name="doc-xpath-VersionDecl"></a>[3]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-VersionDecl" class="xquery">VersionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"xquery"</span>  <span class="xquery">"version"</span>  <a href="#doc-xpath-StringLiteral" class="xquery">StringLiteral</a>  (<span class="xquery">"encoding"</span>  <a href="#doc-xpath-StringLiteral" class="xquery">StringLiteral</a>)?  <a href="#doc-xpath-Separator" class="xquery">Separator</a></span></code></td></tr></span></tbody></span></table><p>[<a title="version declaration" id="dt-version-declaration" name="dt-version-declaration">Definition</a>: Any <a title="module" href="#dt-module">module</a> may contain a <b>version declaration</b>. If present, the version declaration occurs at the beginning of the <a title="module" href="#dt-module">module</a> and identifies the applicable XQuery syntax and semantics for the <a title="module" href="#dt-module">module</a>.]
The version number "1.0" indicates a requirement that the <a title="module" href="#dt-module">module</a> must be processed by an implementation that supports XQuery Version 1.0.  If the
version declaration is not present, the version is presumed to be "1.0".
An XQuery implementation must raise a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0031" href="#ERRXQST0031">err:XQST0031</a>] when processing a <a title="module" href="#dt-module">module</a> labeled with
a version that the implementation does not support.  It is the intent of the XQuery working group
to give later versions of this specification numbers other than "1.0", but
this intent does not indicate a commitment to produce any future versions of
XQuery, nor if any are produced, to use any particular numbering scheme.</p><p>[<a title="encoding declaration" id="dt-encoding-declaration" name="dt-encoding-declaration">Definition</a>: If present, a version declaration may optionally include an <b>encoding declaration</b>. The value of the string literal following the keyword <code>encoding</code> is an encoding
name, and must conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a>[<a title="err:XQST0087" href="#ERRXQST0087">err:XQST0087</a>]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as "<code>UTF-8</code>", "<code>UTF-16</code>", or "<code>US-ASCII</code>".] Since the encoding of a query may change as the query moves from one environment to another, there can be no guarantee that the encoding declaration is correct.</p><p>The handling of an encoding declaration is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. If an implementation has <em>a priori</em> knowledge of the encoding of a query, it may use this knowledge  and disregard the encoding declaration. The semantics of a query are not affected by the presence or absence of an encoding declaration.</p><p>The following examples illustrate version declarations:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>xquery version "1.0";</pre></div></div><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>xquery version "1.0" encoding "utf-8";</pre></div></div></div><div class="div2">
<h3><a id="id-module-declaration" name="id-module-declaration"></a>4.2 Module Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ModuleDecl" name="doc-xpath-ModuleDecl"></a>[6]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ModuleDecl" class="xquery">ModuleDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"module"</span>  <span class="xquery">"namespace"</span>  <a href="#prod-xpath-NCName" class="xquery">NCName</a>  <span class="xquery">"="</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a>  <a href="#doc-xpath-Separator" class="xquery">Separator</a></span></code></td></tr></span></tbody></span></table><p>[<a title="module declaration" id="dt-module-declaration" name="dt-module-declaration">Definition</a>: A <b>module declaration</b> serves to identify a <a title="module" href="#dt-module">module</a> as a <a title="library module" href="#dt-library-module">library module</a>. A module declaration begins with the keyword <code>module</code> and contains a namespace prefix and a <a href="#doc-xpath-URILiteral">URILiteral</a>.] The URILiteral  identifies the <a title="target namespace" href="#dt-target-namespace">target namespace</a> of the library module, which is the namespace for all variables and functions exported by the library module. The name of every variable and function declared in a library module must
have a namespace URI that is the same as the target namespace of the module; otherwise a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0048" href="#ERRXQST0048">err:XQST0048</a>]. In the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> of the library module, the namespace prefix specified in the module declaration is bound to the module's target namespace.</p><p>Any <a title="module" href="#dt-module">module</a> may import one or more library modules by means of a <a title="module import" href="#dt-module-import">module import</a> that specifies the target namespace of the library modules to be imported. When a module imports one or more library modules, the variables and functions declared in the imported modules are added to the <a title="static context" href="#dt-static-context">static context</a> and (where applicable) to the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> of the importing module.</p><p>The following is an example of a module declaration:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>module namespace math = "http://example.org/math-functions";</pre></div></div></div><div class="div2">
<h3><a id="id-boundary-space-decls" name="id-boundary-space-decls"></a>4.3 Boundary-space Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-BoundarySpaceDecl" name="doc-xpath-BoundarySpaceDecl"></a>[12]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-BoundarySpaceDecl" class="xquery">BoundarySpaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"boundary-space"</span>  (<span class="xquery">"preserve"</span>  |  <span class="xquery">"strip"</span>)</span></code></td></tr></span></tbody></span></table><p>[<a title="boundary-space declaration" id="dt-boundary-space-decl" name="dt-boundary-space-decl">Definition</a>: A <b>boundary-space declaration</b> sets the <a title="boundary-space policy" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Boundary-space policy controls whether <a title="boundary whitespace" href="#dt-boundary-whitespace">boundary whitespace</a> is preserved by element constructors during processing of the query.] If boundary-space policy is <code>preserve</code>, boundary whitespace is preserved. If boundary-space policy is <code>strip</code>, boundary whitespace is stripped (deleted). A further discussion of whitespace in constructed elements can be found in <a href="#id-whitespace"><b>3.7.1.4 Boundary Whitespace</b></a>.</p><p>The following example illustrates a boundary-space declaration:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare boundary-space preserve;</pre></div></div><p>If a Prolog contains more than one boundary-space declaration, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0068" href="#ERRXQST0068">err:XQST0068</a>].</p></div><div class="div2">
<h3><a id="id-default-collation-declaration" name="id-default-collation-declaration"></a>4.4 Default Collation Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DefaultCollationDecl" name="doc-xpath-DefaultCollationDecl"></a>[20]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DefaultCollationDecl" class="xquery">DefaultCollationDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"default"</span>  <span class="xquery">"collation"</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a></span></code></td></tr></span></tbody></span></table><p>[<a title="default collation declaration" id="dt-default-collation-decl" name="dt-default-collation-decl">Definition</a>: A <b>default collation declaration</b> sets the value of the <a title="default collation" href="#dt-def-collation">default
	 collation</a> in the <a title="static context" href="#dt-static-context">static context</a>, overriding any implementation-defined default.] The default collation is the collation that is
	 used by functions and operators that require a collation
	 if no other collation is specified. For example, the
	 <code>gt</code> operator on strings is defined by a call to
	 the <code>fn:compare</code> function, which takes an optional
	 collation parameter. Since the <code>gt</code> operator does
	 not specify a collation, the <code>fn:compare</code> function
	 implements <code>gt</code> by using the default collation.</p><p>If neither the implementation nor the Prolog
	 specifies a default collation, the Unicode codepoint collation
	 (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>)
	 is used. </p><p>The following
	 example illustrates a default
	 collation declaration:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare default collation
	 "http://example.org/languages/Icelandic";</pre></div></div><p>If a Prolog contains more than one default collation declaration, or the value specified by a default collation declaration (after resolution of a relative URI, if necessary) is not present in <a title="statically known collations" href="#dt-static-collations">statically known collations</a>, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0038" href="#ERRXQST0038">err:XQST0038</a>].</p></div><div class="div2">
<h3><a id="id-base-uri-decl" name="id-base-uri-decl"></a>4.5 Base URI Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-BaseURIDecl" name="doc-xpath-BaseURIDecl"></a>[21]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-BaseURIDecl" class="xquery">BaseURIDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"base-uri"</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a></span></code></td></tr></span></tbody></span></table><p>[<a title="base URI declaration" id="dt-base-uri-decl" name="dt-base-uri-decl">Definition</a>: A <b>base URI declaration</b> specifies the
         <a title="base URI" href="#dt-base-uri">base URI</a> property of the <a title="static context" href="#dt-static-context">static context</a>, which
         is used when resolving relative URIs within a
         <a title="module" href="#dt-module">module</a>.] For example, the <code>fn:doc</code>
         function resolves a relative URI using the base URI of the
         calling module.</p><p>The following is an example of a base URI declaration:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare base-uri "http://example.org";</pre></div></div><p>If a Prolog contains more than one base URI declaration, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0032" href="#ERRXQST0032">err:XQST0032</a>].</p></div><div class="div2">
<h3><a id="id-construction-declaration" name="id-construction-declaration"></a>4.6 Construction Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ConstructionDecl" name="doc-xpath-ConstructionDecl"></a>[26]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ConstructionDecl" class="xquery">ConstructionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"construction"</span>  (<span class="xquery">"strip"</span>  |  <span class="xquery">"preserve"</span>)</span></code></td></tr></span></tbody></span></table><p>[<a title="construction declaration" id="dt-construction-decl" name="dt-construction-decl">Definition</a>: A <b>construction declaration</b> sets the <a title="construction mode" href="#dt-construction-mode">construction
	 mode</a> in the <a title="static context" href="#dt-static-context">static
	 context</a>, overriding any implementation-defined default.] The
			 construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction    retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xdt:untyped</code>; all element nodes copied during node construction receive the type <code>xdt:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xdt:untypedAtomic</code>.</p><p>The following example illustrates a construction declaration:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare construction strip;</pre></div></div><p>If a Prolog specifies more than one construction declaration,  a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0067" href="#ERRXQST0067">err:XQST0067</a>].</p></div><div class="div2">
<h3><a id="id-default-ordering-decl" name="id-default-ordering-decl"></a>4.7 Ordering Mode Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-OrderingModeDecl" name="doc-xpath-OrderingModeDecl"></a>[15]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-OrderingModeDecl" class="xquery">OrderingModeDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"ordering"</span>  (<span class="xquery">"ordered"</span>  |  <span class="xquery">"unordered"</span>)</span></code></td></tr></span></tbody></span></table><p>[<a title="ordering mode declaration" id="dt-ordering-mode-decl" name="dt-ordering-mode-decl">Definition</a>: An <b>ordering mode declaration</b> sets the <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> in the <a title="static context" href="#dt-static-context">static context</a>, overriding any implementation-defined default.]  This ordering mode applies to all expressions in a <a title="module" href="#dt-module">module</a> (including both the <a title="Prolog" href="#dt-prolog">Prolog</a> and the <a title="query body" href="#dt-queryBody">Query Body</a>, if any), unless overridden by an <code>ordered</code> or <code>unordered</code> expression.</p><p> <a title="ordering mode" href="#dt-ordering-mode">Ordering mode</a> affects the behavior of <a title="path expression" href="#dt-path-expression">path expressions</a> that include a "<code>/</code>" or "<code>//</code>" operator or an <a title="axis step" href="#dt-axis-step">axis step</a>; <code>union</code>, <code>intersect</code>, and <code>except</code> expressions; and FLWOR expressions that have no <code>order by</code> clause. If ordering mode is <code>ordered</code>, node sequences returned by path,  <code>union</code>, <code>intersect</code>, and <code>except</code> expressions are in <a title="document order" href="#dt-document-order">document order</a>; otherwise the order of these return sequences is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>. The effect of ordering mode on FLWOR expressions is described in <a href="#id-flwor-expressions"><b>3.9 FLWOR Expressions</b></a>.</p><p>The following example illustrates an ordering mode declaration:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare ordering unordered;</pre></div></div><p>If a Prolog contains more than one ordering mode declaration, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0065" href="#ERRXQST0065">err:XQST0065</a>].</p></div><div class="div2">
<h3><a id="id-empty-order-decl" name="id-empty-order-decl"></a>4.8 Empty Order Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-EmptyOrderDecl" name="doc-xpath-EmptyOrderDecl"></a>[16]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-EmptyOrderDecl" class="xquery">EmptyOrderDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"default"</span>  <span class="xquery">"order"</span>  <span class="xquery">"empty"</span>  (<span class="xquery">"greatest"</span>  |  <span class="xquery">"least"</span>)</span></code></td></tr></span></tbody></span></table><p>[<a title="empty order declaration" id="dt-empty-order-decl" name="dt-empty-order-decl">Definition</a>: An <b>empty order declaration</b> sets the <a title="default order for empty sequences" href="#dt-default-empty-order">default order for empty sequences</a> in the <a title="static context" href="#dt-static-context">static context,</a> which controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression.] An individual <code>order by</code> clause may override the default order for empty sequences by specifying <code>empty greatest</code> or <code>empty least</code>.</p><p>The following example illustrates an empty order declaration:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare default order empty least;</pre></div></div><p>If a Prolog contains more than one empty order declaration, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0069" href="#ERRXQST0069">err:XQST0069</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is important to distinguish an <a title="empty order declaration" href="#dt-empty-order-decl">empty order declaration</a> from an <a title="ordering mode declaration" href="#dt-ordering-mode-decl">ordering mode declaration</a>. An <a title="empty order declaration" href="#dt-empty-order-decl">empty order declaration</a> applies only when an <code>order by</code> clause is present, and specifies how empty sequences are treated by the <code>order by</code> clause (unless overridden). An <a title="ordering mode declaration" href="#dt-ordering-mode-decl">ordering mode declaration</a>, on the other hand, applies only in the absence of an <code>order by</code> clause.</p></div></div><div class="div2">
<h3><a id="id-copy-namespaces-decl" name="id-copy-namespaces-decl"></a>4.9 Copy-Namespaces Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-CopyNamespacesDecl" name="doc-xpath-CopyNamespacesDecl"></a>[17]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CopyNamespacesDecl" class="xquery">CopyNamespacesDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"copy-namespaces"</span>  <a href="#doc-xpath-PreserveMode" class="xquery">PreserveMode</a>  <span class="xquery">","</span>  <a href="#doc-xpath-InheritMode" class="xquery">InheritMode</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-PreserveMode" name="doc-xpath-PreserveMode"></a>[18]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PreserveMode" class="xquery">PreserveMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"preserve"</span>  |  <span class="xquery">"no-preserve"</span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-InheritMode" name="doc-xpath-InheritMode"></a>[19]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-InheritMode" class="xquery">InheritMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"inherit"</span>  |  <span class="xquery">"no-inherit"</span></span></code></td></tr></span></tbody></span></table><p>[<a title="copy-namespaces declaration" id="dt-copy-namespaces-decl" name="dt-copy-namespaces-decl">Definition</a>: A <b>copy-namespaces declaration</b> sets the value of <a title="copy-namespaces mode" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> in the <a title="static context" href="#dt-static-context">static context</a>, overwriting any implementation-defined default. Copy-namespaces mode  controls the 
namespace bindings that are assigned when an existing element node is 
copied by an element constructor.] Handling of namespace bindings by element constructors is described in <a href="#id-element-constructor"><b>3.7.1 Direct Element Constructors</b></a>.</p><p>The following example illustrates a copy-namespaces declaration:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare copy-namespaces preserve, no-inherit;</pre></div></div><p>If a Prolog contains more than one copy-namespaces declaration, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0055" href="#ERRXQST0055">err:XQST0055</a>].</p></div><div class="div2">
<h3><a id="id-schema-imports" name="id-schema-imports"></a>4.10 Schema Import</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-SchemaImport" name="doc-xpath-SchemaImport"></a>[22]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-SchemaImport" class="xquery">SchemaImport</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"import"</span>  <span class="xquery">"schema"</span>  <a href="#doc-xpath-SchemaPrefix" class="xquery">SchemaPrefix</a>?  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a>  (<span class="xquery">"at"</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a>  (<span class="xquery">","</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a>)*)?</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-SchemaPrefix" name="doc-xpath-SchemaPrefix"></a>[23]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-SchemaPrefix" class="xquery">SchemaPrefix</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery">"namespace"</span>  <a href="#prod-xpath-NCName" class="xquery">NCName</a>  <span class="xquery">"="</span>)  |  (<span class="xquery">"default"</span>  <span class="xquery">"element"</span>  <span class="xquery">"namespace"</span>)</span></code></td></tr></span></tbody></span></table><p>[<a title="schema import" id="dt-schema-import" name="dt-schema-import">Definition</a>: A <b>schema
import</b> imports the element declarations, attribute declarations, and type definitions
from a schema into the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>.] The schema to be imported is identified by its <a title="target namespace" href="#dt-target-namespace">target namespace</a>. The schema import may bind a namespace prefix to the target namespace of the imported schema, or may declare that target namespace to be the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a>. The schema import may also provide optional hints for locating the schema.</p><p> The first <a href="#doc-xpath-URILiteral">URILiteral</a> in a schema import specifies the target namespace of the schema to be imported. The URILiterals that follow the <code>at</code> keyword are optional location hints, and can be interpreted or disregarded in an implementation-dependent way. Multiple location hints might be used to indicate more than one possible place to look for the schema or multiple physical resources to be assembled to form the schema.</p><p>A schema import that specifies a zero-length string as target namespace is considered to import a schema that has no target namespace. Such a schema import may not bind a namespace prefix [<a title="err:XQST0057" href="#ERRXQST0057">err:XQST0057</a>], but it may set the default element/type namespace to a zero-length string (representing "no namespace"), thus enabling the definitions in the imported namespace to be referenced. If the default element/type namespace is not set to "no namespace", there is no way to reference the definitions in an imported schema that has no target namespace.</p><p>It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0058" href="#ERRXQST0058">err:XQST0058</a>] if more than one schema import in the same <a title="Prolog" href="#dt-prolog">Prolog</a> specifies the same target namespace. It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0059" href="#ERRXQST0059">err:XQST0059</a>] if the implementation is not able to process a schema import by finding a valid schema with the specified target namespace. It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0035" href="#ERRXQST0035">err:XQST0035</a>] if multiple imported schemas, or multiple physical resorces within one schema, contain definitions for the same name in the same symbol space (for example, two definitions for the same element name, even if the definitions are consistent).  However, it is not an error to import the schema with target namespace <code>http://www.w3.org/2001/XMLSchema </code>(predeclared prefix <code>xs</code>), even though the built-in types defined in this schema are implicitly included in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types.</a></p><p>
It is a  <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0012" href="#ERRXQST0012">err:XQST0012</a>] if the set of
definitions contained in all schemas imported by a Prolog do not satisfy the
conditions for schema validity specified in Sections 3 and 5 of
<a href="#XMLSchema">[XML Schema]</a> Part 1--i.e., each definition must
be valid, complete, and unique.</p><p>The following example imports a schema,
specifying both its target namespace and its location, and binding the
prefix <code>soap</code> to the target namespace:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>import schema namespace soap="http://www.w3.org/2003/05/soap-envelope"
at "http://www.w3.org/2003/05/soap-envelope/";</pre></div></div><p>The
            following example imports a schema by specifying only its
            target namespace, and makes it the default element/type
            namespace:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>import schema default element namespace "http://example.org/abc";</pre></div></div><p>The following example imports a schema that has no target namespace, providing a location hint, and sets the default element/type namespace to "no namespace" so that the definitions in the imported schema can be referenced:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>import schema default element namespace "" 
at "http://example.org/xyz.xsd";</pre></div></div><p>The following example imports a schema that has no target namespace and sets the default element/type namespace to "no namespace". Since no location hint is provided, it is up to the implementation to find the schema to be imported.</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>import schema default element namespace "";</pre></div></div></div><div class="div2">
<h3><a id="id-module-imports" name="id-module-imports"></a>4.11 Module Import</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ModuleImport" name="doc-xpath-ModuleImport"></a>[24]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ModuleImport" class="xquery">ModuleImport</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"import"</span>  <span class="xquery">"module"</span>  (<span class="xquery">"namespace"</span>  <a href="#prod-xpath-NCName" class="xquery">NCName</a>  <span class="xquery">"="</span>)?  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a>  (<span class="xquery">"at"</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a>  (<span class="xquery">","</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a>)*)?</span></code></td></tr></span></tbody></span></table><p>[<a title="module import" id="dt-module-import" name="dt-module-import">Definition</a>: A <b>module import</b> imports the function
	 declarations and variable declarations from one or more
	 <a title="library module" href="#dt-library-module">library modules</a> into the <a title="function signature" href="#dt-function-signature">function signatures</a> and  <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> of the importing <a title="module" href="#dt-module">module</a>.] Each module import names a  <a title="target namespace" href="#dt-target-namespace">target namespace</a> and imports all the modules that share this target namespace. The module import may bind a namespace prefix to the target namespace, and it may provide optional hints for locating the modules to be imported.</p><p>The first <a href="#doc-xpath-URILiteral">URILiteral</a> in a module import specifies the target namespace of the modules to be imported. The URILiterals that follow the <code>at</code> keyword are optional location hints, and can be interpreted or disregarded in an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> way.</p><p>It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0047" href="#ERRXQST0047">err:XQST0047</a>] if more than one module import in a <a title="Prolog" href="#dt-prolog">Prolog</a> specifies the same target namespace. It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0059" href="#ERRXQST0059">err:XQST0059</a>] if the implementation is not able to process a module import by finding a valid module definition with the specified target namespace. It is a <a title="static error" href="#dt-static-error">static error</a> if the name and arity of a function declared in an imported module is the same as the name and arity of a function declared in the importing module or in another imported module  (even if the declarations are consistent) [<a title="err:XQST0034" href="#ERRXQST0034">err:XQST0034</a>]. It is a <a title="static error" href="#dt-static-error">static error</a> if the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of a variable declared in an imported module is the same as the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of a variable declared in the importing module or in another imported module (even if the declarations are consistent) [<a title="err:XQST0049" href="#ERRXQST0049">err:XQST0049</a>].</p><p>Each <a title="module" href="#dt-module">module</a> has its own <a title="static context" href="#dt-static-context">static context</a>. A <a title="module import" href="#dt-module-import">module import</a> imports only 
functions and variable declarations; it does not import other objects from the imported modules, such as 
<a title="in-scope schema definitions" href="#dt-issd">in-scope schema definitions</a> or <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. Module imports are not 
transitive&mdash;that is, importing a module provides access only to function and 
variable declarations contained directly in the imported module. For 
example, if module A imports module B, and module B imports module C, 
module A does not have access to the functions and variables declared in module C. </p><p>A module may import its own target namespace (this is interpreted as importing all the other modules that share the same target namespace.) However, it is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0073" href="#ERRXQST0073">err:XQST0073</a>] if the graph of module imports contains a cycle (that is, if there exists a sequence of modules M<sub>1</sub> ... M<sub>n</sub> such that each M<sub>i</sub> imports M<sub>i+1</sub> and M<sub>n</sub> imports M<sub>1</sub>), unless all the modules in the cycle share a common namespace.</p><p>It is a
	 <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0036" href="#ERRXQST0036">err:XQST0036</a>] to import a module if the importing module's 
<a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> do not include definitions for the schema type names that appear in variable declarations, function parameters, or function returns found in the 
imported module.</p><p>To illustrate the above rules, suppose that a certain schema defines a type named <code>triangle</code>. Suppose that a library module imports the schema, binds its target namespace to the prefix <code>geometry</code>, and declares a function with the following <a title="function signature" href="#dt-function-signature">function signature</a>: <code>math:area($t as geometry:triangle) as xs:double</code>. If a query wishes to use this function, it must import <em>both</em> the library module and the schema on which it is based. Importing the library module alone would not provide access to the definition of the type <code>geometry:triangle</code> used in the signature of  the <code>area</code> function.</p><p>The following example illustrates a module import:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>import module namespace math = "http://example.org/math-functions";</pre></div></div></div><div class="div2">
<h3><a id="id-namespace-decls" name="id-namespace-decls"></a>4.12 Namespace Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-NamespaceDecl" name="doc-xpath-NamespaceDecl"></a>[11]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-NamespaceDecl" class="xquery">NamespaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"namespace"</span>  <a href="#prod-xpath-NCName" class="xquery">NCName</a>  <span class="xquery">"="</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a></span></code></td></tr></span></tbody></span></table><p>[<a title="namespace declaration" id="dt-namespace-declaration" name="dt-namespace-declaration">Definition</a>: A <b>namespace declaration</b> declares a namespace prefix and
	 associates it with a namespace URI, adding the (prefix, URI) pair to the set of
	 <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>.] The namespace declaration is in scope throughout the query
	 in which it is declared, unless it is overridden by a <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attribute</a> in a <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructor</a>.</p><p>If the URILiteral part of a namespace declaration is a zero-length 
string, any existing namespace binding for the given prefix is removed 
from the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>. This feature provides a way to 
remove predeclared namespace prefixes such as <code>local</code>.</p><p>The following query illustrates a namespace declaration:</p><div class="parse-test"><div class="exampleInner"><pre>declare namespace foo = "http://example.org";
&lt;foo:bar&gt; Lentils &lt;/foo:bar&gt;</pre></div></div><p>In the query result, the newly created node is in the namespace
	 associated with the namespace URI <code>http://example.org</code>.</p><p>Multiple declarations of the same namespace prefix in a <a title="Prolog" href="#dt-prolog">Prolog</a> result in a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0033" href="#ERRXQST0033">err:XQST0033</a>].</p><p>It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XPST0008" href="#ERRXPST0008">err:XPST0008</a>] if an expression contains a QName with a namespace prefix that is not in the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>.</p><p>XQuery has several predeclared namespace prefixes that are present in the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> before each query is processed. These prefixes may be used without an explicit declaration. They may be overridden by <a title="namespace declaration" href="#dt-namespace-declaration">namespace declarations</a> in a <a title="Prolog" href="#dt-prolog">Prolog</a> or by <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attributes</a>  on constructed elements (however,  the prefix <code>xml</code> may not be redeclared, and no other prefix may be bound to the namespace URI associated with the prefix <code>xml</code> [<a title="err:XQST0070" href="#ERRXQST0070">err:XQST0070</a>]). The predeclared namespace prefixes are as follows:</p><ul><li><p><code>xml = http://www.w3.org/XML/1998/namespace</code></p></li><li><p><code>xs = http://www.w3.org/2001/XMLSchema</code></p></li><li><p><code>xsi = http://www.w3.org/2001/XMLSchema-instance</code></p></li><li><p><code>fn = http://www.w3.org/2005/xpath-functions</code></p></li><li><p><code>xdt = http://www.w3.org/2005/xpath-datatypes</code></p></li><li><p><code>local = http://www.w3.org/2005/xquery-local-functions</code> (see <a href="#FunctionDeclns"><b>4.15 Function Declaration</b></a>.)</p></li></ul><p>Additional predeclared namespace prefixes may be added to the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> by an implementation.</p><p>The namespace prefix <code>xmlns</code> also has a special significance (it identifies a <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attribute</a>), and it may not be redeclared [<a title="err:XQST0070" href="#ERRXQST0070">err:XQST0070</a>].</p><p>When element or attribute names are compared, they are considered identical if
	 the local parts and namespace URIs match on a codepoint basis. Namespace prefixes need not be identical for two names to match, as illustrated by the following example:</p><div class="parse-test"><div class="exampleInner"><pre>declare namespace xx = "http://example.org";

let $i := &lt;foo:bar xmlns:foo = "http://example.org"&gt;
              &lt;foo:bing&gt; Lentils &lt;/foo:bing&gt;
          &lt;/foo:bar&gt;
return $i/xx:bing</pre></div></div><p>Although the namespace prefixes <code>xx</code> and <code>foo</code> differ, both are bound to the namespace URI <code>"http://example.org"</code>. Since <code>xx:bing</code> and <code>foo:bing</code> have the same local name and the same namespace URI, they match. The
	 output of the above query is as follows.</p><div class="parse-test"><div class="exampleInner"><pre>&lt;foo:bing xmlns:foo = "http://example.org"&gt; Lentils &lt;/foo:bing&gt;</pre></div></div></div><div class="div2">
<h3><a id="id-default-namespace" name="id-default-namespace"></a>4.13 Default Namespace Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-DefaultNamespaceDecl" name="doc-xpath-DefaultNamespaceDecl"></a>[13]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DefaultNamespaceDecl" class="xquery">DefaultNamespaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"default"</span>  (<span class="xquery">"element"</span>  |  <span class="xquery">"function"</span>)  <span class="xquery">"namespace"</span>  <a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a></span></code></td></tr></span></tbody></span></table><p><b>Default namespace declarations</b> can be
	 used in a <a title="Prolog" href="#dt-prolog">Prolog</a> to facilitate the use of unprefixed
	 QNames. The following kinds of default namespace declarations
	 are supported:</p><ul><li><p>A <b>default element/type namespace declaration</b> declares a namespace URI that is associated with unprefixed names of elements and types. This declaration is recorded as the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> in the <a title="static context" href="#dt-static-context">static
		context</a>. A <a title="Prolog" href="#dt-prolog">Prolog</a> may contain at most one default element/type namespace declaration [<a title="err:XQST0066" href="#ERRXQST0066">err:XQST0066</a>]. If the <a href="#doc-xpath-URILiteral">URILiteral</a> in a default element/type namespace declaration is a zero-length string, the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> is undeclared (set to "none"), and unprefixed names of elements and types are considered to be in no
	 namespace. The following example illustrates the declaration
	 of a default namespace for elements and types:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare default element namespace "http://example.org/names";</pre></div></div><p>A default element/type namespace declaration may be overridden by a <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration attribute</a> in a <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructor</a>.</p></li><li><p>A <b>default function namespace declaration</b> declares a namespace URI that is associated with unprefixed function names in function calls and function declarations. This declaration is recorded as the <a title="default function namespace" href="#dt-def-fn-ns">default function namespace</a> in the <a title="static context" href="#dt-static-context">static
		context</a>. A <a title="Prolog" href="#dt-prolog">Prolog</a> may contain at most one default function namespace declaration [<a title="err:XQST0066" href="#ERRXQST0066">err:XQST0066</a>]. If the StringLiteral in a default function
namespace declaration is a zero-length string, the default function
namespace is undeclared (set to "none"). In that case, any functions that are associated
with a namespace can be called only by using an explicit namespace prefix.</p><p>If no default
	 function namespace declaration is present, the default function namespace is the namespace of XPath/XQuery functions,
	 <code>http://www.w3.org/2005/xpath-functions</code> (however, this default may be overridden by an implementation.)</p><p>The
	 following example illustrates the declaration of a default
	 function namespace:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare default function namespace 
     "http://example.org/math-functions";</pre></div></div><p>The effect of declaring
	 a default function namespace is that all functions in the
	 default function namespace, including implicitly-declared
	 <a title="constructor function" href="#dt-constructor-function">constructor functions</a>, can be invoked without
specifying a namespace prefix.  When a function call uses a
	 function name with no prefix, the local name of the function
	 must match a function (including
	 implicitly-declared <a title="constructor function" href="#dt-constructor-function">constructor functions</a>) in the default
	 function namespace [<a title="err:XPST0017" href="#ERRXPST0017">err:XPST0017</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Only <a title="constructor function" href="#dt-constructor-function">constructor functions</a> can be in no namespace.</p></div></li></ul><p> Unprefixed attribute names and variable names are in no namespace.</p></div><div class="div2">
<h3><a id="id-variable-declarations" name="id-variable-declarations"></a>4.14 Variable Declaration</h3><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-VarDecl" name="doc-xpath-VarDecl"></a>[25]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-VarDecl" class="xquery">VarDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"variable"</span>  <span class="xquery">"$"</span>  <a href="#prod-xpath-QName" class="xquery">QName</a>  <a href="#doc-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  ((<span class="xquery">":="</span>  <a href="#doc-xpath-ExprSingle" class="xquery">ExprSingle</a>)  |  <span class="xquery">"external"</span>)</span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="noid_N151D3.doc-xpath-VarName" name="noid_N151D3.doc-xpath-VarName"></a>[91]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-VarName" class="xquery">VarName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName" class="xquery">QName</a></code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="noid_N151D5.doc-xpath-TypeDeclaration" name="noid_N151D5.doc-xpath-TypeDeclaration"></a>[121]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"as"</span>  <a href="#doc-xpath-SequenceType" class="xquery">SequenceType</a></span></code></td></tr></span></tbody></span></table><p>A <b>variable
	 declaration</b> adds the <a title="static type" href="#dt-static-type">static type</a> of a variable to the
	 <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a>,  and may also add a value for
	 the variable to the  <a title="variable values" href="#dt-variable-values">variable values</a>. If the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> of the variable is the same as that of another variable in <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a>, a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0049" href="#ERRXQST0049">err:XQST0049</a>].</p><p>If a
	 variable declaration includes a type, that type is added to
	 the <a title="static context" href="#dt-static-context">static context</a> as the type of the variable. If a variable
	 declaration includes an expression but not an explicit type,
	 the type of the variable is inferred from static analysis of the expression and is added to the <a title="static context" href="#dt-static-context">static context</a>. If a variable declaration includes
	 both a type and an expression, the value returned by the expression must match the declared type according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a>; 
	 otherwise a <a title="type error" href="#dt-type-error">type error</a> is
	 raised [<a title="err:XPTY0004" href="#ERRXPTY0004">err:XPTY0004</a>].</p><p>[<a title="initializing expression" id="dt-initializing-expression" name="dt-initializing-expression">Definition</a>: If a variable declaration includes an
	 expression, the expression is called an <b>initializing expression</b>.] The initializing expression for a given variable must be evaluated
before the evaluation of any expression that references the variable. The <a title="static context" href="#dt-static-context">static
		context</a> for an initializing expression includes all functions that are declared or imported anywhere in the <a title="Prolog" href="#dt-prolog">Prolog</a>, but it includes only those variables and namespaces that are declared or imported earlier in the Prolog than the variable that is being initialized. If an initializing expression cannot be evaluated because of a circularity (for example, it depends on a function that in turn depends on the value of the variable that is being initialized), a <a title="static error" href="#dt-static-error">static error</a> is raised [<a title="err:XQST0054" href="#ERRXQST0054">err:XQST0054</a>].</p><p>If the variable declaration
	 includes the keyword <code>external</code>, a value must be
	 provided for the variable by the external environment before
	 the query can be evaluated.   If an external variable declaration also includes a declared type, the value provided by the external environment must match the declared type according to the rules for <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a> (see <a href="#id-consistency-constraints"><b>2.2.5 Consistency Constraints</b></a>). If an external variable declaration does not include a declared type, the type and a matching value must be provided by the external environment at evaluation time. The <a title="static type" href="#dt-static-type">static type</a> of such a variable is considered to be <code>item()*</code>.</p><p>All variable names declared in a <a title="library module" href="#dt-library-module">library module</a> must (when expanded) be in the <a title="target namespace" href="#dt-target-namespace">target namespace</a> of the library module [<a title="err:XQST0048" href="#ERRXQST0048">err:XQST0048</a>].  When a library module is imported, variables declared in the
imported module are added to the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> of the importing
module.</p><p>Variable names that have no namespace prefix are in no namespace. Variable declarations that have no namespace prefix may appear only in a main module.</p><p>The term <b>variable declaration</b> always refers to a declaration of a
      variable in a <a title="Prolog" href="#dt-prolog">Prolog</a>. The binding of a variable to
	 a value in a query expression, such as a FLWOR expression, is
	 known as a <b>variable binding</b>, and does not make
	 the variable visible to  an importing module.</p><p>Here are
	 some examples of variable
	 declarations:</p><ul><li><p>The following declaration
	 specifies both the type and the value of a variable. This
	 declaration causes the type <code>xs:integer</code> to be
	 associated with variable <code>$x</code>  in the <a title="static context" href="#dt-static-context">static context</a>, and the
	 value <code>7</code> to be associated with variable
	 <code>$x</code> in the <a title="dynamic context" href="#dt-dynamic-context">dynamic
	 context</a>.</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare variable $x as xs:integer := 7;</pre></div></div></li><li><p>The following declaration specifies a
	 value but not a type. The <a title="static type" href="#dt-static-type">static type</a> of the variable is
	 inferred from the static type of its value. In this case, the
	 variable <code>$x</code> has a static type of
	 <code>xs:decimal</code>, inferred from its value which is
	 7.5.</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare variable $x := 7.5;</pre></div></div></li><li><p>The
	 following declaration specifies a type but not a value. The
	 keyword <code>external</code> indicates that the value of the
	 variable will be provided by the external environment. At
	 evaluation time, if the variable <code>$x</code> in the
	 <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a>
	 does not have a value of type <code>xs:integer</code>, a type
	 error is raised.</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare variable $x as xs:integer external;</pre></div></div></li><li><p>The following declaration
	 specifies neither a type nor a value. It simply declares that
	 the query depends on the existence of a variable named
	 <code>$x</code>, whose type and value will be provided by the
	 external environment. During query analysis, the type of
	 <code>$x</code> is considered to be
	 <code>item()*</code>. During query evaluation, the
	 <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> must include a type and a value for <code>$x</code>, and its value must be compatible with its type.</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare variable $x external;</pre></div></div></li><li><p>The following declaration, which might appear in a library module, declares a variable whose name includes a namespace prefix:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare variable $math:pi as xs:double := 3.14159E0;</pre></div></div></li></ul></div><div class="div2">
<h3><a id="FunctionDeclns" name="FunctionDeclns"></a>4.15 Function Declaration</h3><p>In addition to the built-in functions described in
<a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>, XQuery allows users to declare functions
of their own. A function declaration specifies the name of the function, the
names and datatypes of the parameters, and the datatype of the result. All
datatypes are specified using the syntax described in
<a href="#id-types"><b>2.5 Types</b></a>. A function declaration causes the declared function to be added to the <a title="function signature" href="#dt-function-signature">function signatures</a> of the <a title="module" href="#dt-module">module</a> in which it appears.</p><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-FunctionDecl" name="doc-xpath-FunctionDecl"></a>[27]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-FunctionDecl" class="xquery">FunctionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"function"</span>  <a href="#prod-xpath-QName" class="xquery">QName</a>  <span class="xquery">"("</span>  <a href="#doc-xpath-ParamList" class="xquery">ParamList</a>?  <span class="xquery">")"</span>  (<span class="xquery">"as"</span>  <a href="#doc-xpath-SequenceType" class="xquery">SequenceType</a>)?  (<a href="#doc-xpath-EnclosedExpr" class="xquery">EnclosedExpr</a>  |  <span class="xquery">"external"</span>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-ParamList" name="doc-xpath-ParamList"></a>[28]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ParamList" class="xquery">ParamList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#doc-xpath-Param" class="xquery">Param</a>  (<span class="xquery">","</span>  <a href="#doc-xpath-Param" class="xquery">Param</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-Param" name="doc-xpath-Param"></a>[29]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Param" class="xquery">Param</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"$"</span>  <a href="#prod-xpath-QName" class="xquery">QName</a>  <a href="#doc-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="noid_N152E4.doc-xpath-TypeDeclaration" name="noid_N152E4.doc-xpath-TypeDeclaration"></a>[121]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"as"</span>  <a href="#doc-xpath-SequenceType" class="xquery">SequenceType</a></span></code></td></tr></span></tbody></span></table><p> A function declaration specifies whether a function is <a title="user-defined function" href="#dt-udf">user-defined</a> or <a title="external function" href="#dt-external-function">external</a>. [<a title="user-defined function" id="dt-udf" name="dt-udf">Definition</a>: For a <b>user-defined function</b>, the function declaration includes an
expression called the <b>function body</b> that defines how the result of
the function is computed from its parameters.]. The <a title="static context" href="#dt-static-context">static
		context</a> for a function body includes all functions that are declared or imported anywhere in the <a title="Prolog" href="#dt-prolog">Prolog</a>, but it includes only those variables and namespaces that are declared or imported earlier in the Prolog than the function that is being defined.</p><p> [<a title="external function" id="dt-external-function" name="dt-external-function">Definition</a>: <b>External functions</b> are functions that are implemented outside the query environment.] For example, an XQuery implementation might provide a set of external functions in addition to the core function library described in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. External functions are identified by the keyword <code>external</code>. The purpose of a function declaration for an external function is to declare the datatypes of the function parameters and result, for use in type checking of the query that contains or imports the function declaration.</p><p>An XQuery implementation may provide a facility whereby external functions can be implemented using a host programming language, but it is not required to do so. If such a facility is provided, the protocols by which parameters are passed to an external function, and the result of the function is returned to the invoking query, are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>. An XQuery implementation may augment the type system of
<a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> with additional types  that are designed to facilitate exchange of data with host programming
languages, or it may provide mechanisms for the user to define such
types. For example, a type might be provided that encapsulates an object returned by an
external function, such as an SQL database connection. These additional types, if defined, are considered to be derived
by restriction from <code>xdt:anyAtomicType</code>.</p><p>Every user-defined function must be in a namespace--that is, every declared function name must (when expanded) have a non-null namespace URI [<a title="err:XQST0060" href="#ERRXQST0060">err:XQST0060</a>]. If the function name in a function declaration has no namespace prefix, it is considered to be in the <a title="default function namespace" href="#dt-def-fn-ns">default function namespace</a>. Every function name declared in a <a title="library module" href="#dt-library-module">library module</a> must (when expanded) be in the <a title="target namespace" href="#dt-target-namespace">target namespace</a> of the library module [<a title="err:XQST0048" href="#ERRXQST0048">err:XQST0048</a>].  It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0045" href="#ERRXQST0045">err:XQST0045</a>] if the function name in a function declaration (when expanded) is in any of the following namespaces:</p><ul><li><p><code>http://www.w3.org/XML/1998/namespace</code></p></li><li><p><code>http://www.w3.org/2001/XMLSchema</code></p></li><li><p><code>http://www.w3.org/2001/XMLSchema-instance</code></p></li><li><p><code>http://www.w3.org/2005/xpath-functions</code></p></li><li><p><code>http://www.w3.org/2005/xpath-datatypes</code></p></li></ul><p>It is a <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0034" href="#ERRXQST0034">err:XQST0034</a>] if the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and arity (number of arguments) of the declared function are the same as the <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and arity of another function in <a title="function signature" href="#dt-function-signature">function signatures</a>.</p><p>In order to allow main modules to declare functions for local use within the  module without defining a new namespace, XQuery predefines the namespace prefix <code>local</code> to the namespace <code>http://www.w3.org/2005/xquery-local-functions</code>. It is suggested (but not required) that this namespace be used for defining local functions.</p><p>If a function parameter is declared using a name but no type, its default type is <code>item()*</code>. If the result type is omitted from a function declaration, its default result type is <code>item()*</code>.</p><p>The parameters of a function declaration are considered to be variables whose scope is the function body.

It is an <a title="static error" href="#dt-static-error">static error</a> [<a title="err:XQST0039" href="#ERRXQST0039">err:XQST0039</a>] for a function declaration to have more than one parameter with the same name.

The type of a function parameter can be any type that can be expressed as a <a title="sequence type" href="#dt-sequence-type">sequence type</a>.</p><p>The following example illustrates the declaration and use of a local function that
accepts a sequence of <code>employee</code> elements, summarizes them by department, and returns a sequence of <code>dept</code> elements.</p><ul><li><p>Using a function, prepare a summary of employees that are located in
Denver.</p><div class="parse-test"><div class="exampleInner"><pre>declare function local:summary($emps as element(employee)*) 
   as element(dept)*
{
   for $d in fn:distinct-values($emps/deptno)
   let $e := $emps[deptno = $d]
   return
      &lt;dept&gt;
         &lt;deptno&gt;{$d}&lt;/deptno&gt;
         &lt;headcount&gt; {fn:count($e)} &lt;/headcount&gt;
         &lt;payroll&gt; {fn:sum($e/salary)} &lt;/payroll&gt;
      &lt;/dept&gt;
};

local:summary(fn:doc("acme_corp.xml")//employee[location = "Denver"])</pre></div></div></li></ul><p>Rules for converting function arguments to their declared parameter types, and for converting the result of a function to its declared result type, are described in <a href="#id-function-calls"><b>3.1.5 Function Calls</b></a></p><p>A function declaration may be recursive&mdash;that is, it may reference itself. Mutually recursive functions, whose bodies reference each other,
are also allowed. The following example declares a recursive function that
computes the maximum depth of a node hierarchy, and calls the function to
find the maximum depth of a particular document. In its declaration, the
user-declared function <code>local:depth</code> calls the built-in functions <code>empty</code> and <code>max</code>, which are in the default function namespace.</p><ul><li><p>Find the maximum depth of the document named <code>partlist.xml</code>.</p><div class="parse-test"><div class="exampleInner"><pre>declare function local:depth($e as node()) as xs:integer
{
   (: A node with no children has depth 1 :)
   (: Otherwise, add 1 to max depth of children :)
   if (fn:empty($e/*)) then 1
   else fn:max(for $c in $e/* return local:depth($c)) + 1
};

local:depth(fn:doc("partlist.xml"))
</pre></div></div></li></ul><p>Since a
<a title="constructor function" href="#dt-constructor-function">constructor function</a> is effectively declared for every
user-defined atomic type in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a>, a <a title="static error" href="#dt-static-error">static
error</a> [<a title="err:XQST0034" href="#ERRXQST0034">err:XQST0034</a>]  is raised if the Prolog attempts to declare a single-parameter function with the same <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a>  as any of these types.</p></div><div class="div2">
<h3><a id="id-option-declaration" name="id-option-declaration"></a>4.16 Option Declaration</h3><p>[<a title="option declaration" id="dt-option-declaration" name="dt-option-declaration">Definition</a>: An <b>option declaration</b> declares an option that affects the behavior of
a particular implementation. Each option consists of an identifying QName and a StringLiteral.]</p><table summary="Scrap" class="scrap"><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="doc-xpath-OptionDecl" name="doc-xpath-OptionDecl"></a>[14]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-OptionDecl" class="xquery">OptionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"option"</span>  <a href="#prod-xpath-QName" class="xquery">QName</a>  <a href="#doc-xpath-StringLiteral" class="xquery">StringLiteral</a></span></code></td></tr></span></tbody></span></table><p>Typically, a particular option will be recognized by some implementations and
not by others. The syntax is designed so that option declarations can be
successfully parsed by all implementations.</p><p>The QName of an option must resolve to a namespace URI and local name, using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a> [<a title="err:XPST0081" href="#ERRXPST0081">err:XPST0081</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no default namespace for
options.</p></div><p>Each implementation recognizes an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> set of namespace
URIs used to denote option declarations.</p><p>If the namespace part of the QName is not a namespace recognized by the
implementation as one used to denote option declarations, then the option
declaration is ignored.</p><p>Otherwise, the effect of the option declaration, including its error behavior, is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.
For example, if the local part of the QName is
not recognized, or if the StringLiteral does not conform to the rules
defined by the implementation for the particular option declaration, the implementation may choose
whether to report an error, ignore the option declaration, or take some
other action.</p><p>Implementations may impose rules on where particular option declarations may
appear relative to variable declarations and function declarations, and the
interpretation of an option declaration may depend on its position.</p><p>An option declaration must not be used to change the syntax accepted by the
processor, or to suppress the detection of static errors. However, it may be
used without restriction to modify the semantics of the query. The scope of
the option declaration is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>&mdash;for example, an option
declaration might apply to the whole query, to the current module, or to
the immediately following function declaration.</p><p>The following examples illustrate several possible uses for option declarations:</p><ul><li><p>This option declaration might be used to set a serialization parameter:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare namespace exq = "http://example.org/XQueryImplementation";
declare option exq:output "encoding = iso-8859-1";
</pre></div></div></li><li><p>This option declaration might be used to specify how comments in source documents returned by
the <code>fn:doc()</code> function should be handled:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare option exq:strip-comments "true";
</pre></div></div></li><li><p>This option declaration might be used to associate a namespace used in function names with a
Java class:
</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare namespace math = "http://example.org/MathLibrary";
declare option exq:java-class "math = java.lang.Math";
</pre></div></div></li></ul></div></div></div></span><span class="xquery"><div class="xquery"><div class="div1">
<h2><a id="id-xquery-conformance" name="id-xquery-conformance"></a>5 Conformance</h2><p>This section defines the conformance criteria for an XQuery processor. In this section, the
        following terms are used to indicate the requirement levels defined in <a href="#RFC2119">[RFC 2119]</a>. [<a title="must" id="must" name="must">Definition</a>: 
            <b>MUST</b> means that the item is an absolute requirement of the specification.]
        [<a title="may" id="may" name="may">Definition</a>: 
            <b>MAY</b> means that an item is truly optional.]
        [<a title="should" id="should" name="should">Definition</a>: 
            <b>SHOULD</b> means that there may exist valid reasons in particular circumstances
            to ignore a particular item, but the full implications must be understood and carefully
            weighed before choosing a different course.]
    </p><p>An XQuery processor that claims to conform to this specification <a title="must" href="#must">MUST</a> include a claim of Minimal Conformance as defined in <a href="#id-minimal-conformance"><b>5.1 Minimal Conformance</b></a>. In addition to a claim of Minimal Conformance, it
            <a title="may" href="#may">MAY</a> claim conformance to one or more optional features
        defined in <a href="#id-conform-optional-features"><b>5.2 Optional Features</b></a>.</p><div class="div2">
<h3><a id="id-minimal-conformance" name="id-minimal-conformance"></a>5.1 Minimal Conformance</h3><p>Minimal Conformance to this specification <a title="must" href="#must">MUST</a> include all
            of the following items:</p><ol class="enumar"><li><p>Support for everything specified in this document except those features specified
                    in <a href="#id-conform-optional-features"><b>5.2 Optional Features</b></a> to be optional. If an
                    implementation does not provide a given optional feature, it <a title="must" href="#must">MUST</a> implement any requirements specified in <a href="#id-conform-optional-features"><b>5.2 Optional Features</b></a> for implementations that do not provide
                    that feature.</p></li><li><p>A definition of every item specified to be <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>, unless
                    that item is part of an optional feature that is not supported by the
                    implementation. A list of <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> items can be found in <a href="#id-impl-defined-items"><b>E Implementation-Defined Items</b></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations are not required to define items specified to be <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p></div></li><li><p>Support for <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>, as specified in <a href="#id-data-model-conformance"><b>5.3 Data Model Conformance</b></a>.</p></li><li><p>Support for all functions defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p></li></ol></div><div class="div2">
<h3><a id="id-conform-optional-features" name="id-conform-optional-features"></a>5.2 Optional Features</h3><div class="div3">
<h4><a id="id-schema-import-feature" name="id-schema-import-feature"></a>5.2.1 Schema Import Feature</h4><p>
                [<a title="schema import feature" id="dt-schema-import-feature" name="dt-schema-import-feature">Definition</a>: The <b>Schema
                        Import Feature</b> permits the query Prolog to contain a <a title="schema import" href="#dt-schema-import">schema import</a>.]
            </p><p>If an XQuery implementation does not support the Schema Import Feature, it <a title="must" href="#must">MUST</a> raise a static error [<a title="err:XQST0009" href="#ERRXQST0009">err:XQST0009</a>] if it encounters a schema import.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If an implementation does not support the Schema Import Feature, the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> consist only of built-in
                    and <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>
                    schema type definitions, as described in <a href="#id-xq-static-context-components"><b>C.1 Static Context Components</b></a>.</p></div></div><div class="div3">
<h4><a id="id-schema-validation-feature" name="id-schema-validation-feature"></a>5.2.2 Schema Validation Feature</h4><p>
                [<a title="schema validation feature" id="dt-schema-validation-feature" name="dt-schema-validation-feature">Definition</a>: The
                        <b>Schema Validation Feature</b> permits a query to contain a
                        <code>validate</code> expression (see <a href="#id-validate"><b>3.14 Validate Expressions</b></a>.)]
            </p><p>If an XQuery implementation does not support the Schema Validation Feature, it
                    <a title="must" href="#must">MUST</a> raise a static error [<a title="err:XQST0075" href="#ERRXQST0075">err:XQST0075</a>] if it encounters a <code>validate</code> expression.</p></div><div class="div3">
<h4><a id="id-static-typing-feature" name="id-static-typing-feature"></a>5.2.3 Static Typing Feature</h4><p>
                <span class="xquery">[<a title="static typing feature" id="dt-static-typing-feature" name="dt-static-typing-feature">Definition</a>: The <b>Static Typing Feature</b> provides support for the static
                    semantics defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, and requires
                    implementations to detect and report <a title="type error" href="#dt-type-error">type
                    errors</a> during the <a title="static analysis phase" href="#dt-static-analysis">static analysis
                        phase</a>.]</span>
            </p><p>If an implementation does not support the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a>, but can nevertheless determine during the
                static analysis phase that an expression, if evaluated, will necessarily raise a
                type error at run time, the implementation <a title="may" href="#may">MAY</a> raise
                that error during the static analysis phase. The choice of whether to raise such an
                error at analysis time is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation
                    dependent</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An implementation that does not support the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a> is not
                    required to raise type errors during the static analysis phase; however, it
                        <a title="must" href="#must">MUST</a> detect and raise non-type-related static
                    errors during the static analysis phase.</p></div><span class="xquery"><div class="xquery"><div class="div4">
<h5><a id="id-static-extensions" name="id-static-extensions"></a>5.2.3.1 Static Typing Extensions</h5><p>In some cases, the static typing rules defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a> are not very precise (see, for example, the
                    type inference rules for the ancestor axes&mdash;parent, ancestor, and
                    ancestor-or-self&mdash;and for the function <code>fn:root</code>). Some
                    implementations may wish to support more precise static typing rules.</p><p>A conforming implementation that implements the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a>
                    <a title="may" href="#may">MAY</a> also provide one or more <b>static typing
                        extensions</b>. [<a title="static typing extension" id="dt-static-typing-extension" name="dt-static-typing-extension">Definition</a>: A <b>static typing extension</b> is an
                            <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> type inference rule that infers a more
                        precise static type than that inferred by the type inference rules in
                            <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.] See <a href="http://www.w3.org/TR/xquery-semantics/#id-static-extensions">Section 
6.1.1 Static Typing Extensions</a><sup><small>FS</small></sup> for a formal definition of the constraints on
                    static typing extensions.</p></div></div></span></div><div class="div3">
<h4><a id="id-full-axis-feature" name="id-full-axis-feature"></a>5.2.4 Full Axis Feature</h4><p>
                [<a title="optional axis" id="dt-optional-axis" name="dt-optional-axis">Definition</a>: The following axes are
                    designated as <b>optional axes</b>: <code>ancestor</code>,
                        <code>ancestor-or-self</code>, <code>following</code>,
                        <code>following-sibling</code>, <code>preceding</code>, and
                        <code>preceding-sibling</code>.]
            </p><p>
                [<a title="Full Axis Feature" id="dt-full-axis-feature" name="dt-full-axis-feature">Definition</a>: A conforming XQuery
                    implementation that supports the <b>Full Axis Feature</b>
                    <a title="must" href="#must">MUST</a> support all the <a title="optional axis" href="#dt-optional-axis">optional axes</a>.]
            </p><p>Conforming XQuery implementations that do not support the Full Axis Feature <a title="may" href="#may">MAY</a> support one or more optional axes; it is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> which optional
                axes are supported by such implementations. A conforming implementation that
                encounters a reference to an optional axis that it does not support <a title="must" href="#must">MUST</a> raise a <a title="static error" href="#dt-static-error">static error</a>
                [<a title="err:XPST0010" href="#ERRXPST0010">err:XPST0010</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>XQuery does not recognize the <code>namespace</code> axis (defined by XPath 1.0
                    and deprecated by XPath 2.0).</p></div></div><div class="div3">
<h4><a id="id-module-feature" name="id-module-feature"></a>5.2.5 Module Feature</h4><p>
                [<a title="module feature" id="dt-module-feature" name="dt-module-feature">Definition</a>: A conforming XQuery
                    implementation that supports the <b>Module Feature</b> allows a query
                    Prolog to contain a <b>Module Import</b> and allows <b>library
                    modules</b> to be created.]
            </p><p>A conforming implementation that does not support the Module Feature <a title="must" href="#must">MUST</a> raise a <a title="static error" href="#dt-static-error">static error</a>
                [<a title="err:XQST0016" href="#ERRXQST0016">err:XQST0016</a>] if it encounters a <a title="module declaration" href="#dt-module-declaration">module declaration</a> or a <a title="module import" href="#dt-module-import">module import</a>. Since a <a title="module declaration" href="#dt-module-declaration">module declaration</a> is required in a
                    <a title="library module" href="#dt-library-module">library module</a>, the Module Feature is
                required in order to create a <a title="library module" href="#dt-library-module">library
                module</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the absence of the Module Feature, each query consists of a single <a title="main module" href="#dt-main-module">main module</a>.</p></div></div><div class="div3">
<h4><a id="id-serialization-feature" name="id-serialization-feature"></a>5.2.6 Serialization Feature</h4><p>
                [<a title="serialization feature" id="dt-serialization-feature" name="dt-serialization-feature">Definition</a>: A conforming
                    XQuery implementation that supports the <b>Serialization Feature</b>
                    <a title="must" href="#must">MUST</a> provide means for serializing the result of a
                    query, as specified in <a href="#id-serialization"><b>2.2.4 Serialization</b></a>.]
            </p><p>A conforming XQuery implementation that supports the Serialization Feature <a title="must" href="#must">MUST</a> conform to <a href="#id-xq-serialization-parameters"><b>C.3 Serialization Parameters</b></a>. The means by which serialization is
                invoked is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p><p>If an error is raised during the serialization process as specified in <a href="#serialization">[XSLT 2.0 and XQuery 1.0 Serialization]</a>, an conforming XQuery implementation <a title="must" href="#must">MUST</a> report the error to the calling environment.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Not all implementations need to serialize. For instance, an implementation might
                    provide results via an XML API instead of producing a textual
                representation.</p></div></div></div><div class="div2">
<h3><a id="id-data-model-conformance" name="id-data-model-conformance"></a>5.3 Data Model Conformance</h3><p>All XQuery implementations process data represented in the <a title="data model" href="#dt-datamodel">data model</a>. <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> relies on specifications that use
            the data model to specify conformance criteria for the data model in their respective
            environments, and suggests that the following issues should be considered:</p><ol class="enumar"><li><p>
                    <em>Support for normative construction from an infoset.</em> A conforming
                    implementation <a title="may" href="#may">MAY</a> choose to claim conformance to
                        <a href="http://www.w3.org/TR/xpath-datamodel/#const-infoset">Section 
3.2 Construction from an Infoset</a><sup><small>DM</small></sup>. This specification defines a
                    normative way to construct a data model instance from an XML document that is
                    merely well-formed or is governed by a DTD.</p></li><li><p>
                    <em>Support for normative construction from a PSVI.</em> A conforming
                    implementation <a title="may" href="#may">MAY</a> choose to claim conformance to
                        <a href="http://www.w3.org/TR/xpath-datamodel/#const-psvi">Section 
3.3 Construction from a PSVI</a><sup><small>DM</small></sup>. This specification defines a
                    normative way to construct a data model instance from an XML document that is
                    governed by a W3C XML Schema.</p></li><li><p>
                    <em>Support for XML 1.0 and XML 1.1.</em> The <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>
                    supports either <a href="#XML">[XML 1.0]</a> or <a href="#XML1.1">[XML 1.1]</a>. In XQuery, the
                    choice of which XML version to support is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></li></ol></div></div></div></span></div><div class="back"><div class="div1">
<h2><a id="nt-bnf" name="nt-bnf"></a>A [XPath/XQuery] Grammar</h2><div class="div2">
<h3><a id="id-grammar" name="id-grammar"></a>A.1 EBNF</h3><p>The grammar of [XPath/XQuery] uses the same simple Extended Backus-Naur Form
(EBNF) notation as <a href="#XML">[XML 1.0]</a> with the following minor differences.    </p><ul><li><p>All named symbols have a name that begins with an uppercase letter.</p></li><li><p>It adds a notation for referring to productions in external specs.</p></li><li><p>The notation "&lt; ... &gt;" is
used to indicate a grouping of terminals that together may help
help a parser differentiate various constructs.  To help readability, this "&lt;
... &gt;" notation is absent in the EBNF in the main body of this
document.  The presence of angle-bracket-groups in the EBNF has no effect on the set
    of syntactically legal queries defined by the grammar.  </p></li><li><p>Comments or extra-grammatical constraints on grammar productions are between '/*' and
'*/' symbols.</p><ul><li><p>A 'xgc:' prefix is an extra-grammatical constraint, the
details of which are explained in <a href="#extra-grammatical-constraints"><b>A.1.2 Extra-grammatical Constraints</b></a></p></li><li><p>A 'ws:' prefix explains the whitespace rules for the production, the
details of which are explained in <a href="#whitespace-rules"><b>A.2.4 Whitespace Rules</b></a></p></li><li><p>A 'gn:'
prefix means a 'Grammar Note', and is meant as a clarification for
parsing rules, and is explained in <a href="#notes-on-parsing"><b>A.1.3 Grammar Notes</b></a>.
 These notes are not normative.</p></li></ul></li></ul><p>The terminal symbols for this grammar include the quoted
  strings used in the production rules below, and the terminal
  symbols defined in section <a href="#terminal-symbols"><b>A.2.1 Terminal Symbols</b></a>.</p><p>The EBNF notation is described in more detail in <a href="#EBNFNotation"><b>A.1.1 Notation</b></a>.</p><p>To increase readability, the EBNF in the main body of this document omits
    some of these notational features. This appendix is the normative
    version of the EBNF.   </p><table summary="Scrap" class="scrap"><span class="xpath"><tbody><span class="xpath"><tr class="xpath" valign="baseline"><td><a id="prod-xpath-XPath" name="prod-xpath-XPath"></a>[1]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-XPath" class="xpath">XPath</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xpath"><a href="#prod-xpath-Expr" class="xpath">Expr</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-Module" name="prod-xpath-Module"></a>[2]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Module" class="xquery">Module</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-VersionDecl" class="xquery">VersionDecl</a>?<sup>L2</sup>  (<a href="#prod-xpath-LibraryModule" class="xquery">LibraryModule</a><sup>L2</sup>  |  <a href="#prod-xpath-MainModule" class="xquery">MainModule</a>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-VersionDecl" name="prod-xpath-VersionDecl"></a>[3]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-VersionDecl" class="xquery">VersionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"xquery"</span>  <span class="xquery">"version"</span>  <a href="#prod-xpath-StringLiteral" class="xquery">StringLiteral</a>  (<span class="xquery">"encoding"</span>  <a href="#prod-xpath-StringLiteral" class="xquery">StringLiteral</a>)?  <a href="#prod-xpath-Separator" class="xquery">Separator</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-MainModule" name="prod-xpath-MainModule"></a>[4]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-MainModule" class="xquery">MainModule</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Prolog" class="xquery">Prolog</a>  <a href="#prod-xpath-QueryBody" class="xquery">QueryBody</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-LibraryModule" name="prod-xpath-LibraryModule"></a>[5]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-LibraryModule" class="xquery">LibraryModule</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-ModuleDecl" class="xquery">ModuleDecl</a>  <a href="#prod-xpath-Prolog" class="xquery">Prolog</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ModuleDecl" name="prod-xpath-ModuleDecl"></a>[6]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ModuleDecl" class="xquery">ModuleDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"module"</span>  <span class="xquery">"namespace"</span>  <a href="#prod-xpath-NCName" class="xquery">NCName</a>  <span class="xquery">"="</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a>  <a href="#prod-xpath-Separator" class="xquery">Separator</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-Prolog" name="prod-xpath-Prolog"></a>[7]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Prolog" class="xquery">Prolog</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">((<a href="#prod-xpath-DefaultNamespaceDecl" class="xquery">DefaultNamespaceDecl</a><sup>L3</sup>  |  <a href="#prod-xpath-Setter" class="xquery">Setter</a><sup>L3</sup>  |  <a href="#prod-xpath-NamespaceDecl" class="xquery">NamespaceDecl</a><sup>L2</sup>  |  <a href="#prod-xpath-Import" class="xquery">Import</a>)  <a href="#prod-xpath-Separator" class="xquery">Separator</a>)*<sup>L2</sup>  ((<a href="#prod-xpath-VarDecl" class="xquery">VarDecl</a><sup>L2</sup>  |  <a href="#prod-xpath-FunctionDecl" class="xquery">FunctionDecl</a><sup>L2</sup>  |  <a href="#prod-xpath-OptionDecl" class="xquery">OptionDecl</a>)  <a href="#prod-xpath-Separator" class="xquery">Separator</a>)*<sup>L2</sup></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-Setter" name="prod-xpath-Setter"></a>[8]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Setter" class="xquery">Setter</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-BoundarySpaceDecl" class="xquery">BoundarySpaceDecl</a><sup>L2</sup>  |  <a href="#prod-xpath-DefaultCollationDecl" class="xquery">DefaultCollationDecl</a><sup>L3</sup>  |  <a href="#prod-xpath-BaseURIDecl" class="xquery">BaseURIDecl</a><sup>L2</sup>  |  <a href="#prod-xpath-ConstructionDecl" class="xquery">ConstructionDecl</a><sup>L2</sup>  |  <a href="#prod-xpath-OrderingModeDecl" class="xquery">OrderingModeDecl</a><sup>L2</sup>  |  <a href="#prod-xpath-EmptyOrderDecl" class="xquery">EmptyOrderDecl</a><sup>L3</sup>  |  <a href="#prod-xpath-CopyNamespacesDecl" class="xquery">CopyNamespacesDecl</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-Import" name="prod-xpath-Import"></a>[9]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Import" class="xquery">Import</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-SchemaImport" class="xquery">SchemaImport</a><sup>L2</sup>  |  <a href="#prod-xpath-ModuleImport" class="xquery">ModuleImport</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-Separator" name="prod-xpath-Separator"></a>[10]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Separator" class="xquery">Separator</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">";"</span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-NamespaceDecl" name="prod-xpath-NamespaceDecl"></a>[11]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-NamespaceDecl" class="xquery">NamespaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"namespace"</span>  <a href="#prod-xpath-NCName" class="xquery">NCName</a>  <span class="xquery">"="</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-BoundarySpaceDecl" name="prod-xpath-BoundarySpaceDecl"></a>[12]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-BoundarySpaceDecl" class="xquery">BoundarySpaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"boundary-space"</span>  (<span class="xquery">"preserve"</span>  |  <span class="xquery">"strip"</span>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DefaultNamespaceDecl" name="prod-xpath-DefaultNamespaceDecl"></a>[13]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DefaultNamespaceDecl" class="xquery">DefaultNamespaceDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"default"</span>  (<span class="xquery">"element"</span>  |  <span class="xquery">"function"</span>)  <span class="xquery">"namespace"</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-OptionDecl" name="prod-xpath-OptionDecl"></a>[14]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-OptionDecl" class="xquery">OptionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"option"</span>  <a href="#prod-xpath-QName" class="xquery">QName</a>  <a href="#prod-xpath-StringLiteral" class="xquery">StringLiteral</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-OrderingModeDecl" name="prod-xpath-OrderingModeDecl"></a>[15]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-OrderingModeDecl" class="xquery">OrderingModeDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"ordering"</span>  (<span class="xquery">"ordered"</span>  |  <span class="xquery">"unordered"</span>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-EmptyOrderDecl" name="prod-xpath-EmptyOrderDecl"></a>[16]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-EmptyOrderDecl" class="xquery">EmptyOrderDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"default"</span>  <span class="xquery">"order"</span>  <span class="xquery">"empty"</span>  (<span class="xquery">"greatest"</span>  |  <span class="xquery">"least"</span>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CopyNamespacesDecl" name="prod-xpath-CopyNamespacesDecl"></a>[17]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CopyNamespacesDecl" class="xquery">CopyNamespacesDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"copy-namespaces"</span>  <a href="#prod-xpath-PreserveMode" class="xquery">PreserveMode</a>  <span class="xquery">","</span>  <a href="#prod-xpath-InheritMode" class="xquery">InheritMode</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-PreserveMode" name="prod-xpath-PreserveMode"></a>[18]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-PreserveMode" class="xquery">PreserveMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"preserve"</span>  |  <span class="xquery">"no-preserve"</span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-InheritMode" name="prod-xpath-InheritMode"></a>[19]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-InheritMode" class="xquery">InheritMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"inherit"</span>  |  <span class="xquery">"no-inherit"</span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DefaultCollationDecl" name="prod-xpath-DefaultCollationDecl"></a>[20]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DefaultCollationDecl" class="xquery">DefaultCollationDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"default"</span>  <span class="xquery">"collation"</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-BaseURIDecl" name="prod-xpath-BaseURIDecl"></a>[21]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-BaseURIDecl" class="xquery">BaseURIDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"base-uri"</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-SchemaImport" name="prod-xpath-SchemaImport"></a>[22]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-SchemaImport" class="xquery">SchemaImport</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"import"</span>  <span class="xquery">"schema"</span>  <a href="#prod-xpath-SchemaPrefix" class="xquery">SchemaPrefix</a>?  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a>  (<span class="xquery">"at"</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a>  (<span class="xquery">","</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a>)*)?</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-SchemaPrefix" name="prod-xpath-SchemaPrefix"></a>[23]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-SchemaPrefix" class="xquery">SchemaPrefix</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery">"namespace"</span>  <a href="#prod-xpath-NCName" class="xquery">NCName</a>  <span class="xquery">"="</span>)  |  (<span class="xquery">"default"</span>  <span class="xquery">"element"</span>  <span class="xquery">"namespace"</span>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ModuleImport" name="prod-xpath-ModuleImport"></a>[24]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ModuleImport" class="xquery">ModuleImport</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"import"</span>  <span class="xquery">"module"</span>  (<span class="xquery">"namespace"</span>  <a href="#prod-xpath-NCName" class="xquery">NCName</a>  <span class="xquery">"="</span>)?  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a>  (<span class="xquery">"at"</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a>  (<span class="xquery">","</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a>)*)?</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-VarDecl" name="prod-xpath-VarDecl"></a>[25]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-VarDecl" class="xquery">VarDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"variable"</span>  <span class="xquery">"$"</span>  <a href="#prod-xpath-QName" class="xquery">QName</a>  <a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  ((<span class="xquery">":="</span>  <a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a>)  |  <span class="xquery">"external"</span>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ConstructionDecl" name="prod-xpath-ConstructionDecl"></a>[26]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ConstructionDecl" class="xquery">ConstructionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"construction"</span>  (<span class="xquery">"strip"</span>  |  <span class="xquery">"preserve"</span>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-FunctionDecl" name="prod-xpath-FunctionDecl"></a>[27]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-FunctionDecl" class="xquery">FunctionDecl</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"declare"</span>  <span class="xquery">"function"</span>  <a href="#prod-xpath-QName" class="xquery">QName</a>  <span class="xquery">"("</span>  <a href="#prod-xpath-ParamList" class="xquery">ParamList</a>?  <span class="xquery">")"</span>  (<span class="xquery">"as"</span>  <a href="#prod-xpath-SequenceType" class="xquery">SequenceType</a>)?  (<a href="#prod-xpath-EnclosedExpr" class="xquery">EnclosedExpr</a>  |  <span class="xquery">"external"</span>)</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ParamList" name="prod-xpath-ParamList"></a>[28]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ParamList" class="xquery">ParamList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Param" class="xquery">Param</a>  (<span class="xquery">","</span>  <a href="#prod-xpath-Param" class="xquery">Param</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-Param" name="prod-xpath-Param"></a>[29]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Param" class="xquery">Param</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"$"</span>  <a href="#prod-xpath-QName" class="xquery">QName</a>  <a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-EnclosedExpr" name="prod-xpath-EnclosedExpr"></a>[30]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-EnclosedExpr" class="xquery">EnclosedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-QueryBody" name="prod-xpath-QueryBody"></a>[31]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-QueryBody" class="xquery">QueryBody</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Expr" class="xquery">Expr</a></span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-Expr" name="prod-xpath-Expr"></a>[32]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Expr">Expr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xpath-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ExprSingle" name="prod-xpath-ExprSingle"></a>[33]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ExprSingle">ExprSingle</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-FLWORExpr" class="xquery">FLWORExpr</a><sup>L2</sup><br>|  <a href="#prod-xpath-ForExpr" class="xpath">ForExpr</a><sup>L2</sup><br>|  <a href="#prod-xpath-QuantifiedExpr">QuantifiedExpr</a><sup>L2</sup><br>|  <a href="#prod-xpath-TypeswitchExpr" class="xquery">TypeswitchExpr</a><sup>L2</sup><br>|  <a href="#prod-xpath-IfExpr">IfExpr</a><sup>L2</sup><br>|  <a href="#prod-xpath-OrExpr">OrExpr</a></code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-FLWORExpr" name="prod-xpath-FLWORExpr"></a>[34]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-FLWORExpr" class="xquery">FLWORExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<a href="#prod-xpath-ForClause" class="xquery">ForClause</a>  |  <a href="#prod-xpath-LetClause" class="xquery">LetClause</a>)+  <a href="#prod-xpath-WhereClause" class="xquery">WhereClause</a>?  <a href="#prod-xpath-OrderByClause" class="xquery">OrderByClause</a>?  <span class="xquery">"return"</span>  <a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a></span></code></td></tr></span></tbody></span><span class="xpath"><tbody><span class="xpath"><tr class="xpath" valign="baseline"><td><a id="prod-xpath-ForExpr" name="prod-xpath-ForExpr"></a>[35]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ForExpr" class="xpath">ForExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xpath"><a href="#prod-xpath-SimpleForClause" class="xpath">SimpleForClause</a>  <span class="xpath">"return"</span>  <a href="#prod-xpath-ExprSingle" class="xpath">ExprSingle</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ForClause" name="prod-xpath-ForClause"></a>[36]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ForClause" class="xquery">ForClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"for"</span>  <span class="xquery">"$"</span>  <a href="#prod-xpath-VarName" class="xquery">VarName</a>  <a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  <a href="#prod-xpath-PositionalVar" class="xquery">PositionalVar</a>?  <span class="xquery">"in"</span>  <a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a>  (<span class="xquery">","</span>  <span class="xquery">"$"</span>  <a href="#prod-xpath-VarName" class="xquery">VarName</a>  <a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  <a href="#prod-xpath-PositionalVar" class="xquery">PositionalVar</a>?  <span class="xquery">"in"</span>  <a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-PositionalVar" name="prod-xpath-PositionalVar"></a>[37]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-PositionalVar" class="xquery">PositionalVar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"at"</span>  <span class="xquery">"$"</span>  <a href="#prod-xpath-VarName" class="xquery">VarName</a></span></code></td></tr></span></tbody></span><span class="xpath"><tbody><span class="xpath"><tr class="xpath" valign="baseline"><td><a id="prod-xpath-SimpleForClause" name="prod-xpath-SimpleForClause"></a>[38]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-SimpleForClause" class="xpath">SimpleForClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xpath"><span class="xpath">"for"</span>  <span class="xpath">"$"</span>  <a href="#prod-xpath-VarName" class="xpath">VarName</a>  <span class="xpath">"in"</span>  <a href="#prod-xpath-ExprSingle" class="xpath">ExprSingle</a>  (<span class="xpath">","</span>  <span class="xpath">"$"</span>  <a href="#prod-xpath-VarName" class="xpath">VarName</a>  <span class="xpath">"in"</span>  <a href="#prod-xpath-ExprSingle" class="xpath">ExprSingle</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-LetClause" name="prod-xpath-LetClause"></a>[39]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-LetClause" class="xquery">LetClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"let"</span>  <span class="xquery">"$"</span>  <a href="#prod-xpath-VarName" class="xquery">VarName</a>  <a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  <span class="xquery">":="</span>  <a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a>  (<span class="xquery">","</span>  <span class="xquery">"$"</span>  <a href="#prod-xpath-VarName" class="xquery">VarName</a>  <a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  <span class="xquery">":="</span>  <a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-WhereClause" name="prod-xpath-WhereClause"></a>[40]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-WhereClause" class="xquery">WhereClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"where"</span>  <a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-OrderByClause" name="prod-xpath-OrderByClause"></a>[41]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-OrderByClause" class="xquery">OrderByClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">((<span class="xquery">"order"</span>  <span class="xquery">"by"</span>)  |  (<span class="xquery">"stable"</span>  <span class="xquery">"order"</span>  <span class="xquery">"by"</span>))  <a href="#prod-xpath-OrderSpecList" class="xquery">OrderSpecList</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-OrderSpecList" name="prod-xpath-OrderSpecList"></a>[42]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-OrderSpecList" class="xquery">OrderSpecList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-OrderSpec" class="xquery">OrderSpec</a>  (<span class="xquery">","</span>  <a href="#prod-xpath-OrderSpec" class="xquery">OrderSpec</a>)*</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-OrderSpec" name="prod-xpath-OrderSpec"></a>[43]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-OrderSpec" class="xquery">OrderSpec</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a>  <a href="#prod-xpath-OrderModifier" class="xquery">OrderModifier</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-OrderModifier" name="prod-xpath-OrderModifier"></a>[44]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-OrderModifier" class="xquery">OrderModifier</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery">"ascending"</span>  |  <span class="xquery">"descending"</span>)?  (<span class="xquery">"empty"</span>  (<span class="xquery">"greatest"</span>  |  <span class="xquery">"least"</span>))?  (<span class="xquery">"collation"</span>  <a href="#prod-xpath-URILiteral" class="xquery">URILiteral</a>)?</span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-QuantifiedExpr" name="prod-xpath-QuantifiedExpr"></a>[45]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-QuantifiedExpr">QuantifiedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("some"  |  "every")  "$"  <a href="#prod-xpath-VarName">VarName</a>  <a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  "in"  <a href="#prod-xpath-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-xpath-VarName">VarName</a>  <a href="#prod-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a>?  "in"  <a href="#prod-xpath-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#prod-xpath-ExprSingle">ExprSingle</a></code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-TypeswitchExpr" name="prod-xpath-TypeswitchExpr"></a>[46]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-TypeswitchExpr" class="xquery">TypeswitchExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"typeswitch"</span>  <span class="xquery">"("</span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery">")"</span>  <a href="#prod-xpath-CaseClause" class="xquery">CaseClause</a>+  <span class="xquery">"default"</span>  (<span class="xquery">"$"</span>  <a href="#prod-xpath-VarName" class="xquery">VarName</a>)?  <span class="xquery">"return"</span>  <a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CaseClause" name="prod-xpath-CaseClause"></a>[47]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CaseClause" class="xquery">CaseClause</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"case"</span>  (<span class="xquery">"$"</span>  <a href="#prod-xpath-VarName" class="xquery">VarName</a>  <span class="xquery">"as"</span>)?  <a href="#prod-xpath-SequenceType" class="xquery">SequenceType</a>  <span class="xquery">"return"</span>  <a href="#prod-xpath-ExprSingle" class="xquery">ExprSingle</a></span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-IfExpr" name="prod-xpath-IfExpr"></a>[48]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-IfExpr">IfExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"if"  "("  <a href="#prod-xpath-Expr">Expr</a>  ")"  "then"  <a href="#prod-xpath-ExprSingle">ExprSingle</a>  "else"  <a href="#prod-xpath-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-OrExpr" name="prod-xpath-OrExpr"></a>[49]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-OrExpr">OrExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AndExpr">AndExpr</a> ( "or"  <a href="#prod-xpath-AndExpr">AndExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AndExpr" name="prod-xpath-AndExpr"></a>[50]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AndExpr">AndExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a> ( "and"  <a href="#prod-xpath-ComparisonExpr">ComparisonExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ComparisonExpr" name="prod-xpath-ComparisonExpr"></a>[51]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ComparisonExpr">ComparisonExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-RangeExpr">RangeExpr</a> ( (<a href="#prod-xpath-ValueComp">ValueComp</a><br>|  <a href="#prod-xpath-GeneralComp">GeneralComp</a><br>|  <a href="#prod-xpath-NodeComp">NodeComp</a>)  <a href="#prod-xpath-RangeExpr">RangeExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-RangeExpr" name="prod-xpath-RangeExpr"></a>[52]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-RangeExpr">RangeExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a> ( "to"  <a href="#prod-xpath-AdditiveExpr">AdditiveExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AdditiveExpr" name="prod-xpath-AdditiveExpr"></a>[53]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AdditiveExpr">AdditiveExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+"  |  "-")  <a href="#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-MultiplicativeExpr" name="prod-xpath-MultiplicativeExpr"></a>[54]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-UnionExpr">UnionExpr</a> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <a href="#prod-xpath-UnionExpr">UnionExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-UnionExpr" name="prod-xpath-UnionExpr"></a>[55]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-UnionExpr">UnionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"  |  "|")  <a href="#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-IntersectExceptExpr" name="prod-xpath-IntersectExceptExpr"></a>[56]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a> ( ("intersect"  |  "except")  <a href="#prod-xpath-InstanceofExpr">InstanceofExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-InstanceofExpr" name="prod-xpath-InstanceofExpr"></a>[57]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-InstanceofExpr">InstanceofExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-TreatExpr">TreatExpr</a> ( "instance"  "of"  <a href="#prod-xpath-SequenceType">SequenceType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-TreatExpr" name="prod-xpath-TreatExpr"></a>[58]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-TreatExpr">TreatExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CastableExpr">CastableExpr</a> ( "treat"  "as"  <a href="#prod-xpath-SequenceType">SequenceType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-CastableExpr" name="prod-xpath-CastableExpr"></a>[59]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CastableExpr">CastableExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#prod-xpath-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-CastExpr" name="prod-xpath-CastExpr"></a>[60]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CastExpr">CastExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-UnaryExpr">UnaryExpr</a> ( "cast"  "as"  <a href="#prod-xpath-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-UnaryExpr" name="prod-xpath-UnaryExpr"></a>[61]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-UnaryExpr">UnaryExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("-"  |  "+")* <a href="#prod-xpath-ValueExpr">ValueExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ValueExpr" name="prod-xpath-ValueExpr"></a>[62]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ValueExpr">ValueExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ValidateExpr" class="xquery">ValidateExpr</a><sup>L2</sup>  |  <a href="#prod-xpath-PathExpr">PathExpr</a>  |  <a href="#prod-xpath-ExtensionExpr" class="xquery">ExtensionExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-GeneralComp" name="prod-xpath-GeneralComp"></a>[63]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-GeneralComp">GeneralComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ValueComp" name="prod-xpath-ValueComp"></a>[64]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ValueComp">ValueComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-NodeComp" name="prod-xpath-NodeComp"></a>[65]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-NodeComp">NodeComp</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ValidateExpr" name="prod-xpath-ValidateExpr"></a>[66]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ValidateExpr" class="xquery">ValidateExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"validate"</span>  <a href="#prod-xpath-ValidationMode" class="xquery">ValidationMode</a>?  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ValidationMode" name="prod-xpath-ValidationMode"></a>[67]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ValidationMode" class="xquery">ValidationMode</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"lax"</span>  |  <span class="xquery">"strict"</span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ExtensionExpr" name="prod-xpath-ExtensionExpr"></a>[68]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ExtensionExpr" class="xquery">ExtensionExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Pragma" class="xquery">Pragma</a>+  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>?  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-Pragma" name="prod-xpath-Pragma"></a>[69]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Pragma" class="xquery">Pragma</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"(#"</span></span>  <a href="#prod-xpath-S" class="xquery">S</a>?  <span class="xquery"><a href="#prod-xpath-QName" class="xquery">QName</a></span>  <a href="#prod-xpath-PragmaContents" class="xquery">PragmaContents</a>  <span class="xquery"><span class="xquery">"#)"</span></span></span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-PragmaContents" name="prod-xpath-PragmaContents"></a>[70]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-PragmaContents" class="xquery">PragmaContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery"><a href="#prod-xpath-Char" class="xquery">Char</a></span>* - (Char* '#)' Char*))</span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-PathExpr" name="prod-xpath-PathExpr"></a>[71]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-PathExpr">PathExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("/"  <a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a>?<sup>CC</sup>)<br>|  ("//"  <a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a>)<br>|  <a href="#prod-xpath-RelativePathExpr">RelativePathExpr</a></code></td><td><i>/* <a href="#parse-note-leading-lone-slash">xgs: leading-lone-slash</a> */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-RelativePathExpr" name="prod-xpath-RelativePathExpr"></a>[72]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-StepExpr">StepExpr</a>  (("/"  |  "//")  <a href="#prod-xpath-StepExpr">StepExpr</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-StepExpr" name="prod-xpath-StepExpr"></a>[73]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-StepExpr">StepExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-FilterExpr">FilterExpr</a><sup>L3</sup>  |  <a href="#prod-xpath-AxisStep">AxisStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AxisStep" name="prod-xpath-AxisStep"></a>[74]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AxisStep">AxisStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xpath-ReverseStep">ReverseStep</a><sup>L2</sup>  |  <a href="#prod-xpath-ForwardStep">ForwardStep</a>)  <a href="#prod-xpath-PredicateList">PredicateList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ForwardStep" name="prod-xpath-ForwardStep"></a>[75]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ForwardStep">ForwardStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xpath-ForwardAxis">ForwardAxis</a>  <a href="#prod-xpath-NodeTest">NodeTest</a>)<sup>L2</sup>  |  <a href="#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ForwardAxis" name="prod-xpath-ForwardAxis"></a>[76]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ForwardAxis">ForwardAxis</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("child"  "::")<br>|  ("descendant"  "::")<br>|  ("attribute"  "::")<br>|  ("self"  "::")<br>|  ("descendant-or-self"  "::")<br>|  ("following-sibling"  "::")<br>|  ("following"  "::")<br>|  (<span class="xpath">"namespace"</span>  <span class="xpath">"::"</span>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AbbrevForwardStep" name="prod-xpath-AbbrevForwardStep"></a>[77]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"@"?  <a href="#prod-xpath-NodeTest">NodeTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ReverseStep" name="prod-xpath-ReverseStep"></a>[78]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ReverseStep">ReverseStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xpath-ReverseAxis">ReverseAxis</a>  <a href="#prod-xpath-NodeTest">NodeTest</a>)  |  <a href="#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ReverseAxis" name="prod-xpath-ReverseAxis"></a>[79]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ReverseAxis">ReverseAxis</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("parent"  "::")<br>|  ("ancestor"  "::")<br>|  ("preceding-sibling"  "::")<br>|  ("preceding"  "::")<br>|  ("ancestor-or-self"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AbbrevReverseStep" name="prod-xpath-AbbrevReverseStep"></a>[80]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>".."</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-NodeTest" name="prod-xpath-NodeTest"></a>[81]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-NodeTest">NodeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-KindTest">KindTest</a><sup>L2</sup>  |  <a href="#prod-xpath-NameTest">NameTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-NameTest" name="prod-xpath-NameTest"></a>[82]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-NameTest">NameTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a>  |  <a href="#prod-xpath-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-Wildcard" name="prod-xpath-Wildcard"></a>[83]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Wildcard">Wildcard</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"*"<br>|  (<a href="#prod-xpath-NCName">NCName</a>  ":"  "*")<br>|  ("*"  ":"  <a href="#prod-xpath-NCName">NCName</a>)</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-FilterExpr" name="prod-xpath-FilterExpr"></a>[84]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-FilterExpr">FilterExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-PrimaryExpr">PrimaryExpr</a>  <a href="#prod-xpath-PredicateList">PredicateList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-PredicateList" name="prod-xpath-PredicateList"></a>[85]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-PredicateList">PredicateList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Predicate">Predicate</a>*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-Predicate" name="prod-xpath-Predicate"></a>[86]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Predicate">Predicate</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"["  <a href="#prod-xpath-Expr">Expr</a>  "]"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-PrimaryExpr" name="prod-xpath-PrimaryExpr"></a>[87]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-PrimaryExpr">PrimaryExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Literal">Literal</a>  |  <a href="#prod-xpath-VarRef">VarRef</a>  |  <a href="#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</a>  |  <a href="#prod-xpath-ContextItemExpr">ContextItemExpr</a>  |  <a href="#prod-xpath-FunctionCall">FunctionCall</a><sup>L2</sup>  |  <a href="#prod-xpath-OrderedExpr" class="xquery">OrderedExpr</a><sup>L2</sup>  |  <a href="#prod-xpath-UnorderedExpr" class="xquery">UnorderedExpr</a><sup>L2</sup>  |  <a href="#prod-xpath-Constructor" class="xquery">Constructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-Literal" name="prod-xpath-Literal"></a>[88]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Literal">Literal</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-NumericLiteral">NumericLiteral</a>  |  <a href="#prod-xpath-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-NumericLiteral" name="prod-xpath-NumericLiteral"></a>[89]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-NumericLiteral">NumericLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a>  |  <a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a>  |  <a href="#prod-xpath-DoubleLiteral">DoubleLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-VarRef" name="prod-xpath-VarRef"></a>[90]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-VarRef">VarRef</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"$"  <a href="#prod-xpath-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-VarName" name="prod-xpath-VarName"></a>[91]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-VarName">VarName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ParenthesizedExpr" name="prod-xpath-ParenthesizedExpr"></a>[92]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"("  <a href="#prod-xpath-Expr">Expr</a>?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ContextItemExpr" name="prod-xpath-ContextItemExpr"></a>[93]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ContextItemExpr">ContextItemExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"."</code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-OrderedExpr" name="prod-xpath-OrderedExpr"></a>[94]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-OrderedExpr" class="xquery">OrderedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"ordered"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-UnorderedExpr" name="prod-xpath-UnorderedExpr"></a>[95]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-UnorderedExpr" class="xquery">UnorderedExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"unordered"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-FunctionCall" name="prod-xpath-FunctionCall"></a>[96]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-FunctionCall">FunctionCall</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a>  "("  (<a href="#prod-xpath-ExprSingle">ExprSingle</a>  (","  <a href="#prod-xpath-ExprSingle">ExprSingle</a>)*)?  ")"</code></td><td><i>/* <a href="#parse-note-reserved-function-names">xgs: reserved-function-names</a> */</i></td></tr><tr valign="baseline"><td></td><td></td><td></td><td></td><td><i>/* <a href="#parse-note-parens">gn: parens</a> */</i></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-Constructor" name="prod-xpath-Constructor"></a>[97]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Constructor" class="xquery">Constructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-DirectConstructor" class="xquery">DirectConstructor</a><br>|  <a href="#prod-xpath-ComputedConstructor" class="xquery">ComputedConstructor</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DirectConstructor" name="prod-xpath-DirectConstructor"></a>[98]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DirectConstructor" class="xquery">DirectConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-DirElemConstructor" class="xquery">DirElemConstructor</a><br>|  <a href="#prod-xpath-DirCommentConstructor" class="xquery">DirCommentConstructor</a><br>|  <a href="#prod-xpath-DirPIConstructor" class="xquery">DirPIConstructor</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DirElemConstructor" name="prod-xpath-DirElemConstructor"></a>[99]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DirElemConstructor" class="xquery">DirElemConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"&lt;"</span>  <span class="xquery"><a href="#prod-xpath-QName" class="xquery">QName</a></span>  <a href="#prod-xpath-DirAttributeList" class="xquery">DirAttributeList</a>  (<span class="xquery"><span class="xquery">"/&gt;"</span></span>  |  (<span class="xquery"><span class="xquery">"&gt;"</span></span>  <a href="#prod-xpath-DirElemContent" class="xquery">DirElemContent</a>*  <span class="xquery"><span class="xquery">"&lt;/"</span></span>  <span class="xquery"><a href="#prod-xpath-QName" class="xquery">QName</a></span>  <a href="#prod-xpath-S" class="xquery">S</a>?  <span class="xquery"><span class="xquery">"&gt;"</span></span>))</span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DirAttributeList" name="prod-xpath-DirAttributeList"></a>[100]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DirAttributeList" class="xquery">DirAttributeList</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<a href="#prod-xpath-S" class="xquery">S</a>  (<span class="xquery"><a href="#prod-xpath-QName" class="xquery">QName</a></span>  <a href="#prod-xpath-S" class="xquery">S</a>?  <span class="xquery"><span class="xquery">"="</span></span>  <a href="#prod-xpath-S" class="xquery">S</a>?  <a href="#prod-xpath-DirAttributeValue" class="xquery">DirAttributeValue</a>)?)*</span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DirAttributeValue" name="prod-xpath-DirAttributeValue"></a>[101]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DirAttributeValue" class="xquery">DirAttributeValue</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery"><span class="xquery">'"'</span></span>  (<a href="#prod-xpath-EscapeQuot" class="xquery">EscapeQuot</a>  |  <a href="#prod-xpath-QuotAttrValueContent" class="xquery">QuotAttrValueContent</a>)*  <span class="xquery"><span class="xquery">'"'</span></span>)<br>|  (<span class="xquery"><span class="xquery">"'"</span></span>  (<a href="#prod-xpath-EscapeApos" class="xquery">EscapeApos</a>  |  <a href="#prod-xpath-AposAttrValueContent" class="xquery">AposAttrValueContent</a>)*  <span class="xquery"><span class="xquery">"'"</span></span>)</span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-QuotAttrValueContent" name="prod-xpath-QuotAttrValueContent"></a>[102]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-QuotAttrValueContent" class="xquery">QuotAttrValueContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-QuotAttrContentChar" class="xquery">QuotAttrContentChar</a><br>|  <a href="#prod-xpath-CommonContent" class="xquery">CommonContent</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-AposAttrValueContent" name="prod-xpath-AposAttrValueContent"></a>[103]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AposAttrValueContent" class="xquery">AposAttrValueContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-AposAttrContentChar" class="xquery">AposAttrContentChar</a><br>|  <a href="#prod-xpath-CommonContent" class="xquery">CommonContent</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DirElemContent" name="prod-xpath-DirElemContent"></a>[104]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DirElemContent" class="xquery">DirElemContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-DirectConstructor" class="xquery">DirectConstructor</a><br>|  <a href="#prod-xpath-CDataSection" class="xquery">CDataSection</a><br>|  <a href="#prod-xpath-CommonContent" class="xquery">CommonContent</a><br>|  <a href="#prod-xpath-ElementContentChar" class="xquery">ElementContentChar</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CommonContent" name="prod-xpath-CommonContent"></a>[105]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CommonContent" class="xquery">CommonContent</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-PredefinedEntityRef" class="xquery">PredefinedEntityRef</a>  |  <a href="#prod-xpath-CharRef" class="xquery">CharRef</a>  |  <span class="xquery"><span class="xquery">"{{"</span></span>  |  <span class="xquery"><span class="xquery">"}}"</span></span>  |  <a href="#prod-xpath-EnclosedExpr" class="xquery">EnclosedExpr</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DirCommentConstructor" name="prod-xpath-DirCommentConstructor"></a>[106]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DirCommentConstructor" class="xquery">DirCommentConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"&lt;!--"</span></span>  <a href="#prod-xpath-DirCommentContents" class="xquery">DirCommentContents</a>  <span class="xquery"><span class="xquery">"--&gt;"</span></span></span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DirCommentContents" name="prod-xpath-DirCommentContents"></a>[107]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DirCommentContents" class="xquery">DirCommentContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<span class="xquery">(<a href="#prod-xpath-Char" class="xquery">Char</a> - '-')</span>  |  <span class="xquery">('-'  (<a href="#prod-xpath-Char" class="xquery">Char</a> - '-'))</span>)*</span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DirPIConstructor" name="prod-xpath-DirPIConstructor"></a>[108]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DirPIConstructor" class="xquery">DirPIConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"&lt;?"</span></span>  <a href="#prod-xpath-PITarget" class="xquery">PITarget</a>  (<a href="#prod-xpath-S" class="xquery">S</a>  <a href="#prod-xpath-DirPIContents" class="xquery">DirPIContents</a>)?  <span class="xquery"><span class="xquery">"?&gt;"</span></span></span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-DirPIContents" name="prod-xpath-DirPIContents"></a>[109]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DirPIContents" class="xquery">DirPIContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<a href="#prod-xpath-Char" class="xquery">Char</a>* - (Char* '?&gt;' Char*))</span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CDataSection" name="prod-xpath-CDataSection"></a>[110]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CDataSection" class="xquery">CDataSection</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery"><span class="xquery">"&lt;![CDATA["</span></span>  <a href="#prod-xpath-CDataSectionContents" class="xquery">CDataSectionContents</a>  <span class="xquery"><span class="xquery">"]]&gt;"</span></span></span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CDataSectionContents" name="prod-xpath-CDataSectionContents"></a>[111]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CDataSectionContents" class="xquery">CDataSectionContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">(<a href="#prod-xpath-Char" class="xquery">Char</a>* - (Char* ']]&gt;' Char*))</span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ComputedConstructor" name="prod-xpath-ComputedConstructor"></a>[112]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ComputedConstructor" class="xquery">ComputedConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-CompDocConstructor" class="xquery">CompDocConstructor</a><br>|  <a href="#prod-xpath-CompElemConstructor" class="xquery">CompElemConstructor</a><br>|  <a href="#prod-xpath-CompAttrConstructor" class="xquery">CompAttrConstructor</a><br>|  <a href="#prod-xpath-CompTextConstructor" class="xquery">CompTextConstructor</a><br>|  <a href="#prod-xpath-CompCommentConstructor" class="xquery">CompCommentConstructor</a><br>|  <a href="#prod-xpath-CompPIConstructor" class="xquery">CompPIConstructor</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CompDocConstructor" name="prod-xpath-CompDocConstructor"></a>[113]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CompDocConstructor" class="xquery">CompDocConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"document"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CompElemConstructor" name="prod-xpath-CompElemConstructor"></a>[114]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CompElemConstructor" class="xquery">CompElemConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"element"</span>  (<a href="#prod-xpath-QName" class="xquery">QName</a>  |  (<span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span>))  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-ContentExpr" class="xquery">ContentExpr</a>?  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ContentExpr" name="prod-xpath-ContentExpr"></a>[115]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ContentExpr" class="xquery">ContentExpr</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Expr" class="xquery">Expr</a></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CompAttrConstructor" name="prod-xpath-CompAttrConstructor"></a>[116]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CompAttrConstructor" class="xquery">CompAttrConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"attribute"</span>  (<a href="#prod-xpath-QName" class="xquery">QName</a>  |  (<span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span>))  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>?  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CompTextConstructor" name="prod-xpath-CompTextConstructor"></a>[117]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CompTextConstructor" class="xquery">CompTextConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"text"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CompCommentConstructor" name="prod-xpath-CompCommentConstructor"></a>[118]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CompCommentConstructor" class="xquery">CompCommentConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"comment"</span>  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CompPIConstructor" name="prod-xpath-CompPIConstructor"></a>[119]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CompPIConstructor" class="xquery">CompPIConstructor</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"processing-instruction"</span>  (<a href="#prod-xpath-NCName" class="xquery">NCName</a>  |  (<span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>  <span class="xquery"><span class="xquery">"}"</span></span>))  <span class="xquery"><span class="xquery">"{"</span></span>  <a href="#prod-xpath-Expr" class="xquery">Expr</a>?  <span class="xquery"><span class="xquery">"}"</span></span></span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-SingleType" name="prod-xpath-SingleType"></a>[120]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-SingleType">SingleType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AtomicType">AtomicType</a>  "?"?</code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-TypeDeclaration" name="prod-xpath-TypeDeclaration"></a>[121]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-TypeDeclaration" class="xquery">TypeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"as"</span>  <a href="#prod-xpath-SequenceType" class="xquery">SequenceType</a></span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-SequenceType" name="prod-xpath-SequenceType"></a>[122]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-SequenceType">SequenceType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("empty-sequence"  "("  ")")<sup>L2</sup><br>|  (<a href="#prod-xpath-ItemType">ItemType</a>  <a href="#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</a>?<sup>CC</sup>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-OccurrenceIndicator" name="prod-xpath-OccurrenceIndicator"></a>[123]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"?"  |  "*"  |  "+"</code></td><td><i>/* <a href="#parse-note-occurrence-indicators">xgs: occurrence-indicators</a> */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ItemType" name="prod-xpath-ItemType"></a>[124]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ItemType">ItemType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-KindTest">KindTest</a><sup>L2</sup>  |  ("item"  "("  ")")<sup>L2</sup>  |  <a href="#prod-xpath-AtomicType">AtomicType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AtomicType" name="prod-xpath-AtomicType"></a>[125]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AtomicType">AtomicType</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-KindTest" name="prod-xpath-KindTest"></a>[126]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-KindTest">KindTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-DocumentTest">DocumentTest</a><br>|  <a href="#prod-xpath-ElementTest">ElementTest</a><br>|  <a href="#prod-xpath-AttributeTest">AttributeTest</a><br>|  <a href="#prod-xpath-SchemaElementTest">SchemaElementTest</a><br>|  <a href="#prod-xpath-SchemaAttributeTest">SchemaAttributeTest</a><br>|  <a href="#prod-xpath-PITest">PITest</a><br>|  <a href="#prod-xpath-CommentTest">CommentTest</a><br>|  <a href="#prod-xpath-TextTest">TextTest</a><br>|  <a href="#prod-xpath-AnyKindTest">AnyKindTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AnyKindTest" name="prod-xpath-AnyKindTest"></a>[127]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AnyKindTest">AnyKindTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"node"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-DocumentTest" name="prod-xpath-DocumentTest"></a>[128]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DocumentTest">DocumentTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"document-node"  "("  (<a href="#prod-xpath-ElementTest">ElementTest</a>  |  <a href="#prod-xpath-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-TextTest" name="prod-xpath-TextTest"></a>[129]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-TextTest">TextTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"text"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-CommentTest" name="prod-xpath-CommentTest"></a>[130]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CommentTest">CommentTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"comment"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-PITest" name="prod-xpath-PITest"></a>[131]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-PITest">PITest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"processing-instruction"  "("  (<a href="#prod-xpath-NCName">NCName</a>  |  <a href="#prod-xpath-StringLiteral">StringLiteral</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AttributeTest" name="prod-xpath-AttributeTest"></a>[132]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AttributeTest">AttributeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"attribute"  "("  (<a href="#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#prod-xpath-TypeName">TypeName</a>)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AttribNameOrWildcard" name="prod-xpath-AttribNameOrWildcard"></a>[133]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AttributeName">AttributeName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-SchemaAttributeTest" name="prod-xpath-SchemaAttributeTest"></a>[134]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-attribute"  "("  <a href="#prod-xpath-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AttributeDeclaration" name="prod-xpath-AttributeDeclaration"></a>[135]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AttributeDeclaration">AttributeDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-AttributeName">AttributeName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ElementTest" name="prod-xpath-ElementTest"></a>[136]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ElementTest">ElementTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"element"  "("  (<a href="#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#prod-xpath-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ElementNameOrWildcard" name="prod-xpath-ElementNameOrWildcard"></a>[137]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ElementName">ElementName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-SchemaElementTest" name="prod-xpath-SchemaElementTest"></a>[138]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-SchemaElementTest">SchemaElementTest</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"schema-element"  "("  <a href="#prod-xpath-ElementDeclaration">ElementDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ElementDeclaration" name="prod-xpath-ElementDeclaration"></a>[139]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ElementDeclaration">ElementDeclaration</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-ElementName">ElementName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-AttributeName" name="prod-xpath-AttributeName"></a>[140]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AttributeName">AttributeName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-ElementName" name="prod-xpath-ElementName"></a>[141]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ElementName">ElementName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-TypeName" name="prod-xpath-TypeName"></a>[142]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-TypeName">TypeName</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-QName">QName</a></code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-URILiteral" name="prod-xpath-URILiteral"></a>[143]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-URILiteral" class="xquery">URILiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-StringLiteral" class="xquery">StringLiteral</a></span></code></td></tr></span></tbody></span></table><div class="div3">
<h4><a id="EBNFNotation" name="EBNFNotation"></a>A.1.1 Notation</h4><p>The following definitions will be helpful in defining precisely this exposition.</p><p>[<a title="symbol" id="symbol" name="symbol">Definition</a>: Each rule in the grammar defines one symbol, in the form]</p><div class="exampleInner"><pre>symbol ::= expression</pre></div><p>[<a title="terminal" id="terminal" name="terminal">Definition</a>: A <b>terminal</b> is a symbol or string or pattern that can appear
    in the right-hand side of a rule, but never appears on the
    left hand side in the main grammar, although it may appear
    on the left-hand side of a rule in the grammar for terminals.]   The following constructs are used to match strings of one or more characters in a terminal:</p><dl><dt class="label">#xN</dt><dd><p><span>where N is a hexadecimal integer, the expression matches the character in <a href="#ISO10646">[ISO/IEC 10646]</a> whose canonical (UCS-4) code value, when interpreted as an unsigned binary number, has the value indicated. The number of leading zeros in the #xN form is insignificant; the number of leading zeros in the corresponding code value is governed by the character encoding in use and is not significant for XML.</span></p></dd><dt class="label">[a-zA-Z]</dt><dd><p>matches any
<a href="#prod-xpath-Char">Char</a>
with a value in the range(s) indicated (inclusive).</p></dd><dt class="label">[abc]</dt><dd><p>matches any
<a href="#prod-xpath-Char">Char</a>
with a value among the characters enumerated. </p></dd><dt class="label">[^a-z]</dt><dd><p>matches any
<a href="#prod-xpath-Char">Char</a>
with a value outside the range indicated.</p></dd><dt class="label">[^abc]</dt><dd><p>matches any
<a href="#prod-xpath-Char">Char</a>
with a value not among the characters given.</p></dd><dt class="label">"string"</dt><dd><p>matches the sequence of characters that appear inside the double
quotes.</p></dd><dt class="label">'string'</dt><dd><p>matches the sequence of characters that appear inside the single
quotes.</p></dd><dt class="label">	[http://www.w3.org/TR/REC-example/#NT-Example]</dt><dd><p>matches any string matched by the production defined in the external specification as per the provided reference.</p></dd></dl><p>Patterns (including the above constructs) can be combined with
grammatical operators to form more complex patterns, matching more
complex sets of character strings. In the examples that follow,
 A and B represent (sub-)patterns.</p><dl><dt class="label">(A)</dt><dd><p><code>A</code> is treated as a unit and may be combined as described in this list.</p></dd><dt class="label">&lt;A B&gt;</dt><dd><p>matches <code>A</code> followed by <code>B</code>.   Thus <code>&lt;A B&gt;</code> is equivelent to <code>A B</code>.    This notation is
used to indicate a grouping of terminals that together may help
help a parser differentiate various constructs.</p></dd><dt class="label">A?</dt><dd><p>matches <code>A</code> or nothing; optional <code>A</code>.</p></dd><dt class="label">A B</dt><dd><p>matches <code>A</code> followed by <code>B</code>.  This operator has higher precedence than alternation; thus <code>A B | C D</code> is identical to <code>(A B) | (C D)</code>.</p></dd><dt class="label">A | B</dt><dd><p>matches <code>A</code> or <code>B</code> but not both.</p></dd><dt class="label">A - B</dt><dd><p>matches any string that matches <code>A</code> but does not match <code>B</code>.</p></dd><dt class="label">A+</dt><dd><p>matches one or more occurrences of <code>A</code>.  Concatenation has higher precedence than alternation; thus <code>A+ | B+</code> is identical to <code>(A+) | (B+)</code>.</p></dd></dl><dl><dt class="label">A*</dt><dd><p>matches zero or more occurrences of <code>A</code>.   Concatenation has higher precedence than alternation; thus <code>A* | B*</code> is identical to <code>(A*) | (B*)</code></p></dd></dl></div><div class="div3">
<h4><a id="extra-grammatical-constraints" name="extra-grammatical-constraints"></a>A.1.2 Extra-grammatical Constraints</h4><p>This section contains constraints  on the EBNF productions, which are required to parse legal sentences.  The notes below are referenced from the right side of the production, with the notation: <em>/* xgc: &lt;id&gt; */</em>.</p><div class="constraint"><p class="prefix"><a id="parse-note-leading-lone-slash" name="parse-note-leading-lone-slash"></a><b>Constraint: leading-lone-slash</b></p><p>A single slash may appear either as a complete path expression
   or as the first part of a path expression in which it is
   followed by a <a href="#doc-xpath-RelativePathExpr">RelativePathExpr</a>, which can take the form
   of a <a href="#doc-xpath-NameTest">NameTest</a> ("*" or a QName).  In contexts where operators
   like "*", "union", etc., can occur, parsers may have
   difficulty distinguishing operators from NameTests.  For
   example, without lookahead the first part of the expression "/
   * 5", for example is easily taken to be a complete expression,
   "/ *", which has a very different interpretation (the child
   nodes of "/").</p><p>To reduce the need for lookahead, therefore, if the token
   immediately following a slash is "*" or a keyword, then the
   slash must be the beginning, but not the entirety, of a
   <a href="#doc-xpath-PathExpr">PathExpr</a> (and the following token must be a <a href="#doc-xpath-NameTest">NameTest</a>,
   not an operator).</p><p>A single slash may be used as the left-hand argument of an
   operator by parenthesizing it: <code>(/) * 5</code>.  The expression <code>5 *
   /</code>, on the other hand, is legal without parentheses.</p></div><div class="constraint"><p class="prefix"><a id="parse-note-xml-version" name="parse-note-xml-version"></a><b>Constraint: xml-version</b></p><p>An implementation's choice to support the <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>, or <a href="#XML1.1">[XML 1.1]</a>
        and <a href="#XMLNAMES11">[XML Names 1.1]</a> lexical specification determines the external document from which 
        to obtain the definition for this production.  The EBNF only has references to the 1.0 versions.  In some cases, the XML 1.0 and XML 1.1 definitions may be exactly the same.  Also please note that these external productions follow the whitespace rules of their respective specifications, and not the rules of this specification, in particular <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace Handling</b></a>.    Thus <code>prefix : localname</code> is not a valid QName for purposes
of this specification, just as it is not permitted in a  XML document.
Also, comments are not permissible on either side of the colon.  Also extra-grammatical constraints such as well-formedness constraints must be taken into account.</p></div><div class="constraint"><p class="prefix"><a id="parse-note-reserved-function-names" name="parse-note-reserved-function-names"></a><b>Constraint: reserved-function-names</b></p><p>Unprefixed function names spelled the same way as language
   keywords could make the language harder to recognize.  For
   instance, <code>if(foo)</code> could be taken either as a <a href="#doc-xpath-FunctionCall">FunctionCall</a> or
   as the beginning of an <a href="#doc-xpath-IfExpr">IfExpr</a>.  Therefore it is not legal
   syntax for a user to invoke functions with unprefixed names
   which match any of the names in <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p><p>A function named "if" can be called by binding its namespace
   to a prefix and using the prefixed form:  "library:if(foo)"
   instead of "if(foo)".</p></div><div class="constraint"><p class="prefix"><a id="parse-note-occurrence-indicators" name="parse-note-occurrence-indicators"></a><b>Constraint: occurrence-indicators</b></p><p>As written, the grammar in <a href="#nt-bnf"><b>A [XPath/XQuery] Grammar</b></a> is ambiguous for some forms
       using the '+' and '*' Kleene operators.  The ambiguity is
       resolved as follows:  these operators are tightly bound
       to the <a href="#doc-xpath-SequenceType">SequenceType</a> expression, and have higher precedence
       than other uses of these symbols. Any occurrence of '+'
       and '*', as well as '?', following a sequence type is
       assumed to be an occurrence indicator.  That is, a 
       "+", "*", or "?" immediately following an <a href="#doc-xpath-ItemType">ItemType</a> must
       be an <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>.  Thus, <code>4 treat as
       item() + - 5</code> must be interpreted as <code>(4 treat as item()+) - 5</code>,
       taking the '+' as an OccurrenceIndicator and the
       '-' as a subtraction operator. To force the interpretation
       of "+" as an addition operator (and the corresponding
       interpretation of the "-" as a unary minus), parentheses
       may be used:  the form <code>(4 treat as item()) + -5</code> surrounds
       the <a href="#doc-xpath-SequenceType">SequenceType</a> expression with parentheses and leads
       to the desired interpretation.</p><p>This rule has as a consequence that certain forms which
       would otherwise be legal and unambiguous are not
       recognized:  in "4 treat as item() + 5", the "+" is
       taken as an <a href="#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</a>, and not as an operator,
       which means this is not a legal expression.</p></div></div><div class="div3">
<h4><a id="notes-on-parsing" name="notes-on-parsing"></a>A.1.3 Grammar Notes</h4><p>This section contains general notes on the EBNF productions, which may be helpful in understanding how to create a parser based on this EBNF, how to read the EBNF, and generally call out issues with the syntax.  These notes are not normative.  The notes below are referenced from the right side of the production, with the notation: <em>/* gn: &lt;id&gt; */</em>.</p><div class="note"><p class="prefix"><b>Note:</b></p><dl><dt class="label"><a id="parse-note-parens" name="parse-note-parens"></a>grammar-note: parens</dt><dd><p>Look-ahead is required to distinguish <a href="#doc-xpath-FunctionCall">FunctionCall</a> from a QName or keyword followed by a <span class="xquery"><span class="xquery"><span class="xquery"><a href="#doc-xpath-Pragma">Pragma</a> or</span></span></span> <a href="#doc-xpath-Comment">Comment</a>. For example: <code>address (: this may be empty :)</code> may be mistaken for a call to a function named "address" unless this lookahead is employed.  Another example is <code>for (: whom the bell :) $tolls in 3 return $tolls</code>, where the keyword "for" must not be mistaken for a function name.</p></dd><dt class="label"><a id="parse-note-comments" name="parse-note-comments"></a>grammar-note: comments</dt><dd><p>Comments are allowed everywhere that <a title="Ignorable whitespace" href="#IgnorableWhitespace">ignorable whitespace</a> is allowed, and the <a href="#doc-xpath-Comment">Comment</a> symbol does not explicity appear on the right-hand side of the grammar (except in its own production).  See <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace Handling</b></a>.  <span class="xquery"><span class="xquery"><span class="xquery">Note that  comments are not allowed in direct constructor content, though they are allowed in  nested 	<a href="#doc-xpath-EnclosedExpr">EnclosedExprs</a>.</span></span></span></p><p>A comment can contain nested comments, as long as all "(:" and ":)" patterns are balanced, no matter where they occur within the outer comment.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Lexical analysis may typically handle nested comments by incrementing a counter for each "(:" pattern, and decrementing the counter for each ":)" pattern.  The comment does not terminate until the counter is back to zero.</p></div><p>Some illustrative examples:</p><ul><li><p><code>(: commenting out a (: comment :) may be confusing, but often helpful :)</code> is a legal Comment, since balanced nesting of comments is allowed.</p></li><li><p><code>"this is just a string :)"</code> is a legal expression.  However, <code>(: "this is just a string :)" :)</code> will cause a syntax error.  Likewise, <code>"this is another string (:"</code> is a legal expression, but <code>(: "this is another string (:" :)</code> will cause a syntax error.    It  is a limitation of nested comments that literal content can cause unbalanced nesting of comments.</p></li><li><p><code>for (: set up loop :) $i in $x return $i</code> is syntactically legal, ignoring the comment.</p></li><li><p><code>5 instance (: strange place for a comment :) of xs:integer</code> is also syntactically legal.</p></li><span class="xquery"><li class="xquery"><p><code>&lt;eg (: an example:)&gt;{$i//title}&lt;/eg&gt;</code> is not syntactically legal.</p></li></span><span class="xquery"><li class="xquery"><p><code>&lt;eg&gt; (: an example:) &lt;/eg&gt;</code> is syntactically legal, but the characters that look like a comment are in
     fact literal element content.</p></li></span></ul></dd></dl></div></div></div><div class="div2">
<h3><a id="lexical-structure" name="lexical-structure"></a>A.2 Lexical structure</h3><p>The terminal symbols assumed by the grammar above are described
  in this section.</p><p>Quoted strings appearing in production rules are terminal
  symbols.</p><p>Other terminal symbols are defined in <a href="#terminal-symbols"><b>A.2.1 Terminal Symbols</b></a>.</p><span class="xpath"><div class="xpath"><p class="xpath">A <b>host language</b> may choose whether the lexical rules of  <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a>    are followed, or alternatively, the lexical rules of <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a> are followed.</p></div></span><span class="xquery"><div class="xquery"><p class="xquery">It is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> whether the lexical rules of  <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a> are followed, or alternatively, the lexical rules of <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a> are followed.</p></div></span><span class="xquery"><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations that support the full <a href="#XML1.1">[XML 1.1]</a> character set may wish, for purposes of interoperability, to provide a mode that follows only the <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a> lexical rules.</p></div></span><p>It is up to an implementation to decide on the exact tokenization strategy, which may be different depending on the parser construction.  In the
EBNF, the notation "&lt; ... &gt;" is used to indicate a grouping of terminals that together may
help a parser differentiate various constructs.</p><p>When tokenizing, the  longest possible match that is valid in the current context is used.</p><p>All keywords are case sensitive. Keywords are not reserved&mdash;that is, any QName may duplicate a keyword except as noted in <a href="#id-reserved-fn-names"><b>A.3 Reserved Function Names</b></a>.</p><div class="div3">
<h4><a id="terminal-symbols" name="terminal-symbols"></a>A.2.1 Terminal Symbols</h4><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="prod-xpath-IntegerLiteral" name="prod-xpath-IntegerLiteral"></a>[144]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-IntegerLiteral">IntegerLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#prod-xpath-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-DecimalLiteral" name="prod-xpath-DecimalLiteral"></a>[145]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DecimalLiteral">DecimalLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("."  <a href="#prod-xpath-Digits">Digits</a>)  |  (<a href="#prod-xpath-Digits">Digits</a>  "."  [0-9]*)</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-DoubleLiteral" name="prod-xpath-DoubleLiteral"></a>[146]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-DoubleLiteral">DoubleLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(("."  <a href="#prod-xpath-Digits">Digits</a>)  |  (<a href="#prod-xpath-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#prod-xpath-Digits">Digits</a></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-StringLiteral" name="prod-xpath-StringLiteral"></a>[147]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-StringLiteral">StringLiteral</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>('"'  (<a href="#prod-xpath-PredefinedEntityRef" class="xquery">PredefinedEntityRef</a>  |  <a href="#prod-xpath-CharRef" class="xquery">CharRef</a>  |  <a href="#prod-xpath-EscapeQuot">EscapeQuot</a>  |  [^"&amp;])*  '"')  |  ("'"  (<a href="#prod-xpath-PredefinedEntityRef" class="xquery">PredefinedEntityRef</a>  |  <a href="#prod-xpath-CharRef" class="xquery">CharRef</a>  |  <a href="#prod-xpath-EscapeApos">EscapeApos</a>  |  [^'&amp;])*  "'")</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-PredefinedEntityRef" name="prod-xpath-PredefinedEntityRef"></a>[148]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-PredefinedEntityRef" class="xquery">PredefinedEntityRef</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><span class="xquery">"&amp;"</span>  (<span class="xquery">"lt"</span>  |  <span class="xquery">"gt"</span>  |  <span class="xquery">"amp"</span>  |  <span class="xquery">"quot"</span>  |  <span class="xquery">"apos"</span>)  <span class="xquery">";"</span></span></code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-EscapeQuot" name="prod-xpath-EscapeQuot"></a>[149]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-EscapeQuot">EscapeQuot</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>'""'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-EscapeApos" name="prod-xpath-EscapeApos"></a>[150]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-EscapeApos">EscapeApos</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"''"</code></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-ElementContentChar" name="prod-xpath-ElementContentChar"></a>[151]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-ElementContentChar" class="xquery">ElementContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Char" class="xquery">Char</a> - [{}&lt;&amp;]</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-QuotAttrContentChar" name="prod-xpath-QuotAttrContentChar"></a>[152]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-QuotAttrContentChar" class="xquery">QuotAttrContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Char" class="xquery">Char</a> - ["{}&lt;&amp;]</span></code></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-AposAttrContentChar" name="prod-xpath-AposAttrContentChar"></a>[153]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-AposAttrContentChar" class="xquery">AposAttrContentChar</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery"><a href="#prod-xpath-Char" class="xquery">Char</a> - ['{}&lt;&amp;]</span></code></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-Comment" name="prod-xpath-Comment"></a>[154]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Comment">Comment</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(:"  (<a href="#prod-xpath-CommentContents">CommentContents</a>  |  <a href="#prod-xpath-Comment">Comment</a>)*  ":)"</code></td><td><i>/* <a href="#ws-explicit">ws: explicit</a> */</i></td></tr><tr valign="baseline"><td></td><td></td><td></td><td></td><td><i>/* <a href="#parse-note-comments">gn: comments</a> */</i></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-PITarget" name="prod-xpath-PITarget"></a>[155]&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">PITarget</span></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a><sup><small>XML</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a> */</i></td></tr></span></tbody></span><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-CharRef" name="prod-xpath-CharRef"></a>[156]&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">CharRef</span></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-CharRef">[http://www.w3.org/TR/REC-xml#NT-CharRef]</a><sup><small>XML</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a> */</i></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-QName" name="prod-xpath-QName"></a>[157]&nbsp;&nbsp;&nbsp;</td><td><code>QName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a> */</i></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-NCName" name="prod-xpath-NCName"></a>[158]&nbsp;&nbsp;&nbsp;</td><td><code>NCName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a> */</i></td></tr></tbody><span class="xquery"><tbody><span class="xquery"><tr class="xquery" valign="baseline"><td><a id="prod-xpath-S" name="prod-xpath-S"></a>[159]&nbsp;&nbsp;&nbsp;</td><td><code><span class="xquery">S</span></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a> */</i></td></tr></span></tbody></span><tbody><tr valign="baseline"><td><a id="prod-xpath-Char" name="prod-xpath-Char"></a>[160]&nbsp;&nbsp;&nbsp;</td><td><code>Char</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td><td><i>/* <a href="#parse-note-xml-version">xgs: xml-version</a> */</i></td></tr></tbody></table><p>The following symbols are used only in the definition of
  terminal symbols; they are not terminal symbols in the
  grammar of <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="prod-xpath-Digits" name="prod-xpath-Digits"></a>[161]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-Digits">Digits</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>[0-9]+</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-xpath-CommentContents" name="prod-xpath-CommentContents"></a>[162]&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xpath-CommentContents">CommentContents</a></code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#prod-xpath-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></td></tr></tbody></table></div><div class="div3">
<h4><a id="N17673" name="N17673"></a>A.2.2 Terminal Delimitation</h4><p>[XPath/XQuery] [2.0/1.0] expressions consist of <a href="#terminal-symbols">terminal symbols</a>
  and <a title="symbol separators" href="#symbolseparators">symbol separators</a>.
</p><p>Terminal symbols are of two kinds: delimiting and
  non-delimiting.</p><p>[<a title="Delimiting Terminal" id="delimiting-token" name="delimiting-token">Definition</a>: The <b>delimiting terminal</b> symbols are: "=", ";", ",", "$", ":=", "(", ")", "!=", "&lt;=", "&gt;", "&gt;=", "&lt;&lt;", "&gt;&gt;", "::", "@", "..", "*", "[", "]", ".", "?", "+", <a href="#prod-xpath-PredefinedEntityRef">PredefinedEntityRef</a>, "{", "}", "{{", "}}", "&lt;", """, "'", "/&gt;", "&lt;/", "(#", "#)", "&lt;?", "?&gt;", "&lt;![CDATA[", "]]&gt;", "&lt;!--", "--&gt;", <a href="#prod-xpath-Comment">Comment</a>, "/", "//", <a href="#prod-xpath-CharRef">CharRef</a>, ":", <a href="#prod-xpath-S">S</a>]  </p><p>[<a title="Non-delimiting terminals" id="non-delimiting-token" name="non-delimiting-token">Definition</a>: The <b>Non-delimiting terminals</b> symbols are:  "xquery", "version", "encoding", "module", "namespace", "declare", "boundary-space", "preserve", "strip", "default", "element", "function", "option", "ordering", "ordered", "unordered", "order", "empty", "greatest", "least", "copy-namespaces", "no-preserve", "inherit", "no-inherit", "collation", "base-uri", "import", "schema", "at", "variable", "external", "construction", "as", "return", "for", "in", "let", "where", "by", "stable", "ascending", "descending", "some", "every", "satisfies", "typeswitch", "case", "if", "then", "else", "eq", "ne", "lt", "le", "gt", "ge", "is", "validate", "lax", "strict", "child", "descendant", "attribute", "self", "descendant-or-self", "following-sibling", "following", "parent", "ancestor", "preceding-sibling", "preceding", "ancestor-or-self", "document", "text", "comment", "processing-instruction", "empty-sequence", "item", "node", "document-node", "schema-attribute", "schema-element", <a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a>, <a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a>, <a href="#prod-xpath-DoubleLiteral">DoubleLiteral</a>, <a href="#prod-xpath-StringLiteral">StringLiteral</a>, <a href="#prod-xpath-EscapeQuot">EscapeQuot</a>, <a href="#prod-xpath-EscapeApos">EscapeApos</a>, <a href="#prod-xpath-ElementContentChar">ElementContentChar</a>, <a href="#prod-xpath-QuotAttrContentChar">QuotAttrContentChar</a>, <a href="#prod-xpath-AposAttrContentChar">AposAttrContentChar</a>, <a href="#prod-xpath-PITarget">PITarget</a>, <a href="#prod-xpath-QName">QName</a>, <a href="#prod-xpath-NCName">NCName</a>, <a href="#prod-xpath-Char">Char</a>, <a href="#prod-xpath-Digits">Digits</a>]  </p><p>[<a title="symbol separators" id="symbolseparators" name="symbolseparators">Definition</a>: <a title="Whitespace" href="#Whitespace">Whitespace</a> and <a href="#doc-xpath-Comment">Comments</a>  function as
  <b>symbol separators</b>.  For the most part, they are not mentioned
  in the grammar, and may occur between any two terminal symbols
  mentioned in the grammar, except where that is forbidden by
  the <a href="#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by the 	<a href="#parse-note-xml-version">/* xgs: xml-version */</a> annotation.
]</p><p>It is customary to separate consecutive terminal symbols by
  <a title="Whitespace" href="#Whitespace">whitespace</a> and <a href="#doc-xpath-Comment">Comments</a>, but this is required only when
  otherwise two non-delimiting symbols would be adjacent to each
  other.  There are two exceptions to this, that of "." and "-", which do require a <a title="symbol separators" href="#symbolseparators">symbol separator</a> if they follow a QName or NCName.</p></div><div class="div3">
<h4><a id="N17733" name="N17733"></a>A.2.3 End-of-Line Handling</h4><p>The [XPath/XQuery] processor must behave as if it normalized all line breaks on input, before parsing. The normalization should be done according to the choice to support <a href="#XML">[XML 1.0]</a>, or <a href="#XML1.1">[XML 1.1]</a> lexical processing.</p><div class="div4">
<h5><a id="N1773E" name="N1773E"></a>A.2.3.1 XML 1.0 End-of-Line Handling</h5><p>For <a href="#XML">[XML 1.0]</a> processing, all of the following must be translated to a single #xA character:</p><ol class="enumar"><li><p>the two-character sequence #xD #xA</p></li><li><p>any #xD character that is not immediately followed by #xA.</p></li></ol></div><div class="div4">
<h5><a id="N1774D" name="N1774D"></a>A.2.3.2 XML 1.1 End-of-Line Handling</h5><p>For <a href="#XML1.1">[XML 1.1]</a> processing, all of the following must be translated to a single #xA character:</p><ol class="enumar"><li><p>the two-character sequence #xD #xA</p></li><li><p>the two-character sequence #xD #x85</p></li><li><p>the single character #x85</p></li><li><p>the single character #x2028</p></li><li><p>any #xD character that is not immediately followed by #xA or #x85.</p></li></ol><span class="xquery"><div class="xquery"><p class="xquery">The characters #x85 and #x2028 cannot be reliably recognized and translated until the <a href="#doc-xpath-VersionDecl">VersionDecl</a> declaration (if present) has been read. </p></div></span></div></div><div class="div3">
<h4><a id="whitespace-rules" name="whitespace-rules"></a>A.2.4 Whitespace Rules</h4><div class="div4">
<h5><a id="DefaultWhitespaceHandling" name="DefaultWhitespaceHandling"></a>A.2.4.1 Default Whitespace Handling</h5><p>[<a title="Whitespace" id="Whitespace" name="Whitespace">Definition</a>: A <b>whitespace character</b>  is any of the characters defined by <a href="http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a>.]</p><p>  [<a title="Ignorable whitespace" id="IgnorableWhitespace" name="IgnorableWhitespace">Definition</a>: An <b>ignorable whitespace</b> character    is any <a title="Whitespace" href="#Whitespace">whitespace character</a> that may occur between <a title="terminal" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with  a <a href="#ExplicitWhitespaceHandling">ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><b>A.2.4.2 Explicit  Whitespace Handling</b></a>).]  Ignorable whitespace characters are not significant to the semantics of an expression.        Whitespace is allowed before the first terminal and after the last terminal of  a  module.  Whitespace is allowed between any two <a title="terminal" href="#terminal">terminals</a>.   <a href="#doc-xpath-Comment">Comments</a> may also act as "whitespace" to prevent two adjacent terminals from being recognized as one.  Some illustrative examples are as follows:</p><ul><li><p><code>foo- foo</code> results in a syntax error.  "foo-" would be recognized as a QName.</p></li><li><p><code>foo -foo</code> is syntactically equivalent to <code>foo - foo</code>, two QNames separated by a subtraction operator.  </p></li><li><p><code>foo(: This is a comment :)- foo</code> is syntactically equivalent to <code>foo - foo</code>.  This is because the comment prevents the two adjacent terminals from being recognized as one.</p></li><li><p><code>foo-foo</code> is syntactically equivalent to single QName.    This is because "-" is a valid character in a QName.
         When used as an operator after the characters of a name, the "-"
         must be separated from the name, e.g. by using whitespace or
         parentheses.</p></li><li><p><code>10div 3</code> results in a syntax error.</p></li><li><p><code>10 div3</code> also results in a syntax error.</p></li><li><p><code>10div3</code> also results in a syntax error.</p></li></ul></div><div class="div4">
<h5><a id="ExplicitWhitespaceHandling" name="ExplicitWhitespaceHandling"></a>A.2.4.2 Explicit  Whitespace Handling</h5><p>Explict whitespace notation is specified
	 with the EBNF productions, when it is different from the
	 default rules, as follows.  These notations are not inherited.  In other words, if an EBNF rule is marked as /* ws: explicit */, the notation does not automatically apply to all the 'child' EBNF productions of that rule.</p><dl><dt class="label"><a id="ws-explicit" name="ws-explicit"></a>ws: explicit</dt><dd><p>/* ws: explicit */ means that  the EBNF
	 notation explicitly notates,  with <code>S</code> or otherwise,  where <a title="Whitespace" href="#Whitespace">whitespace characters</a> are allowed.  In productions with the /* ws: explicit */ annotation,   <a href="#DefaultWhitespaceHandling"><b>A.2.4.1 Default Whitespace Handling</b></a> does not apply.  <a href="#doc-xpath-Comment">Comments</a> are also not allowed in these productions.</p></dd></dl><span class="xquery"><div class="xquery"><p id="ws-explicit-lex-states" class="xquery">For example, whitespace is not freely allowed by the direct constructor productions, but is specified explicitly in the grammar, in order to be more consistent with XML.  </p></div></span></div></div></div><div class="div2">
<h3><a id="id-reserved-fn-names" name="id-reserved-fn-names"></a>A.3 Reserved Function Names</h3><p>The following names are not allowed as function names in an
unprefixed form because expression syntax takes precedence.</p><ul><li><p><code>attribute</code></p></li><li><p><code>comment</code></p></li><li><p><code>document-node</code></p></li><li><p><code>element</code></p></li><li><p><code>item</code></p></li><li><p><code>if</code></p></li><li><p><code>item</code></p></li><li><p><code>node</code></p></li><li><p><code>processing-instruction</code></p></li><li><p><code>schema-attribute</code></p></li><li><p><code>schema-element</code></p></li><li><p><code>text</code></p></li><li><p><code>typeswitch</code></p><span class="xpath"><div class="note"><p class="prefix"><b>Note:</b></p><p>Although the keyword typeswitch is not used in XPath, it is considered a reserved function name for compatibility with XQuery.</p></div></span></li><li><p><code>empty-sequence</code></p></li></ul></div><div class="div2">
<h3><a id="id-precedence-order" name="id-precedence-order"></a>A.4 Precedence Order</h3><p>  The grammar defines built-in precedence among the operators of [XPath/XQuery]. These operators are summarised here in order of their precedence from lowest to highest.
   Operators that have a lower precedence number cannot be contained by operators with a higher precedence number.   The associativity column indicates the order in which operators of equal precedence in an expression are applied.</p><table border="1"><tbody><tr><th>#</th><th>Operator</th><th> 	

Associativity</th></tr><tr><td>1</td><td>, (comma)</td><td>left-to-right</td></tr><span class="xquery"><tr class="xquery"><td>2</td><td>:= (assignment)</td><td>right-to-left</td></tr></span><tr><td>3</td><td><span class="xpath"><span class="xpath"><span class="xpath"><a href="#doc-xpath-ForExpr">for</a>, </span></span></span><span class="xquery"><span class="xquery"><span class="xquery"><a href="#doc-xpath-FLWORExpr">for</a>, </span></span></span><a href="#doc-xpath-QuantifiedExpr">some, every</a>, <span class="xquery"><span class="xquery"><span class="xquery"><a href="#doc-xpath-TypeswitchExpr">typeswitch</a>, </span></span></span><a href="#doc-xpath-IfExpr">if</a></td><td>left-to-right</td></tr><tr><td>4</td><td><a href="#doc-xpath-OrExpr">or</a></td><td>left-to-right</td></tr><tr><td>5</td><td><a href="#doc-xpath-AndExpr">and</a></td><td>left-to-right</td></tr><tr><td>6</td><td><a href="#doc-xpath-ValueComp">eq, ne, lt, le, gt, ge</a>, <a href="#doc-xpath-GeneralComp">=, !=, &lt;, &lt;=, &gt;, &gt;=</a>, <a href="#doc-xpath-NodeComp">is</a>, <a href="#doc-xpath-NodeComp">&lt;&lt;, &gt;&gt;</a></td><td>left-to-right</td></tr><tr><td>7</td><td><a href="#doc-xpath-RangeExpr">to</a></td><td>left-to-right</td></tr><tr><td>8</td><td><a href="#doc-xpath-AdditiveExpr">+, -</a></td><td>left-to-right</td></tr><tr><td>9</td><td><a href="#doc-xpath-MultiplicativeExpr">*, div, idiv, mod</a></td><td>left-to-right</td></tr><tr><td>10</td><td><a href="#doc-xpath-UnionExpr">union, |</a></td><td>left-to-right</td></tr><tr><td>11</td><td><a href="#doc-xpath-IntersectExceptExpr">intersect, except</a></td><td>left-to-right</td></tr><tr><td>12</td><td><a href="#doc-xpath-InstanceofExpr">instance of</a> </td><td>left-to-right</td></tr><tr><td>13</td><td><a href="#doc-xpath-TreatExpr">treat</a></td><td>left-to-right</td></tr><tr><td>14</td><td><a href="#doc-xpath-CastableExpr">castable</a></td><td>left-to-right</td></tr><tr><td>15</td><td><a href="#doc-xpath-CastExpr">cast</a></td><td>left-to-right</td></tr><tr><td>16</td><td><a href="#doc-xpath-UnaryExpr"> -(unary),  +(unary)</a></td><td>right-to-left</td></tr><tr><td>17</td><td><a href="#doc-xpath-OccurrenceIndicator">?, *(OccurrenceIndicator), +(OccurrenceIndicator)</a></td><td>left-to-right</td></tr><tr><td>18</td><td><a href="#doc-xpath-PathExpr">/, //</a></td><td>left-to-right</td></tr><tr><td>19</td><td><a href="#doc-xpath-Predicate">[ ]</a>, <a href="#doc-xpath-ParenthesizedExpr">( )</a>, {}</td><td>left-to-right</td></tr></tbody></table></div></div><div class="div1">
<h2><a id="N179C4" name="N179C4"></a>B Type Promotion and Operator Mapping</h2><div class="div2">
<h3><a id="promotion" name="promotion"></a>B.1 Type Promotion</h3><p>[<a title="type promotion" id="dt-type-promotion" name="dt-type-promotion">Definition</a>: Under certain circumstances, an atomic value can be promoted from
one type to another. <b>Type promotion</b> is used in evaluating function calls (see <a href="#id-function-calls"><b>3.1.5 Function Calls</b></a>)<span class="xquery"><span class="xquery"><span class="xquery">, <code>order by</code> clauses (see <a href="#id-orderby-return"><b>3.9.3 Order By and Return Clauses</b></a>),</span></span></span>  and operators that accept numeric or string operands (see <a href="#mapping"><b>B.2 Operator Mapping</b></a>).] The following type promotions are permitted:</p><ol class="enumar"><li><p>Numeric type promotion:</p><ol class="enumla"><li><p>A value of type <code>xs:float</code> (or any type
derived by restriction from <code>xs:float</code>) can be promoted to
the type <code>xs:double</code>. The result is the
<code>xs:double</code> value that is the same as the original
value.</p></li><li><p>A value of type <code>xs:decimal</code> (or any type derived
by restriction from <code>xs:decimal</code>) can be promoted to either
of the types <code>xs:float</code> or <code>xs:double</code>.  The
result of this promotion is created by casting the original value to
the required type. This kind of promotion may cause loss of
precision.</p></li></ol></li><li><p>URI type promotion: A value of type <code>xs:anyURI</code> (or any type derived by restriction from <code>xs:anyURI</code>) can be promoted to the type <code>xs:string</code>. The result of this promotion is created by casting the original value to the type <code>xs:string</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Since <code>xs:anyURI</code> values can be promoted to <code>xs:string</code>, functions and operators that compare strings using the <a title="default collation" href="#dt-def-collation">default collation</a> also compare <code>xs:anyURI</code> values using the <a title="default collation" href="#dt-def-collation">default collation</a>. This ensures that orderings that include strings, <code>xs:anyURI</code> values, or any combination of the two types are consistent and well-defined.</p></div></li></ol><p>Note that <a title="type promotion" href="#dt-type-promotion">type promotion</a> is different from <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a>. For example:</p><ul><li><p>A function that expects a parameter <code>$p</code> of type <code>xs:float</code> can be invoked with a value of type <code>xs:decimal</code>. This is an example of <a title="type promotion" href="#dt-type-promotion">type promotion</a>. The value is actually converted to the expected type. Within the body of the function, <code>$p instance of xs:decimal</code> returns <code>false</code>.</p></li><li><p>A function that expects a parameter <code>$p</code> of type <code>xs:decimal</code> can be invoked with a value of type <code>xs:integer</code>. This is an example of <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a>. The value retains its original type. Within the body of the function, <code>$p instance of xs:integer</code> returns <code>true</code>.</p></li></ul></div><div class="div2">
<h3><a id="mapping" name="mapping"></a>B.2 Operator Mapping</h3><p>The operator mapping tables in this section list the
combinations of types for which the various operators of [XPath/XQuery]
are defined. [<a title="operator function" id="dt-operator-function" name="dt-operator-function">Definition</a>: For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <b>operator function</b> that implements the semantics of the operator for the given types.] The definitions of the operator functions are given in  <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. The result of an operator may be the raising of an error by its operator function, as defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>. In some cases, the operator function does not implement the full semantics of
a given operator. For the definition of each operator (including its
behavior for empty sequences or sequences of length greater than one),
see the descriptive material in the main part of this
document.</p><p>The <code>and</code> and
<code>or</code> operators are defined directly in the main body of
this document, and do not occur in the operator mapping tables. </p><p>Any operator listed in the operator mapping tables may be validly
applied to an operand of type <em>AT</em> if the table calls for
an operand of type <em>ET</em> and
<code>type-matches(</code><em>ET, AT</em><code>)</code> is
<code>true</code> (see <a href="#id-sequencetype-matching"><b>2.5.4 SequenceType Matching</b></a>). For
example, a table entry indicates that the <code>gt</code> operator may
be applied to two <code>xs:date</code> operands, returning
<code>xs:boolean</code>. Therefore, the <code>gt</code> operator may
also be applied to two (possibly different) subtypes of
<code>xs:date</code>, also returning <code>xs:boolean</code>.</p><p>[<a title="numeric" id="dt-numeric" name="dt-numeric">Definition</a>: When referring to a type, the term <b>numeric</b> denotes the types
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code>.] An operator whose
operands and result are designated as <a title="numeric" href="#dt-numeric">numeric</a> might be
thought of as representing four operators, one for each of the numeric
types. For example, the numeric <code>+</code> operator might be
thought of as representing the following four operators:</p><table width="80%" border="1" summary="Operators"><tbody><tr><td align="center">Operator</td><td align="center">First operand type</td><td align="center">Second operand type</td><td align="center">Result type</td></tr><tr><td align="center"><code>+</code></td><td align="center"><code>xs:integer</code></td><td align="center"><code>xs:integer</code></td><td align="center"><code>xs:integer</code></td></tr><tr><td align="center"><code>+</code></td><td align="center"><code>xs:decimal</code></td><td align="center"><code>xs:decimal</code></td><td align="center"><code>xs:decimal</code></td></tr><tr><td align="center"><code>+</code></td><td align="center"><code>xs:float</code></td><td align="center"><code>xs:float</code></td><td align="center"><code>xs:float</code></td></tr><tr><td align="center"><code>+</code></td><td align="center"><code>xs:double</code></td><td align="center"><code>xs:double</code></td><td align="center"><code>xs:double</code></td></tr></tbody></table><p>A numeric operator may be validly applied to an operand of type <em>AT</em> if <code>type-matches(</code><em>ET, AT</em><code>)</code> is true where <em>ET</em> is any of the four numeric types. If the result type of an operator is listed as numeric, it means "the first type in the ordered list <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which all operands can be converted by <a title="subtype substitution" href="#dt-subtype-substitution">subtype substitution</a> and <a title="type promotion" href="#dt-type-promotion">type promotion</a>." As an example, suppose that the type <code>hatsize</code> is derived from <code>xs:integer</code> and the type <code>shoesize</code> is derived from <code>xs:float</code>.   Then if the <code>+</code> operator is invoked with operands of type <code>hatsize</code> and <code>shoesize</code>, it returns a result of type <code>xs:float</code>.  Similarly, if <code>+</code> is invoked with two operands of type <code>hatsize</code> it returns a result of type <code>xs:integer</code>.</p><p>[<a title="Gregorian" id="dt-gregorian" name="dt-gregorian">Definition</a>: In the operator mapping tables,
the term <b>Gregorian</b> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.]  For binary operators that accept two
Gregorian-type operands, both operands must have the same type (for
example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p><div class="small"><table border="1" summary="Binary operators" class="small"><caption>Binary Operators</caption><tbody><tr><th>Operator</th><th>Type(A)</th><th>Type(B)</th><th>Function</th><th>Result type</th></tr><tr><td>A + B</td><td>numeric</td><td>numeric</td><td>op:numeric-add(A, B)</td><td>numeric</td></tr><tr><td>A + B</td><td>xs:date</td><td>xdt:yearMonthDuration</td><td>op:add-yearMonthDuration-to-date(A, B)</td><td>xs:date</td></tr><tr><td>A + B</td><td>xdt:yearMonthDuration</td><td>xs:date</td><td>op:add-yearMonthDuration-to-date(B, A)</td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:date</td><td>xdt:dayTimeDuration</td><td>op:add-dayTimeDuration-to-date(A, B)</td><td>xs:date</td></tr><tr><td>A + B</td><td>xdt:dayTimeDuration</td><td>xs:date</td><td>op:add-dayTimeDuration-to-date(B, A)</td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:time</td><td>xdt:dayTimeDuration</td><td>op:add-dayTimeDuration-to-time(A, B)</td><td>xs:time</td></tr><tr><td>A + B</td><td>xdt:dayTimeDuration</td><td>xs:time</td><td>op:add-dayTimeDuration-to-time(B, A)</td><td>xs:time</td></tr><tr><td>A + B</td><td>xs:dateTime</td><td>xdt:yearMonthDuration</td><td>op:add-yearMonthDuration-to-dateTime(A, B)</td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xdt:yearMonthDuration</td><td>xs:dateTime</td><td>op:add-yearMonthDuration-to-dateTime(B, A)</td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:dateTime</td><td>xdt:dayTimeDuration</td><td>op:add-dayTimeDuration-to-dateTime(A, B)</td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xdt:dayTimeDuration</td><td>xs:dateTime</td><td>op:add-dayTimeDuration-to-dateTime(B, A)</td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xdt:yearMonthDuration</td><td>xdt:yearMonthDuration</td><td>op:add-yearMonthDurations(A, B)</td><td>xdt:yearMonthDuration</td></tr><tr><td>A + B</td><td>xdt:dayTimeDuration</td><td>xdt:dayTimeDuration</td><td>op:add-dayTimeDurations(A, B)</td><td>xdt:dayTimeDuration</td></tr><tr><td>A - B</td><td>numeric</td><td>numeric</td><td>op:numeric-subtract(A, B)</td><td>numeric</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:date</td><td>op:subtract-dates(A, B)</td><td>xdt:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:date</td><td>xdt:yearMonthDuration</td><td>op:subtract-yearMonthDuration-from-date(A, B)</td><td>xs:date</td></tr><tr><td>A - B</td><td>xs:date</td><td>xdt:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-date(A, B)</td><td>xs:date</td></tr><tr><td>A - B</td><td>xs:time</td><td>xs:time</td><td>op:subtract-times(A, B)</td><td>xdt:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:time</td><td>xdt:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-time(A, B)</td><td>xs:time</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:subtract-dateTimes(A, B)</td><td>xdt:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xdt:yearMonthDuration</td><td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td><td>xs:dateTime</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xdt:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td><td>xs:dateTime</td></tr><tr><td>A - B</td><td>xdt:yearMonthDuration</td><td>xdt:yearMonthDuration</td><td>op:subtract-yearMonthDurations(A, B)</td><td>xdt:yearMonthDuration</td></tr><tr><td>A - B</td><td>xdt:dayTimeDuration</td><td>xdt:dayTimeDuration</td><td>op:subtract-dayTimeDurations(A, B)</td><td>xdt:dayTimeDuration</td></tr><tr><td>A * B</td><td>numeric</td><td>numeric</td><td>op:numeric-multiply(A, B)</td><td>numeric</td></tr><tr><td>A * B</td><td>xdt:yearMonthDuration</td><td>numeric</td><td>op:multiply-yearMonthDuration(A, B)</td><td>xdt:yearMonthDuration</td></tr><tr><td>A * B</td><td>numeric</td><td>xdt:yearMonthDuration</td><td>op:multiply-yearMonthDuration(B, A)</td><td>xdt:yearMonthDuration</td></tr><tr><td>A * B</td><td>xdt:dayTimeDuration</td><td>numeric</td><td>op:multiply-dayTimeDuration(A, B)</td><td>xdt:dayTimeDuration</td></tr><tr><td>A * B</td><td>numeric</td><td>xdt:dayTimeDuration</td><td>op:multiply-dayTimeDuration(B, A)</td><td>xdt:dayTimeDuration</td></tr><tr><td>A idiv B</td><td>numeric</td><td>numeric</td><td>op:numeric-integer-divide(A, B)</td><td>xs:integer</td></tr><tr><td>A div B</td><td>numeric</td><td>numeric</td><td>op:numeric-divide(A, B)</td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr><tr><td>A div B</td><td>xdt:yearMonthDuration</td><td>numeric</td><td>op:divide-yearMonthDuration(A, B)</td><td>xdt:yearMonthDuration</td></tr><tr><td>A div B</td><td>xdt:dayTimeDuration</td><td>numeric</td><td>op:divide-dayTimeDuration(A, B)</td><td>xdt:dayTimeDuration</td></tr><tr><td>A div B</td><td>xdt:yearMonthDuration</td><td>xdt:yearMonthDuration</td><td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td>xs:decimal</td></tr><tr><td>A div B</td><td>xdt:dayTimeDuration</td><td>xdt:dayTimeDuration</td><td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td>xs:decimal</td></tr><tr><td>A mod B</td><td>numeric</td><td>numeric</td><td>op:numeric-mod(A, B)</td><td>numeric</td></tr><tr><td>A eq B</td><td>numeric</td><td>numeric</td><td>op:numeric-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:boolean</td><td>xs:boolean</td><td>op:boolean-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-equal(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:date</td><td>xs:date</td><td>op:date-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:time</td><td>xs:time</td><td>op:time-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:datetime-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xdt:yearMonthDuration</td><td>xdt:yearMonthDuration</td><td>op:yearMonthDuration-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xdt:dayTimeDuration</td><td>xdt:dayTimeDuration</td><td>op:dayTimeDuration-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:duration</td><td>xs:duration</td><td>op:duration-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>Gregorian</td><td>Gregorian</td><td>op:gYear-equal(A, B) etc.</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:hexBinary</td><td>xs:hexBinary</td><td>op:hex-binary-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:base64Binary</td><td>xs:base64Binary</td><td>op:base64-binary-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:anyURI</td><td>xs:anyURI</td><td>op:numeric-equal(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:QName</td><td>xs:QName</td><td>op:QName-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A eq B</td><td>xs:NOTATION</td><td>xs:NOTATION</td><td>op:NOTATION-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>numeric</td><td>numeric</td><td>fn:not(op:numeric-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:boolean</td><td>xs:boolean</td><td>fn:not(op:boolean-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:string</td><td>xs:string</td><td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:date</td><td>xs:date</td><td>fn:not(op:date-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:time</td><td>xs:time</td><td>fn:not(op:time-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>fn:not(op:datetime-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xdt:yearMonthDuration</td><td>xdt:yearMonthDuration</td><td>fn:not(op:yearMonthDuration-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xdt:dayTimeDuration</td><td>xdt:dayTimeDuration</td><td>fn:not(op:dayTimeDuration-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:duration</td><td>xs:duration</td><td>fn:not(op:duration-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>Gregorian</td><td>Gregorian</td><td>fn:not(op:gYear-equal(A, B)) etc.</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:hexBinary</td><td>xs:hexBinary</td><td>fn:not(op:hex-binary-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:base64Binary</td><td>xs:base64Binary</td><td>fn:not(op:base64-binary-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:anyURI</td><td>xs:anyURI</td><td>fn:not(op:numeric-equal(fn:compare(A, B), 0))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:QName</td><td>xs:QName</td><td>fn:not(op:QName-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A ne B</td><td>xs:NOTATION</td><td>xs:NOTATION</td><td>fn:not(op:NOTATION-equal(A, B))</td><td>xs:boolean</td></tr><tr><td>A gt B</td><td>numeric</td><td>numeric</td><td>op:numeric-greater-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A gt B</td><td>xs:boolean</td><td>xs:boolean</td><td>op:boolean-greater-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A gt B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-greater-than(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr><tr><td>A gt B</td><td>xs:date</td><td>xs:date</td><td>op:date-greater-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A gt B</td><td>xs:time</td><td>xs:time</td><td>op:time-greater-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A gt B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:datetime-greater-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A gt B</td><td>xdt:yearMonthDuration</td><td>xdt:yearMonthDuration</td><td>op:yearMonthDuration-greater-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A gt B</td><td>xdt:dayTimeDuration</td><td>xdt:dayTimeDuration</td><td>op:dayTimeDuration-greater-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>numeric</td><td>numeric</td><td>op:numeric-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:boolean</td><td>xs:boolean</td><td>op:boolean-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-less-than(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:date</td><td>xs:date</td><td>op:date-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:time</td><td>xs:time</td><td>op:time-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:datetime-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xdt:yearMonthDuration</td><td>xdt:yearMonthDuration</td><td>op:yearMonthDuration-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A lt B</td><td>xdt:dayTimeDuration</td><td>xdt:dayTimeDuration</td><td>op:dayTimeDuration-less-than(A, B)</td><td>xs:boolean</td></tr><tr><td>A ge B</td><td>numeric</td><td>numeric</td><td>op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A ge B</td><td>xs:boolean</td><td>xs:boolean</td><td>fn:not(op:boolean-less-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A ge B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-greater-than(fn:compare(A, B), -1)</td><td>xs:boolean</td></tr><tr><td>A ge B</td><td>xs:date</td><td>xs:date</td><td>fn:not(op:date-less-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A ge B</td><td>xs:time</td><td>xs:time</td><td>fn:not(op:time-less-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A ge B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>fn:not(op:datetime-less-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A ge B</td><td>xdt:yearMonthDuration</td><td>xdt:yearMonthDuration</td><td>fn:not(op:yearMonthDuration-less-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A ge B</td><td>xdt:dayTimeDuration</td><td>xdt:dayTimeDuration</td><td>fn:not(op:dayTimeDuration-less-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A le B</td><td>numeric</td><td>numeric</td><td>op:numeric-less-than(A, B) or op:numeric-equal(A, B)</td><td>xs:boolean</td></tr><tr><td>A le B</td><td>xs:boolean</td><td>xs:boolean</td><td>fn:not(op:boolean-greater-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A le B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-less-than(fn:compare(A, B), 1)</td><td>xs:boolean</td></tr><tr><td>A le B</td><td>xs:date</td><td>xs:date</td><td>fn:not(op:date-greater-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A le B</td><td>xs:time</td><td>xs:time</td><td>fn:not(op:time-greater-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A le B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>fn:not(op:datetime-greater-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A le B</td><td>xdt:yearMonthDuration</td><td>xdt:yearMonthDuration</td><td>fn:not(op:yearMonthDuration-greater-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A le B</td><td>xdt:dayTimeDuration</td><td>xdt:dayTimeDuration</td><td>fn:not(op:dayTimeDuration-greater-than(A, B))</td><td>xs:boolean</td></tr><tr><td>A is B</td><td>node()</td><td>node()</td><td>op:is-same-node(A, B)</td><td>xs:boolean</td></tr><tr><td>A &lt;&lt; B</td><td>node()</td><td>node()</td><td>op:node-before(A, B)</td><td>xs:boolean</td></tr><tr><td>A &gt;&gt; B</td><td>node()</td><td>node()</td><td>op:node-after(A, B)</td><td>xs:boolean</td></tr><tr><td>A union B</td><td>node()*</td><td>node()*</td><td>op:union(A, B)</td><td>node()*</td></tr><tr><td>A | B</td><td>node()*</td><td>node()*</td><td>op:union(A, B)</td><td>node()*</td></tr><tr><td>A intersect B</td><td>node()*</td><td>node()*</td><td>op:intersect(A, B)</td><td>node()*</td></tr><tr><td>A except B</td><td>node()*</td><td>node()*</td><td>op:except(A, B)</td><td>node()*</td></tr><tr><td>A to B</td><td>xs:integer</td><td>xs:integer</td><td>op:to(A, B)</td><td>xs:integer*</td></tr><tr><td>A , B</td><td>item()*</td><td>item()*</td><td>op:concatenate(A, B)</td><td>item()*</td></tr></tbody></table></div><div class="small"><table border="1" summary="Unary operators" class="small"><caption>Unary Operators</caption><tbody><tr><th>Operator</th><th>Operand type</th><th>Function</th><th>Result type</th></tr><tr><td>+ A</td><td>numeric</td><td>op:numeric-unary-plus(A)</td><td>numeric</td></tr><tr><td>- A</td><td>numeric</td><td>op:numeric-unary-minus(A)</td><td>numeric</td></tr></tbody></table></div></div></div><span class="xquery"><div class="xquery"><div class="div1">
<h2><a id="id-xq-context-components" name="id-xq-context-components"></a>C Context Components</h2><p>The tables in this section describe how values are assigned to the various components of the static context and dynamic context, and to the parameters that control the serialization process.</p><div class="div2">
<h3><a id="id-xq-static-context-components" name="id-xq-static-context-components"></a>C.1 Static Context Components</h3><p>The following table describes the components of the <b>static context</b>. The following aspects of each component are described:</p><ul><li><p><em>Default initial value:</em> This is the initial value of the component if it is not overridden or augmented by the implementation or by a query.</p></li><li><p><em>Can be overwritten or augmented by implementation:</em> Indicates whether an XQuery implementation is allowed to replace the default initial value of the component by a different, <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> value and/or to augment the default initial value by additional <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> values.</p></li><li><p><em>Can be overwritten or augmented by a query:</em> Indicates whether a query is allowed to replace and/or augment the initial value provided by default or by the implementation. If so, indicates how this is accomplished (for example, by a declaration in the prolog).</p></li><li><p><em>Scope:</em> Indicates where the component is applicable. "Global" indicates that the component applies globally, throughout all the modules used in a query. "Module" indicates that the component applies throughout a <a title="module" href="#dt-module">module</a>. "Lexical" indicates that the component applies within the expression in which it is defined (equivalent to "module" if the component is declared in a <a title="Prolog" href="#dt-prolog">Prolog</a>.)</p></li><li><p><em>Consistency Rules:</em> Indicates rules that must be observed in assigning values to the component. Additional consistency rules may be found in <a href="#id-consistency-constraints"><b>2.2.5 Consistency Constraints</b></a>.</p></li></ul><div class="small"><table width="100%" border="1" summary="Static Context" class="small"><caption>Static Context Components</caption><tbody><tr><th>Component</th><th>Default initial value</th><th>Can be overwritten or augmented by implementation?</th><th>Can be overwritten or augmented by a query?</th><th>Scope</th><th>Consistency rules</th></tr><tr><td>XPath 1.0 Compatibility Mode</td><td><code>false</code></td><td>no</td><td>no</td><td>global</td><td>Must be <code>false</code>.</td></tr><tr><td>Statically known namespaces</td><td><code>fn</code>, <code>xml</code>, <code>xs</code>, <code>xsi</code>, <code>xdt</code>, <code>local</code></td><td>overwriteable and augmentable (except for <code>xml</code>)</td><td>overwriteable and augmentable by prolog or element constructor</td><td>lexical</td><td>Only one namespace can be assigned to a given prefix
per lexical scope.</td></tr><tr><td>Default element/type namespace</td><td>no namespace</td><td>overwriteable</td><td>overwriteable by prolog or element constructor</td><td>lexical</td><td>Only one default namespace per lexical scope.</td></tr><tr><td>Default function namespace</td><td><code>fn</code></td><td>overwriteable (not recommended)</td><td>overwriteable by prolog</td><td>module</td><td>None.</td></tr><tr><td>In-scope schema types</td><td>built-in types in <code>xs</code>, <code>xdt</code></td><td>augmentable</td><td>augmentable by schema import in prolog</td><td>module</td><td>Only one definition per global or local type.</td></tr><tr><td>In-scope element declarations</td><td>none</td><td>augmentable</td><td>augmentable by schema import in prolog</td><td>module</td><td>Only one definition per global or local element name.</td></tr><tr><td>In-scope attribute declarations</td><td>none</td><td>augmentable</td><td>augmentable by schema import in prolog</td><td>module</td><td>Only one definition per global or local attribute name.</td></tr><tr><td>In-scope variables</td><td>none</td><td>augmentable</td><td>overwriteable and augmentable by prolog and by variable-binding expressions</td><td>lexical</td><td>Only one definition per variable per lexical scope.</td></tr><tr><td>Context item static type</td><td><code>none</code> (raises error on access)</td><td>overwriteable</td><td>not explicitly, but can be influenced by expressions</td><td>lexical</td><td>None.</td></tr><tr><td>Function signatures</td><td>functions in <code>fn</code> namespace, and constructors for built-in atomic types</td><td>augmentable</td><td>augmentable by module import and by function declaration in prolog</td><td>module</td><td>Each function must have a unique expanded QName and number of arguments.</td></tr><tr><td>Statically known collations</td><td>only the default collation</td><td>augmentable</td><td>no</td><td>module</td><td>Each URI uniquely identifies a collation.</td></tr><tr><td>Default collation</td><td>Unicode codepoint collation</td><td>overwriteable</td><td>overwriteable by prolog</td><td>module</td><td>None.</td></tr><tr><td>Construction mode</td><td><code>preserve</code></td><td>overwriteable</td><td>overwriteable by prolog</td><td>module</td><td>Value must be <code>preserve</code> or <code>strip</code>. </td></tr><tr><td>Ordering mode</td><td><code>ordered</code></td><td>overwriteable</td><td>overwriteable by prolog or expression</td><td>lexical</td><td>Value must be <code>ordered</code> or <code>unordered</code>.</td></tr><tr><td>Default order for empty sequences</td><td>implementation-defined</td><td>overwriteable</td><td>overwriteable by prolog</td><td>module</td><td>Value must be <code>greatest</code> or <code>least</code>.</td></tr><tr><td>Boundary-space policy</td><td><code>strip</code></td><td>overwriteable</td><td>overwriteable by prolog</td><td>module</td><td>Value must be <code>preserve</code> or <code>strip</code>. </td></tr><tr><td>Copy-namespaces mode</td><td><code>inherit, preserve</code></td><td>overwriteable</td><td>overwriteable by prolog</td><td>module</td><td>Value consists of <code>inherit</code> or <code>no-inherit</code>, and <code>preserve</code> or <code>no-preserve</code>.</td></tr><tr><td>Base URI</td><td>none</td><td>overwriteable</td><td>overwriteable by prolog</td><td>module</td><td>Value must be a valid lexical representation of the type xs:anyURI.</td></tr><tr><td>Statically known documents</td><td>none</td><td>augmentable</td><td>no</td><td>module</td><td>None.</td></tr><tr><td>Statically known collections</td><td>none</td><td>augmentable</td><td>no</td><td>module </td><td>None.</td></tr><tr><td>Statically known default collection type</td><td><code>node()*</code></td><td>overwriteable</td><td>no</td><td>module</td><td>None.</td></tr></tbody></table></div></div><div class="div2">
<h3><a id="id-xq-evaluation-context-components" name="id-xq-evaluation-context-components"></a>C.2 Dynamic Context Components</h3><p>The following table describes the components of the <b>dynamic context</b>. The following aspects of each component are described:</p><ul><li><p><em>Default initial value:</em> This is the initial value of the component if it is not overridden or augmented by the implementation or by a query.</p></li><li><p><em>Can be overwritten or augmented by implementation:</em> Indicates whether an XQuery implementation is allowed to replace the default initial value of the component by a different <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> value and/or to augment the default initial value by additional <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> values.</p></li><li><p><em>Can be overwritten or augmented by a query:</em> Indicates whether a query is allowed to replace and/or augment the initial value provided by default or by the implementation. If so, indicates how this is accomplished.</p></li><li><p><em>Scope:</em> Indicates where the component is applicable. "Global" indicates that the component applies globally, throughout all the modules used in a query, and remains constant during evaluation of a query.  "Dynamic" indicates that evalation of an expression may influence the value of the component for that expression and for nested expressions.</p></li><li><p><em>Consistency Rules:</em> Indicates rules that must be observed in assigning values to the component. Additional consistency rules may be found in <a href="#id-consistency-constraints"><b>2.2.5 Consistency Constraints</b></a>.</p></li></ul><div class="small"><table width="100%" border="1" summary="Static Context" class="small"><caption>Dynamic Context Components</caption><tbody><tr><th>Component</th><th>Default initial value</th><th>Can be overwritten or augmented by implementation?</th><th>Can be overwritten or augmented by a query?</th><th>Scope</th><th>Consistency rules</th></tr><tr><td>Context item</td><td>none</td><td>overwriteable</td><td>overwritten during evaluation of path expressions and predicates</td><td>dynamic</td><td>None</td></tr><tr><td>Context position</td><td>none</td><td>overwriteable </td><td>overwritten during evaluation of path expressions and predicates</td><td>dynamic</td><td>If context item is defined, context position must be &gt;0 and &lt;= context size; else  context position is undefined. </td></tr><tr><td>Context size</td><td>none</td><td>overwriteable</td><td>overwritten during evaluation of path expressions and predicates</td><td>dynamic</td><td>If context item is defined, context size must be &gt;0; else context size is undefined.</td></tr><tr><td>Variable values</td><td>none</td><td>augmentable</td><td>overwriteable and augmentable by prolog and by variable-binding expressions</td><td>dynamic</td><td>Names and values must be consistent with in-scope variables.</td></tr><tr><td>Function implementations</td><td>functions in <code>fn</code> namespace, and constructors for built-in atomic types</td><td>augmentable</td><td>augmentable by module import and by function declaration in prolog</td><td>global</td><td>Must be consistent with function signatures</td></tr><tr><td>Current dateTime</td><td>none</td><td>must be initialized by implementation</td><td>no</td><td>global</td><td>Must include a timezone. Remains constant during evaluation of a query.</td></tr><tr><td>Implicit timezone</td><td>none</td><td>must be initialized by implementation</td><td>no</td><td>global</td><td>Remains constant during evaluation of a query.</td></tr><tr><td>Available documents</td><td>none</td><td>must be initialized by implementation</td><td>no</td><td>global</td><td>None</td></tr><tr><td>Available collections</td><td>none</td><td>must be initialized by implementation</td><td>no</td><td>global</td><td>None</td></tr><tr><td>Default collection</td><td>none</td><td>overwriteable</td><td>no</td><td>global</td><td>None</td></tr></tbody></table></div></div><div class="div2">
<h3><a id="id-xq-serialization-parameters" name="id-xq-serialization-parameters"></a>C.3 Serialization Parameters</h3><p>The following table specifies default values for  the parameters that control the process of serializing a Data Model instance into XML notation (<code>method = "xml"</code>). The meanings of the various parameters are defined in <a href="#serialization">[XSLT 2.0 and XQuery 1.0 Serialization]</a>. For each parameter, an XQuery implementation may (but is not required to) provide a means whereby a user can override the default value.</p><div class="small"><table border="1" width="60%" summary="Unary operators" class="small"><caption>Serialization Parameters</caption><tbody><tr><th>Parameter</th><th>Default Value</th></tr><tr><td>byte-order-mark</td><td>implementation-defined</td></tr><tr><td>cdata-section-elements</td><td>empty</td></tr><tr><td>doctype-public</td><td>(none)</td></tr><tr><td>doctype-system</td><td>(none)</td></tr><tr><td>encoding</td><td>implementation-defined choice between "utf-8" and "utf-16"</td></tr><tr><td>escape-uri-attributes</td><td>(not applicable when method = xml)</td></tr><tr><td>include-content-type</td><td>(not applicable when method = xml)</td></tr><tr><td>indent</td><td>no</td></tr><tr><td>media-type</td><td>implementation-defined</td></tr><tr><td>method</td><td>xml</td></tr><tr><td>normalization-form</td><td>implementation-defined</td></tr><tr><td>omit-xml-declaration</td><td>implementation-defined</td></tr><tr><td>standalone</td><td>implementation-defined</td></tr><tr><td>undeclare-prefixes</td><td>no</td></tr><tr><td>use-character-maps</td><td>empty</td></tr><tr><td>version</td><td>implementation-defined</td></tr></tbody></table></div></div></div></div></span><span class="xpath"><div class="xpath"><div class="div1">
<h2><a id="id-xp-context-components" name="id-xp-context-components"></a>D Context Components</h2><p>The tables in this
section describe the scope (range of applicability) of the various
components in the static context and dynamic context.</p><div class="div2">
<h3><a id="id-xp-static-context-components" name="id-xp-static-context-components"></a>D.1 Static Context
Components</h3><p>The following table describes the components of
the <b>static context</b>. For each component, "global"
indicates that the value of the component applies throughout an XPath
expression, whereas "lexical" indicates that the value of the
component applies only within the subexpression in which it is
defined.</p><div class="small"><table width="60%" border="1" summary="Static Context" class="small"><caption>Static Context Components</caption><tbody><tr><th>Component</th><th>Scope</th></tr><tr><td>XPath 1.0 Compatibility Mode</td><td>global</td></tr><tr><td>Statically known namespaces</td><td>global</td></tr><tr><td>Default element/type namespace</td><td>global</td></tr><tr><td>Default function namespace</td><td>global</td></tr><tr><td>In-scope schema types</td><td>global</td></tr><tr><td>In-scope element declarations</td><td>global</td></tr><tr><td>In-scope attribute declarations</td><td>global</td></tr><tr><td>In-scope variables</td><td>lexical; for-expressions and quantified expressions can bind new variables</td></tr><tr><td>Context item static type</td><td>lexical</td></tr><tr><td>Function signatures</td><td>global</td></tr><tr><td>Statically known collations</td><td>global</td></tr><tr><td>Default collation</td><td>global</td></tr><tr><td>Base URI</td><td>global</td></tr><tr><td>Statically known documents</td><td>global</td></tr><tr><td>Statically known collections</td><td>global  </td></tr><tr><td>Statically known default collection type</td><td>global</td></tr></tbody></table></div></div><div class="div2">
<h3><a id="id-xp-evaluation-context-components" name="id-xp-evaluation-context-components"></a>D.2 Dynamic Context Components</h3><p>The following table describes how values are assigned to the various components of the <b>dynamic context</b>. All these components are initialized by mechanisms defined by the host language. For each component, "global" indicates that the value of the component remains constant throughout evaluation of the XPath expression, whereas "dynamic" indicates that the value of the component can be modified by the evaluation of subexpressions.</p><div class="small"><table width="60%" border="1" summary="Static Context" class="small"><caption>Dynamic Context Components</caption><tbody><tr><th>Component</th><th>Scope</th></tr><tr><td>Context item</td><td>dynamic; changes during evaluation of path expressions and predicates</td></tr><tr><td>Context position</td><td>dynamic; changes during evaluation of path expressions and predicates</td></tr><tr><td>Context size</td><td>dynamic; changes during evaluation of path expressions and predicates</td></tr><tr><td>Variable values</td><td>dynamic; for-expressions and quantified expressions can bind new variables</td></tr><tr><td>Current date and time</td><td>global; must be initialized by implementation</td></tr><tr><td>Implicit timezone</td><td>global; must be initialized by implementation</td></tr><tr><td>Available documents</td><td>global; must be initialized by implementation</td></tr><tr><td>Available collections</td><td>global; must be initialized by implementation</td></tr><tr><td>Default collection</td><td>global; overwriteable by implementation</td></tr></tbody></table></div></div></div></div></span><div class="div1">
<h2><a id="id-impl-defined-items" name="id-impl-defined-items"></a>E Implementation-Defined Items</h2><p>The following items are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>:</p><ol class="enumar"><li><p>The version of Unicode that is used to construct expressions.</p></li><li><p>The <a title="statically known collations" href="#dt-static-collations">statically-known collations</a>.</p></li><li><p>The <a title="implicit timezone" href="#dt-timezone">implicit timezone</a>.</p></li><li><p>The circumstances in which <a title="warning" href="#dt-warning">warnings</a> are raised, and the ways in which warnings are handled.</p></li><li><p>The method by which errors are reported to the external processing environment.</p></li><li><p>Whether the implementation is based on the rules of  <a href="#XML">[XML 1.0]</a> and <a href="#XMLNAMES">[XML Names]</a> or the rules of <a href="#XML1.1">[XML 1.1]</a> and <a href="#XMLNAMES11">[XML Names 1.1]</a>. One of these sets of rules must be applied consistently by all aspects of the implementation.</p></li><span class="xquery"><li class="xquery"><p>Any components of the <a title="static context" href="#dt-static-context">static context</a> or <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a> that are overwritten or augmented by the implementation.</p></li></span><span class="xpath"><li class="xpath"><p>Whether the implementation supports the namespace axis.</p></li></span><span class="xquery"><li class="xquery"><p>Which of the <a title="optional axis" href="#dt-optional-axis">optional axes</a> are supported by the implementation, if the <a title="Full Axis Feature" href="#dt-full-axis-feature">Full-Axis Feature</a> is not supported.</p></li></span><span class="xquery"><li class="xquery"><p>The default handling of empty sequences returned by an ordering key (sortspec) in an <code>order by</code> clause (<code>empty least</code> or <code>empty greatest</code>).</p></li></span><span class="xquery"><li class="xquery"><p>The names and semantics of any <a title="extension expression" href="#dt-extension-expression">extension expressions</a> (<a title="pragma" href="#dt-pragma">pragmas</a>) recognized by the implementation.</p></li></span><span class="xquery"><li class="xquery"><p>The names and semantics of any <a title="option declaration" href="#dt-option-declaration">option declarations</a>  recognized by the implementation.</p></li></span><span class="xquery"><li class="xquery"><p>Protocols (if any) by which parameters can be passed to an external function, and the result of the function can returned to the invoking query.</p></li></span><span class="xquery"><li class="xquery"><p>How the implementation handles location hints in <a title="module import" href="#dt-module-import">module imports</a>, if the <a title="module feature" href="#dt-module-feature">Module Feature</a> is supported.</p></li></span><span class="xquery"><li class="xquery"><p>Any <a title="static typing extension" href="#dt-static-typing-extension">static typing extensions</a> supported by the implementation, if the <a title="static typing feature" href="#dt-static-typing-feature">Static Typing Feature</a> is supported.</p></li></span><span class="xpath"><li class="xpath"><p>Any <a title="static typing extension" href="#dt-xpath-static-typing-extension">static typing extensions</a> supported by the implementation, if the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a> is supported.</p></li></span><span class="xquery"><li class="xquery"><p>The means by which serialization is invoked, if the <a title="serialization feature" href="#dt-serialization-feature">Serialization Feature</a> is supported.</p></li></span><span class="xquery"><li class="xquery"><p>The default values for the <code>byte-order-mark</code>, <code>encoding</code>, <code>media-type</code>, <code>normalization-form</code>, <code>omit-xml-declaration</code>, <code>standalone</code>, and <code>version</code> parameters, if the <a title="serialization feature" href="#dt-serialization-feature">Serialization Feature</a> is supported.</p></li></span></ol></div><div class="div1">
<h2><a id="id-references" name="id-references"></a>F References</h2><div class="div2">
<h3><a id="id-normative-references" name="id-normative-references"></a>F.1 Normative References</h3><dl><dt class="label"><span><a id="ISO10646" name="ISO10646"></a>ISO/IEC 10646</span></dt><dd><div>ISO (International Organization for Standardization). <em>ISO/IEC 10646:2003. Information technology&mdash;Universal Multiple-Octet Coded Character Set (UCS)</em>, as, from time to time, amended, replaced by a new edition, or expanded by the addition of new parts. [Geneva]: International Organization for Standardization. (See  <a href="http://www.iso.ch">http://www.iso.ch</a> for the latest version.)</div></dd><dt class="label"><span><a id="RFC2119" name="RFC2119"></a>RFC 2119</span></dt><dd><div>S. Bradner. <em>Key Words for use in RFCs to Indicate Requirement Levels.</em> IETF RFC 2119. See <a href="http://rfc.net/rfc2119.html">http://www.ietf.org/rfc/rfc2119.txt</a>.</div></dd><dt class="label"><span><a id="RFC2396" name="RFC2396"></a>RFC2396</span></dt><dd><div>T. Berners-Lee, R. Fielding, and
L. Masinter.  <em>Uniform Resource Identifiers (URI): Generic
Syntax</em>. IETF RFC 2396. See <a href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</a>.</div></dd><dt class="label"><span><a id="RFC3986" name="RFC3986"></a>RFC3986</span></dt><dd><div>T. Berners-Lee, R. Fielding, and
L. Masinter.  <em>Uniform Resource Identifiers (URI): Generic
Syntax</em>. IETF RFC 3986. See <a href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</div></dd><dt class="label"><span><a id="RFC3987" name="RFC3987"></a>RFC3987</span></dt><dd><div>M. Duerst and M. Suignard.  <em>Internationalized Resource Identifiers (IRIs)</em>. IETF RFC 3987. See <a href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</div></dd><dt class="label"><span><a id="Unicode" name="Unicode"></a>Unicode</span></dt><dd><div>The Unicode Consortium. <em>The Unicode Standard</em>  Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions. See <a href="http://www.unicode.org/unicode/standard/versions">http://www.unicode.org/unicode/standard/versions</a> for the latest version and additional information on versions of the standard and of the Unicode Character Database. The version of Unicode to be used is <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>, but implementations are recommended to use the latest Unicode version.</div></dd><dt class="label"><span><a id="XML" name="XML"></a>XML 1.0</span></dt><dd><div>World Wide Web Consortium. <em>Extensible
Markup Language (XML) 1.0.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/2000/REC-xml-20001006">http://www.w3.org/TR/2000/REC-xml-20001006</a></div></dd><dt class="label"><span><a id="XML1.1" name="XML1.1"></a>XML 1.1</span></dt><dd><div>World Wide Web Consortium. <em>Extensible
Markup Language (XML) 1.1.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</a></div></dd><dt class="label"><span><a id="XMLID" name="XMLID"></a>XML ID</span></dt><dd><div>World Wide Web Consortium. <em>xml:id Version 1.0.</em> W3C Proposed Recommendation. See <a href="http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</a></div></dd><dt class="label"><span><a id="XMLNAMES" name="XMLNAMES"></a>XML Names</span></dt><dd><div>World Wide Web
Consortium. <em>Namespaces in XML.</em> W3C Recommendation. See
<a href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a></div></dd><dt class="label"><span><a id="XMLNAMES11" name="XMLNAMES11"></a>XML Names 1.1</span></dt><dd><div>World Wide Web
Consortium. <em>Namespaces in XML 1.1.</em> W3C Recommendation. See
<a href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></div></dd><dt class="label"><span><a id="XMLSchema" name="XMLSchema"></a>XML Schema</span></dt><dd><div>World Wide Web
Consortium. <em>XML Schema, Parts 0, 1, and 2</em>. W3C Recommendation, 2 May
2001. See <a href="http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-0-20010502/</a>, <a href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/</a>, and <a href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/">http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/</a>.</div></dd><dt class="label"><span><a id="datamodel" name="datamodel"></a>XQuery 1.0 and XPath 2.0 Data Model</span></dt><dd><div>World Wide Web Consortium. <em>XQuery 1.0 and XPath
2.0 Data Model</em>. W3C Working Draft, 15 Sept. 2005. See <a href="http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</a>.</div></dd><dt class="label"><span><a id="XQueryFormalSemantics" name="XQueryFormalSemantics"></a>XQuery 1.0 and XPath 2.0 Formal Semantics</span></dt><dd><div>World
Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Formal Semantics</em>.  W3C Working Draft,
15 Sept. 2005. See <a href="http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</a>.</div></dd><dt class="label"><span><a id="FunctionsAndOperators" name="FunctionsAndOperators"></a>XQuery 1.0 and XPath 2.0 Functions and Operators</span></dt><dd><div>World Wide Web Consortium. <em>XQuery 1.0 and XPath 2.0 Functions and
     Operators</em> W3C Working Draft, 15 Sept. 2005. See <a href="http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xpath-functions/</a>.</div></dd><dt class="label"><span><a id="serialization" name="serialization"></a>XSLT 2.0 and XQuery 1.0 Serialization</span></dt><dd><div>World
Wide Web Consortium.
<em>XSLT 2.0 and XQuery 1.0 Serialization</em>.
W3C Working Draft, 15 Sept.  2005.
See <a href="http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</a>.</div></dd></dl></div><div class="div2">
<h3><a id="id-non-normative-references" name="id-non-normative-references"></a>F.2 Non-normative References</h3><dl><dt class="label"><span><a id="DOM" name="DOM"></a>Document Object Model</span></dt><dd><div>World Wide Web Consortium. <em>Document Object Model (DOM) Level 3 Core Specification.</em> W3C Recommendation, April 7, 2004. See <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/">http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/</a>.</div></dd><span class="xquery"><dt class="label"><span class="xquery"><a id="ODMG" name="ODMG"></a>ODMG</span></dt><dd><div class="xquery">Rick Cattell et al. <em>The
Object Database Standard: ODMG-93, Release 1.2</em>. Morgan Kaufmann
Publishers, San Francisco, 1996.</div></dd></span><span class="xquery"><dt class="label"><span class="xquery"><a id="Quilt" name="Quilt"></a>Quilt</span></dt><dd><div class="xquery">Don Chamberlin,
Jonathan Robie, and Daniela Florescu. <em>Quilt: an XML Query Language for
Heterogeneous Data Sources</em>.  In <em>Lecture Notes in Computer
Science</em>, Springer-Verlag, Dec. 2000.  Also available at <a href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf">http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf</a>.
See also <a href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html</a>.</div></dd></span><span class="xquery"><dt class="label"><span class="xquery"><a id="SQL" name="SQL"></a>SQL</span></dt><dd><div class="xquery">International Organization for
Standardization (ISO).  <em>Information Technology-Database Language
SQL</em>. Standard No. ISO/IEC 9075:2003.  (Available from American
National Standards Institute, New York, NY 10036, (212)
642-4900.)</div></dd></span><span class="xquery"><dt class="label"><span class="xquery"><a id="RFC1738" name="RFC1738"></a>Uniform Resource Locators (URL)</span></dt><dd><div class="xquery">Internet Engineering Task Force (IETF).  <em>Uniform Resource Locators (URL)</em>. Request For Comment No. 1738, Dec. 1994. See <a href="http://www.ietf.org/rfc/rfc1738.txt">http://www.ietf.org/rfc/rfc1738.txt</a>.</div></dd></span><dt class="label"><span><a id="XINFO" name="XINFO"></a>XML Infoset</span></dt><dd><div>World Wide Web
Consortium. <em>XML Information Set.</em> W3C Recommendation 24 October 2001. See
<a href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</a>
</div></dd><span class="xquery"><dt class="label"><span class="xquery"><a id="XML-QL" name="XML-QL"></a>XML-QL</span></dt><dd><div class="xquery">Alin Deutsch, Mary Fernandez, Daniela
Florescu, Alon Levy, and Dan Suciu. <em>A Query Language for XML</em>. See <a href="http://www.research.att.com/~mff/files/final.html">http://www.research.att.com/~mff/files/final.html</a>
</div></dd></span><span class="xquery"><dt class="label"><span class="xquery"><a id="Requirements" name="Requirements"></a>XML Query 1.0 Requirements</span></dt><dd><div class="xquery">World Wide
Web Consortium. <em>XML Query 1.0 Requirements</em>. W3C Working Draft,
14 Nov 2003. See <a href="http://www.w3.org/TR/xquery-requirements/">http://www.w3.org/TR/xquery-requirements/</a>.
</div></dd></span><span class="xquery"><dt class="label"><span class="xquery"><a id="UseCases" name="UseCases"></a>XML Query Use Cases</span></dt><dd><div class="xquery">World Wide
Web Consortium. <em>XML Query Use Cases</em>. W3C Working Draft, 15 Sept. 2005. See <a href="http://www.w3.org/TR/xquery-use-cases/">http://www.w3.org/TR/xquery-use-cases/</a>.</div></dd></span><dt class="label"><span><a id="XPath" name="XPath"></a>XPath 1.0</span></dt><dd><div> World Wide Web Consortium. <em>XML Path
Language (XPath) Version 1.0</em>. W3C Recommendation, Nov. 16, 1999. See
<a href="http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</a></div></dd><span class="xquery"><dt class="label"><span class="xquery"><a id="XPath20" name="XPath20"></a>XPath 2.0</span></dt><dd><div class="xquery"> World Wide Web Consortium. <em>XML Path
Language (XPath) Version 2.0</em>. W3C Working Draft, 15 Sept. 2005.  See
<a href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a>.</div></dd></span><span class="xpath"><dt class="label"><span class="xpath"><a id="XPath-Requirements" name="XPath-Requirements"></a>XPath 2.0 Requirements</span></dt><dd><div class="xpath">World Wide
Web Consortium. <em>XPath Requirements
Version 2.0</em>. W3C Working Draft 22 August 2003. See <a href="http://www.w3.org/TR/xpath20req">http://www.w3.org/TR/xpath20req</a>.
</div></dd></span><dt class="label"><span><a id="XPTR" name="XPTR"></a>XPointer</span></dt><dd><div>World Wide Web Consortium. <em>XML
Pointer Language (XPointer).</em> W3C Last Call Working Draft 8 January 2001. See <a href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</a></div></dd><span class="xquery"><dt class="label"><span class="xquery"><a id="XQL" name="XQL"></a>XQL</span></dt><dd><div class="xquery">J. Robie, J. Lapp, D. Schach. <em>XML
Query Language (XQL)</em>. See <a href="http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</a>.</div></dd></span><span class="xpath"><dt class="label"><span class="xpath"><a id="xquery" name="xquery"></a>XQuery</span></dt><dd><div class="xpath">World Wide Web Consortium. <em>XQuery 1.0: An XML Query Language</em>. W3C Working Draft, 15 Sept. 2005. See
<a href="http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</a>.</div></dd></span><span class="xquery"><dt class="label"><span class="xquery"><a id="XQueryX" name="XQueryX"></a>XQueryX 1.0</span></dt><dd><div class="xquery">
World Wide Web Consortium. <em>XQueryX, Version
1.0</em>. W3C Working Draft, 15 Sept. 2005.  See <a href="http://www.w3.org/TR/xqueryx">http://www.w3.org/TR/xqueryx</a>.</div></dd></span><dt class="label"><span><a id="XSLT" name="XSLT"></a>XSLT 2.0</span></dt><dd><div>World Wide Web Consortium.  <em>XSL
Transformations (XSLT) 2.0.</em> W3C Working Draft, 15 Sept. 2005.  See <a href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a></div></dd></dl></div><div class="div2">
<h3><a id="id-background-material" name="id-background-material"></a>F.3 Background Material</h3><dl><dt class="label"><span><a id="xquery-xpath-parsing" name="xquery-xpath-parsing"></a>Building a Tokenizer for XPath or XQuery</span></dt><dd><div>
<a href="http://www.w3.org/TR/xquery-xpath-parsing/"><cite>Building a Tokenizer
for XPath or XQuery</cite></a>,
Scott Boag, Editor.
World Wide Web Consortium,
4 Apr 2005.
This version is http://www.w3.org/TR/2005/WD-xquery-xpath-parsing-20050404/.
The <a href="http://www.w3.org/TR/xquery-xpath-parsing/">latest version</a>
is available at http://www.w3.org/TR/xquery-xpath-parsing/.</div></dd><dt class="label"><span><a id="CHARMOD" name="CHARMOD"></a>Character Model</span></dt><dd><div>World Wide Web Consortium.
<em>Character Model for the World Wide Web.</em> W3C Working
Draft. See <a href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</a>.</div></dd><span class="xquery"><dt class="label"><span class="xquery"><a id="UseCaseQueries" name="UseCaseQueries"></a>Use Case Sample Queries</span></dt><dd><div class="xquery">Queries
from the XQuery 1.0 Use Cases, presented in a single file.
See
<a href="http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-use-case-queries.txt">http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-use-case-queries.txt</a>.
</div></dd></span><span class="xquery"><dt class="label"><span class="xquery"><a id="XQueryQueries" name="XQueryQueries"></a>XQuery Sample Queries</span></dt><dd><div class="xquery">Queries
from this document, presented in a single file.
See
<a href="http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-wd-queries.txt">http://www.w3.org/TR/2005/WD-xquery-use-cases-20050915/xquery-wd-queries.txt</a>.
</div></dd></span><dt class="label"><span><a id="XSLT1" name="XSLT1"></a>XSLT 1.0</span></dt><dd><div>World Wide Web Consortium. <em>XSL
Transformations (XSLT) 1.0.</em> W3C Recommendation. See <a href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</a></div></dd></dl></div></div><span class="xpath"><div class="xpath"><div class="div1">
<h2><a id="id-xpath-conformance" name="id-xpath-conformance"></a>G Conformance</h2><p>XPath is
intended primarily as a component that can be used by other
specifications. Therefore, XPath relies on specifications that use it
(such as <a href="#XPTR">[XPointer]</a> and <a href="#XSLT">[XSLT 2.0]</a>) to specify
conformance criteria for XPath in their respective
environments. Specifications that set conformance criteria for their
use of XPath must not change the syntactic or semantic definitions of XPath as
given in this specification, except by subsetting and/or compatible extensions.</p><div class="div2">
<h3><a id="id-xpath-static-typing" name="id-xpath-static-typing"></a>G.1 Static Typing Feature</h3><p>
                <span class="xpath">[<a title="static typing feature" id="dt-xpath-static-typing-feature" name="dt-xpath-static-typing-feature">Definition</a>: The <b>Static
                    Typing Feature</b> is an optional feature of XPath that provides support for the static semantics defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, and requires implementations to detect and report <a title="type error" href="#dt-type-error">type errors</a> during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>.]</span> Specifications that use XPath may specify conformance criteria for use of the Static Typing Feature.</p><p>If an implementation does not support the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a>, but can
                nevertheless determine during the static analysis phase that an expression will necessarily
                raise a type error if evaluated at run time, the implementation may raise that error during the static analysis phase. The choice
                of whether to raise such an error at analysis time is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation dependent</a>.</p><div class="div3">
<h4><a id="id-xpath-static-extensions" name="id-xpath-static-extensions"></a>G.1.1 Static Typing Extensions</h4><p>In some cases, the static typing rules defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a> are not very precise (see, for example, the type
                    inference rules for the ancestor axes&mdash;parent, ancestor, and
                    ancestor-or-self&mdash;and for the function <code>fn:root</code>). Some
                    implementations may wish to support more precise
                    static typing rules.</p><p>A conforming implementation that implements the <a title="static typing feature" href="#dt-xpath-static-typing-feature">Static Typing Feature</a> may also provide one or more
                        <b>static typing extensions</b>. [<a title="static typing extension" id="dt-xpath-static-typing-extension" name="dt-xpath-static-typing-extension">Definition</a>: A
                            <b>static typing extension</b> is an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> type inference rule that
                        infers a more precise static type than that inferred by the type inference
                        rules in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.] See <a href="http://www.w3.org/TR/xquery-semantics/#id-static-extensions">Section 
6.1.1 Static Typing Extensions</a><sup><small>FS</small></sup> for a formal definition of the constraints on static typing extensions.</p></div></div></div></div></span><div class="div1">
<h2><a id="id-errors" name="id-errors"></a>H Error Conditions</h2><dl>
<dt><a name="ERRXPST0001"></a>err:XPST0001</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static error</a>
if analysis of an 
expression relies on some component of the <a title="static context" href="#dt-static-context">static context</a> that has not been 
assigned a value.</p></dd>

<dt><a name="ERRXPDY0002"></a>err:XPDY0002</dt><dd>
<p>It is a  <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if evaluation of an expression relies on some part of the <a title="dynamic context" href="#dt-dynamic-context">dynamic
context</a> that has not been assigned a value.</p></dd>

<dt><a name="ERRXPST0003"></a>err:XPST0003</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static error</a> if an expression 
is not a valid instance of the grammar defined in <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p></dd>

<dt><a name="ERRXPTY0004"></a>err:XPTY0004</dt><dd>
<p>It is a  <a title="type error" href="#dt-type-error">type error</a> 
if, during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>, an expression is found to have a <a title="static type" href="#dt-static-type">static type</a> that is not appropriate
for the context in which the expression occurs, or during the <a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
phase</a>, the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value does not match a required type as
specified by the matching rules in <a href="#id-sequencetype-matching"><b>2.5.4 SequenceType Matching</b></a>.</p></dd>

<dt><a name="ERRXPST0005"></a>err:XPST0005</dt><dd>
<p>
During the analysis phase,
it is a  <a title="static error" href="#dt-static-error">static error</a> 
if the <a title="static type" href="#dt-static-type">static type</a> assigned to an
expression other than the expression <code>()</code> or <code>data(())</code> is <code>empty-sequence()</code>.</p></dd>

<dt><a name="ERRXPTY0006"></a>err:XPTY0006</dt><dd>
<p>
(Not currently used.)</p></dd>

<dt><a name="ERRXPTY0007"></a>err:XPTY0007</dt><dd>
<p>(Not currently used.)</p>
</dd>

<dt><a name="ERRXPST0008"></a>err:XPST0008</dt><dd>
<p>
It is a  <a title="static error" href="#dt-static-error">static error</a>  if
an expression refers to an element name, attribute name,  schema type name, namespace prefix,
or variable name that is not defined in the 
<a title="static context" href="#dt-static-context">static context</a>, except within an <a href="#doc-xpath-ElementTest">ElementTest</a> or an <a href="#doc-xpath-AttributeTest">AttributeTest</a>.</p>
</dd>

<dt><a name="ERRXQST0009"></a>err:XQST0009</dt><dd>
<p>
An implementation that does not support the Schema Import Feature must raise a  <a title="static error" href="#dt-static-error">static error</a> if 
a Prolog contains a schema import.</p>
</dd>





<dt><a name="ERRXPST0010"></a>err:XPST0010</dt><dd>
<p>
An implementation  must raise a  <a title="static error" href="#dt-static-error">static error</a> if 
it encounters a reference to an axis that it does not support.</p>
</dd><dt><a name="ERRXQST0012"></a>err:XQST0012</dt><dd>
<p>
It is a  <a title="static error" href="#dt-static-error">static error</a> if the set of
definitions contained in all schemas imported by a Prolog do not satisfy the
conditions for schema validity specified in Sections 3 and 5 of
<a href="#XMLSchema">[XML Schema]</a> Part 1--i.e., each definition must
be valid, complete, and unique.</p>
</dd>

<dt><a name="ERRXQST0013"></a>err:XQST0013</dt><dd>
<p>It is a  <a title="static error" href="#dt-static-error">static error</a> 
if an implementation recognizes a pragma but
determines that its content is  invalid.</p></dd>

<dt><a name="ERRXQST0014"></a>err:XQST0014</dt><dd>
<p>(Not currently used.)</p></dd>

<dt><a name="ERRXQST0015"></a>err:XQST0015</dt><dd>
<p>(Not currently used.)</p>
</dd>

<dt><a name="ERRXQST0016"></a>err:XQST0016</dt><dd>
<p>An implementation that does not support the Module  Feature raises a  <a title="static error" href="#dt-static-error">static 
error</a>  if it encounters a <a title="module declaration" href="#dt-module-declaration">module declaration</a> or a   <a title="module import" href="#dt-module-import">module import</a>.</p>
</dd>

<dt><a name="ERRXPST0017"></a>err:XPST0017</dt><dd>
<p>
<span class="xquery"><span class="xquery"><span class="xquery">It is a <a title="static error" href="#dt-static-error">static error</a>
</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">It is an error (the host
language environment may define this error as either a <a title="static error" href="#dt-static-error">static error</a> or a
<a title="dynamic error" href="#dt-dynamic-error">dynamic
error</a>)</span></span></span>
if the expanded QName and number of arguments in a function call do
not match the name and arity of a <a title="function signature" href="#dt-function-signature">function signature</a> in
the <a title="static context" href="#dt-static-context">static context</a>.</p>
</dd>

<dt><a name="ERRXPTY0018"></a>err:XPTY0018</dt><dd>
<p>It is a  <a title="type error" href="#dt-type-error">type error</a> if
the result of  the last step in a path expression contains both nodes and atomic values.</p>
</dd>

<dt><a name="ERRXPTY0019"></a>err:XPTY0019</dt><dd>
<p>
It is a  <a title="type error" href="#dt-type-error">type error</a> if
the result of a step (other than the last step) in a path expression contains an atomic value.</p>
</dd>

<dt><a name="ERRXPTY0020"></a>err:XPTY0020</dt><dd>
<p>
It is a <a title="type error" href="#dt-type-error">type error</a> if,
in an axis step, the context item is not a node.</p>
</dd>

<dt><a name="ERRXPDY0021"></a>err:XPDY0021</dt><dd>
<p>
(Not currently used.)</p>
</dd>

<dt><a name="ERRXQST0022"></a>err:XQST0022</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static error</a>
if the value of a <a title="namespace declaration attribute" href="#dt-namespace-decl-attr">namespace declaration
attribute</a> is not a <a href="#doc-xpath-URILiteral">URILiteral</a>.
</p>
</dd>

<dt><a name="ERRXQTY0023"></a>err:XQTY0023</dt><dd>
<p>(Not currently used.)</p>
</dd>

<dt><a name="ERRXQTY0024"></a>err:XQTY0024</dt><dd>
<p>
It is  a <a title="type error" href="#dt-type-error">type error</a>
if the content sequence in an element constructor contains an attribute
node following a node that is not an attribute node.</p></dd>

<dt><a name="ERRXQDY0025"></a>err:XQDY0025</dt><dd>
<p>
It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
 error</a>
if any attribute of a constructed element 
 does not have a name that is distinct from the names of all other attributes of the constructed element.</p>
</dd>

<dt><a name="ERRXQDY0026"></a>err:XQDY0026</dt><dd>
<p>
It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
 error</a> if the result of the content expression of a computed processing instruction constructor contains the string "<code>?&gt;</code>".</p>
</dd>

<dt><a name="ERRXQDY0027"></a>err:XQDY0027</dt><dd>
<p>
In a validate expression, 
it is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a> if
the root element information item in the PSVI resulting from validation does not have the expected validity property: <code>valid</code> if validation mode is <code>strict</code>, or either <code>valid</code> or <code>notKnown</code> if  validation mode is <code>lax</code>.</p>
</dd>

<dt><a name="ERRXQTY0028"></a>err:XQTY0028</dt><dd>
<p>
(Not currently used.)</p>
</dd>

<dt><a name="ERRXQDY0029"></a>err:XQDY0029</dt><dd>
<p>(Not currently used.)</p>
</dd>


<dt><a name="ERRXQTY0030"></a>err:XQTY0030</dt><dd>
<p>
It is a <a title="type error" href="#dt-type-error">type error</a> 
if the argument of a <code>validate</code> expression does not
evaluate to exactly one document or element node.
</p>
</dd>

<dt><a name="ERRXQST0031"></a>err:XQST0031</dt><dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a>
if the version number specified in a version declaration is not
supported by the implementation.
</p>
</dd>

<dt><a name="ERRXQST0032"></a>err:XQST0032</dt><dd>
<p>A <a title="static error" href="#dt-static-error">static error</a> is raised 
if a Prolog contains more than one <a title="base URI declaration" href="#dt-base-uri-decl">base URI declaration</a>.</p>
</dd>

<dt><a name="ERRXQST0033"></a>err:XQST0033</dt><dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a>
if a Prolog contains multiple declarations for the same
namespace prefix.
</p>
</dd>



<dt><a name="ERRXQST0034"></a>err:XQST0034</dt><dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> 
if multiple functions declared or imported by a <a title="module" href="#dt-module">module</a> have the same expanded QName and the same number of arguments.</p>
</dd><dt><a name="ERRXQST0035"></a>err:XQST0035</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static error</a> to import two schema components that both define the same
name in the same symbol space and in the same scope. </p>
</dd>


<dt><a name="ERRXQST0036"></a>err:XQST0036</dt><dd>
<p>It is a <a title="static error" href="#dt-static-error">static
error</a> to import a module if the importing module's
<a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> do not include definitions for
the schema type names that appear in variable declarations, function
parameters, or function returns found in the imported module. </p>
</dd>

<dt><a name="ERRXQST0037"></a>err:XQST0037</dt><dd>
<p>(Not currently used.)</p>
</dd>

<dt><a name="ERRXQST0038"></a>err:XQST0038</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static
error</a>
if a Prolog contains more than one <a title="default collation declaration" href="#dt-default-collation-decl">default
collation declaration</a>, or the value specified by a default collation declaration is not present in <a title="statically known collations" href="#dt-static-collations">statically known collations</a>.</p>
</dd>

<dt><a name="ERRXQST0039"></a>err:XQST0039</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static error</a> for a
function declaration to have more than one parameter with the same name.
</p>
</dd>

<dt><a name="ERRXQST0040"></a>err:XQST0040</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static error</a> if the attributes specified by a direct element constructor do not have distinct expanded QNames.</p>
</dd><dt><a name="ERRXQDY0041"></a>err:XQDY0041</dt><dd>
<p>
It is  a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the value of the name expression in a computed processing instruction constructor cannot be cast to the type <code>xs:NCName</code>.</p></dd><dt><a name="ERRXQST0042"></a>err:XQST0042</dt><dd>
<p>
(Not currently used.)</p></dd><dt><a name="ERRXQST0043"></a>err:XQST0043</dt><dd>
<p>
(Not currently used.)</p></dd><dt><a name="ERRXQDY0044"></a>err:XQDY0044</dt><dd>
<p>
It is  a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the <code>node-name</code> property of the node constructed by a computed attribute constructor  is in the namespace <code>http://www.w3.org/2000/xmlns/</code> (corresponding to namespace prefix  <code>xmlns</code>), or is in no namespace and has local name <code>xmlns</code>.</p></dd><dt><a name="ERRXQST0045"></a>err:XQST0045</dt><dd>
<p>
It is  a <a title="static error" href="#dt-static-error">static error</a>
if the function name in a function declaration is in one of the following namespaces: <code>http://www.w3.org/XML/1998/namespace, http://www.w3.org/2001/XMLSchema, http://www.w3.org/2001/XMLSchema-instance, http://www.w3.org/2005/xpath-functions, http://www.w3.org/2005/xpath-datatypes</code>.</p></dd><dt><a name="ERRXQST0046"></a>err:XQST0046</dt><dd>
<p>An implementation <a title="may" href="#may">MAY</a> raise a <a title="static error" href="#dt-static-error">static error</a> if the value of a <a href="#doc-xpath-URILiteral">URILiteral</a> is of nonzero length and is not in the lexical
space of <code>xs:anyURI</code>, or if it is a string that represents a "relative reference" as
defined in <a href="#RFC3986">[RFC3986]</a>.</p></dd><dt><a name="ERRXQST0047"></a>err:XQST0047</dt><dd>
<p>
It is  a <a title="static error" href="#dt-static-error">static error</a>
if multiple module imports in the same Prolog specify the same target namespace.</p></dd><dt><a name="ERRXQST0048"></a>err:XQST0048</dt><dd>
<p>
It is  a <a title="static error" href="#dt-static-error">static error</a>
if a function or variable declared in a library module is not in the target namespace of the library module.</p></dd><dt><a name="ERRXQST0049"></a>err:XQST0049</dt><dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> 
if more than one variable declared or imported by a <a title="module" href="#dt-module">module</a> has the same expanded QName.</p>
</dd><dt><a name="ERRXPDY0050"></a>err:XPDY0050</dt><dd>
<p>It is  a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of the operand of a <code>treat</code> expression does not match the <a title="sequence type" href="#dt-sequence-type">sequence type</a> specified by the <code>treat</code> expression. This error might also be raised by a path expression beginning with "<code>/</code>" or "<code>//</code>" if the context node is not in a tree that is rooted at a document node. This is because a leading "<code>/</code>" or "<code>//</code>" in a path expression is an abbreviation for an initial step that includes the clause <code>treat as document-node()</code>.</p></dd><dt><a name="ERRXPST0051"></a>err:XPST0051</dt><dd>
<p>It is  a <a title="static error" href="#dt-static-error">static error</a>
if a QName that is used as an <a href="#doc-xpath-AtomicType">AtomicType</a> in a <a href="#doc-xpath-SequenceType">SequenceType</a> is not defined in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> as an atomic type.</p></dd><dt><a name="ERRXQDY0052"></a>err:XQDY0052</dt><dd>
<p>(Not currently used.)</p>
</dd><dt><a name="ERRXQST0053"></a>err:XQST0053</dt><dd>
<p>
(Not currently used.)</p></dd><dt><a name="ERRXQST0054"></a>err:XQST0054</dt><dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> 
if the <a title="initializing expression" href="#dt-initializing-expression">initializing expression</a> in a variable declaration cannot be executed because of a circularity (for example, the expression depends on a function that in turn depends on the value of the initialized variable).</p>
</dd><dt><a name="ERRXQST0055"></a>err:XQST0055</dt><dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> if a Prolog contains more than one <a title="copy-namespaces declaration" href="#dt-copy-namespaces-decl">copy-namespaces declaration</a>.</p></dd><dt><a name="ERRXQST0056"></a>err:XQST0056</dt><dd>
<p>
(Not currently used.)</p></dd><dt><a name="ERRXQST0057"></a>err:XQST0057</dt><dd>
<p>
It is  a <a title="static error" href="#dt-static-error">static error</a>
if a schema import binds a namespace prefix but does not specify a target namespace other than a zero-length string.</p></dd><dt><a name="ERRXQST0058"></a>err:XQST0058</dt><dd>
<p>
It is  a <a title="static error" href="#dt-static-error">static error</a>
if multiple schema imports specify the same target namespace.</p></dd><dt><a name="ERRXQST0059"></a>err:XQST0059</dt><dd>
<p>
It is  a <a title="static error" href="#dt-static-error">static error</a>
if an implementation is unable to process a schema or module import by finding a schema or module with the specified target namespace.</p></dd><dt><a name="ERRXQST0060"></a>err:XQST0060</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static error</a> if the name of a function in a function declaration is not in a namespace (expanded QName has a null namespace URI).</p></dd><dt><a name="ERRXQDY0061"></a>err:XQDY0061</dt><dd>
<p>
It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the operand of a validate expression is a document node whose children do not consist of exactly one element node  and zero or more comment and processing instruction nodes, in any order.</p>
</dd><dt><a name="ERRXQDY0062"></a>err:XQDY0062</dt><dd>
<p>(Not currently used.)</p>
</dd><dt><a name="ERRXQST0063"></a>err:XQST0063</dt><dd>
<p>
(Not currently used.)</p></dd><dt><a name="ERRXQDY0064"></a>err:XQDY0064</dt><dd>
<p>
It is  a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the value of the name expression in a computed processing instruction constructor is equal to "XML" (in any combination of upper and lower case).</p></dd><dt><a name="ERRXQST0065"></a>err:XQST0065</dt><dd>
<p>A <a title="static error" href="#dt-static-error">static error</a> is raised 
if a Prolog contains more than one <a title="ordering mode declaration" href="#dt-ordering-mode-decl">ordering mode declaration</a>.</p>
</dd><dt><a name="ERRXQST0066"></a>err:XQST0066</dt><dd>
<p>A <a title="static error" href="#dt-static-error">static error</a> is raised 
if a Prolog contains more than one default element/type namespace declaration, or more than one default function namespace declaration.
</p>
</dd><dt><a name="ERRXQST0067"></a>err:XQST0067</dt><dd>
<p>A <a title="static error" href="#dt-static-error">static error</a> is raised 
if a Prolog contains more than one <a title="construction declaration" href="#dt-construction-decl">construction declaration</a>.</p>
</dd><dt><a name="ERRXQST0068"></a>err:XQST0068</dt><dd>
<p>A <a title="static error" href="#dt-static-error">static error</a> is raised 
if a Prolog contains more than one <a title="boundary-space declaration" href="#dt-boundary-space-decl">boundary-space declaration</a>.</p>
</dd><dt><a name="ERRXQST0069"></a>err:XQST0069</dt><dd>
<p>A <a title="static error" href="#dt-static-error">static error</a> is raised 
if a Prolog contains more than one <a title="empty order declaration" href="#dt-empty-order-decl">empty order declaration</a>.</p>
</dd><dt><a name="ERRXQST0070"></a>err:XQST0070</dt><dd>
<p>A <a title="static error" href="#dt-static-error">static error</a> is raised 
if the predefined namespace prefix <code>xml</code> or <code>xmlns</code> is redeclared by a namespace declaration or namespace declaration attribute, or if another namespace prefix is bound to the namespace URI associated with the prefix <code>xml</code>.</p>
</dd><dt><a name="ERRXQST0071"></a>err:XQST0071</dt><dd>
<p>A <a title="static error" href="#dt-static-error">static error</a> is raised 
if the namespace declaration attributes of a direct element constructor do not have distinct names.</p>
</dd><dt><a name="ERRXQDY0072"></a>err:XQDY0072</dt><dd>
<p>
It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic
 error</a> if the result of the content expression of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</p>
</dd><dt><a name="ERRXQST0073"></a>err:XQST0073</dt><dd>
<p>It is a <a title="static error" href="#dt-static-error">static error</a> if the graph of <a title="module import" href="#dt-module-import">module imports</a> contains a cycle (that is, if there exists a sequence of modules M<sub>1</sub> ... M<sub>n</sub> such that each M<sub>i</sub> imports M<sub>i+1</sub> and M<sub>n</sub> imports M<sub>1</sub>), unless all the modules in the cycle share a common namespace.</p>
</dd><dt><a name="ERRXQDY0074"></a>err:XQDY0074</dt><dd>
<p>
It is  a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the value of the name expression in a computed element or attribute constructor cannot be converted to an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for example, because it contains a namespace prefix not found in <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>.)</p></dd><dt><a name="ERRXQST0075"></a>err:XQST0075</dt><dd>
<p>
An implementation that does not support the Validation Feature must raise a  <a title="static error" href="#dt-static-error">static error</a> if 
it encounters a <code>validate</code> expression.</p>
</dd><dt><a name="ERRXQST0076"></a>err:XQST0076</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static
error</a>
if a <code>collation</code> subclause in an <code>order by</code> clause of a FLWOR expression does not identify a collation that is present in <a title="statically known collations" href="#dt-static-collations">statically known collations</a>.</p>
</dd><dt><a name="ERRXQST0077"></a>err:XQST0077</dt><dd>
<p>
(Not currently used.)</p>
</dd><dt><a name="ERRXQST0078"></a>err:XQST0078</dt><dd>
<p>
(Not currently used.)</p>
</dd><dt><a name="ERRXQST0079"></a>err:XQST0079</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static
error</a>
if an extension expression contains neither a <a title="pragma" href="#dt-pragma">pragma</a> that is recognized by the implementation nor an expression enclosed in curly braces.</p>
</dd><dt><a name="ERRXPST0080"></a>err:XPST0080</dt><dd>
<p>
The target type of a <code>cast</code> or <code>castable</code> expression must be an atomic type that is in the <a title="in-scope schema type" href="#dt-is-types">in-scope schema types</a> and is not <code>xs:NOTATION</code> or <code>xdt:anyAtomicType</code>, optionally followed by the occurrence indicator "<code>?</code>"; otherwise a <a title="static error" href="#dt-static-error">static
error</a> is raised.</p>
</dd><dt><a name="ERRXPST0081"></a>err:XPST0081</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static
error</a>
if a QName used in <span class="xquery"><span class="xquery"><span class="xquery">a query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">an expression</span></span></span> contains a namespace prefix that cannot be expanded into a namespace URI by using the <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>.</p>
</dd><dt><a name="ERRXQST0082"></a>err:XQST0082</dt><dd>
<p>(Not currently used.)</p>
</dd><dt><a name="ERRXPST0083"></a>err:XPST0083</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static
error</a>
if the target type of a <code>cast</code> expression or constructor function is <code>xs:QName</code> or a type derived from <code>xs:QName</code> or <code>xs:NOTATION</code>, and the argument of the <code>cast</code> expression or constructor function is not a string literal.</p>
</dd><dt><a name="ERRXQDY0084"></a>err:XQDY0084</dt><dd>
<p>
It is a <a title="dynamic error" href="#dt-dynamic-error">dynamic error</a>
if the element validated by a <code>validate</code> statement does not have a top-level element declaration in the <a title="in-scope element declarations" href="#dt-is-elems">in-scope element declarations</a>, if validation mode is <code>strict</code>.</p>
</dd><dt><a name="ERRXQST0085"></a>err:XQST0085</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static
error</a>
if the namespace URI in a namespace declaration attribute is a zero-length string, and the implementation does not support <a href="#XMLNAMES11">[XML Names 1.1]</a>.</p>
</dd><dt><a name="ERRXQTY0086"></a>err:XQTY0086</dt><dd>
<p>
It is a <a title="type error" href="#dt-type-error">type error</a> 
if the typed value of a copied element or attribute node is <a title="namespace-sensitive" href="#dt-namespace-sensitive">namespace-sensitive</a> when <a title="construction mode" href="#dt-construction-mode">construction mode</a> is <code>preserve</code> and <a title="copy-namespaces mode" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> is <code>no-preserve</code>.</p>
</dd><dt><a name="ERRXQST0087"></a>err:XQST0087</dt><dd>
<p>
It is a <a title="static error" href="#dt-static-error">static
error</a>
if the encoding specified in a Version Declaration does not conform to  the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a>.</p>
</dd></dl></div><span class="xquery"><div class="xquery"><div class="div1">
<h2><a id="id-mime-type" name="id-mime-type"></a>I The <code>application/xquery</code> Media Type</h2><p>This Appendix 
    specifies the media type for XQuery Version 1.0.  XQuery is a language for querying over
    collections of data from XML data sources, as specified in the main body of this document.</p><div class="div2">
<h3><a id="N19474" name="N19474"></a>I.1 Introduction</h3><p>
      This document, together with its normative references,  defines the language XQuery Version 1.0.  This Appendix
      provides information about the <code>application/xquery</code> media type,
      which is intended to be used for transmitting queries written in the
      XQuery language.</p><p>This document was prepared by members of the W3C XML Query Working
      Group.  Please send comments to public-qt-comments@w3.org,
      a public mailing list with archives at
      <a href="http://lists.w3.org/Archives/Public/public-qt-comments">http://lists.w3.org/Archives/Public/public-qt-comments</a>.</p></div><div class="div2">
<h3><a id="N19486" name="N19486"></a>I.2 Registration of MIME Media Type <code>application/xquery</code></h3><p>MIME media type name:  <code>application</code></p><p>MIME subtype name:    <code>xquery</code></p><p>Required parameters:  none</p><p>Optional parameters: none</p><p>The syntax of XQuery is expressed in Unicode but may be written
	with any Unicode-compatible character encoding, including UTF-8 or
	UTF-16, or transported as US-ASCII or Latin-1 with Unicode
	characters outside the range of the given encoding represented using
	an XML-style <code>&amp;#xddd;</code> syntax.</p><div class="div3">
<h4><a id="N1949C" name="N1949C"></a>I.2.1 Interoperability Considerations</h4><p>None known.</p></div><div class="div3">
<h4><a id="N194A1" name="N194A1"></a>I.2.2 Applications Using this Media Type</h4><p>The public
	  <a href="http://www.w3.org/XML/Query">XQuery Web page</a>
	  lists more than two dozen implementations of the XQuery language,
	  both proprietary and open source.</p><p>This new media type is being registered to allow for deployment
	  of XQuery on the World Wide Web.</p></div><div class="div3">
<h4><a id="N194B0" name="N194B0"></a>I.2.3 File Extensions</h4><p>The most common file extensions in use for XQuery are
	  <code>.xq</code> and <code>.xquery</code>.</p><p>The appropriate Macintosh file type code is <code>TEXT</code>.</p></div><div class="div3">
<h4><a id="N194C0" name="N194C0"></a>I.2.4 Intended Usage</h4><p>The intended usage of this media type is for interchange
	of XQuery expressions.</p></div><div class="div3">
<h4><a id="N194C5" name="N194C5"></a>I.2.5 Author/Change Controller</h4><p>XQuery was produced by, and is maintained by, the World Wide Web
	Consortium's XML Query Working Group.  The W3C has change
	control over this specification.</p></div></div><div class="div2">
<h3><a id="xquery-mime-encoding" name="xquery-mime-encoding"></a>I.3 Encoding Considerations</h3><p>For use with transports that are not 8-bit clean, quoted-printable
    encoding is recommended since the XQuery syntax itself uses the
    US-ASCII-compatible subset of Unicode.</p><p>An XQuery document may contain an <a title="encoding declaration" href="#dt-encoding-declaration">encoding 
declaration</a> as part of its <a title="version declaration" href="#dt-version-declaration">version declaration</a>:</p><div class="exampleInner"><pre>xquery version "1.0" encoding "utf-8";</pre></div></div><div class="div2">
<h3><a id="xquery-mime-recognizing" name="xquery-mime-recognizing"></a>I.4 Recognizing XQuery Files</h3><p>An XQuery file may have the string <code>xquery version "V.V"</code> near the
    beginning of the document, where <code>"V.V"</code> is a version number.
    Currently the version number, if present, must be <code>"1.0"</code>.</p></div><div class="div2">
<h3><a id="N194EC" name="N194EC"></a>I.5 Charset Default Rules</h3><p>XQuery documents use the Unicode character set and, by default, the UTF-8 encoding.</p></div><div class="div2">
<h3><a id="N194F1" name="N194F1"></a>I.6 Security Considerations</h3><p>Queries written in XQuery may cause arbitrary URIs or IRIs to be
    dereferenced.  Therefore, the security issues of <a href="#RFC3987">[RFC3987]</a> Section 8 should be considered.
    In addition, the contents of <code>file:</code> URIs can in some cases be
    accessed, processed and returned as results.</p><p>Furthermore, because the XQuery language permits extensions, 
    it is possible that <code>application/xquery</code>
    may describe content that has
    security implications beyond those described here.</p><p>The XML Query Working group is working on a facility to
    allow XQuery expressions to be used to create and update 
    persistent data.  Untrusted queries should not be given write
    access to data.</p></div></div></div></span><div class="div1">
<h2><a id="id-glossary" name="id-glossary"></a>J Glossary (Non-Normative)</h2><dl><dt><a name="GLdt-atomic-value"></a>atomic value</dt><dd><p>An <b>atomic
	 value</b> is a value in the value space of an <b>atomic
	 type</b>, as defined in <a href="#XMLSchema">[XML Schema]</a>.</p></dd><dt><a name="GLdt-atomization"></a>atomization</dt><dd><p><b>Atomization</b> of a sequence
is defined as the result of invoking the <code>fn:data</code> function
on the sequence, as defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p></dd><dt><a name="GLdt-available-collections"></a>available collections</dt><dd><p><b>Available
                         collections.</b> This is a mapping of
                         strings onto sequences of nodes. The string
                         represents the absolute URI of a
                         resource. The sequence of nodes represents
                         the result of the <code>fn:collection</code>
                         function when that URI is supplied as the
                         argument. </p></dd><dt><a name="GLdt-available-docs"></a>available documents</dt><dd><p><b>Available
                         documents.</b> This is a mapping of
                         strings onto document nodes.  The string
                         represents the absolute URI of a
                         resource. The document node is the root of a tree that represents that resource using the <a title="data model" href="#dt-datamodel">data model</a>. The document node is returned by the <code>fn:doc</code> function when applied to that URI.</p></dd><dt><a name="GLdt-axis-step"></a>axis step</dt><dd><p>An <b>axis step</b> returns a sequence of nodes that are reachable from the context node via a specified axis. Such a step has two parts: an
		<b>axis</b>, which defines the "direction of
		movement" for the step, and a <a title="node test" href="#dt-node-test">node test</a>,
		which selects nodes based on their kind, name, and/or
		<a title="type annotation" href="#dt-type-annotation">type annotation</a>.</p></dd><dt><a name="GLdt-base-uri"></a>base URI</dt><dd><p><b>Base URI.</b> This is an absolute URI, used when necessary in the resolution of relative URIs (for example, by the <code>fn:resolve-uri</code> function.)</p></dd><dt><a name="GLdt-base-uri-decl"></a>base URI declaration</dt><dd><p>A <b>base URI declaration</b> specifies the
         <a title="base URI" href="#dt-base-uri">base URI</a> property of the <a title="static context" href="#dt-static-context">static context</a>, which
         is used when resolving relative URIs within a
         <a title="module" href="#dt-module">module</a>.</p></dd><dt><a name="GLdt-binding-sequence"></a>binding sequence</dt><dd><p>The value of the expression associated with a variable in a <code>for</code> clause is called the <b>binding sequence</b> for that variable.</p></dd><dt><a name="GLdt-boundary-space-decl"></a>boundary-space declaration</dt><dd><p>A <b>boundary-space declaration</b> sets the <a title="boundary-space policy" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Boundary-space policy controls whether <a title="boundary whitespace" href="#dt-boundary-whitespace">boundary whitespace</a> is preserved by element constructors during processing of the query.</p></dd><dt><a name="GLdt-boundary-space-policy"></a>boundary-space policy</dt><dd><p><b>Boundary-space
			 policy.</b> This component controls the processing of <a title="boundary whitespace" href="#dt-boundary-whitespace">boundary whitespace</a>
			 by <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructors</a>, as described in <a href="#id-whitespace"><b>3.7.1.4 Boundary Whitespace</b></a>.</p></dd><dt><a name="GLdt-boundary-whitespace"></a>boundary whitespace</dt><dd><p><b>Boundary whitespace</b> is a
sequence of consecutive whitespace characters within the content of a <a title="direct element constructor" href="#dt-direct-elem-const">direct element constructor</a>, that is delimited at each end either by the start or
end of the content, or by a <a href="#doc-xpath-DirectConstructor">DirectConstructor</a>, or by an <a href="#doc-xpath-EnclosedExpr">EnclosedExpr</a>. For this purpose, characters generated by
   <a title="character reference" href="#dt-character-reference">character references</a> such as <code>&amp;#x20;</code> or by <a href="#doc-xpath-CDataSection">CdataSections</a> are not
   considered to be whitespace characters.</p></dd><dt><a name="GLdt-built-in-function"></a>built-in function</dt><dd><p>The <b>built-in functions</b> supported by [XPath/XQuery] are defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p></dd><dt><a name="GLdt-character-reference"></a>character reference</dt><dd><p>A <b>character reference</b> is an XML-style reference to a <a href="#Unicode">[Unicode]</a> character, identified by its decimal or hexadecimal code point.</p></dd><dt><a name="GLdt-collation"></a>collation</dt><dd><p>A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p></dd><dt><a name="GLdt-comma-operator"></a>comma operator</dt><dd><p>One way to construct a sequence is by using the <b>comma operator</b>, which evaluates each of its operands and concatenates the resulting sequences, in order, into a single result sequence.</p></dd><dt><a name="GLdt-computed-elem-const"></a>computed element constructor</dt><dd><p>A <b>computed element constructor</b> creates an element node, allowing both the name and the content of the node to be computed.</p></dd><dt><a name="GLdt-construction-decl"></a>construction declaration</dt><dd><p>A <b>construction declaration</b> sets the <a title="construction mode" href="#dt-construction-mode">construction
	 mode</a> in the <a title="static context" href="#dt-static-context">static
	 context</a>, overriding any implementation-defined default.</p></dd><dt><a name="GLdt-construction-mode"></a>construction mode</dt><dd><p><b>Construction mode.</b> The
			 construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction    retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xdt:untyped</code>; all element nodes copied during node construction receive the type <code>xdt:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xdt:untypedAtomic</code>.</p></dd><dt><a name="GLdt-constructor-function"></a>constructor function</dt><dd><p>The <b>constructor function</b> for a given type is used to convert instances of other atomic types into the given type. The semantics of the constructor function <code>T($arg)</code> are defined to be equivalent to the expression <code>($arg cast as T?)</code>.</p></dd><dt><a name="GLdt-content-expression"></a>content expression</dt><dd><p>The final part of a
   computed constructor is an expression enclosed in braces, called
   the <b>content expression</b> of the constructor, that generates the content of
   the node.</p></dd><dt><a name="GLdt-context-item"></a>context item</dt><dd><p>The <b>context item</b>
is the item currently being processed. An item is
either an atomic value or a node.</p></dd><dt><a name="GLdt-context-item-static-type"></a>context item static type</dt><dd><p><b>Context item static type.</b> This component defines the <a title="static type" href="#dt-static-type">static type</a> of the context item within the scope of a given expression.</p></dd><dt><a name="GLdt-context-node"></a>context node</dt><dd><p>When the context item is a
node, it can also be referred to as the <b>context
node</b>.</p></dd><dt><a name="GLdt-context-position"></a>context position</dt><dd><p>The <b>context
position</b> is the position of the context item within the
sequence of items currently being processed.</p></dd><dt><a name="GLdt-context-size"></a>context size</dt><dd><p>The <b>context
size</b> is the number of items in the sequence of items currently
being processed.</p></dd><dt><a name="GLdt-copy-namespaces-decl"></a>copy-namespaces declaration</dt><dd><p>A <b>copy-namespaces declaration</b> sets the value of <a title="copy-namespaces mode" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> in the <a title="static context" href="#dt-static-context">static context</a>, overwriting any implementation-defined default. Copy-namespaces mode  controls the 
namespace bindings that are assigned when an existing element node is 
copied by an element constructor.</p></dd><dt><a name="GLdt-copy-namespaces-mode"></a>copy-namespaces mode</dt><dd><p><b>Copy-namespaces mode.</b> This component controls the namespace bindings that 
are assigned when an existing element node is copied by an element 
constructor, as described in <a href="#id-element-constructor"><b>3.7.1 Direct Element Constructors</b></a>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.</p></dd><dt><a name="GLdt-date-time"></a>current dateTime</dt><dd><p><b>Current dateTime.</b> This information represents
				an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> point in time during the processing of <span class="xquery"><span class="xquery"><span class="xquery">a query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">an expression</span></span></span>, and includes an explicit timezone. It can be retrieved by the  <code>fn:current-dateTime</code> function. If invoked multiple times during the execution of <span class="xquery"><span class="xquery"><span class="xquery">a query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">an expression</span></span></span>,
				this function always returns the same result.</p></dd><dt><a name="GLdt-datamodel"></a>data model</dt><dd><p>[XPath/XQuery] operates on the abstract,
	logical structure of an XML document, rather than its surface
	syntax.  This logical structure, known as the <b>data
	model</b>,  is defined in the <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> document.</p></dd><dt><a name="GLdt-data-model-instance"></a>data model instance</dt><dd><p>The term <b>data model instance</b> is used, synonymously with the term <b>value</b>, to denote an unconstrained sequence of <a title="node" href="#dt-node">nodes</a> and/or <a title="atomic value" href="#dt-atomic-value">atomic values</a>.</p></dd><dt><a name="GLdt-data-model-schema"></a>data model schema</dt><dd><p>For a given node in a <a title="data model instance" href="#dt-data-model-instance">data model instance</a>, the
<b>data model schema</b> is defined as the schema from which the
<a title="type annotation" href="#dt-type-annotation">type annotation</a> of that node was derived.</p></dd><dt><a name="GLdt-def-collation"></a>default collation</dt><dd><p><b>Default
				collation.</b> This identifies one of the collations in <a title="statically known collations" href="#dt-static-collations">statically known collations</a> as the  collation to be
				used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no
				explicit collation is
				specified.</p></dd><dt><a name="GLdt-default-collation-decl"></a>default collation declaration</dt><dd><p>A <b>default collation declaration</b> sets the value of the <a title="default collation" href="#dt-def-collation">default
	 collation</a> in the <a title="static context" href="#dt-static-context">static context</a>, overriding any implementation-defined default.</p></dd><dt><a name="GLdt-default-collection"></a>default collection</dt><dd><p><b>Default collection.</b> This is the sequence of nodes that would result from calling the <code>fn:collection</code> function with no arguments.</p></dd><dt><a name="GLdt-def-elemtype-ns"></a>default element/type namespace</dt><dd><p><b>Default element/type namespace.</b> This is a
				namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a
				position where an element or type name is expected.</p></dd><dt><a name="GLdt-def-fn-ns"></a>default function namespace</dt><dd><p><b>Default function namespace.</b> This is a
				namespace URI or "none". The namespace URI, if present, is used for any unprefixed QName appearing in a position where a function name is expected.</p></dd><dt><a name="GLdt-default-empty-order"></a>default order for empty sequences</dt><dd><p><b>Default order for empty sequences.</b> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <a href="#id-orderby-return"><b>3.9.3 Order By and Return Clauses</b></a>.</p></dd><dt><a name="GLdelimiting-token"></a>Delimiting Terminal</dt><dd><p>The <b>delimiting terminal</b> symbols are: "=", ";", ",", "$", ":=", "(", ")", "!=", "&lt;=", "&gt;", "&gt;=", "&lt;&lt;", "&gt;&gt;", "::", "@", "..", "*", "[", "]", ".", "?", "+", <a href="#prod-xpath-PredefinedEntityRef">PredefinedEntityRef</a>, "{", "}", "{{", "}}", "&lt;", """, "'", "/&gt;", "&lt;/", "(#", "#)", "&lt;?", "?&gt;", "&lt;![CDATA[", "]]&gt;", "&lt;!--", "--&gt;", <a href="#prod-xpath-Comment">Comment</a>, "/", "//", <a href="#prod-xpath-CharRef">CharRef</a>, ":", <a href="#prod-xpath-S">S</a></p></dd><dt><a name="GLdt-direct-elem-const"></a>direct element constructor</dt><dd><p>A <b>direct element constructor</b> is a form of element constructor in which the name of the constructed element is a constant.</p></dd><dt><a name="GLdt-document-order"></a>document order</dt><dd><p>Informally, <b>document order</b> is the order in
which nodes appear in the XML serialization of a document.</p></dd><dt><a name="GLdt-dynamic-context"></a>dynamic context</dt><dd><p>The <b>dynamic
context</b> of an expression is defined as information that is
available at the time the expression is evaluated.</p></dd><dt><a name="GLdt-dynamic-error"></a>dynamic error</dt><dd><p>A <b>dynamic
error</b> is an error that
must be detected during the dynamic evaluation phase and may be detected
during the static analysis phase.
Numeric overflow is an example of a dynamic error. 
</p></dd><dt><a name="GLdt-dynamic-evaluation"></a>dynamic evaluation phase</dt><dd><p>The <b>dynamic evaluation phase</b> is the phase during which the value of an expression is computed.</p></dd><dt><a name="GLdt-dynamic-type"></a>dynamic type</dt><dd><p>A <b>dynamic type</b> is associated with each value as it is computed. The dynamic type of a value may be more specific than the <a title="static type" href="#dt-static-type">static type</a> of the expression that computed it (for example, the  static type of an expression might be <code>xs:integer*</code>, denoting a sequence of zero or more integers, but at evaluation time its value may have the dynamic type <code>xs:integer</code>, denoting exactly one integer.)</p></dd><dt><a name="GLdt-ebv"></a>effective boolean value</dt><dd><p>The
<b>effective boolean value</b> of a value is defined as the result
of applying the <code>fn:boolean</code> function to the value, as
defined in <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p></dd><dt><a name="GLdt-effective-case"></a>effective case</dt><dd><p>The <b>effective case</b> in a <code>typeswitch</code> expression is the first <code>case</code> clause such that the value of the operand expression matches the <a href="#doc-xpath-SequenceType">SequenceType</a> in the <code>case</code> clause, using the rules of <a title="SequenceType matching" href="#dt-sequencetype-matching">SequenceType
matching</a>.</p></dd><dt><a name="GLdt-empty-order-decl"></a>empty order declaration</dt><dd><p>An <b>empty order declaration</b> sets the <a title="default order for empty sequences" href="#dt-default-empty-order">default order for empty sequences</a> in the <a title="static context" href="#dt-static-context">static context,</a> which controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression.</p></dd><dt><a name="GLdt-empty-sequence"></a>empty sequence</dt><dd><p>A sequence containing zero items is called an <b>empty sequence</b>.</p></dd><dt><a name="GLdt-encoding-declaration"></a>encoding declaration</dt><dd><p>If present, a version declaration may optionally include an <b>encoding declaration</b>. The value of the string literal following the keyword <code>encoding</code> is an encoding
name, and must conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a>[<a title="err:XQST0087" href="#ERRXQST0087">err:XQST0087</a>]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as "<code>UTF-8</code>", "<code>UTF-16</code>", or "<code>US-ASCII</code>".</p></dd><dt><a name="GLdt-error-value"></a>error value</dt><dd><p>In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <b>error values</b>.</p></dd><dt><a name="GLdt-expanded-qname"></a>expanded QName</dt><dd><p>An <b>expanded QName</b> consists of an optional namespace URI and a local name. An expanded QName also retains its original namespace prefix (if any), to facilitate casting the expanded QName into a string.</p></dd><dt><a name="GLdt-expression-context"></a>expression context</dt><dd><p>The <b>expression context</b> for a given expression consists of
		all the information that can affect the result of the expression.</p></dd><dt><a name="GLdt-extension-expression"></a>extension expression</dt><dd><p>An <b>extension expression</b> is an expression whose semantics are
<a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a name="GLdt-external-function"></a>external function</dt><dd><p><b>External functions</b> are functions that are implemented outside the query environment.</p></dd><dt><a name="GLdt-filter-expression"></a>filter expression</dt><dd><p>A <b>filter
		expression</b> consists simply of a <b>primary
		expression</b> followed by zero or more
		<a title="predicate" href="#dt-predicate">predicates</a>. The result of the filter expression consists of
		all the items returned by the primary expression for
		which all the predicates are true.</p></dd><dt><a name="GLdt-focus"></a>focus</dt><dd><p>The first three components of
the <a title="dynamic context" href="#dt-dynamic-context">dynamic context</a>
(context item, context position, and context size) are called the
<b>focus</b> of the expression. </p></dd><dt><a name="GLdt-full-axis-feature"></a>Full Axis Feature</dt><dd><p>A conforming XQuery
                    implementation that supports the <b>Full Axis Feature</b>
                    <a title="must" href="#must">MUST</a> support all the <a title="optional axis" href="#dt-optional-axis">optional axes</a>.</p></dd><dt><a name="GLdt-function-implementation"></a>function implementation</dt><dd><p><b>Function implementations</b>. Each function in <a title="function signature" href="#dt-function-signature">function signatures</a> has a function implementation that enables the function to map instances of its parameter types into an instance of its result type. <span class="xquery"><span class="xquery"><span class="xquery">For a
			 <a title="user-defined function" href="#dt-udf">user-defined function</a>, the
			 function implementation is an XQuery
			 expression. For a <a title="built-in function" href="#dt-built-in-function">built-in function</a> or <a title="external function" href="#dt-external-function">external
			 function</a>, the function implementation is
			 <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</span></span></span></p></dd><dt><a name="GLdt-function-signature"></a>function signature</dt><dd><p><b>Function signatures.</b> This component defines the set of functions that are available
				to be called from within an
			 expression. Each function is uniquely
			 identified by its <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> and its arity (number
			 of parameters).</p></dd><dt><a name="GLdt-gregorian"></a>Gregorian</dt><dd><p>In the operator mapping tables,
the term <b>Gregorian</b> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.</p></dd><dt><a name="GLIgnorableWhitespace"></a>Ignorable whitespace</dt><dd><p>An <b>ignorable whitespace</b> character    is any <a title="Whitespace" href="#Whitespace">whitespace character</a> that may occur between <a title="terminal" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with  a <a href="#ExplicitWhitespaceHandling">ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><b>A.2.4.2 Explicit  Whitespace Handling</b></a>).</p></dd><dt><a name="GLdt-implementation-defined"></a>implementation defined</dt><dd><p><b>Implementation-defined</b>
		indicates an aspect that may differ between
		implementations, but must be specified by the
		implementor for each particular
		implementation.</p></dd><dt><a name="GLdt-implementation-dependent"></a>implementation   dependent</dt><dd><p><b>Implementation-dependent</b>
		indicates an aspect that may differ between
		implementations, is not specified by this or any W3C
		specification, and is not required to be specified by
		the implementor for any particular
		implementation.</p></dd><dt><a name="GLdt-timezone"></a>implicit timezone</dt><dd><p><b>Implicit timezone.</b> This is the timezone to be used when a date,
time, or dateTime value that does not have a timezone is used in a
comparison or arithmetic operation. The implicit timezone is an  <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> value of type
<code>xdt:dayTimeDuration</code>. See <a href="#XMLSchema">[XML Schema]</a> for the range of legal values
                         of a timezone.</p></dd><dt><a name="GLdt-initializing-expression"></a>initializing expression</dt><dd><p>If a variable declaration includes an
	 expression, the expression is called an <b>initializing expression</b>.</p></dd><dt><a name="GLdt-is-attrs"></a>in-scope attribute declarations</dt><dd><p><b>In-scope attribute
declarations.</b> Each attribute declaration is identified either
by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an
<a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute
declaration).  <span class="xquery"><span class="xquery"><span class="xquery">If the <a title="schema import feature" href="#dt-schema-import-feature">Schema Import Feature</a> is
supported, in-scope attribute declarations include all attribute
declarations found in imported
schemas.</span></span></span></p></dd><dt><a name="GLdt-is-elems"></a>in-scope element declarations</dt><dd><p><b>In-scope element declarations.</b> Each element
declaration is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> (for a top-level element
declaration) or by an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a
local element declaration). <span class="xquery"><span class="xquery"><span class="xquery"> If the <a title="schema import feature" href="#dt-schema-import-feature">Schema Import Feature</a> is
supported, in-scope element declarations include all element
declarations found in imported schemas. </span></span></span></p></dd><dt><a name="GLdt-in-scope-namespaces"></a>in-scope namespaces</dt><dd><p>The <b>in-scope namespaces</b> property of an element node is a set of <b>namespace bindings</b>, each of which associates a namespace prefix with a URI, thus defining the set of namespace prefixes that are available for interpreting QNames within the scope of the element. For a given element, one namespace binding may have an empty prefix; the URI of this namespace binding is the default namespace within the scope of the element.</p></dd><dt><a name="GLdt-issd"></a>in-scope schema definitions</dt><dd><p><b>In-scope schema
			 definitions.</b> This is a generic term
			 for all the element declarations, attribute declarations, and schema type
			 definitions that are in scope during
			 processing of an expression.</p></dd><dt><a name="GLdt-is-types"></a>in-scope schema type</dt><dd><p><b>In-scope schema types.</b> Each schema type
			        definition is identified either by an <a title="expanded QName" href="#dt-expanded-qname">expanded
			        QName</a> (for a <b>named type</b>)
			        or by an <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a> type
			        identifier (for an <b>anonymous
			        type</b>). The in-scope schema types include the predefined schema types described in <a href="#id-predefined-types"><b>2.5.1 Predefined Schema Types</b></a>.

                                <span class="xquery"><span class="xquery"><span class="xquery">If the
                                <a title="schema import feature" href="#dt-schema-import-feature">Schema Import Feature</a> is
                                supported, in-scope schema types
                                also include all type definitions
                                found in imported schemas.</span></span></span>

                         </p></dd><dt><a name="GLdt-in-scope-variables"></a>in-scope variables</dt><dd><p><b>In-scope variables.</b> This is a set of (expanded QName, type) pairs. It defines the
set of variables that are available for reference within an
expression. The <a title="expanded QName" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the
<a title="static type" href="#dt-static-type">static type</a> of the
variable.</p></dd><dt><a name="GLdt-item"></a>item</dt><dd><p>An
	 <b>item</b> is either an <a title="atomic value" href="#dt-atomic-value">atomic value</a> or a <a title="node" href="#dt-node">node</a>.</p></dd><dt><a name="GLdt-kind-test"></a>kind test</dt><dd><p>An alternative
		  form of a node test called a
		  <b>kind test</b> can select nodes based
		  on their kind, name, and <a title="type annotation" href="#dt-type-annotation">type annotation</a>.</p></dd><dt><a name="GLdt-library-module"></a>library module</dt><dd><p>A module that does not contain a <a title="query body" href="#dt-queryBody">Query Body</a> is called a <b>library module</b>. A library module consists of a <a title="module declaration" href="#dt-module-declaration">module declaration</a> followed by  a <a title="Prolog" href="#dt-prolog">Prolog</a>.</p></dd><dt><a name="GLdt-literal"></a>literal</dt><dd><p>A <b>literal</b> is a direct syntactic representation of an
		atomic value.</p></dd><dt><a name="GLdt-main-module"></a>main module</dt><dd><p>A <b>main module</b> consists of a
<a title="Prolog" href="#dt-prolog">Prolog</a> followed by a <a title="query body" href="#dt-queryBody">Query Body</a>.</p></dd><dt><a name="GLmay"></a>may</dt><dd><p>
            <b>MAY</b> means that an item is truly optional.</p></dd><dt><a name="GLdt-module"></a>module</dt><dd><p>A <b>module</b> is a fragment of XQuery code that conforms to the <a href="#doc-xpath-Module">Module</a> grammar and can independently undergo the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a> described in <a href="#id-expression-processing"><b>2.2.3 Expression
Processing</b></a>. Each module is either a <a title="main module" href="#dt-main-module">main module</a> or a <a title="library module" href="#dt-library-module">library module</a>.</p></dd><dt><a name="GLdt-module-declaration"></a>module declaration</dt><dd><p>A <b>module declaration</b> serves to identify a <a title="module" href="#dt-module">module</a> as a <a title="library module" href="#dt-library-module">library module</a>. A module declaration begins with the keyword <code>module</code> and contains a namespace prefix and a <a href="#doc-xpath-URILiteral">URILiteral</a>.</p></dd><dt><a name="GLdt-module-feature"></a>module feature</dt><dd><p>A conforming XQuery
                    implementation that supports the <b>Module Feature</b> allows a query
                    Prolog to contain a <b>Module Import</b> and allows <b>library
                    modules</b> to be created.</p></dd><dt><a name="GLdt-module-import"></a>module import</dt><dd><p>A <b>module import</b> imports the function
	 declarations and variable declarations from one or more
	 <a title="library module" href="#dt-library-module">library modules</a> into the <a title="function signature" href="#dt-function-signature">function signatures</a> and  <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> of the importing <a title="module" href="#dt-module">module</a>.</p></dd><dt><a name="GLmust"></a>must</dt><dd><p>
            <b>MUST</b> means that the item is an absolute requirement of the specification.</p></dd><dt><a name="GLdt-name-expression"></a>name expression</dt><dd><p>When an expression is used to specify the name of a constructed node, that expression is called the <b>name expression</b> of the constructor.</p></dd><dt><a name="GLdt-namespace-declaration"></a>namespace declaration</dt><dd><p>A <b>namespace declaration</b> declares a namespace prefix and
	 associates it with a namespace URI, adding the (prefix, URI) pair to the set of
	 <a title="statically known namespaces" href="#dt-static-namespaces">statically known namespaces</a>.</p></dd><dt><a name="GLdt-namespace-decl-attr"></a>namespace declaration attribute</dt><dd><p>A
  <b>namespace declaration attribute</b>  is used inside a direct element constructor. Its purpose is to bind a namespace prefix or to set the <a title="default element/type namespace" href="#dt-def-elemtype-ns">default element/type namespace</a> for the constructed element node, including its attributes.</p></dd><dt><a name="GLdt-namespace-sensitive"></a>namespace-sensitive</dt><dd><p>A value is <b>namespace-sensitive</b> if it
includes an item that has a <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of <code>xs:QName</code> or <code>xs:NOTATION</code> or a type
derived by restriction therefrom.</p></dd><dt><a name="GLdt-name-test"></a>name test</dt><dd><p>A node test that consists only of a QName or a
		  Wildcard is called a <b>name test</b>.</p></dd><dt><a name="GLdt-node"></a>node</dt><dd><p>A <b>node</b> is an instance of one of the
	  <b>node kinds</b> defined in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a>.</p></dd><dt><a name="GLdt-node-test"></a>node test</dt><dd><p>A <b>node test</b> is a condition that must
		  be true for each node selected by a <a title="step" href="#dt-step">step</a>.</p></dd><dt><a name="GLnon-delimiting-token"></a>Non-delimiting terminals</dt><dd><p>The <b>Non-delimiting terminals</b> symbols are:  "xquery", "version", "encoding", "module", "namespace", "declare", "boundary-space", "preserve", "strip", "default", "element", "function", "option", "ordering", "ordered", "unordered", "order", "empty", "greatest", "least", "copy-namespaces", "no-preserve", "inherit", "no-inherit", "collation", "base-uri", "import", "schema", "at", "variable", "external", "construction", "as", "return", "for", "in", "let", "where", "by", "stable", "ascending", "descending", "some", "every", "satisfies", "typeswitch", "case", "if", "then", "else", "eq", "ne", "lt", "le", "gt", "ge", "is", "validate", "lax", "strict", "child", "descendant", "attribute", "self", "descendant-or-self", "following-sibling", "following", "parent", "ancestor", "preceding-sibling", "preceding", "ancestor-or-self", "document", "text", "comment", "processing-instruction", "empty-sequence", "item", "node", "document-node", "schema-attribute", "schema-element", <a href="#prod-xpath-IntegerLiteral">IntegerLiteral</a>, <a href="#prod-xpath-DecimalLiteral">DecimalLiteral</a>, <a href="#prod-xpath-DoubleLiteral">DoubleLiteral</a>, <a href="#prod-xpath-StringLiteral">StringLiteral</a>, <a href="#prod-xpath-EscapeQuot">EscapeQuot</a>, <a href="#prod-xpath-EscapeApos">EscapeApos</a>, <a href="#prod-xpath-ElementContentChar">ElementContentChar</a>, <a href="#prod-xpath-QuotAttrContentChar">QuotAttrContentChar</a>, <a href="#prod-xpath-AposAttrContentChar">AposAttrContentChar</a>, <a href="#prod-xpath-PITarget">PITarget</a>, <a href="#prod-xpath-QName">QName</a>, <a href="#prod-xpath-NCName">NCName</a>, <a href="#prod-xpath-Char">Char</a>, <a href="#prod-xpath-Digits">Digits</a></p></dd><dt><a name="GLdt-numeric"></a>numeric</dt><dd><p>When referring to a type, the term <b>numeric</b> denotes the types
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code>.</p></dd><dt><a name="GLdt-numeric-predicate"></a>numeric predicate</dt><dd><p>A predicate whose predicate expression returns a numeric type is called a <b>numeric predicate</b>.</p></dd><dt><a name="GLdt-operator-function"></a>operator function</dt><dd><p>For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <b>operator function</b> that implements the semantics of the operator for the given types.</p></dd><dt><a name="GLdt-optional-axis"></a>optional axis</dt><dd><p>The following axes are
                    designated as <b>optional axes</b>: <code>ancestor</code>,
                        <code>ancestor-or-self</code>, <code>following</code>,
                        <code>following-sibling</code>, <code>preceding</code>, and
                        <code>preceding-sibling</code>.</p></dd><dt><a name="GLdt-option-declaration"></a>option declaration</dt><dd><p>An <b>option declaration</b> declares an option that affects the behavior of
a particular implementation. Each option consists of an identifying QName and a StringLiteral.</p></dd><dt><a name="GLdt-ordering-mode"></a>ordering mode</dt><dd><p><b>Ordering mode.</b> Ordering mode, which has the value <code>ordered</code> or <code>unordered</code>, affects the ordering of the result sequence returned by certain <a title="path expression" href="#dt-path-expression">path expressions</a>, <code>union</code>, <code>intersect</code>, and <code>except</code> expressions, and FLWOR expressions that have no <code>order by</code> clause.</p></dd><dt><a name="GLdt-ordering-mode-decl"></a>ordering mode declaration</dt><dd><p>An <b>ordering mode declaration</b> sets the <a title="ordering mode" href="#dt-ordering-mode">ordering mode</a> in the <a title="static context" href="#dt-static-context">static context</a>, overriding any implementation-defined default.</p></dd><dt><a name="GLdt-path-expression"></a>path expression</dt><dd><p>A <b>path expression</b> can be used to locate nodes
	 within trees. A path expression consists of a series of one or more
	 <a title="step" href="#dt-step">steps</a>, separated by "<code>/</code>" or
	 "<code>//</code>", and optionally beginning with
	 "<code>/</code>" or "<code>//</code>".</p></dd><dt><a name="GLdt-pragma"></a>pragma</dt><dd><p>A <b>pragma</b> is denoted by the delimiters <code>(#</code> and <code>#)</code>, and consists of an identifying QName followed by <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> content.</p></dd><dt><a name="GLdt-predefined-entity-reference"></a>predefined entity reference</dt><dd><p>A <b>predefined entity reference</b> is a short sequence of characters, beginning with an ampersand, that represents a single character that might otherwise have syntactic significance.</p></dd><dt><a name="GLdt-predicate"></a>predicate</dt><dd><p>A <b>predicate</b> consists of an expression, called a <b>predicate
		expression</b>, enclosed in square brackets. A predicate serves to filter a sequence, retaining some items and discarding others.</p></dd><dt><a name="GLdt-primary-expression"></a>primary expression</dt><dd><p><b>Primary expressions</b> are the basic primitives of the
	 language. They include literals, variable references,  context item expressions, <span class="xquery"><span class="xquery"><span class="xquery">constructors, </span></span></span>and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</p></dd><dt><a name="GLdt-principal-node-kind"></a>principal node kind</dt><dd><p>Every axis has a <b>principal node kind</b>. If an axis can
		  contain elements, then the principal node kind is element; otherwise, it is the
		  kind of nodes that the axis can contain.</p></dd><dt><a name="GLdt-prolog"></a>Prolog</dt><dd><p>A <b>Prolog</b> is a series of declarations and imports that define the processing environment for the <a title="module" href="#dt-module">module</a> that contains the Prolog.</p></dd><dt><a name="GLdt-qname"></a>QName</dt><dd><p>Lexically, a <b>QName</b> consists of an optional namespace prefix and a local name. If the namespace prefix is present, it is separated from the local name by a colon.</p></dd><dt><a name="GLdt-query"></a>query</dt><dd><p>A <b>query</b> consists of one or more <a title="module" href="#dt-module">modules</a>.</p></dd><dt><a name="GLdt-queryBody"></a>query body</dt><dd><p>The <b>Query Body</b>, if present, consists of an expression that defines the result of the query.</p></dd><dt><a name="GLdt-reverse-document-order"></a>reverse document order</dt><dd><p>The node ordering that is the reverse of document order is called <b>reverse document order</b>.</p></dd><dt><a name="GLdt-schema-import"></a>schema import</dt><dd><p>A <b>schema
import</b> imports the element declarations, attribute declarations, and type definitions
from a schema into the <a title="in-scope schema definitions" href="#dt-issd">in-scope schema
definitions</a>.</p></dd><dt><a name="GLdt-schema-import-feature"></a>schema import feature</dt><dd><p>The <b>Schema
                        Import Feature</b> permits the query Prolog to contain a <a title="schema import" href="#dt-schema-import">schema import</a>.</p></dd><dt><a name="GLdt-schema-type"></a>schema type</dt><dd><p>A <b>schema type</b> is a type that is (or could be) defined using the facilities of <a href="#XMLSchema">[XML Schema]</a> (including the built-in types of <a href="#XMLSchema">[XML Schema]</a>).</p></dd><dt><a name="GLdt-schema-validation-feature"></a>schema validation feature</dt><dd><p>The
                        <b>Schema Validation Feature</b> permits a query to contain a
                        <code>validate</code> expression (see <a href="#id-validate"><b>3.14 Validate Expressions</b></a>.)</p></dd><dt><a name="GLdt-sequence"></a>sequence</dt><dd><p>A
<b>sequence</b> is an ordered collection of zero or more
<a title="item" href="#dt-item">items</a>.</p></dd><dt><a name="GLdt-sequence-type"></a>sequence type</dt><dd><p>A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xpath-SequenceType">SequenceType</a>
syntax. Sequence types are used whenever it is necessary to refer to a type in an [XPath/XQuery] expression. The term <b>sequence type</b> suggests that this syntax is used to describe the type of an [XPath/XQuery] value, which is always a sequence.</p></dd><dt><a name="GLdt-sequencetype-matching"></a>SequenceType matching</dt><dd><p>During evaluation of an expression, it is sometimes necessary to determine whether a value with a known <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> "matches" an expected  <a title="sequence type" href="#dt-sequence-type">sequence type</a>. This process is known as <b>SequenceType matching</b>.</p></dd><dt><a name="GLdt-serialization"></a>serialization</dt><dd><p><b>Serialization</b> is the process of converting a <a title="data model instance" href="#dt-data-model-instance">data model instance</a> into a sequence of octets (step DM4 in Figure 1.) </p></dd><dt><a name="GLdt-serialization-feature"></a>serialization feature</dt><dd><p>A conforming
                    XQuery implementation that supports the <b>Serialization Feature</b>
                    <a title="must" href="#must">MUST</a> provide means for serializing the result of a
                    query, as specified in <a href="#id-serialization"><b>2.2.4 Serialization</b></a>.</p></dd><dt><a name="GLdt-setter"></a>setter</dt><dd><p><b>Setters</b> are declarations that set the value of some property that affects query processing, such as construction mode, ordering mode, or default collation.</p></dd><dt><a name="GLshould"></a>should</dt><dd><p>
            <b>SHOULD</b> means that there may exist valid reasons in particular circumstances
            to ignore a particular item, but the full implications must be understood and carefully
            weighed before choosing a different course.</p></dd><dt><a name="GLdt-singleton"></a>singleton</dt><dd><p>A sequence containing exactly one item is called a
	 <b>singleton</b>.</p></dd><dt><a name="GLstable"></a>stable</dt><dd><p>Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xquery"><span class="xquery"><span class="xquery">query</span></span></span><span class="xpath"><span class="xpath"><span class="xpath">expression</span></span></span>, even if this order is <a title="implementation   dependent" href="#dt-implementation-dependent">implementation-dependent</a>.</p></dd><dt><a name="GLdt-static-collations"></a>statically known collations</dt><dd><p><b>Statically known collations.</b> This is an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> set of (URI,
				collation) pairs. It defines the names of the collations that are available for
				use in processing <span class="xquery"><span class="xquery"><span class="xquery">queries and</span></span></span> expressions.</p></dd><dt><a name="GLdt-known-collections"></a>statically known  collections</dt><dd><p><b>Statically known collections.</b> This is a
mapping from strings onto types.  The string represents the absolute
URI of a resource that is potentially available using the
<code>fn:collection</code> function.  The type is the type of the
sequence of nodes that would result from calling the
<code>fn:collection</code> function with this URI as its
argument.</p></dd><dt><a name="GLdt-known-default-collection"></a>statically known default collection type</dt><dd><p><b>Statically known default collection type.</b> This is the type of the sequence of nodes that would result from calling the <code>fn:collection</code> function with no arguments.</p></dd><dt><a name="GLdt-known-docs"></a>statically known  documents</dt><dd><p><b>Statically known documents.</b> This is a mapping
from strings onto types.  The string represents the absolute URI of a
resource that is potentially available using the <code>fn:doc</code>
function.  The type is the <a title="static type" href="#dt-static-type">static type</a> of a call to <code>fn:doc</code>  with the given URI as its
literal argument. </p></dd><dt><a name="GLdt-static-namespaces"></a>statically known namespaces</dt><dd><p><b>Statically known namespaces.</b> This is a set of (prefix,
				URI) pairs that define all the namespaces that are known during static processing of a given expression.</p></dd><dt><a name="GLdt-static-analysis"></a>static analysis phase</dt><dd><p>The
<b>static analysis phase</b> depends on the expression itself
and on the <a title="static context" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does
not depend on input data (other than schemas).</p></dd><dt><a name="GLdt-static-context"></a>static context</dt><dd><p>The <b>static context</b> of an expression is
		  the information that is available during static analysis of the expression, prior
		  to its evaluation.</p></dd><dt><a name="GLdt-static-error"></a>static error</dt><dd><p>
A <b>static error</b> is an 
error that
must be detected during the static analysis phase.
A syntax error is an example of a <a title="static error" href="#dt-static-error">static error</a>.</p></dd><dt><a name="GLdt-static-type"></a>static type</dt><dd><p>The <b>static type</b> of an expression is a type such that, when the expression is evaluated, the resulting value will always conform to the static type.</p></dd><dt><a name="GLdt-static-typing-extension"></a>static typing extension</dt><dd><p>A <b>static typing extension</b> is an
                            <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> type inference rule that infers a more
                        precise static type than that inferred by the type inference rules in
                            <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p></dd><dt><a name="GLdt-xpath-static-typing-extension"></a>static typing extension</dt><dd><p>A
                            <b>static typing extension</b> is an <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a> type inference rule that
                        infers a more precise static type than that inferred by the type inference
                        rules in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>.</p></dd><dt><a name="GLdt-static-typing-feature"></a>static typing feature</dt><dd><p>The <b>Static Typing Feature</b> provides support for the static
                    semantics defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, and requires
                    implementations to detect and report <a title="type error" href="#dt-type-error">type
                    errors</a> during the <a title="static analysis phase" href="#dt-static-analysis">static analysis
                        phase</a>.</p></dd><dt><a name="GLdt-xpath-static-typing-feature"></a>static typing feature</dt><dd><p>The <b>Static
                    Typing Feature</b> is an optional feature of XPath that provides support for the static semantics defined in <a href="#XQueryFormalSemantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, and requires implementations to detect and report <a title="type error" href="#dt-type-error">type errors</a> during the <a title="static analysis phase" href="#dt-static-analysis">static analysis phase</a>.</p></dd><dt><a name="GLdt-step"></a>step</dt><dd><p>A <b>step</b> is a part of a <a title="path expression" href="#dt-path-expression">path expression</a> that generates a sequence of items
		and then filters the sequence by zero or more
		<a title="predicate" href="#dt-predicate">predicates</a>. The value of the step
		consists of those items that satisfy the
		predicates. A step may be either an <a title="axis step" href="#dt-axis-step">axis step</a> or a <a title="filter expression" href="#dt-filter-expression">filter expression</a>.</p></dd><dt><a name="GLdt-string-value"></a>string value</dt><dd><p>The <b>string
 value</b> of a node is a string and 
 can be extracted by applying the <code>fn:string</code>
 function to the node.</p></dd><dt><a name="GLdt-substitution-group"></a>substitution group</dt><dd><p><b>Substitution groups</b> are defined in <a href="#XMLSchema">[XML Schema]</a> Part 1,  Section 2.2.2.2. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of  the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</p></dd><dt><a name="GLdt-subtype-substitution"></a>subtype substitution</dt><dd><p>The use of a value whose <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> is derived from an expected type is known as <b>subtype substitution</b>.</p></dd><dt><a name="GLsymbol"></a>symbol</dt><dd><p>Each rule in the grammar defines one symbol, in the form</p></dd><dt><a name="GLsymbolseparators"></a>symbol separators</dt><dd><p><a title="Whitespace" href="#Whitespace">Whitespace</a> and <a href="#doc-xpath-Comment">Comments</a>  function as
  <b>symbol separators</b>.  For the most part, they are not mentioned
  in the grammar, and may occur between any two terminal symbols
  mentioned in the grammar, except where that is forbidden by
  the <a href="#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by the 	<a href="#parse-note-xml-version">/* xgs: xml-version */</a> annotation.
</p></dd><dt><a name="GLdt-target-namespace"></a>target namespace</dt><dd><p>Each imported schema or module is identified by its <b>target namespace</b>, which is the namespace of the objects (such as elements or functions) that are defined by the schema or module.</p></dd><dt><a name="GLterminal"></a>terminal</dt><dd><p>A <b>terminal</b> is a symbol or string or pattern that can appear
    in the right-hand side of a rule, but never appears on the
    left hand side in the main grammar, although it may appear
    on the left-hand side of a rule in the grammar for terminals.</p></dd><dt><a name="GLdt-type-annotation"></a>type annotation</dt><dd><p>Each element node and attribute node in a <a title="data model instance" href="#dt-data-model-instance">data model instance</a> has a <b>type annotation</b> (referred to in <a href="#datamodel">[XQuery 1.0 and XPath 2.0 Data Model]</a> as its <code>type-name</code> property.) The type annotation of a node is a <a title="schema type" href="#dt-schema-type">schema type</a> that describes the relationship between the <a title="string value" href="#dt-string-value">string value</a> of the node and its <a title="typed value" href="#dt-typed-value">typed value</a>.</p></dd><dt><a name="GLdt-typed-value"></a>typed value</dt><dd><p>The <b>typed value</b> of a node is a sequence of atomic values
and can be extracted by applying the <code>fn:data</code> function to
the node.</p></dd><dt><a name="GLdt-type-error"></a>type error</dt><dd><p>A <b>type
error</b> may be raised during the static analysis phase or the dynamic evaluation phase.
During the static analysis phase, a <a title="type error" href="#dt-type-error">type error</a> occurs
when the <a title="static type" href="#dt-static-type">static type</a> of an expression does not match the expected type
of the context in which the expression occurs.
During the dynamic evaluation phase, a <a title="type error" href="#dt-type-error">type error</a> occurs 
when the <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a> of a value does not match the expected type of 
the context in which the value occurs. 
</p></dd><dt><a name="GLdt-type-promotion"></a>type promotion</dt><dd><p>Under certain circumstances, an atomic value can be promoted from
one type to another. <b>Type promotion</b> is used in evaluating function calls (see <a href="#id-function-calls"><b>3.1.5 Function Calls</b></a>)<span class="xquery"><span class="xquery"><span class="xquery">, <code>order by</code> clauses (see <a href="#id-orderby-return"><b>3.9.3 Order By and Return Clauses</b></a>),</span></span></span>  and operators that accept numeric or string operands (see <a href="#mapping"><b>B.2 Operator Mapping</b></a>).</p></dd><dt><a name="GLdt-URI"></a>URI</dt><dd><p>Within this specification, the term <b>URI</b> refers to a Universal Resource Identifier as
defined in <a href="#RFC3986">[RFC3986]</a> and extended in <a href="#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.</p></dd><dt><a name="GLdt-udf"></a>user-defined function</dt><dd><p>For a <b>user-defined function</b>, the function declaration includes an
expression called the <b>function body</b> that defines how the result of
the function is computed from its parameters.</p></dd><dt><a name="GLdt-value"></a>value</dt><dd><p>In the <a title="data model" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" href="#dt-sequence">sequence</a>.</p></dd><dt><a name="GLdt-variable-reference"></a>variable reference</dt><dd><p>A <b>variable reference</b> is a QName preceded by a $-sign.</p></dd><dt><a name="GLdt-variable-values"></a>variable values</dt><dd><p><b>Variable values</b>. This is a set of
				(expanded QName, value) pairs. It contains the
				same <a title="expanded QName" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" href="#dt-in-scope-variables">in-scope variables</a> in the
				<a title="static context" href="#dt-static-context">static context</a> for the expression. The expanded QName is the name of the variable and the value is the dynamic value of the variable, which includes its <a title="dynamic type" href="#dt-dynamic-type">dynamic type</a>.</p></dd><dt><a name="GLdt-version-declaration"></a>version declaration</dt><dd><p>Any <a title="module" href="#dt-module">module</a> may contain a <b>version declaration</b>. If present, the version declaration occurs at the beginning of the <a title="module" href="#dt-module">module</a> and identifies the applicable XQuery syntax and semantics for the <a title="module" href="#dt-module">module</a>.</p></dd><dt><a name="GLdt-warning"></a>warning</dt><dd><p>In addition to <a title="static error" href="#dt-static-error">static errors</a>, <a title="dynamic error" href="#dt-dynamic-error">dynamic errors</a>, and <a title="type error" href="#dt-type-error">type
errors</a>, an [XPath/XQuery]
implementation may raise <b>warnings</b>, either during the <a title="static analysis phase" href="#dt-static-analysis">static analysis
phase</a> or the
<a title="dynamic evaluation phase" href="#dt-dynamic-evaluation">dynamic evaluation
phase</a>. The circumstances in which warnings are raised, and
the ways in which warnings are handled, are <a title="implementation defined" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a name="GLWhitespace"></a>Whitespace</dt><dd><p>A <b>whitespace character</b>  is any of the characters defined by <a href="http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a>.</p></dd><dt><a name="GLdt-anyAtomicType"></a>xdt:anyAtomicType</dt><dd><p><code>xdt:anyAtomicType</code> is an atomic type that includes all atomic values (and no values that
are not atomic). Its base type is
<code>xs:anySimpleType</code> from which all simple types, including atomic,
list, and union types, are derived. All primitive atomic types, such as
<code>xs:integer</code>, <code>xs:string</code>, and <code>xdt:untypedAtomic</code>, have <code>xdt:anyAtomicType</code> as their base type.</p></dd><dt><a name="GLdt-dayTimeDuration"></a>xdt:dayTimeDuration</dt><dd><p><code>xdt:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The  lexical representation of <code>xdt:dayTimeDuration</code>
is restricted to contain only day, hour, minute, and second
components.</p></dd><dt><a name="GLdt-untyped"></a>xdt:untyped</dt><dd><p><code>xdt:untyped</code> is  used as the <a title="type annotation" href="#dt-type-annotation">type annotation</a> of an element node that has not been validated, or has been validated in <code>skip</code> mode.</p></dd><dt><a name="GLdt-untypedAtomic"></a>xdt:untypedAtomic</dt><dd><p><code>xdt:untypedAtomic</code>
is an atomic type that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.</p></dd><dt><a name="GLdt-yearMonthDuration"></a>xdt:yearMonthDuration</dt><dd><p><code>xdt:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xdt:yearMonthDuration</code> is
restricted to contain only year and month
components.</p></dd><dt><a name="GLdt-xpath-compat-mode"></a>XPath 1.0 compatibility     mode</dt><dd><p><b>XPath 1.0 compatibility
			 mode.</b> <span class="xquery"><span class="xquery"><span class="xquery">This
			 component must be set by all host languages
			 that include XPath 2.0  as a subset,
			 indicating whether rules for compatibility
			 with XPath 1.0 are in effect.
			 XQuery sets the value of this component to
			 <code>false</code>.
                         </span></span></span> <span class="xpath"><span class="xpath"><span class="xpath">This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is <code>false</code>.</span></span></span></p></dd></dl></div><span class="xquery"><div class="xquery"><div class="div1">
<h2><a id="N19509" name="N19509"></a>K Example Applications (Non-Normative)</h2><p>This section
	contains examples of several important classes of queries that
	can be expressed using XQuery.  The applications described here include joins across
	multiple data sources, grouping and aggregation, queries
	based on sequential relationships, recursive transformations, and selection of distinct combinations of values.</p><div class="div2">
<h3><a id="id-joins" name="id-joins"></a>K.1 Joins</h3><p>Joins, which
				combine data from multiple sources
				into a single result, are a very
				important type of query. In this
				section we will illustrate how several
				types of joins can be expressed in
				XQuery. We will base our examples on
				the following three documents:</p><ol class="enumar"><li><p>A document named
						<code>parts.xml</code> that
						contains many
						<code>part</code> elements;
						each <code>part</code>
						element in turn
						contains
						<code>partno</code> and
						<code>description</code>
						subelements.</p></li><li><p>A document named
						<code>suppliers.xml</code> that
						contains many
						<code>supplier</code>
						elements; each
						<code>supplier</code>
						element in turn
						contains
						<code>suppno</code> and
						<code>suppname</code>
						subelements.</p></li><li><p>A document named
						<code>catalog.xml</code> that
						contains information
						about the
						relationships between
						suppliers and
						parts. The catalog
						document contains many
						<code>item</code> elements,
						each of which in turn
						contains
						<code>partno</code>,
						<code>suppno</code>, and
						<code>price</code>
						subelements.</p></li></ol><p>A conventional ("inner") join
				returns information from two or more
				related sources, as illustrated by the
				following example, which combines
				information from three documents. The example
					generates a "descriptive
					catalog" derived from the
					catalog document, but
					containing part descriptions
					instead of part numbers and
					supplier names instead of
					supplier numbers. The
					new catalog is ordered 
					alphabetically by
					part description and
					secondarily by supplier
					name.</p><div class="parse-test"><div class="exampleInner"><pre>&lt;descriptive-catalog&gt;
   { 
     for $i in fn:doc("catalog.xml")/items/item,
         $p in fn:doc("parts.xml")/parts/part[partno = $i/partno],
         $s in fn:doc("suppliers.xml")/suppliers
                  /supplier[suppno = $i/suppno]
     order by $p/description, $s/suppname
     return
        &lt;item&gt;
           {
           $p/description,
           $s/suppname,
           $i/price
           }
        &lt;/item&gt;
   }
&lt;/descriptive-catalog&gt;</pre></div></div><p>The previous query returns
				information only about parts that have
				suppliers and suppliers that have
				parts. An <b>outer join</b> is a join that
				preserves information from one or more
				of the participating sources,
				including elements that have no
				matching element in the other
				source. For example, a <b>left outer
				join</b> between suppliers and parts
				might return information about
				suppliers that have no matching parts.
				 </p><p>The following query
					demonstrates a left outer
					join. It returns names of all
					the suppliers in alphabetic
					order, including those that
					supply no parts.  In the
					result, each supplier element
					contains the descriptions of
					all the parts it supplies, in
					alphabetic order.</p><div class="parse-test"><div class="exampleInner"><pre>for $s in fn:doc("suppliers.xml")/suppliers/supplier
order by $s/suppname
return
   &lt;supplier&gt;
      { 
        $s/suppname,
        for $i in fn:doc("catalog.xml")/items/item
                 [suppno = $s/suppno],
            $p in fn:doc("parts.xml")/parts/part
                 [partno = $i/pno]
        order by $p/description
        return $p/description 
      }
   &lt;/supplier&gt;</pre></div></div><p>The previous query preserves information about
		suppliers that supply no parts. Another type of join,
		called a <b>full outer join</b>, might be used
		to preserve information about both suppliers that
		supply no parts and parts that have no supplier. The
		result of a full outer join can be structured in any
		of several ways.  The following query generates a list
		of <code>supplier</code> elements, each containing
		nested <code>part</code> elements for the parts that
		it supplies (if any), followed by a list of
		<code>part</code> elements for the parts that have no
		supplier. This might be thought of as a
		"supplier-centered" full outer join. Other forms of
		outer join queries are also possible.</p><div class="parse-test"><div class="exampleInner"><pre>&lt;master-list&gt;
 {
    for $s in fn:doc("suppliers.xml")/suppliers/supplier
    order by $s/suppname
    return
        &lt;supplier&gt;
           { 
             $s/suppname,
             for $i in fn:doc("catalog.xml")/items/item
                     [suppno = $s/suppno],
                 $p in fn:doc("parts.xml")/parts/part
                     [partno = $i/partno]
             order by $p/description
             return
                &lt;part&gt;
                   {
                     $p/description,
                     $i/price
                   }
                &lt;/part&gt; 
           }
        &lt;/supplier&gt; 
    ,
    (: parts that have no supplier :)
    &lt;orphan-parts&gt;
       { for $p in fn:doc("parts.xml")/parts/part
         where fn:empty(fn:doc("catalog.xml")/items/item
               [partno = $p/partno] )
         order by $p/description
         return $p/description 
       }
    &lt;/orphan-parts&gt;
 }
&lt;/master-list&gt;</pre></div></div><p>The previous query uses an element constructor to
		enclose its output inside a <code>master-list</code>
		element. The concatenation operator (",") is used to
		combine the two main parts of the query. The result is
		an ordered sequence of <code>supplier</code> elements
		followed by an <code>orphan-parts</code> element that
		contains descriptions of all the parts that have no
		supplier.</p></div><div class="div2">
<h3><a id="id-grouping" name="id-grouping"></a>K.2 Grouping</h3><p>Many queries
				involve forming data into groups and
				applying some aggregation function
				such as <code>fn:count</code> or
				<code>fn:avg</code> to each group. The
				following example shows how such a
				query might be expressed in XQuery,
				using the catalog document defined in
				the previous section.</p><p>This query finds the part
					number and average price for
					parts that have at least 3
					suppliers.</p><div class="parse-test"><div class="exampleInner"><pre>for $pn in fn:distinct-values(
      fn:doc("catalog.xml")/items/item/partno)
let $i := fn:doc("catalog.xml")/items/item[partno = $pn]
where fn:count($i) &gt;= 3
order by $pn
return 
   &lt;well-supplied-item&gt;
      &lt;partno&gt; {$p} &lt;/partno&gt;
      &lt;avgprice&gt; {fn:avg($i/price)} &lt;/avgprice&gt;
   &lt;/well-supplied-item&gt;</pre></div></div><p>The <code>fn:distinct-values</code> function
				in this query eliminates duplicate
				part numbers from the set of all part
				numbers in the catalog document. The
				result of <code>fn:distinct-values</code> is a
				sequence in which order is not
				significant.</p><p>Note that <code>$pn</code>, bound by a
				for clause, represents an individual
				part number, whereas <code>$i</code>, bound by a
				let clause, represents a set of items
				which serves as argument to the
				aggregate functions
				<code>fn:count($i)</code> and
				<code>fn:avg($i/price)</code>.  The query
				uses an element constructor to enclose
				each part number and average price in
				a containing element called
				<code>well-supplied-item</code>.</p><p>The method illustrated above generalizes easily to grouping by more than one data value. For example, consider a census document containing a sequence of <code>person</code> elements, each with subelements named <code>state</code>, <code>job</code>, and <code>income</code>. A census analyst might need to prepare a report listing the average <code>income</code> for each combination of <code>state</code> and <code>job</code>. This report might be produced using the following query:</p><div class="parse-test"><div class="exampleInner"><pre>for $s in fn:distinct-values(
        fn:doc("census.xml")/census/person/state),
    $j in fn:distinct-values(
        fn:doc("census.xml")/census/person/job)
let $p := fn:doc("census.xml")/census/person
        [state = $s and job = $j]
order by $s, $j
return 
   if (fn:exists($p)) then
      &lt;group&gt;
         &lt;state&gt; {$s} &lt;/state&gt;
         &lt;job&gt; {$j} &lt;/job&gt;
         &lt;avgincome&gt; {fn:avg($p/income)} &lt;/avgincome&gt;
      &lt;/group&gt;
   else ()</pre></div></div><p>The <code>if-then-else</code> expression in the above example prevents generation of groups that contain no data. For example, the census data may contain some persons who live in Nebraska, and some persons whose job is Deep Sea Fisherman, but no persons who live in Nebraska and have the job of Deep Sea Fisherman. If output groups are desired for all possible combinations of states and jobs, the <code>if-then-else</code> expression can be omitted from the query. In this case, the output may include "empty" groups such as the following:</p><div class="parse-test"><div class="exampleInner"><pre>&lt;group&gt;
   &lt;state&gt;Nebraska&lt;/state&gt;
   &lt;job&gt;Deep Sea Fisherman&lt;/state&gt;
   &lt;avgincome/&gt;
&lt;/group&gt;</pre></div></div></div><div class="div2">
<h3><a id="id-queries-on-sequence" name="id-queries-on-sequence"></a>K.3 Queries on Sequence</h3><p>XQuery uses the
		<code>&lt;&lt;</code> and <code>&gt;&gt;</code>
		operators to compare nodes based on document
		order. Although these operators are quite simple, they
		can be used to express complex queries for XML
		documents in which sequence is meaningful.  The first
		two queries in this section involve a surgical report
		that contains <code>procedure</code>,
		<code>incision</code>, <code>instrument</code>,
		<code>action</code>, and <code>anesthesia</code>
		elements.</p><p>The following query returns all the
		<code>action</code> elements that occur between the
		first and second <code>incision</code> elements inside
		the first procedure.  The original document order
		among these nodes is preserved in the result of the
		query.</p><div class="parse-test"><div class="exampleInner"><pre>let $proc := /report/procedure[1]
for $i in $proc//action
where $i &gt;&gt; ($proc//incision)[1]
   and $i &lt;&lt; ($proc//incision)[2]
return $i</pre></div></div><p>It is worth noting here that document order is
		defined in such a way that a node is considered to
		precede its descendants in document order. In the
		surgical report, an <code>action</code> is never part
		of an <code>incision</code>, but an
		<code>instrument</code> is. Since the
		<code>&gt;&gt;</code> operator is based on document
		order, the predicate <code>$i &gt;&gt;
		($proc//incision)[1]</code> is true for any
		<code>instrument</code> element that is a descendant
		of the first <code>incision</code> element in the
		first procedure.</p><p>For some queries, it may be
		helpful to define a function that can test whether a
		node precedes another node without being its
		ancestor. The following function returns
		<code>true</code> if its first operand precedes its
		second operand but is not an ancestor of its second
		operand; otherwise it returns <code>false</code>:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare function local:precedes($a as node(), $b as node()) 
   as boolean
   {
      $a &lt;&lt; $b
        and
      fn:empty($a//node() intersect $b) 
   };
</pre></div></div><p>Similarly, a <code>local:follows</code> function could be written:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare function local:follows($a as node(), $b as node()) 
   as boolean
   {
      $a &gt;&gt; $b
        and
      fn:empty($b//node() intersect $a) 
   };
</pre></div></div><p>Using the <code>local:precedes</code> function, we can write a
query that finds <code>instrument</code> elements between the first
two incisions, excluding from the query result any
<code>instrument</code> that is a descendant of the first
<code>incision</code>:</p><div class="parse-test"><div class="exampleInner"><pre>let $proc := /report/procedure[1]
for $i in $proc//instrument
where local:precedes(($proc//incision)[1], $i)
   and local:precedes($i, ($proc//incision)[2])
return $i</pre></div></div><p>The following query reports incisions for which no prior anesthesia
was recorded in the surgical report. Since an <code>anesthesia</code>
is never part of an <code>incision</code>, we can use
<code>&lt;&lt;</code> instead of the less-efficient
<code>local:precedes</code> function:</p><div class="parse-test"><div class="exampleInner"><pre>for $proc in /report/procedure
where some $i in $proc//incision satisfies
         fn:empty($proc//anesthesia[. &lt;&lt; $i])
return $proc</pre></div></div><p>In some documents, particular sequences
			of elements may indicate a logical hierarchy.
			This is most commonly true of HTML. The following
			query returns the introduction of an XHTML document,
			wrapping it in a <code>div</code> element. In this example, we
			assume that an <code>h2</code> element containing the text
			"Introduction" marks the beginning of the introduction,
			and the introduction continues until the next <code>h2</code>
			or <code>h1</code> element, or the end of the document, whichever
			comes first.
			</p><div class="parse-test"><div class="exampleInner"><pre>let $intro := //h2[text()="Introduction"],
    $next-h := //(h1|h2)[. &gt;&gt; $intro][1]
return
   &lt;div&gt;
     {
       $intro,
       if (fn:empty($next-h))
         then //node()[. &gt;&gt; $intro]
         else //node()[. &gt;&gt; $intro and . &lt;&lt; $next-h]
     }
   &lt;/div&gt;</pre></div></div><p>Note that the above query makes explicit the hierarchy that was implicit in the
			original document. In this example, we assume that the <code>h2</code> element containing the text "Introduction" has no subelements.</p></div><div class="div2">
<h3><a id="id-recursive-transformations" name="id-recursive-transformations"></a>K.4 Recursive Transformations</h3><p>Occasionally it is necessary to scan over a hierarchy of elements, applying some transformation at each level of the hierarchy. In XQuery this can be accomplished by defining a recursive function. In this section we will present two examples of such recursive functions.</p><p>Suppose that we need to compute a table of contents for a given document by scanning over the document, retaining only elements named <code>section</code> or <code>title</code>, and preserving the hierarchical relationships among these elements. For each <code>section</code>, we retain subelements named <code>section</code> or <code>title</code>; but for each <code>title</code>, we retain the full content of the element. This might be accomplished by the following recursive function:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare function local:sections-and-titles($n as node()) as node()?
   {
   if (fn:local-name($n) = "section")
   then element
          { fn:local-name($n) }
          { for $c in $n/* return local:sections-and-titles($c) }
   else if (fn:local-name($n) = "title")
   then $n
   else ( )
   };</pre></div></div><p>The "skeleton" of a given document, containing only its sections and titles, can then be obtained by invoking the <code>local:sections-and-titles</code> function on the root node of the document, as follows:</p><div class="parse-test"><div class="exampleInner"><pre>local:sections-and-titles(fn:doc("cookbook.xml"))</pre></div></div><p>As another example of a recursive transformation, suppose that we wish to scan over a document, transforming every attribute named <code>color</code> to an element named <code>color</code>, and every element named <code>size</code> to an attribute named <code>size</code>. This can be accomplished by the following recursive function:</p><div class="frag-prolog-parse-test"><div class="exampleInner"><pre>declare function local:swizzle($n as node()) as node() 
  { 
   typeswitch($n)
     case $a as attribute(color)
       return element color { fn:string($a) } 
     case $es as element(size) 
       return attribute size { fn:string($es) } 
     case $e as element() 
       return element 
         { fn:local-name($e) } 
         { for $c in $e/(* | @*) return local:swizzle($c) } 
     case $d as document-node() 
       return document 
         { for $c in $d/* return local:swizzle($c) } 
     default return $n 
  };</pre></div></div><p>The transformation can be applied to a whole document by invoking the <code>local:swizzle</code> function on the root node of the document, as follows:</p><div class="parse-test"><div class="exampleInner"><pre>local:swizzle(fn:doc("plans.xml"))</pre></div></div></div><div class="div2">
<h3><a id="id-select-distinct" name="id-select-distinct"></a>K.5 Selecting Distinct Combinations</h3><p>It is sometimes necessary to search through a set of data to find all the distinct combinations of a given list of properties. For example, an input data set might consist of a large set of <code>order</code> elements, each of which has the same basic structure, as illustrated by the following example:</p><div class="exampleInner"><pre>&lt;order&gt;
   &lt;date&gt;2003-10-15&lt;/date&gt;
   &lt;product&gt;Dress Shirt&lt;/product&gt;
   &lt;size&gt;M&lt;/size&gt;
   &lt;color&gt;Blue&lt;/color&gt;
   &lt;supplier&gt;Fashion Trends&lt;/supplier&gt;
   &lt;quantity&gt;50&lt;/quantity&gt;
&lt;/order&gt;</pre></div><p>From this data set, a user might wish to find all the distinct combinations of <code>product</code>, <code>size</code>, and <code>color</code> that occur together in an <code>order</code>. The following query returns this list, enclosing each distinct combination in a new element named <code>option</code>:</p><div class="parse-test"><div class="exampleInner"><pre>for $p in fn:distinct-values(/orders/order/product),
    $s in fn:distinct-values(/orders/order/size),
    $c in fn:distinct-values(/orders/order/color)
    order by $p, $s, $c
    return
       if (fn:exists(/orders/order[product eq $p
                and size eq $s and color eq $c]))
       then
          &lt;option&gt;
             &lt;product&gt;{$p}&lt;/product&gt;
             &lt;size&gt;{$s}&lt;/size&gt;
             &lt;color&gt;{$c}&lt;/color&gt;
          &lt;/option&gt;
       else ()</pre></div></div></div></div></div></span><span class="xpath"><div class="xpath"><div class="div1">
<h2><a id="id-backwards-compatibility" name="id-backwards-compatibility"></a>L Backwards Compatibility with
XPath 1.0 (Non-Normative)</h2><p>This appendix provides a summary of the areas of incompatibility
between XPath 2.0 and <a href="#XPath">[XPath 1.0]</a>. </p><p>Three separate cases are considered:</p><ol class="enumar"><li><p>Incompatibilities that exist when source documents have no schema,
and when running with XPath 1.0 compatibility mode set to true. This specification
has been designed to reduce the number of incompatibilities in this situation to
an absolute minumum, but some differences remain and are listed individually.</p></li><li><p>Incompatibilities that arise when XPath 1.0 compatibility mode is set to false.
In this case, the number of expressions where compatibility is lost is rather greater.</p></li><li><p>Incompatibilities that arise when the source document is processed using a schema
(whether or not XPath 1.0 compatibility mode is set to true). Processing the document with
a schema changes the way that the values of nodes are interpreted, and this can cause an XPath
expression to return different results.</p></li></ol><div class="div2">
<h3><a id="N196D7" name="N196D7"></a>L.1 Incompatibilities when Compatibility Mode is true</h3><p>The list below contains all known areas, within the scope of this specification, where
an XPath 2.0 processor running with compatibility mode set to true will produce different
results from an XPath 1.0 processor evaluating the same expression, assuming that the expression
was valid in XPath 1.0, and that the nodes in the source document have no type annotations other than
<code>xdt:untyped</code> and <code>xdt:untypedAtomic</code>.</p><p>Incompatibilities in the behavior of individual functions are not listed here, but are included
in an appendix of <a href="#FunctionsAndOperators">[XQuery 1.0 and XPath 2.0 Functions and Operators]</a>.</p><p>Since both XPath 1.0 and XPath 2.0 leave some aspects of the specification 
implementation-defined, there may be incompatiblities in the behavior of a particular implementation
that are outside the scope of this specification. Equally, some aspects of the behavior of XPath are defined
by the host language.</p><ol class="enumar"><li><p>Consecutive comparison operators such as <code>A &lt; B &lt; C</code> were 
supported in XPath 1.0, but are not permitted by the XPath 2.0 grammar. In most cases such
comparisons in XPath 1.0 did not have the intuitive meaning, so it is unlikely that
they have been widely used in practice. If such a construct is found, an XPath 2.0 processor
will report a syntax error, and the construct can be rewritten as <code>(A &lt; B) &lt; C</code></p></li><li><p>When converting strings to numbers (either explicitly when using the <code>number</code> function,
or implicitly say on a function call), certain strings that converted to the special value <code>NaN</code>
under XPath 1.0 will convert to values other than <code>NaN</code> under XPath 2.0. These include
any number written with a leading <code>+</code> sign, any number in exponential floating point 
notation (for example <code>1.0e+9</code>), and the strings <code>INF</code> and <code>-INF</code>.</p></li><li><p>XPath 2.0 does not allow a token starting with a letter to follow immediately after a numeric
literal, without intervening whitespace. For example, <code>10div 3</code> was permitted in XPath 1.0,
but in XPath 2.0 must be written as <code>10 div 3</code>.</p></li><li><p>The namespace axis is deprecated in XPath 2.0. Implementations may support 
the namespace axis for backward compatibility with XPath 1.0, but they are not 
required to do so. (XSLT 2.0 requires that if XPath backwards compatibility
mode is supported, then the namespace axis must also be supported; but other host languages
may define the conformance rules differently.)</p></li></ol></div><div class="div2">
<h3><a id="N19716" name="N19716"></a>L.2 Incompatibilities when Compatibility Mode is false</h3><p>Even when the setting of the XPath 1.0 compatibility mode is false, many XPath
expressions will still produce the same results under XPath 2.0 as under XPath 1.0. The exceptions
are described in this section.</p><p>In all cases it is assumed that the expression
in question was valid under XPath 1.0, that XPath 1.0 compatibility mode is false, and that all elements
and attributes are annotated with the types <code>xdt:untyped</code> and <code>xdt:untypedAtomic</code>
respectively.</p><p>In the description below, the terms <em>node-set</em> and <em>number</em>
are used with their XPath 1.0 meanings, that is, to describe expressions which according 
to the rules of XPath 1.0 would have generated a node-set or a number respectively.</p><ol class="enumar"><li><p>When a node-set containing more than one node is supplied as an argument to a
function or operator that expects a single node or value, the XPath 1.0 rule was that all nodes after the first were
discarded. Under XPath 2.0, a type error occurs if there is more than one node.
The XPath 1.0 behavior can always be restored by using the predicate <code>[1]</code> to 
explicitly select the first node in the node-set.</p></li><li><p>In XPath 1.0, the <code>&lt;</code> and <code>&gt;</code> operators, when applied
to two strings, attempted to convert both the strings to numbers and then made a numeric
comparison between the results. In XPath 2.0, these operators perform a string comparison using the
default collating sequence. (If either value is numeric, however, the results are compatible
with XPath 1.0)</p></li><li><p>When an empty node-set is supplied as an argument to a
function or operator that expects a number, the value is no longer converted
implicitly to NaN.
The XPath 1.0 behavior can always be restored by using the <code>number</code>
function to perform an explicit conversion.</p></li><li><p>More generally, the supplied arguments to a function or operator are no longer implicitly converted
to the required type, except in the case where the supplied argument is of type <code>xdt:untypedAtomic</code>
(which will commonly be the case when a node in a schemaless document is supplied as the argument).
For example, the function call <code>substring-before(10 div 3, ".")</code> raises a type error under XPath 2.0, because the arguments
to the <code>substring-before</code> function must be strings rather than numbers. The XPath 1.0 behavior can be
restored by performing an explicit conversion to the required type using a constructor function
or cast.</p></li><li><p>The rules for comparing a node-set to a boolean have changed. In XPath 1.0,
an expression such as <code>$node-set = true()</code> was evaluated by converting the
node-set to a boolean and then performing a boolean comparison: so this expression would return <code>true</code>
if <code>$node-set</code> was non-empty. In XPath 2.0, this expression is handled in 
the same way as other comparisons between a sequence and a singleton: it is <code>true</code> if
<code>$node-set</code> contains at least one node whose value, after atomization and conversion
to a boolean using the casting rules, is <code>true</code>.</p><p>This means that if <code>$node-set</code> is empty, the result under XPath 2.0 
will be <code>false</code> regardless of
the value of the boolean operand, and regardless of which operator is used.
If <code>$node-set</code> is non-empty, then in most cases the comparison with a boolean is
likely to fail, giving a dynamic error. But if a node has the value "0",
"1", "true", or "false", evaluation of the expression may succeed.</p></li><li><p>Comparisons of a number to a boolean, a number to a string, or a string to a boolean
are not allowed in XPath 2.0: they result in a type error. In XPath 1.0 such comparisons were
allowed, and were handled by converting one of the operands to the type of the other. So for
example in XPath 1.0 <code>4 = true()</code> was true; <code>4 = "+4"</code> was false (because
the string <code>+4</code> converts to <code>NaN</code>), and <code>false = "false"</code> was
false (because the string <code>"false"</code> converts to the boolean <code>true</code>).
In XPath 2.0 all these comparisons are type errors.</p></li><li><p>Additional numeric types have been introduced, with the effect that arithmetic
may now be done as an integer, decimal, or single- or double-precision floating point calculation
where previously it was always performed as double-precision floating point. 
The result of the <code>div</code> operator when dividing two integers is now a value 
of type decimal rather than double. The expression <code>10 div 0</code> raises an 
error rather than returning positive infinity.</p></li><li><p>The rules for converting numbers to strings have changed. These may affect the
way numbers are displayed in the output of a stylesheet. For numbers whose absolute value
is in the range 1E-6 to 1E+6, the result should be the same, but outside this range,
scientific format is used for non-integral <code>xs:float</code> and <code>xs:double</code> values.</p></li><li><p>The rules for converting strings to numbers have changed. In addition to the changes
that apply when XPath 1.0 compatibility mode is true, when compatibility mode is false the
strings <code>Infinity</code> and <code>-Infinity</code> are no longer recognized as representations
of positive and negative infinity. Note also that while the <code>number</code> function
continues to convert all unrecognized strings to <code>NaN</code>, operations that cast a string
to a number react to such strings with a dynamic error.</p></li><li><p>Many operations in XPath 2.0 produce an empty sequence as their result
when one of the arguments or operands is an empty sequence. Where the operation
expects a string, an empty sequence is usually considered equivalent to a zero-length string, which
is compatible with the XPath 1.0 behavior. Where the operation expects a number, however, the
result is not the same. For example, if <code>@width</code> returns an empty sequence, then
in XPath 1.0 the result of <code>@width+1</code> was <code>NaN</code>, while with XPath 2.0
it is <code>()</code>. This has the effect that a filter expression such as <code>item[@width+1 != 2]</code>
will select items having no <code>width</code> attribute under XPath 1.0, and will not select them
under XPath 2.0.</p></li><li><p>The typed value of a comment node, processing instruction node, or namespace node under
XPath 2.0 is of type <code>xs:string</code>, not <code>xdt:untypedAtomic</code>. This means that no implicit conversions
are applied if the value is used in a context where a number is expected. If a processing-instruction node is used as an operand of
an arithmetic operator, for example, XPath 1.0 would attempt to convert the string value of the node to a number (and deliver
<code>NaN</code> if unsuccessful), while XPath 2.0 will report a type error.</p></li><li><p>In XPath 1.0, it was defined that with an expression of the form <code>A and
B</code>,
B would not be evaluated if A was false. Similarly in the case of <code>A or
B</code>, B would not be evaluated if A was true. This is no longer
guaranteed with XPath 2.0: the implementation is free to evaluate the two
operands in either order or in parallel. This change has been made to give
more scope for optimization in situations where XPath expressions are
evaluated against large data collections supported by indexes. Implementations
may choose to retain backwards compatibility in this area, but they are not
obliged to do so.</p></li></ol></div><div class="div2">
<h3><a id="N197D0" name="N197D0"></a>L.3 Incompatibilities when using a Schema</h3><p>An XPath expression applied to a document that has been processed against a schema will not always
give the same results as the same expression applied to the same document in the absence of a schema.
Since schema processing had no effect on the result of an XPath 1.0 expression, this may give rise
to further incompatibilities. This section gives a few examples of the differences that can arise.</p><p>Suppose that the context node is an element node derived from 
the following markup: <code>&lt;background color="red green blue"/&gt;</code>. 
In XPath 1.0, the predicate <code>[@color="blue"]</code> would return <code>false</code>. 
In XPath 2.0, if the <code>color</code> attribute is defined in a schema 
to be of type <code>xs:NMTOKENS</code>, the same predicate will return <code>true</code>.</p><p>Similarly, consider the expression <code>@birth &lt; @death</code> applied to the
element <code>&lt;person birth="1901-06-06" death="1991-05-09"/&gt;</code>. With XPath 1.0, this
expression would return false, because both attributes are converted to numbers, which returns
<code>NaN</code> in each case. With XPath 2.0, in the presence of a schema that annotates these
attributes as dates, the expression returns <code>true</code>.</p><p>Once schema validation is applied, elements and attributes cannot be used as operands and arguments
of expressions that expect a different data type. For example, it is no longer possible to apply the <code>substring</code>
function to a date to extract the year component, or to a number to extract the integer part. Similarly, if an attribute is
annotated as a boolean then it is not possible to compare it with the strings <code>"true"</code> or <code>"false"</code>.
All such operations lead to type errors. The remedy when such errors occur is to introduce an explicit conversion, or
to do the computation in a different way. For example, <code>substring-after(@temperature, "-")</code> might be
rewritten as <code>abs(@temperature)</code>.</p><p>In the case of an XPath 2.0 implementation that provides the static typing feature, many further type errors will
be reported in respect of expressions that worked under XPath 1.0. For example, an expression such as
<code>round(../@price)</code> might lead to a static type error because the processor cannot infer statically that
<code>../@price</code> is guaranteed to be numeric.</p><p>Schema validation will in many cases perform whitespace normalization on the contents of elements (depending on their type).
This will change the result of operations such as the <code>string-length</code> function.</p><p>Schema validation augments the data model by adding default values for omitted attributes and empty elements.</p></div></div></div></span><div class="div1">
<h2><a id="id-revisions-log" name="id-revisions-log"></a>M Revision
Log (Non-Normative)</h2><p>This log records the changes that have been made to this document since the Last Call Draft of 04 April 2005.</p><div class="div2">
<h3><a id="N1981D" name="N1981D"></a>M.1 7 July 2005</h3><ol class="enumar"><li><p>An error has been corrected in the definition of the expansion of leading-slash in a path expression.</p></li><li><p>Operators <code>eq</code> and <code>ne</code> are now defined for the <code>xs:duration</code> type.</p></li><li><p>Replaced reference to RFC2396 (URI's) with references to RFC3986 and 
RFC3987 (IRI's). Inserted text indicating that IRI's are accepted where URI's are expected. 
Also replaced obsolete reference to RFC1738  by
an updated reference to RFC3987.</p></li><li><p>Added text to section 2.5.2 clarifying that if the nilled property of an 
element node is true, its typed value is the empty sequence.</p></li><li><p>Added a consistency constraint stating that the "xml" prefix is predefined, and it cannot
be bound to anything else, and no other prefix can be bound to the same URI.</p></li><span class="xquery"><li class="xquery"><p>In Section 3.7.1.3, if construction mode is <code>strip</code>
(Rule 1-e-ii-C-II), when stripping the type of an attribute: If the name
of the attribute is xml:ID, then the "is-ID" property of the attribute
is set to True; otherwise False.</p></li></span><span class="xquery"><li class="xquery"><p>Changed Section 3.7.1.3, Rule 1-e-ii-E. The
base-URI property of a copied node is no longer preserved, but inherited from
the new parent. Aligns XQuery with XSLT. New text for rule:
"When an element or processing instruction node is copied, its base-uri
property is set to be the same as that of its new parent,
with the following exception: if a copied element node has an xml:base 
attribute, its base-uri property is set to
the value of that attribute, resolved (if it is relative) against
the base-uri property of the new parent node.
All other properties of the copied nodes are preserved."</p></li></span><span class="xquery"><li class="xquery"><p>In Section 3.7.1.3, rules for copying element nodes when construction
mode is <code>preserve</code> and copy-namespaces mode is <code>no-preserve</code> have been changed to introduce a new type error: XQTY0086.  </p></li></span><span class="xquery"><li class="xquery"><p>The string value of an empty direct constructor is now defined as a zero-length string.</p></li></span><span class="xquery"><li class="xquery"><p>Some changes have been made in the default values of serialization parameters.</p></li></span><li><p>Removed from the main part of the document any references to line-ending normalization.
Affects 3.1.1 (Literals)<span class="xquery"><span class="xquery"><span class="xquery"> and 3.7.1.3 (Dir. Elem. Constructor--Content, Rule 1a)</span></span></span>.
Responds to Bug 1307. Line ending normalization will be applied globally by the parser rather than by individual expressions.</p></li><li><p>In SequenceType syntax, keyword <code>void</code> is changed to <code>empty-sequence</code>.</p></li><li><p>Changes to function names: Changes function names:
<code>fn:subtract-dateTimes-yielding-dayTimeDuration</code> becomes <code>op:subtract-dateTimes</code>
and <code>fn:subtract-dates-yielding-dayTimeDuration</code> becomes <code>op:subtract-dates</code>
 (affects operator mapping table).</p></li><li><p>Various minor changes, both editorial and substantive, have been made in response to public comments and working group discussions</p></li></ol></div><div class="div2">
<h3><a id="N19878" name="N19878"></a>M.2 15 September 2005</h3><ol class="enumar"><span class="xquery"><li class="xquery"><p>An error code (XQST0087) has been defined for an invalid encoding specification in a Version Declaration.</p></li></span><span class="xquery"><li class="xquery"><p>Rules for processing the content of a direct element constructor have been edited to clarify that boundary whitespace is processed (possibly stripped) before entity and character references are expanded.</p></li></span><span class="xquery"><li class="xquery"><p>Rules for constructing attributes with the name <code>xml:id</code> have been modified. Additional normalization rules apply to these attributes. The error (XQST0082) that was raised when the value of  an <code>xml:id</code> attribute was not a valid <code>NCName</code> has been deleted.</p></li></span><span class="xquery"><li class="xquery"><p>Error XPDY0044 is clarified to apply whenever the <code>node-name</code> property of a constructed attribute node is <code>xmlns</code> or <code>xmlns:*</code>, regardless of how the <code>node-name</code> was computed.</p></li></span><span class="xquery"><li class="xquery"><p>The descriptions of all the node constructors have been changed to specify that all newly-constructed nodes have an empty parent property. The parent property of the new node can be set by an outer-level constructor (if any).</p></li></span><li><p>The definition of a range expression has been edited to clarify that, when the lower and upper bound of a range are the same integer, only a single integer is returned by the range expression.</p></li><li><p>Values of numeric literals are now defined by the rules for casting from <code>xdt:untypedAtomic</code> into the appropriate numeric type. This change defines overflow and underflow behavior for numeric literals.</p></li><span class="xpath"><li class="xpath"><p>Invocation of a non-existent function is now defined to be a static error.</p></li></span><li><p>Various minor changes, both editorial and substantive, have been made in response to public comments and working group discussions</p></li></ol></div></div></div></body></html>