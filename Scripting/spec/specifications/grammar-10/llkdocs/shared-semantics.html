<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><title>XQuery 1.0 and XPath 2.0 Formal Semantics</title><style type="text/css">
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
	    border-bottom-width: 1pt;
	    margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
table.small    { font-size: x-small; }

a.judgment:visited, a.judgment:link { font-family: sans-serif;
                              	      color: black; 
                              	      text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                              		  text-decoration: none }
a.env:visited, a.env:link { color: black; 
                            text-decoration: none }
    </style><link type="text/css" rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-WD.css"/></head><body><div class="head"><p><a href="http://www.w3.org/"><img width="72" height="48" alt="W3C" src="http://www.w3.org/Icons/w3c_home"/></a></p>
<h1><a id="title" name="title"/>XQuery 1.0 and XPath 2.0 Formal Semantics</h1>
<h2><a id="w3c-doctype" name="w3c-doctype"/>W3C Editor's Working Draft 27 September 2005</h2><dl><dt>This version:</dt><dd>

    <a href="http://www.w3.org/TR/2005/WD-xquery-semantics-20050927/">http://www.w3.org/TR/2005/WD-xquery-semantics-20050927/</a>

  </dd><dt>Latest version:</dt><dd>

    <a href="http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</a>

  </dd><dt>Previous versions:</dt><dd>

    <a href="http://www.w3.org/TR/2005/WD-xquery-semantics-20050603/">http://www.w3.org/TR/2005/WD-xquery-semantics-20050603/</a>

    <a href="http://www.w3.org/TR/2005/WD-xquery-semantics-20050404/">http://www.w3.org/TR/2005/WD-xquery-semantics-20050404/</a>

    <a href="http://www.w3.org/TR/2005/WD-xquery-semantics-20050211/">http://www.w3.org/TR/2005/WD-xquery-semantics-20050211/</a>



  </dd><dt>Editors:</dt><dd>Denise Draper, Microsoft <a href="mailto:denised@microsoft.com">&lt;denised@microsoft.com&gt;</a></dd><dd>Peter Fankhauser (XML Query WG), Infonyte GmbH <a href="mailto:fankhaus@infonyte.com">&lt;fankhaus@infonyte.com&gt;</a></dd><dd>Mary Fernández (XML Query WG), AT&amp;T Labs - Research <a href="mailto:mff@research.att.com">&lt;mff@research.att.com&gt;</a></dd><dd>Ashok Malhotra (XML Query and XSL WGs), Oracle Corporation <a href="mailto:ashok.malhotra@oracle.com">&lt;ashok.malhotra@oracle.com&gt;</a></dd><dd>Kristoffer Rose (XSL WG), IBM T.J. Watson Research Center <a href="mailto:krisrose@us.ibm.com">&lt;krisrose@us.ibm.com&gt;</a></dd><dd>Michael Rys (XML Query WG), Microsoft <a href="mailto:mrys@microsoft.com">&lt;mrys@microsoft.com&gt;</a></dd><dd>Jérôme Siméon (XML Query WG), IBM T.J. Watson Research Center <a href="mailto:simeon@us.ibm.com">&lt;simeon@us.ibm.com&gt;</a></dd><dd>Philip Wadler (XML Query WG), University of Edinburgh <a href="mailto:wadler@inf.ed.ac.uk">&lt;wadler@inf.ed.ac.uk&gt;</a></dd></dl><p>This document is also available in these non-normative formats: <a href="http://www.w3.org/TR/2005/WD-xquery-semantics-20050927/xquery-semantics.xml">XML</a> and <a href="diff-from-20050603.html">Revisions to LC Draft</a>.</p><p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2005 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p></div><hr/><div>
<h2><a id="abstract" name="abstract"/>Abstract</h2><p>This document defines formally the semantics of <span class="xquery">XQuery 1.0 <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a></span> <span class="shared">and</span> <span class="xpath">XPath 2.0

    <a href="#xpath20">[XML Path Language (XPath) 2.0]</a></span>.</p></div><div>
<h2><a id="status" name="status"/>Status of this Document</h2><p><em>This section describes the status of this document at the

    time of its publication. Other documents may supersede this

    document. A list of current W3C publications and the latest

    revision of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at

    http://www.w3.org/TR/.</em></p><p>This is a public W3C Working Draft for review by W3C Members

    and other interested parties. Publication as a Working Draft does

    not imply endorsement by the W3C Membership. This is a draft

    document and may be updated, replaced or obsoleted by other

    documents at any time. It is inappropriate to cite this document

    as other than work in progress.</p><p>XQuery 1.0, XPath 2.0, and their formal semantics has been

    defined jointly by the <a href="http://www.w3.org/XML/Query">XML

    Query Working Group</a> and the <a href="http://www.w3.org/Style/XSL/">XSL Working Group</a> (both

    part of the <a href="http://www.w3.org/XML/Activity.html">XML

    Activity</a>).</p><p>This draft includes corrections and changes based on public

    comments on the Last Call Working Draft dated 03 June 2005.

These decisions

<a href="http://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;product=XPath+%2F+XQuery+%2F+XSLT&amp;component=Formal+Semantics&amp;version=Last+Call+drafts&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;keywords_type=allwords&amp;keywords=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;bug_status=RESOLVED&amp;bug_status=CLOSED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=Reuse+same+sort+as+last+time&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">are recorded</a>

in the

<a href="http://www.w3.org/Bugs/Public/">Bugzilla database</a> (http://www.w3.org/Bugs/Public/).

 A list

    of changes since the Last Call Working Draft of 03 June 2005 can

    be found in <a href="#id-fs-revisions-log"><b>[F Revision Log]</b></a>.</p><p>A number of technical and editorial issues are still being

    processed by the Working Groups. Some of the main technical

    changes that are still not implemented in this working draft

    include improvements to the formal notations (Bugs <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1605">[1605]</a>,<a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1614">[1614]</a>,

    <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1618">[1618]</a>,

    <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1730">[1730]</a>,

    <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1790">[1790]</a>),

    fixes to bugs in the semantics of function calls (Bugs <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1582">[1582]</a>,<a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1583">[1583]</a>,

    <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1820">[1820]</a>),

    function and variable declarations (Bugs <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1743">[1743]</a>,<a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1964">[1964]</a>,

    <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1965">[1965]</a>),

    and fixes to the semantics of constructors (Bugs <a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1628">[1628]</a>,<a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1629">[1629]</a>,<a href="http://www.w3.org/Bugs/Public/show_bug.cgi?id=1641">[1641]</a>).</p><p>This draft is being provided to permit public review of the changes

that have been made as a result of the Last Call comments.

Comments on the

changes should be made against the pertinent Last Call comment

(instructions can be found at

<a href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>). If access to that system is

not feasible, you may send your comments to the W3C mailing list,

<a href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>

(archived at

<a href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>). Please start

the subject line with “[FS]” so comments can be classified correctly.</p><p>The XML Query and XSL Working Groups expect to progress this document to

<a href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsCR">Candidate

Recommendation</a> status in

the very near future.</p><p>The patent policy for this document is the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5

    February 2004 W3C Patent Policy</a>.  Patent disclosures

    relevant to this specification may be found on the <a href="http://www.w3.org/2002/08/xmlquery-IPR-statements">XML Query

    Working Group's patent disclosure page</a> and the <a href="http://www.w3.org/Style/XSL/Disclosures">XSL Working Group's

    patent disclosure page</a>. An individual who has actual

    knowledge of a patent which the individual believes contains

    Essential Claim(s) with respect to this specification should

    disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section

    6 of the W3C Patent Policy</a>.</p></div><div class="toc">
<h2><a id="contents" name="contents"/>Table of Contents</h2><p class="toc">1 <a href="#introduction">Introduction</a><br/>
    1.1 <a href="#id-normativity">Normative and Informative
  Sections</a><br/>
2 <a href="#sec_preliminaries">Preliminaries</a><br/>
    2.1 <a href="#sec_intro">Introduction to the Formal Semantics</a><br/>
        2.1.1 <a href="#sec_grammar_notations">Notations from grammar productions</a><br/>
        2.1.2 <a href="#sec_judgments">Notations for judgments</a><br/>
        2.1.3 <a href="#sec_environments">Notations for environments</a><br/>
        2.1.4 <a href="#sec_inference">Notations for inference rules</a><br/>
        2.1.5 <a href="#sec_together">Putting it together</a><br/>
    2.2 <a href="#sec_namespaces">URIs, Namespaces, and Prefixes</a><br/>
    2.3 <a href="#sec_values">XML Values</a><br/>
        2.3.1 <a href="#sec_data_model_overview">Formal values</a><br/>
        2.3.2 <a href="#sec_example_values">Examples of values</a><br/>
    2.4 <a href="#sec_types">The [XPath/XQuery] Type System</a><br/>
        2.4.1 <a href="#sec_schema">XML Schema and the [XPath/XQuery] Type System</a><br/>
        2.4.2 <a href="#sec_item_types">Item types</a><br/>
        2.4.3 <a href="#sec_content_models">Content models</a><br/>
        2.4.4 <a href="#sec_top_level_definitions">Top level definitions</a><br/>
        2.4.5 <a href="#sec_types_example">Example of a complete Schema</a><br/>
    2.5 <a href="#sec_fando">Functions and operators</a><br/>
3 <a href="#id-basics">Basics</a><br/>
    3.1 <a href="#sec_context">Expression Context</a><br/>
        3.1.1 <a href="#static_context">Static Context</a><br/>
            3.1.1.1 <a href="#id-expanded-qnames">Resolving QNames to Expanded QNames</a><br/>
        3.1.2 <a href="#eval_context">Dynamic Context</a><br/>
    3.2 <a href="#id-processing-model">Processing Model</a><br/>
        3.2.1 <a href="#id-fs-processing-model">Processing model</a><br/>
        3.2.2 <a href="#sec_normalization">Normalization judgment</a><br/>
        3.2.3 <a href="#sec_static">Static typing judgment</a><br/>
        3.2.4 <a href="#sec_evaluation">Dynamic evaluation judgment</a><br/>
    3.3 <a href="#sec_errors">Error Handling</a><br/>
    3.4 <a href="#id-important-concepts">Concepts</a><br/>
        3.4.1 <a href="#id-doc-order">Document Order</a><br/>
        3.4.2 <a href="#id-atomization">Atomization</a><br/>
        3.4.3 <a href="#id-ebv">Effective Boolean Value</a><br/>
        3.4.4 <a href="#id-input-sources">Input Sources</a><br/>
        3.4.5 <a href="#id-uri-literals">URI Literals</a><br/>
    3.5 <a href="#id-type-conversion">Types</a><br/>
        3.5.1 <a href="#id-predefined-types">Predefined Schema Types</a><br/>
        3.5.2 <a href="#id-typed-value">Typed Value and String Value</a><br/>
        3.5.3 <a href="#id-sequencetype">SequenceType Syntax</a><br/>
        3.5.4 <a href="#id-sequencetype-matching">SequenceType Matching</a><br/>
    3.6 <a href="#comments">Comments</a><br/>
4 <a href="#id-expressions">Expressions</a><br/>
    4.1 <a href="#id-primary-expressions">Primary Expressions</a><br/>
        4.1.1 <a href="#id-literals">Literals</a><br/>
        4.1.2 <a href="#id-variables">Variable References</a><br/>
        4.1.3 <a href="#id-paren-expressions">Parenthesized Expressions</a><br/>
        4.1.4 <a href="#id-context-item-expression">Context Item Expression</a><br/>
        4.1.5 <a href="#id-function-calls">Function Calls</a><br/>
    4.2 <a href="#id-path-expressions">Path Expressions</a><br/>
        4.2.1 <a href="#id-axis-steps">Steps</a><br/>
            4.2.1.1 <a href="#sec_axes">Axes</a><br/>
            4.2.1.2 <a href="#node-tests">Node Tests</a><br/>
        4.2.2 <a href="#id-predicates">Predicates</a><br/>
        4.2.3 <a href="#unabbrev">Unabbreviated Syntax</a><br/>
        4.2.4 <a href="#abbrev">Abbreviated Syntax</a><br/>
    4.3 <a href="#id-sequence-expressions">Sequence Expressions</a><br/>
        4.3.1 <a href="#sec_constructing_sequences">Constructing Sequences</a><br/>
        4.3.2 <a href="#sec_filter_exprs">Filter Expressions</a><br/>
        4.3.3 <a href="#sec_combining_sequences">Combining Node Sequences</a><br/>
    4.4 <a href="#sec_arithmetic">Arithmetic Expressions</a><br/>
    4.5 <a href="#sec_comparisons">Comparison Expressions</a><br/>
        4.5.1 <a href="#sec_value_comparisons">Value Comparisons</a><br/>
        4.5.2 <a href="#sec_general_comparisons">General Comparisons</a><br/>
        4.5.3 <a href="#sec_node-comparisons">Node Comparisons</a><br/>
    4.6 <a href="#id-logical-expressions">Logical Expressions</a><br/>
    4.7 <a href="#sec_constructors">Constructors</a><br/>
        4.7.1 <a href="#id_element_constructor">Direct Element Constructors</a><br/>
            4.7.1.1 <a href="#sec_direct_attributes">Attributes</a><br/>
            4.7.1.2 <a href="#sec_namespace_attrs">Namespace Declaration Attributes</a><br/>
            4.7.1.3 <a href="#sec_content">Content</a><br/>
            4.7.1.4 <a href="#sec_whitespace">Whitespace in Element Content</a><br/>
        4.7.2 <a href="#sec_other_constructors">Other Direct Constructors</a><br/>
        4.7.3 <a href="#sec_computedConstructors">Computed Constructors</a><br/>
            4.7.3.1 <a href="#sec_comp_elem_constructor">Computed Element Constructors</a><br/>
            4.7.3.2 <a href="#sec_attribute_constructor">Computed Attribute Constructors</a><br/>
            4.7.3.3 <a href="#sec_documentConstructors">Document Node Constructors</a><br/>
            4.7.3.4 <a href="#sec_textConstructors">Text Node Constructors</a><br/>
            4.7.3.5 <a href="#sec_computed-pis">Computed Processing Instruction Constructors</a><br/>
            4.7.3.6 <a href="#sec_computed-comments">Computed Comment Constructors</a><br/>
        4.7.4 <a href="#id-ns-nodes-on-elements">In-scope Namespaces of a Constructed Element</a><br/>
    4.8 <a href="#sec_for-expressions">[For/FLWOR] Expressions</a><br/>
        4.8.1 <a href="#sec_flwor-expressions">FLWOR expressions</a><br/>
        4.8.2 <a href="#id-for-expression">For expression</a><br/>
        4.8.3 <a href="#sec_lets">Let Expression</a><br/>
        4.8.4 <a href="#id_orderby_clause">Order By and Return Clauses</a><br/>
    4.9 <a href="#sec_unordered-expressions">Ordered and Unordered Expressions</a><br/>
    4.10 <a href="#sec_conditionals">Conditional Expressions</a><br/>
    4.11 <a href="#id-quantified-expressions">Quantified Expressions</a><br/>
    4.12 <a href="#sec_sequencetype-matching">Expressions on SequenceTypes</a><br/>
        4.12.1 <a href="#sec_instance-of">Instance Of</a><br/>
        4.12.2 <a href="#sec_typeswitch">Typeswitch</a><br/>
        4.12.3 <a href="#sec_cast">Cast</a><br/>
        4.12.4 <a href="#sec_castable">Castable</a><br/>
        4.12.5 <a href="#sec_constructor-functions">Constructor Functions</a><br/>
        4.12.6 <a href="#sec_treat">Treat</a><br/>
    4.13 <a href="#sec_validate_expr">Validate Expressions</a><br/>
        4.13.1 <a href="#sec_validating_element">Validating an Element Node</a><br/>
        4.13.2 <a href="#sec_validating_document">Validating a Document Node</a><br/>
    4.14 <a href="#id-extension-expressions">Extension Expressions</a><br/>
5 <a href="#id-query-prolog">Modules and Prologs</a><br/>
    5.1 <a href="#sec_version-declaration">Version Declaration</a><br/>
    5.2 <a href="#id-module-declaration">Module Declaration</a><br/>
    5.3 <a href="#sec_boundary-space-decls">Boundary-space Declaration</a><br/>
    5.4 <a href="#sec_default-collation-declaration">Default Collation Declaration</a><br/>
    5.5 <a href="#sec_base-uri-decl">Base URI Declaration</a><br/>
    5.6 <a href="#sec_validation_decl">Construction Declaration</a><br/>
    5.7 <a href="#id-default-ordering-decl">Ordering Mode Declaration</a><br/>
    5.8 <a href="#id-empty-order-decl">Empty Order Declaration</a><br/>
    5.9 <a href="#id-copy-namespaces-decl">Copy-Namespaces Declaration</a><br/>
    5.10 <a href="#sec_schema_imports">Schema Import</a><br/>
    5.11 <a href="#id-module-imports">Module Import</a><br/>
    5.12 <a href="#sec_namespace_decls">Namespace Declaration</a><br/>
    5.13 <a href="#sec_default_namespace_decls">Default Namespace Declaration</a><br/>
    5.14 <a href="#sec_variable-declarations">Variable Declaration</a><br/>
    5.15 <a href="#sec_FunctionDeclns">Function Declaration</a><br/>
    5.16 <a href="#id-option-declaration">Option Declaration</a><br/>
6 <a href="#id-xquery-conformance">Conformance</a><br/>
    6.1 <a href="#id-static-typing-feature">Static Typing Feature</a><br/>
        6.1.1 <a href="#id-static-extensions">Static Typing Extensions</a><br/>
7 <a href="#sec_special_functions">Additional Semantics of Functions</a><br/>
    7.1 <a href="#sec_special_fs_functions">Formal Semantics Functions</a><br/>
        7.1.1 <a href="#sec_convert_operand">The fs:convert-operand function</a><br/>
        7.1.2 <a href="#sec_convert_simple_operand">The fs:convert-simple-operand function</a><br/>
        7.1.3 <a href="#sec_distinct_docorder">The fs:distinct-doc-order function</a><br/>
        7.1.4 <a href="#sec_distinct_docorder_or_atomic_sequence">The fs:distinct-doc-order-or-atomic-sequence function</a><br/>
        7.1.5 <a href="#sec_items_to_nodes">The fs:item-sequence-to-node-sequence function</a><br/>
        7.1.6 <a href="#sec_item_seq_to_untypedAtomic">The fs:item-sequence-to-untypedAtomic function</a><br/>
        7.1.7 <a href="#sec_item_seq_to_untypedAtomic_PI">The fs:item-sequence-to-untypedAtomic-PI function</a><br/>
        7.1.8 <a href="#sec_item_seq_to_untypedAtomic_text">The fs:item-sequence-to-untypedAtomic-text function</a><br/>
        7.1.9 <a href="#sec_item_seq_to_untypedAtomic_comment">The fs:item-sequence-to-untypedAtomic-comment function</a><br/>
        7.1.10 <a href="#sec_apply_ordering_mode">The fs:apply-ordering-mode
      function</a><br/>
        7.1.11 <a href="#sec_fs_to">The fs:to function</a><br/>
    7.2 <a href="#function_rules">Standard functions with specific typing rules</a><br/>
        7.2.1 <a href="#sec_fn_last">The fn:last context function</a><br/>
        7.2.2 <a href="#sec_fn_position">The fn:position context function</a><br/>
        7.2.3 <a href="#sec_fn_abs_ceil_floor_round">The fn:abs, fn:ceiling, fn:floor,
      fn:round, and fn:round-half-to-even functions</a><br/>
        7.2.4 <a href="#sec_fn_boolean">The fn:boolean function</a><br/>
        7.2.5 <a href="#sec_fn_doc_collection">The fn:collection and fn:doc functions</a><br/>
        7.2.6 <a href="#sec_fn_data">The fn:data function</a><br/>
        7.2.7 <a href="#sec_fn_distinct_node_vals">The fn:distinct-values function</a><br/>
        7.2.8 <a href="#sec_fn_unordered">The fn:unordered function</a><br/>
        7.2.9 <a href="#sec_fnerror">The fn:error function</a><br/>
        7.2.10 <a href="#sec_fn_aggregates">The fn:min, fn:max, fn:avg, and fn:sum
      functions</a><br/>
        7.2.11 <a href="#sec_fn_remove">The fn:remove function</a><br/>
        7.2.12 <a href="#sec_fn_reverse">The fn:reverse function</a><br/>
        7.2.13 <a href="#sec_fn_subsequence">The fn:subsequence function</a><br/>
        7.2.14 <a href="#sec_op_union_intersect_except">The op:union, op:intersect, and
      op:except operators</a><br/>
        7.2.15 <a href="#sec_fn_insert_before">The fn:insert-before function</a><br/>
        7.2.16 <a href="#sec_fn_cardinality_funcs">The fn:zero-or-one, fn:one-or-more, and
      fn:exactly-one functions</a><br/>
8 <a href="#sec_auxiliary_judgments">Auxiliary Judgments</a><br/>
    8.1 <a href="#sec_accessing_types">Judgments for accessing types</a><br/>
        8.1.1 <a href="#jd_aux_derives_from">Derives from</a><br/>
        8.1.2 <a href="#sec_substitutes">Substitutes for</a><br/>
        8.1.3 <a href="#sec_element_lookup">Element and attribute name lookup (Dynamic)</a><br/>
        8.1.4 <a href="#jd_aux_static_lookup">Element and attribute type lookup (Static)</a><br/>
        8.1.5 <a href="#sec_extension">Extension</a><br/>
        8.1.6 <a href="#sec_mixed">Mixed content</a><br/>
        8.1.7 <a href="#sec_adjustment">Type adjustment</a><br/>
        8.1.8 <a href="#sec_built_in_attributes">Builtin attributes</a><br/>
        8.1.9 <a href="#sec_type_expansion">Type expansion</a><br/>
        8.1.10 <a href="#sec_union_interpretation">Union interpretation of derived types</a><br/>
    8.2 <a href="#sec_auxiliary_xpath">Judgments for step expressions and filtering</a><br/>
        8.2.1 <a href="#sec_jd_principal">Principal Node Kind</a><br/>
        8.2.2 <a href="#sec_axis_judge">Auxiliary judgments for axes</a><br/>
            8.2.2.1 <a href="#sec_static_axis_judge">Static semantics of axes</a><br/>
                8.2.2.1.1 <a href="#sec_inference_axis">Inference rules for all axis</a><br/>
                8.2.2.1.2 <a href="#sec_inference_self">Inference rules for the self axis</a><br/>
                8.2.2.1.3 <a href="#sec_inference_child">Inference rules for the child axis</a><br/>
                8.2.2.1.4 <a href="#sec_inference_attribute">Inference rules for the attribute axis</a><br/>
                8.2.2.1.5 <a href="#sec_inference_parent">Inference rules for the parent axis</a><br/>
                8.2.2.1.6 <a href="#sec_inference_namespace">Inference rules for the namespace axis</a><br/>
                8.2.2.1.7 <a href="#sec_inference_descendant">Inference rules for the descendant axis</a><br/>
                8.2.2.1.8 <a href="#sec_inference_descendant_of_self">Inference rules for the descendant-or-self axis</a><br/>
                8.2.2.1.9 <a href="#sec_inference_ancestor">Inference rules for the ancestor axis</a><br/>
                8.2.2.1.10 <a href="#sec_inference_ancestor_of_self">Inference rules for the ancestor-or-self axis</a><br/>
            8.2.2.2 <a href="#sec_dyn_axes">Dynamic semantics of axes</a><br/>
        8.2.3 <a href="#sec_test_judge">Auxiliary judgments for node tests</a><br/>
            8.2.3.1 <a href="#sec_sem_node_tests">Static semantics of node tests</a><br/>
                8.2.3.1.1 <a href="#sec_sem_name_tests">Name Tests</a><br/>
                8.2.3.1.2 <a href="#sec_sem_kind_tests">Kind Tests</a><br/>
            8.2.3.2 <a href="#sec_dyn_node_tests">Dynamic semantics of node tests</a><br/>
                8.2.3.2.1 <a href="#sec_dyn_sem_name_tests">Name Tests</a><br/>
                8.2.3.2.2 <a href="#sec_dyn_kind_tests">Kind Tests</a><br/>
    8.3 <a href="#sec_type_matching">Judgments for type matching</a><br/>
        8.3.1 <a href="#sec_matches">Matches</a><br/>
        8.3.2 <a href="#sec_subtyping">Subtype and Type equality</a><br/>
    8.4 <a href="#sec_factor">Judgments for FLWOR and other expressions on sequences</a><br/>
    8.5 <a href="#sec_promotion_judgments">Judgments for function calls</a><br/>
        8.5.1 <a href="#sec_promotion">Type promotion</a><br/>
    8.6 <a href="#sec_validation_mode">Judgments for validation modes and contexts</a><br/>
        8.6.1 <a href="#jd_aux_context_is">Elements in validation mode</a><br/>
</p>
<h3><a id="appendices" name="appendices"/>Appendices</h3><p class="toc">A <a href="#sec_core">Normalized core grammar</a><br/>
    A.1 <a href="#sec_core_grammar">Core BNF</a><br/>
B <a href="#sec_functions_and_operators">Functions and Operators</a><br/>
    B.1 <a href="#sec_used_functions">Functions and Operators used in the Formal Semantics</a><br/>
    B.2 <a href="#sec_operators">Mapping of Overloaded Internal Functions</a><br/>
C <a href="#sec_importing_schema">Importing Schemas</a><br/>
    C.1 <a href="#sec_import_intro">Introduction</a><br/>
        C.1.1 <a href="#sec_import_features">Features</a><br/>
        C.1.2 <a href="#sec_import_organization">Organization</a><br/>
        C.1.3 <a href="#sec_import_mapping">Main mapping rules</a><br/>
        C.1.4 <a href="#sec_use">Special attributes</a><br/>
            C.1.4.1 <a href="#sec_import_attributes">use, default, and fixed</a><br/>
            C.1.4.2 <a href="#prod-formal-OccursAttributes">minOccurs, maxOccurs, minLength, maxLength, and length</a><br/>
            C.1.4.3 <a href="#sec_import_mixed">mixed</a><br/>
            C.1.4.4 <a href="#sec_import_nillable">nillable</a><br/>
            C.1.4.5 <a href="#sec_import_substitution">substitutionGroup</a><br/>
        C.1.5 <a href="#sec_import_anonymous">Anonymous type names</a><br/>
    C.2 <a href="#sec_schema_as_a_whole">Schemas as a whole</a><br/>
        C.2.1 <a href="#sec_import_whole">Schema</a><br/>
        C.2.2 <a href="#sec_import_include">Include</a><br/>
        C.2.3 <a href="#sec_import_redefine">Redefine</a><br/>
        C.2.4 <a href="#sec_import_import">Import</a><br/>
    C.3 <a href="#sec_import_attribute_decl">Attribute Declarations</a><br/>
        C.3.1 <a href="#sec_import_global_attributes">Global attributes declarations</a><br/>
        C.3.2 <a href="#sec_import_local_attributes">Local attribute declarations</a><br/>
    C.4 <a href="#sec_import_element">Element Declarations</a><br/>
        C.4.1 <a href="#sec_import_global_element">Global element declarations</a><br/>
        C.4.2 <a href="#sec_import_local_element">Local element declarations</a><br/>
    C.5 <a href="#sec_complex_type">Complex Type Definitions</a><br/>
        C.5.1 <a href="#sec_import_global_complex_type">Global complex type</a><br/>
        C.5.2 <a href="#sec_import_local_complex_type">Local complex type</a><br/>
        C.5.3 <a href="#sec_import_ct_simple">Complex type with simple content</a><br/>
        C.5.4 <a href="#sec_import_ct_complex">Complex type with complex content</a><br/>
    C.6 <a href="#sec_attribute_use">Attribute Uses</a><br/>
    C.7 <a href="#sec_attribute_group">Attribute Group Definitions</a><br/>
        C.7.1 <a href="#sec_attribute_group_def">Attribute group definitions</a><br/>
        C.7.2 <a href="#sec_import_attribute_group_ref">Attribute group reference</a><br/>
    C.8 <a href="#sec_import_model">Model Group Definitions</a><br/>
    C.9 <a href="#sec_import_model_groups">Model Groups</a><br/>
        C.9.1 <a href="#sec_import_all_groups">All groups</a><br/>
        C.9.2 <a href="#sec_import_choice_groups">Choice groups</a><br/>
        C.9.3 <a href="#sec_import_sequence_groups">Sequence groups</a><br/>
    C.10 <a href="#sec_import_particles">Particles</a><br/>
        C.10.1 <a href="#sec_import_element_ref">Element reference</a><br/>
        C.10.2 <a href="#sec_group_ref">Group reference</a><br/>
    C.11 <a href="#sec_import_wildcards">Wildcards</a><br/>
        C.11.1 <a href="#sec_import_attribute_wildcards">Attribute wildcards</a><br/>
        C.11.2 <a href="#sec_import_element_wildcards">Element wildcards</a><br/>
    C.12 <a href="#sec_import_identity">Identity-constraint Definitions</a><br/>
    C.13 <a href="#sec_import_notation">Notation Declarations</a><br/>
    C.14 <a href="#sec_import_annotation">Annotation</a><br/>
    C.15 <a href="#sec_import_simple_type">Simple Type Definitions</a><br/>
        C.15.1 <a href="#sec_import_global_simple_type">Global simple type definition</a><br/>
        C.15.2 <a href="#sec_import_local_simple_type">Local simple type definition</a><br/>
        C.15.3 <a href="#sec_import_simple_type_content">Simple type content</a><br/>
D <a href="#appendix_references">References</a><br/>
    D.1 <a href="#id-normative-references">Normative References</a><br/>
    D.2 <a href="#id-non-normative-references">Non-normative References</a><br/>
    D.3 <a href="#id-background-references">Background References</a><br/>
E <a href="#sec_validation_judgments">Auxiliary Judgments for Validation</a> (Non-Normative)<br/>
    E.1 <a href="#sec_validate">Judgments for the validate expression</a><br/>
        E.1.1 <a href="#N283F9">Type resolution</a><br/>
        E.1.2 <a href="#N2866D">Interleaving</a><br/>
        E.1.3 <a href="#sec_jd_filter">Attribute filtering</a><br/>
        E.1.4 <a href="#N28965">Erasure</a><br/>
            E.1.4.1 <a href="#N28968">Simply erases</a><br/>
            E.1.4.2 <a href="#N28A83">Erases</a><br/>
        E.1.5 <a href="#N28D8B">Annotate</a><br/>
            E.1.5.1 <a href="#sec_simply_annotate">Simply annotate</a><br/>
            E.1.5.2 <a href="#N2915A">Nil-annotate</a><br/>
            E.1.5.3 <a href="#N2934E">Annotate</a><br/>
F <a href="#id-fs-revisions-log">Revision Log</a> (Non-Normative)<br/>
    F.1 <a href="#N29C51">15 September 2005</a><br/>
</p></div><hr/><div class="body"><div class="div1">
<h2><a id="introduction" name="introduction"/>1 Introduction</h2><p>This document defines the formal semantics of XQuery 1.0 and
  XPath 2.0. The present document is part of a set of documents that
  together define the XQuery 1.0 and XPath 2.0 languages:</p><ul><li><p><a href="#xquery">[XQuery 1.0: A Query Language for XML]</a> introduces the XQuery 1.0 language, defines
      its capabilities from a user-centric view, and defines the
      language syntax.</p></li><li><p><a href="#xpath20">[XML Path Language (XPath) 2.0]</a> introduces the XPath 2.0 language, defines its
      capabilities from a user-centric view, and defines the language
      syntax.</p></li><li><p><a href="#xpath-functions">[Functions and Operators]</a> lists the functions and operators defined for
      the [XPath/XQuery] language and specifies the required types of their 
      parameters and return value.  </p></li><li><p><a href="#xpath-datamodel">[Data Model]</a> formally specifies the data model used by
      [XPath/XQuery] to represent the content of XML documents.  The
      [XPath/XQuery] language is formally defined by operations on this
      data model.</p></li><li><p><a href="#xslt-xquery-serialization">[Data Model Serialization]</a> specifies how [XPath/XQuery] data
      model values are serialized into XML.</p></li></ul><p>The scope and goals for the [XPath/XQuery] language are discussed in
  the charter of the W3C [XSL/XML Query] Working Group and in the [XPath/XQuery]
  requirements <a href="#xquery-requirements">[XML Query 1.0 Requirements]</a>.</p><p>This document defines the semantics of [XPath/XQuery] by giving a
  precise formal meaning to each of the expressions of the [XPath/XQuery]
  specification in terms of the [XPath/XQuery] data model. This document
  assumes that the reader is already familiar with the [XPath/XQuery]
  language. This document defines the formal semantics for XPath 2.0
  only when the XPath 1.0 backward compatibility rules are not in
  effect.</p><p>Two important design aspects of [XPath/XQuery] are that it is
  <em>functional</em> and that it is <em>typed</em>. These two
  aspects play an important role in the [XPath/XQuery] Formal
  Semantics.</p><p><b>[XPath/XQuery] is a functional language</b>. [XPath/XQuery] is
  built from expressions, rather than statements. Every construct in
  the language (except for the XQuery query prolog) is an expression
  and expressions can be composed arbitrarily. The result of one
  expression can be used as the input to any other expression, as long
  as the type of the result of the former expression is compatible
  with the input type of the latter expression with which it is
  composed. Another characteristic of a functional language is that
  variables are always passed by value, and a variable's value cannot
  be modified through side effects.</p><p><b>[XPath/XQuery] is a typed language</b>. Types can be
  imported from one or more XML Schemas that describe the input
  documents and the output document, and the [XPath/XQuery] language can
  then perform operations based on these types. In addition,
  [XPath/XQuery] supports <em>static type analysis</em>.  Static type
  analysis infers the output type of an expression based on the type
  of its input expressions.  In addition to inferring the type an
  expression for the user, static typing allows early detection of
  type errors, and can be used as the basis for certain classes of
  optimization. The [XPath/XQuery] type system captures most of the
  features of <a href="#xmlschema-1">[Schema Part 1]</a>, including global and local element and
  attribute declarations, complex and simple type definitions, named
  and anonymous types, derivation by restriction, extension, list and
  union, substitution groups, and wildcard types. It does not model
  uniqueness constraints and facet constraints on simple types.</p><p>This document is organized as follows. <a href="#sec_preliminaries"><b>[2 Preliminaries]</b></a> introduces the notations used to define
  the [XPath/XQuery] Formal Semantics.  These include the formal notations
  for values in the [XPath/XQuery] data model and for types in XML Schema.
  The next three sections: <a href="#id-basics"><b>[3 Basics]</b></a>, <a href="#id-expressions"><b>[4 Expressions]</b></a>, and <a href="#id-query-prolog"><b>[5 Modules and Prologs]</b></a> have
  the same structure as the corresponding sections in the
  <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a> and <a href="#xpath20">[XML Path Language (XPath) 2.0]</a> documents.  This allows the reader to
  quickly find the formal definition of a particular language
  construct.  <a href="#id-basics"><b>[3 Basics]</b></a> defines the semantics for
  basic [XPath/XQuery] concepts, and <a href="#id-expressions"><b>[4 Expressions]</b></a>
  defines the dynamic and static semantics of each [XPath/XQuery]
  expression.  <a href="#id-query-prolog"><b>[5 Modules and Prologs]</b></a> defines the semantics
  of the [XPath/XQuery] prolog.

  <a href="#sec_special_functions"><b>[7 Additional Semantics of Functions]</b></a> defines the static semantics
  of several functions in <a href="#xpath-functions">[Functions and Operators]</a> and gives the dynamic and
  static semantics of several supporting functions used in this
  document.  The remaining sections, <a href="#sec_auxiliary_judgments"><b>[8 Auxiliary Judgments]</b></a> and <a href="#sec_importing_schema"><b>[C Importing Schemas]</b></a>, contain material that supports the
  formal semantics of [XPath/XQuery].  <a href="#sec_auxiliary_judgments"><b>[8 Auxiliary Judgments]</b></a> defines formal judgments that relate
  data model values to types, that relate types to types, and that
  support the formal definition of validation.  These judgments are
  used in the definition of expressions in <a href="#id-expressions"><b>[4 Expressions]</b></a>.

  Lastly, <a href="#sec_importing_schema"><b>[C Importing Schemas]</b></a>, specifies how XML Schema documents are
  imported into the [XPath/XQuery] type system and relates XML Schema
  types to the [XPath/XQuery] type system.</p><div class="div2">
<h3><a id="id-normativity" name="id-normativity"/>1.1 Normative and Informative
  Sections</h3><p>Certain aspects of language processing are described in this
  specification as <b>implementation-defined</b> or
  <b>implementation-dependent</b>.</p><ul><li><p>[<a title="implementation       defined" id="dt-implementation-defined" name="dt-implementation-defined">Definition</a>: <b>Implementation-defined</b> indicates an aspect
      that may differ between implementations, but must be specified
      by the implementor for each particular
      implementation.]</p></li><li><p>[<a title="implementation       dependent" id="dt-implementation-dependent" name="dt-implementation-dependent">Definition</a>: <b>Implementation-dependent</b> indicates an
      aspect that may differ between implementations, is not specified
      by this or any W3C specification, and is not required to be
      specified by the implementor for any particular
      implementation.]</p></li></ul><p class="xpath">A language aspect described in this specification as
  <b>implementation-defined</b> or <b>implementation
  dependent</b> may be further constrained by the specifications of
  a host language in which XPath or XQuery is embedded.</p><p>This document contains the normative static semantics of
  [XPath/XQuery]. The static semantics rules in <a href="#id-basics"><b>[3 Basics]</b></a>, <a href="#id-expressions"><b>[4 Expressions]</b></a>, <a href="#id-query-prolog"><b>[5 Modules and Prologs]</b></a>, and <a href="#sec_special_functions"><b>[7 Additional Semantics of Functions]</b></a>
  are normative. <a href="#static_context"><b>[3.1.1 Static Context]</b></a> is normative, because
  it defines the static context used in the static typing rules.
  <a href="#sec_auxiliary_judgments"><b>[8 Auxiliary Judgments]</b></a> is normative, because it
  contains all the judgments necessary for defining SequenceType
  Matching.</p><p>The dynamic semantics of [XPath/XQuery] are normatively defined in
  <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a> and <a href="#xpath20">[XML Path Language (XPath) 2.0]</a>. In this document, the dynamic
  semantic rules in <a href="#id-basics"><b>[3 Basics]</b></a>, <a href="#id-expressions"><b>[4 Expressions]</b></a>, and <a href="#id-query-prolog"><b>[5 Modules and Prologs]</b></a>, the
  examples, and the material labeled as "Note" are provided for
  explanatory purposes and are not normative.</p><p>The mapping rules from XML Schema to the XQuery type system
  provided in <a href="#sec_importing_schema"><b>[C Importing Schemas]</b></a>, and the formal
  semantics of XML Schema validation in <a href="#sec_validation_judgments"><b>[E Auxiliary Judgments for Validation]</b></a> are informative and do not handle
  every feature of XML Schema.</p></div></div><div class="div1">
<h2><a id="sec_preliminaries" name="sec_preliminaries"/>2 Preliminaries</h2><p>This section provides the background necessary to understand the
  Formal Semantics, introduces the notations that are used, and
  explains its relationship to other documents.</p><div class="div2">
<h3><a id="sec_intro" name="sec_intro"/>2.1 Introduction to the Formal Semantics</h3><p><b>Why a Formal Semantics?</b> The goal of the formal
    semantics is to complement the [XPath/XQuery] specification
    (<a href="#xquery">[XQuery 1.0: A Query Language for XML]</a> and <a href="#xpath20">[XML Path Language (XPath) 2.0]</a>), by defining the meaning of
    [XPath/XQuery] expressions with mathematical rigor.</p><p>A rigorous formal semantics clarifies the intended meaning of
    the English specification, ensures that no corner cases are left
    out, and provides a reference for implementation.</p><p><b>Why use formal notations?</b> Rigor is achieved by the
    use of formal notations to represent [XPath/XQuery] objects such as
    expressions, XML values, and XML Schema types, and by the
    systematic definition of the relationships between those objects
    to reflect the meaning of the language.  In particular, the
    dynamic semantics relates [XPath/XQuery] expressions to the XML value
    to which they evaluate, and the static semantics relates
    [XPath/XQuery] expressions to the XML Schema type that is inferred for
    that expression.</p><p>The Formal Semantics uses several kinds of formal notations to
    define the relationships between [XPath/XQuery] expressions, XML
    values, and XML Schema types. This section introduces the
    notations for judgments, inference rules, and mapping rules as
    well as the notation for environments, which implement the dynamic
    and static contexts. The reader already familiar with these
    notations can skip this section and continue with <a href="#sec_values"><b>[2.3 XML Values]</b></a>.</p><div class="div3">
<h4><a id="sec_grammar_notations" name="sec_grammar_notations"/>2.1.1 Notations from grammar productions</h4><p>Grammar productions are used to describe
      "objects" (values, types, [XPath/XQuery] expressions,
      etc.) manipulated by the Formal Semantics. The Formal Semantics
      makes use of several kinds of grammar productions: productions
      from the [XPath/XQuery] grammar itself, productions for a subset of
      the [XPath/XQuery] language called the XQuery Core which is used
      throughout this document, and other productions used for formal
      specification only such as for the XQuery type system.</p><p>XQuery grammar productions describe the XQuery language and
      expressions. XQuery productions are identified by a number,
      which corresponds to their number in the <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a>
      document, and are marked with "(XQuery)". For
      instance, the following production describes FLWOR expressions
      in XQuery.</p>
<h5><a id="N1032B" name="N1032B"/>[For/FLWOR] Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="noid_N10464.doc-xquery-FLWORExpr" name="noid_N10464.doc-xquery-FLWORExpr"/>[<small>33 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-FLWORExpr">FLWORExpr</a></code></td><td>   ::=   </td><td><code>(<a href="#doc-xquery-ForClause">ForClause</a>  |  <a href="#doc-xquery-LetClause">LetClause</a>)+  <a href="#doc-xquery-WhereClause">WhereClause</a>?  <a href="#doc-xquery-OrderByClause">OrderByClause</a>?  "return"  <a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p>For the purpose of this document, the differences between the
      XQuery 1.0 and the XPath 2.0 grammars are mostly irrelevant. By
      default, this document uses XQuery 1.0 grammar
      productions. Whenever the grammar for XPath 2.0 differs from the
      one for XQuery 1.0, the corresponding XPath 2.0 productions are
      also given. XPath productions are identified by a number, which
      corresponds to their number in <a href="#xpath20">[XML Path Language (XPath) 2.0]</a>, and are marked with
      "(XPath)". For instance, the following production
      describes for expressions in XPath.</p>
<h5><a id="N1035B" name="N1035B"/>[For/FLWOR] Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="noid_N1047B.doc-xpath-ForExpr" name="noid_N1047B.doc-xpath-ForExpr"/>[<small>4 (XPath)</small>]   </td><td><code><a href="http://www.w3.org/TR/xpath20/#prod-xpath-ForExpr">ForExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xpath-SimpleForClause">SimpleForClause</a>  "return"  ExprSingle</code></td></tr></tbody></table><p>XQuery Core grammar productions describe the XQuery Core. The
      Core grammar is given in <a href="#sec_core"><b>[A Normalized core grammar]</b></a>. Core
      productions are identified by a number, which corresponds to
      their number in <a href="#sec_core"><b>[A Normalized core grammar]</b></a>, and are marked with
      "(Core)". For instance, the following production
      describes the simpler form of the "FLWOR"
      expression in the XQuery Core.</p>
<h5><a id="N1037E" name="N1037E"/>Core FLWOR Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="noid_N10496.doc-core-FLWORExpr" name="noid_N10496.doc-core-FLWORExpr"/>[<small>32 (Core)</small>]   </td><td><code><a href="#prod-core-FLWORExpr">FLWORExpr</a></code></td><td>   ::=   </td><td><code>(<a href="#doc-core-ForClause">ForClause</a>  |  <a href="#doc-core-LetClause">LetClause</a>)  "return"  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p>The Formal Semantics manipulates "objects"
      (values, types, expressions, etc.)  for which there is no
      existing grammar production in the <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a> document. In
      these cases, specific grammar productions are
      introduced. Notably, additional productions are used to describe
      values in the <a href="#xpath-datamodel">[Data Model]</a>, and to describe the [XPath/XQuery]
      type system. Formal Semantics productions are identified by a
      number, and are marked by "(Formal)". For instance,
      the following production describes global type definitions in
      the [XPath/XQuery] type system.</p>
<h5><a id="N103A8" name="N103A8"/>Type Definitions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="noid_N104B7.doc-fs-Definition" name="noid_N104B7.doc-fs-Definition"/>[<small>39 (Formal)</small>]   </td><td><code>Definition</code></td><td>   ::=   </td><td><code>("define"  "element"  <a href="#doc-fs-ElementName">ElementName</a>  <a href="#doc-fs-OptSubstitution">OptSubstitution</a>  <a href="#doc-fs-OptNillable">OptNillable</a>  <a href="#doc-fs-TypeReference">TypeReference</a>)<br/>|  ("define"  "attribute"  <a href="#doc-fs-AttributeName">AttributeName</a>  <a href="#doc-fs-TypeReference">TypeReference</a>)<br/>|  ("define"  "type"  <a href="#doc-fs-TypeName">TypeName</a>  <a href="#doc-fs-TypeDerivation">TypeDerivation</a>)</code></td></tr></tbody></table><p>Note that grammar productions that are specific to the Formal
      Semantics (i.e., marked with "(Formal)") are not
      part of [XPath/XQuery]. They are not accessible to the user and are
      only used in the course of defining the languages'
      semantics.</p><p>Grammar non-terminals are used extensively in this document
      to represent objects in judgments (see the next section). As a
      convenience, non-terminals used in judgments link to the
      appropriate grammar production.</p></div><div class="div3">
<h4><a id="sec_judgments" name="sec_judgments"/>2.1.2 Notations for judgments</h4><p>The basic building block of the formal specification is
      called a <em>judgment</em>. A judgment expresses whether a
      property holds or not.</p><p>For example:</p><p><b>Notation</b></p>
        <p>The judgment</p>

        <div align="center">
          
          <em>Object</em> <b>is a positive
          integer</b>
          
        </div>

        <p>holds if the object <em>Object</em> is a positive
        integer.</p>
      <p>A judgment may hold (if it is true) or not hold (if it is
      false). For instance '1 <b>is a positive integer</b>'
      holds and '-1 <b>is a positive integer</b>' does not
      hold.</p><p><b>Notation</b></p>
        <p>Here are two other example judgments.</p>

        <p>The judgment</p>

        <div align="center">
          
          <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
          
        </div>

        <p>holds if the expression <em>Expr</em> yields (or evaluates to)
        the value <a href="#doc-fs-Value"><em>Value</em></a>.</p>

        <p>The judgment</p>

        <div align="center">
        
          <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
        
        </div>

        <p>holds if the expression <em>Expr</em> has the type
        <a href="#doc-fs-Type"><em>Type</em></a>.</p>

        <p>Most other judgments used in this document are short
        English sentences intended to reflect their meaning, and
        written in bold fonts. For instance, the judgment</p>

        <div align="center">
        
          <em>Axis</em> <a href="#jd_principal" class="judgment"><b>principal</b></a> <em>PrincipalNodeKind</em>
        
        </div>

        <p>holds if <em>PrincipalNodeKind</em> is the principal node kind
        for the axis <em>Axis</em>.</p>
      <p>A judgment can contain <em>symbols</em> and
      <em>patterns</em>.</p><p>Symbols are purely syntactic and are used to write the
      judgment itself. In general, symbols in a judgment are chosen to
      reflect its meaning. For example, '<b>is beautiful</b>',
      '<b>=&gt;</b>' and '<b>:</b>' are symbols, the
      second and third of which should be read "yields",
      and "has type" respectively.</p><p>Patterns are used to represent objects that can be
      constructed from a given grammar production. In patterns,
      italicized words correspond to non-terminals in the grammar. The
      name of those non-terminals is significant, and may be
      instantiated only to an "object" (a value, a type,
      an expression, etc.) that can be substituted legally for that
      non-terminal. For example, '<em>Expr</em>' is a pattern that stands
      for every [XPath/XQuery] expressions, '<em>Expr</em><sub><font size="2">1</font></sub> + <em>Expr</em><sub><font size="2">2</font></sub>' is a
      pattern that stands for every addition expression, 'element a {
      <a href="#doc-fs-Value"><em>Value</em></a> }' is a pattern that stands for every value in the
      [XPath/XQuery] data model that is an 'a' element.</p><p>Non-terminals in a pattern may appear with subscripts
      (e.g. <em>Expr</em><sub><font size="2">1</font></sub>, <em>Expr</em><sub><font size="2">2</font></sub>) to distinguish different instances
      of the same sort of pattern. In some cases, non-terminals in a
      pattern may have a name that is not exactly the name of that non
      terminal, but is based on it. For instance, a <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
      is a pattern that stands for a type name, as would
      <a href="#doc-fs-TypeName"><em>TypeName</em></a>, or <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">2</font></sub>. This usage is limited, and
      only occurs to improve the readability of some of the inference
      rules.</p><p>When <em>instantiating</em> the judgment, each pattern
      must be instantiated to an appropriate sort of
      "object" (value, type, expression, etc). For
      example, '3 <b>=&gt;</b> 3' and '$x+0 <b>=&gt;</b>
      3' are both instances of the judgment '<em>Expr</em>
      <b>=&gt;</b> <a href="#doc-fs-Value"><em>Value</em></a>'. Note that in the first
      judgment, '3' corresponds to both the expression '3' (on the
      left-hand side of the <b>=&gt;</b> symbol) and to the
      value '3' (on the right-hand side of the <b>=&gt;</b>
      symbol).</p><p id="jd_not">In some cases, inference rules may need to use
      the fact that a certain judgment <em>does not</em> hold.
      <a href="#jd_not" class="judgment"><b>not</b></a>(<em>Judgment</em>) holds
      iff <em>Judgment</em> does not hold.</p><p id="jd_isin">In some cases, a pattern may be instantiated to
      a value within a finite set of pre-determined values. We may
      write that set of possible values using the <a href="#jd_isin" class="judgment"><b>in</b></a>
      judgment. For instance, the judgment</p><div align="center">
          
          <em>Color</em> <a href="#jd_isin" class="judgment"><b>in</b></a> {
          <b>blue</b>, <b>green</b> }
          
          
        </div><p>holds if the pattern <em>Color</em> has either the value
      <em>blue</em> or the value <em>green</em>.</p></div><div class="div3">
<h4><a id="sec_environments" name="sec_environments"/>2.1.3 Notations for environments</h4><p id="xq_environment">An environment component is a dictionary
      that maps a symbol (e.g., a function name or a variable name) to
      an "object" (e.g., a function body, a type, a
      value). One can access information in an environment component
      or update it.</p><p>If "envComp" is an environment component, then
      "envComp(<em>symbol</em>)" denotes the
      "object" to which <em>symbol</em> is mapped.
      The notation is intentionally similar to function application,
      because an environment component can be considered a function
      from the argument <em>symbol</em> to the
      "object" to which the <em>symbol</em> is
      mapped.</p><p>This document uses <em>environments</em> that group
      related environment components. If "env" is an
      environment containing the environment component
      "envComp", that environment component is denoted
      "env.envComp". The value that <em>symbol</em>
      is mapped to in that environment component is denoted
      "env.envComp(<em>symbol</em>)".</p><p>The two main environments used in the Formal Semantics are: a
      dynamic environment (<a href="#xq_dyn_env_def" class="env">dynEnv</a>), which models the
      [XPath/XQuery]'s dynamic context, and a static environment
      (<a href="#xq_stat_env_def" class="env">statEnv</a>), which models the [XPath/XQuery]'s static
      context. Both are defined in <a href="#sec_context"><b>[3.1 Expression Context]</b></a>.</p><p>For example, <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a> denotes the dynamic environment
      component that maps variables to values and
      <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em>) denotes the value of the variable
      <em>Variable</em> in the dynamic context.</p><p>Environments are used in a judgment to capture some of the
      context in which the judgment is computed, and most judgments
      are computed assuming that some environment is given. This
      <em>assumption</em> is denoted by prefixing the judgment
      with "env |-". The
      "|-" symbol is called a
      "turnstile" and is used in almost all inference
      rules.</p><p>For instance, the judgment</p><div align="center">
        
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
          
      	    <em>Expr</em> <b>=&gt;</b> <a href="#doc-fs-Value"><em>Value</em></a>
          
        
      </div><p>is read as: Assuming the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>,
      the expression <em>Expr</em> yields the value <a href="#doc-fs-Value"><em>Value</em></a>.</p><p>Environments can be <em>updated</em>, using the following
      notation:</p><ul><li><p>
            "env + envComp(<em>symbol</em> =&gt;
            <em>object</em>) "
            denotes the new environment that is identical to
            <em>env</em> except that the environment component
            <em>envComp</em> has been updated to map
            <em>symbol</em> to <em>object</em>. The notation
            <em>symbol</em> =&gt;
            <em>object</em> indicates that
            <em>symbol</em> is mapped to <em>object</em> in
            the new environment.</p></li><li><p>In case the environment component contains only a
            constant value (e.g., the ordering mode which can only be
            either ordered or unordered), the following notation is
            used to set its value.
            "env + envComp(
                    <em>object</em>
                  ) ".</p></li><li><p>
            The following shorthand is also allowed:
            "env + envComp(
                    <em>symbol</em><sub><font size="2">1</font></sub>
                    =&gt;
                    <em>object</em><sub><font size="2">1</font></sub>
                    ; ... ;
                    <em>symbol</em><sub><font size="2">n</font></sub>
                    =&gt;
                    <em>object</em><sub><font size="2">n</font></sub>
                  ) " in which each symbol is
                mapped to a corresponding object in the new
                environment.</p><p>This notation is equivalent to nested updates, as in
            "
              
                (env + envComp(
                <em>symbol</em><sub><font size="2">1</font></sub>
                =&gt;
                <em>object</em><sub><font size="2">1</font></sub>)
                + 
                ...
                ) + env(<em>symbol</em><sub><font size="2">n</font></sub>
                =&gt;
                <em>object</em><sub><font size="2">n</font></sub>)".
          </p></li></ul><p>Updating an environment creates a copy of the original
      environment and overrides any previous binding that might exist
      for the same name and the same component in that
      environment. Updating the environment is used to capture the
      <em>scope</em> of a symbol (e.g., for variables, namespace
      prefixes, etc). For instance, in the following expression</p><div class="exampleInner"><pre>
  let $x := 1 return
  let $x := $x + 2 return
  $x - 3
</pre></div><p>each let expression changes the dynamic context by binding a
      new variable to a new value. Each different context is
      represented by a different environment. The original
      environment, in which the expression <code>1</code> is
      evaluated, does not contain any binding for variable
      <code>$x</code>. This environment is updated a first time with a
      binding of variable <code>$x</code> to the value <code>1</code>,
      and this environment is used for the evaluation of the
      expression <code>$x + 2</code>. Then it is updated a second time
      with a binding of variable <code>$x</code> to the value
      <code>3</code>, and this environment is used for the evaluation
      of the expression <code>$x - 3</code>.</p><p>Also, note that there are no operations to remove entries
      from environments. This is never necessary as updating an
      environment effectively creates a new extended copy of the
      original environment, leaving the original environment
      accessible wherever it is in scope along with the updated
      copy.</p></div><div class="div3">
<h4><a id="sec_inference" name="sec_inference"/>2.1.4 Notations for inference rules</h4><p>Inference rules are used to specify how to infer whether a
      given judgment holds or not. Inference rules express the logical
      relation between judgments and describe how complex judgments
      can be concluded from simpler premise judgments. </p><p>A logical inference rule is written as a collection of
      <em>premise</em>s and a <em>conclusion</em>, written
      respectively above and below a dividing line, as follows:</p><div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
    	 <tr valign="middle" align="center"><td>
    	  
    	   
    	       <em>premise</em><sub><font size="2">1</font></sub>
    	       ...
    	       <em>premise</em><sub><font size="2">n</font></sub>
    	   
    	  
    	 </td></tr>
    	 <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
    	  
    	   
    	       <em>conclusion</em>
    	   
    	  
    	 </td></tr>
    	</table><br/>
      </div><p>All premises and the conclusion are judgments. From a logical
      point of view, an inference rule is a deduction that if the
      premises hold, then the conclusion holds as well. In that sense,
      the previous inference rule has a similar meaning as the
      following logical statement.</p><p>IF <em>premise</em><sub><font size="2">1</font></sub></p><p>AND ...</p><p>AND <em>premise</em><sub><font size="2">n</font></sub></p><p>THEN <em>conclusion</em></p><p>Here is a simple example of inference rule, which uses
      specific instances of the example judgment '<em>Expr</em>
      <b>=&gt;</b> <a href="#doc-fs-Value"><em>Value</em></a>' from above:</p><div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
    	 <tr valign="middle" align="center"><td>
    	  
    	   
    	       $x <b>=&gt;</b> 0
    	   
    	      
    	  
    	   
    	       3 <b>=&gt;</b> 3
    	   
    	  
    	 </td></tr>
    	 <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
    	  
    	    
    	       $x + 3 <b>=&gt;</b> 3
    	    
    	  
    	 </td></tr>
    	</table><br/>
      </div><p>This inference rule expresses the following property:
      <em>if</em> the variable expression '$x' yields the value
      '0', <em>and</em> the literal expression '3' yields the
      value '3', <em>then</em> the expression '$x + 3' yields the
      value '3'.</p><p>An inference rule may have no premises above the line, which
      means that the expression below the line always holds. For
      instance:</p><div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
    	 <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
    	  
    	    
    	       3 <b>=&gt;</b> 3 
    	    
    	  
    	 </td></tr>
    	</table><br/>
      </div><p>This inference rule expresses the following property:
      evaluating the literal expression '3' always yields the value
      '3'.</p><p>The two above rules are expressed in terms of specific
      expressions and values, but usually rules are more abstract.
      That is, the judgments are not fully instantiated. Here is a
      rule that says that for any variable <em>Variable</em> that yields
      the integer value <em>Integer</em>, adding '0' yields the same
      integer value:</p><div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
           
             
                <a href="#prod-core-VarRef"><em>VarRef</em></a> <b>=&gt;</b> <em>Integer</em>
             
           
         </td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
            
              <a href="#prod-core-VarRef"><em>VarRef</em></a> + 0 <b>=&gt;</b> <em>Integer</em>
            
          
         </td></tr>
        </table><br/>
      </div><p>Each occurrence of a given pattern in a particular inference
      rule must be instantiated to the same "object"
      within the entire rule.  This means that one can talk about
      "the value of <em>Variable</em>" instead of the value
      bound to the first (second, etc) occurrence of <a href="#prod-core-VarRef"><em>VarRef</em></a>.</p><p>Here is an example of a rule occurring later in this
      document.</p><div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
         
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <em>Expr</em><sub><font size="2">1</font></sub> <b>:</b> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
             
         
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <em>Expr</em><sub><font size="2">2</font></sub> <b>:</b> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
         
        </td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
         
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <em>Expr</em><sub><font size="2">1</font></sub> , <em>Expr</em><sub><font size="2">2</font></sub> <b>:</b> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
         
        </td></tr>
       </table><br/>
      </div><p>This rule is read as follows: if two expressions <em>Expr</em><sub><font size="2">1</font></sub>
      and <em>Expr</em><sub><font size="2">2</font></sub> are known to have the static types <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> and
      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> (the two premises above the line), then it is the
      case that the sequence expression "<em>Expr</em><sub><font size="2">1</font></sub> ,
      <em>Expr</em><sub><font size="2">2</font></sub>" has the static type "<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>", which is the sequence of types <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
      and <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>. Note that this inference rule does not modify
      the static environment.</p><p>The following rule defines the static semantics of a
      "let" expression. The binding of the new variable
      is captured by an update to the varType component of the
      original static environment.</p><div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
    	<tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
    	 
    	  <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
    	  
    		  <em>VarName</em> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
    	   
    	 
         </td></tr>
         <tr valign="middle" align="center"><td>
    	 
    	  <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
    	  
    		  <em>Expr</em><sub><font size="2">1</font></sub> <b>:</b> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
    	   
    	     
    	 
    		
    		  <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) 
    		<b> |- </b>
    		
    		    <em>Expr</em><sub><font size="2">2</font></sub> <b>:</b> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
    	  
    	 
         </td></tr>
    	</table></td></tr></table></td></tr>
    	<tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
    	 
    	  <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
    	  
    		  <code>let</code>
    		  <code>$</code><em>VarName</em> := <em>Expr</em><sub><font size="2">1</font></sub>
    		  <code>return</code>
    		  <em>Expr</em><sub><font size="2">2</font></sub> <b>:</b> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
    	  
    	 
    	</td></tr>
       </table><br/>
      </div><p>This rule is read as follows: First, because the variable is
      a QName, it is first expanded into an expanded QName.  Second,
      the type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> for the "let" input expression
      <em>Expr</em><sub><font size="2">1</font></sub> is computed.  Then the "let" variable
      with expanded name, <a href="#id-expanded-qnames"><em>expanded-QName</em></a> with type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> is added
      into the varType component of the static environment
      <a href="#xq_stat_env_def" class="env">statEnv</a>. Finally, the type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> of <em>Expr</em><sub><font size="2">2</font></sub> is
      computed in that new environment.</p></div><div class="div3">
<h4><a id="sec_together" name="sec_together"/>2.1.5 Putting it together</h4><p>In isolation, each inference rule describes a fragment of the
      semantics for a given judgment. Put together, inference rules
      describe possible inferences that can be used to decide whether
      that a particular judgment hold.</p><p>For a given judgment, and a set of inference rules, if that
      judgment can be inferred to be true, the inference succeeds. In
      most cases, the inference will proceed by proving intermediate
      judgments, following the consequences from one judgment to the
      next by applying successive inference rules.</p><p>Such inference is a mechanism which can be used to describe
      both static type analysis and dynamic evaluation. More
      specifically, performing static typing consists in proving that
      the following judgment holds for a given expression
      <em>Expr</em>.</p><div align="center">
      
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
        <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
      
      </div><p>If the judgment holds for a given type <a href="#doc-fs-Type"><em>Type</em></a>, this type
      is a possible static type for the expression. If there exists no
      type for which this judgment holds, then static typing
      fails and a static type error is returned to the user.</p><p>Consider the following expression.</p><div class="exampleInner"><pre>
  fn:count((1,2,3))
</pre></div><p>Using the static typing rules given for expressions in the
      rest of this document, one can deduce that the expression is of
      type <code>xs:integer</code> through the following inference.</p><div class="exampleInner"><pre>
  statEnv |- 1 : xs:integer  (from typing of literals)
  statEnv |- 2 : xs:integer  (from typing of literals)
  --------------------------------------------------- (sequence)
    statEnv |- 1,2 : xs:integer, xs:integer
    statEnv |- 3 : xs:integer
    ----------------------------------------------------- (sequence)
    statEnv |- 1,2,3 : xs:integer, xs:integer, xs:integer

    declare function fn:count($x as item()*) as xs:integer
    statEnv |- xs:integer,xs:integer,xs:integer &lt;: item*
    ---------------------------------------------------------- (function call)
    statEnv |- fn:count((1,2,3)) : xs:integer
</pre></div><p>Conversly, consider the following expression.</p><div class="exampleInner"><pre>
  fn:nilled((1,2,3))
</pre></div><p>Using the static typing rules given for expressions in the rest
   of this document, one can apply inference rules up to the
   following point.</p><div class="exampleInner"><pre>
    ....
    ----------------------------------------------------- (sequence)
    statEnv |- 1,2,3 : xs:integer, xs:integer, xs:integer
</pre></div><p>However, there is no rule that can infer the type of
      <code>fn:nilled((1,2,3))</code>, because the static typing rules
      for function calls will only hold if the type of the function
      parameters is a subtype of the expected type. However, here
      <code>(xs:integer,xs:integer,xs:integer)</code> is not a node
      type, which is the expected type for the function
      <code>fn:nilled</code>.</p><p>Note that in some cases, the inference can only proceed
      through the appropriate changes to the environment. For
      instance, consider the following expression.</p><div class="exampleInner"><pre>
  let $x := 1 return ($x,$x)
</pre></div><p>Using the static typing rules given for expressions in the
      rest of this document, one can deduce that the expression is of
      type <code>(xs:integer,xs:integer)</code> through the following
      inference.</p><div class="exampleInner"><pre>
statEnv0.varType = ()

  -------------------------- (literal)
  statEnv0 |- 1 : xs:integer

statEnv1 = statEnv0 + varType($x =&gt; xs:integer)

     statEnv1.varType($x) = xs:integer
     --------------------------------- (variable reference)
     statEnv1 |- $x : xs:integer

     statEnv1.varType($x) = xs:integer
     --------------------------------- (variable reference)
     statEnv1 |- $x : xs:integer

     ------------------------------------------- (sequence)
     statEnv1 |- ($x,$x) : xs:integer,xs:integer

  -------------------------------------------------------------- (let)
  statEnv0 |- let $x := 1 return ($x,$x) : xs:integer,xs:integer
</pre></div><p>This example illustrates how each rule is applied to
      individual sub-expressions, and how the environment is used to
      maintain the relevant context information.</p></div></div><div class="div2">
<h3><a id="sec_namespaces" name="sec_namespaces"/>2.2 URIs, Namespaces, and Prefixes</h3><p>The Formal Semantics does not formally specify the adjustment
    of relative URIs according to a base URI. All URIs used in this
    document are assumed to be absolute URIs.</p><p>The Formal Semantics uses the following namespace prefixes.</p><ul><li><p><code>fn:</code> for functions and operators from the
      <a href="#xpath-functions">[Functions and Operators]</a> document.</p></li><li><p><code>xs:</code> for XML Schema components and
      built-in types.</p></li><li><p><code>xdt:</code> for [XPath/XQuery] built-in
      types.</p></li></ul><p>All these prefixes are assumed to be bound to the appropriate
    URIs.</p><p>In addition, the Formal Semantics uses the following special
    prefixes for specification purposes.</p><ul><li><p><em>dm:</em> for accessors of the
      <a href="#xpath-datamodel">[Data Model]</a>.</p></li><li><p><em>op:</em> for operators in
      <a href="#xpath-functions">[Functions and Operators]</a>.</p></li><li><p><em>fs:</em> for functions and types defined in
      the formal semantics.</p></li></ul><p>These prefixes are always italicized to emphasize that the
    corresponding functions, variables, and types are abstract: they
    are not and cannot be made accessible in [XPath/XQuery]. None of these
    special prefixes are given a URI.</p></div><div class="div2">
<h3><a id="sec_values" name="sec_values"/>2.3 XML Values</h3><p>The [XPath/XQuery] language is defined over values of the
    [XPath/XQuery] data model. The [XPath/XQuery] data model is defined
    normatively in <a href="#xpath-datamodel">[Data Model]</a>. We define the formal notation that
    is used in this document to describe and manipulate values in
    inference rules. Formal values are used for specification purposes
    only and are not exposed to the [XPath/XQuery] user.</p><p>This section gives the grammar for formal values, along with a
    summary of the corresponding data model properties. In the context
    of this document, all constraints on values that are specified in
    <a href="#xpath-datamodel">[Data Model]</a> are assumed to hold.</p><div class="div3">
<h4><a id="sec_data_model_overview" name="sec_data_model_overview"/>2.3.1 Formal values</h4><p>A value is a sequence of zero or more items.  An item is
      either an atomic value or a node.</p><p>An atomic value is a value in the value space of an atomic
      type, labeled with the name of that atomic type. An atomic type
      is either a primitive or derived atomic type according to XML
      Schema <a href="#xmlschema-2">[Schema Part 2]</a>, <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, or
      <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>.</p><p>A node is either an element, an attribute, a document, a
      text, a comment, or a processing-instruction node.</p><p>Element nodes have a <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> and contain a complex value or a
      simple value. Attribute nodes have a <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> and contain a simple value. Text
      nodes always contain one string value of type
      <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, therefore the corresponding type annotation
      is omitted in the formal notation of a text node. Document nodes
      do not have a type annotation and contain a sequence of element,
      text, comment, or processing-instruction nodes.</p><p>A simple value is a sequence of atomic values.</p><p>A complex value is a sequence of attribute nodes followed by
      a sequence of element, text, comment, or processing-instruction
      nodes.</p><p>A <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> can be
      either the <em>QName</em> of a declared type or an anonymous
      type. An anonymous type corresponds to an XML Schema type for
      which the schema writer did not provide a name. Anonymous type
      names are not visible to the user, but are generated during
      schema validation and used to annotate nodes in the data
      model. By convention, anonymous type names are written using the
      <em>fs:</em> Formal Semantics prefix: <em>fs:</em>anon<sub><font size="2">0</font></sub>,
      <em>fs:</em>anon<sub><font size="2">1</font></sub>, etc.</p><p>Formal values are defined by the following grammar.</p>
<h5><a id="N109B7" name="N109B7"/>Values</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-Value" name="doc-fs-Value"/>[<small>7 (Formal)</small>]   </td><td><code>Value</code></td><td>   ::=   </td><td><code><a href="#doc-fs-Item">Item</a><br/>|  (<a href="#doc-fs-Value">Value</a>  ","  <a href="#doc-fs-Value">Value</a>)<br/>|  ("("  ")")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-Item" name="doc-fs-Item"/>[<small>21 (Formal)</small>]   </td><td><code>Item</code></td><td>   ::=   </td><td><code><a href="#doc-fs-NodeValue">NodeValue</a><br/>|  <a href="#doc-fs-AtomicValue">AtomicValue</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-AtomicValue" name="doc-fs-AtomicValue"/>[<small>22 (Formal)</small>]   </td><td><code>AtomicValue</code></td><td>   ::=   </td><td><code><a href="#doc-fs-AtomicValueContent">AtomicValueContent</a>  <a href="#doc-fs-TypeAnnotation">TypeAnnotation</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-AtomicValueContent" name="doc-fs-AtomicValueContent"/>[<small>1 (Formal)</small>]   </td><td><code>AtomicValueContent</code></td><td>   ::=   </td><td><code>String<br/>|  Boolean<br/>|  Decimal<br/>|  Float<br/>|  Double<br/>|  Duration<br/>|  DateTime<br/>|  Time<br/>|  Date<br/>|  GYearMonth<br/>|  GYear<br/>|  GMonthDay<br/>|  GDay<br/>|  GMonth<br/>|  HexBinary<br/>|  Base64Binary<br/>|  AnyURI<br/>|  expanded-QName<br/>|  NOTATION</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-TypeAnnotation" name="doc-fs-TypeAnnotation"/>[<small>2 (Formal)</small>]   </td><td><code>TypeAnnotation</code></td><td>   ::=   </td><td><code>"of"  "type"  <a href="#doc-fs-TypeName">TypeName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-ElementValue" name="doc-fs-ElementValue"/>[<small>9 (Formal)</small>]   </td><td><code>ElementValue</code></td><td>   ::=   </td><td><code>"element"  <a href="#doc-fs-ElementName">ElementName</a>  "nilled"?  <a href="#doc-fs-TypeAnnotation">TypeAnnotation</a>?  "{"  <a href="#doc-fs-Value">Value</a>  "}"  ("{"  <a href="#doc-fs-NamespaceBindings">NamespaceBindings</a>  "}")?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-AttributeValue" name="doc-fs-AttributeValue"/>[<small>10 (Formal)</small>]   </td><td><code>AttributeValue</code></td><td>   ::=   </td><td><code>"attribute"  <a href="#doc-fs-AttributeName">AttributeName</a>  <a href="#doc-fs-TypeAnnotation">TypeAnnotation</a>?  "{"  <a href="#doc-fs-SimpleValue">SimpleValue</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-SimpleValue" name="doc-fs-SimpleValue"/>[<small>8 (Formal)</small>]   </td><td><code>SimpleValue</code></td><td>   ::=   </td><td><code><a href="#doc-fs-AtomicValue">AtomicValue</a><br/>|  (<a href="#doc-fs-SimpleValue">SimpleValue</a>  ","  <a href="#doc-fs-SimpleValue">SimpleValue</a>)<br/>|  ("("  ")")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-DocumentValue" name="doc-fs-DocumentValue"/>[<small>11 (Formal)</small>]   </td><td><code>DocumentValue</code></td><td>   ::=   </td><td><code>"document"  "{"  <a href="#doc-fs-Value">Value</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-CommentValue" name="doc-fs-CommentValue"/>[<small>13 (Formal)</small>]   </td><td><code>CommentValue</code></td><td>   ::=   </td><td><code>"comment"  "{"  String  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-ProcessingInstructionValue" name="doc-fs-ProcessingInstructionValue"/>[<small>14 (Formal)</small>]   </td><td><code>ProcessingInstructionValue</code></td><td>   ::=   </td><td><code>"processing-instruction"  <a href="#prod-core-NCName">NCName</a>  "{"  String  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-TextValue" name="doc-fs-TextValue"/>[<small>12 (Formal)</small>]   </td><td><code>TextValue</code></td><td>   ::=   </td><td><code>"text"  "{"  String  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-NodeValue" name="doc-fs-NodeValue"/>[<small>20 (Formal)</small>]   </td><td><code>NodeValue</code></td><td>   ::=   </td><td><code><a href="#doc-fs-ElementValue">ElementValue</a><br/>|  <a href="#doc-fs-AttributeValue">AttributeValue</a><br/>|  <a href="#doc-fs-DocumentValue">DocumentValue</a><br/>|  <a href="#doc-fs-TextValue">TextValue</a><br/>|  <a href="#doc-fs-CommentValue">CommentValue</a><br/>|  <a href="#doc-fs-ProcessingInstructionValue">ProcessingInstructionValue</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-ElementName" name="doc-fs-ElementName"/>[<small>3 (Formal)</small>]   </td><td><code>ElementName</code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-AttributeName" name="doc-fs-AttributeName"/>[<small>6 (Formal)</small>]   </td><td><code>AttributeName</code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-TypeName" name="doc-fs-TypeName"/>[<small>23 (Formal)</small>]   </td><td><code>TypeName</code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-NamespaceBindings" name="doc-fs-NamespaceBindings"/>[<small>15 (Formal)</small>]   </td><td><code>NamespaceBindings</code></td><td>   ::=   </td><td><code><a href="#doc-fs-NamespaceBinding">NamespaceBinding</a>  (","  <a href="#doc-fs-NamespaceBinding">NamespaceBinding</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-NamespaceBinding" name="doc-fs-NamespaceBinding"/>[<small>17 (Formal)</small>]   </td><td><code>NamespaceBinding</code></td><td>   ::=   </td><td><code>"namespace"  <a href="#prod-core-NCName">NCName</a>  "{"  AnyURI  "}"</code></td></tr></tbody></table><p><b>Notation</b></p>
        <p>In that grammar, "String" indicates the value
        space of <code>xs:string</code>, "Decimal" indicates the
        value space of <code>xs:decimal</code>, etc.</p>
      <p>Element (resp. attributes) without type annotations, are
      assumed to have the type annotation <code>xs:anyType</code>
      (resp. <code>xs:anySimpleType</code>). Atomic values without type
      annotations, are assumed to have a type annotation which is the
      base type for the corresponding value. For instance,
      <code>"Hello, World!"</code> is equivalent to <code>"Hello,
      World!" of type xs:string</code>.</p><p>Untyped elements (e.g., from well-formed documents) have the
      <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a>,
      untyped attributes have the <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, and untyped
      atomic values have the <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.</p><p>An element has an optional "nilled" marker. This
      marker is present only if the element has been validated against
      an element type in the schema which is "nillable",
      and the element has no content and an attribute
      <code>xsi:nil</code> set to <code>"true"</code>.</p><p>An element also has a sequence of namespace bindings, which
      are the set of in-scope namespaces for that element. Each
      namespace binding is a prefix, URI pair. Elements without
      namespace bindings are assumed to have an empty set of in-scope
      namespaces.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In <a href="#">[XPath]</a>, the in-scope
      namespaces of an element node are represented by a collection of
      <b>namespace nodes</b> arranged on a <b>namespace
      axis</b>, which is optional and deprecated in <a href="#xpath20">[XML Path Language (XPath) 2.0]</a>. XQuery does not support the namespace axis and
      does not represent namespace bindings in the form of
      nodes.</p></div></div><div class="div3">
<h4><a id="sec_example_values" name="sec_example_values"/>2.3.2 Examples of values</h4><p><b>A well-formed document</b></p><div class="exampleInner"><pre>
  &lt;fact&gt;The cat weighs &lt;weight units="lbs"&gt;12&lt;/weight&gt; pounds.&lt;/fact&gt;
</pre></div><p>In the absence of a Schema, this document is represented
      as</p><div class="exampleInner"><pre>
  element fact of type xdt:untyped {
    text { "The cat weighs " },
    element weight of type xdt:untyped {
      attribute units of type xdt:untypedAtomic {
        "lbs" of type xdt:untypedAtomic
      }
      text { "12" }
    },
    text { " pounds." }
  }
</pre></div><p><b>A document before and after validation.</b></p><div class="exampleInner"><pre>
  &lt;weight xsi:type="xs:integer"&gt;42&lt;/weight&gt;
</pre></div><p>The formal model for values can represent values before and
      after validation. Before validation, this element is represented
      as:</p><div class="exampleInner"><pre>
  element weight of type xdt:untyped {
    attribute xsi:type of type xdt:untypedAtomic {
      "xs:integer" of type xdt:untypedAtomic
    },
    text { "42" }
  }
</pre></div><p>After validation, this element is represented as:</p><div class="exampleInner"><pre>
  element weight of type xs:integer {
    attribute xsi:type of type xs:QName {
      "xs:integer" of type xs:QName
    },
    42 of type xs:integer
  }
</pre></div><p><b>An element with a list type</b></p><div class="exampleInner"><pre>
  &lt;sizes&gt;1 2 3&lt;/sizes&gt;
</pre></div><p>Before validation, this element is represented as:</p><div class="exampleInner"><pre>
  element sizes of type xdt:untyped {
    text { "1 2 3" }
  }
</pre></div><p>Assume the following Schema.</p><div class="exampleInner"><pre>
  &lt;xs:element name="sizes" type="sizesType"/&gt;
  &lt;xs:simpleType name="sizesType"&gt;
    &lt;xs:list itemType="sizeType"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="sizeType"&gt;
    &lt;xs:restriction base="xs:integer"/&gt;
  &lt;/xs:simpleType&gt;
</pre></div><p>After validation against this Schema, the element is
      represented as:</p><div class="exampleInner"><pre>
  element sizes of type sizesType {
    1 of type sizeType,
    2 of type sizeType,
    3 of type sizeType
  }
</pre></div><p><b>An element with an anonymous type</b></p><div class="exampleInner"><pre>
  &lt;sizes&gt;1 2 3&lt;/sizes&gt;
</pre></div><p>Before validation, this element is represented as:</p><div class="exampleInner"><pre>
  element sizes of type xdt:untyped {
    text { "1 2 3" }
  }
</pre></div><p>Assume the following Schema.</p><div class="exampleInner"><pre>
  &lt;xs:element name="sizes"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:list itemType="xs:integer"/&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:element&gt;
</pre></div><p>After validation, this element is represented as:</p><div class="exampleInner"><pre>
  element sizes of type fs:anon1 {
    1 of type xs:integer,
    2 of type xs:integer,
    3 of type xs:integer
  }
</pre></div><p>where <em>fs:</em>anon<sub><font size="2">1</font></sub> stands for the internal anonymous name
      generated by the system for the <code>sizes</code> element.</p><p>A nillable element with <code>xsi:type</code> set to
      true:</p><div class="exampleInner"><pre>
  &lt;sizes xsi:nil="true"/&gt;
</pre></div><p>Before validation, this element is represented as:</p><div class="exampleInner"><pre>
  element sizes of type xdt:untyped {
    attribute xsi:nil of type xdt:untypedAtomic { "true" of type xdt:untypedAtomic }
  }
</pre></div><p>Assume the following Schema.</p><div class="exampleInner"><pre>
  &lt;xs:element name="sizes" type="sizesType" nillable="true"/&gt;
</pre></div><p>After validation against this Schema, the element is
      represented as:</p><div class="exampleInner"><pre>
  element sizes nilled of type sizesType {
    attribute xsi:nil of type xs:boolean { true of type xs:boolean }
  }
</pre></div><p><b>An element with a union type</b></p><div class="exampleInner"><pre>
  &lt;sizes&gt;1 two 3 four&lt;/sizes&gt;
</pre></div><p>Before validation, this element is represented as:</p><div class="exampleInner"><pre>
  element sizes of type xdt:untyped {
    text { "1 two 3 four" }
  }
</pre></div><p>Assume the following Schema:</p><div class="exampleInner"><pre>
  &lt;xs:element name="sizes" type="sizesType"/&gt;
  &lt;xs:simpleType name="sizesType"&gt;
    &lt;xs:list itemType="sizeType"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="sizeType"&gt;
    &lt;xs:union memberType="xs:integer xs:string"/&gt;
  &lt;/xs:simpleType&gt;
</pre></div><p>After validation against this Schema, the element is
      represented as:</p><div class="exampleInner"><pre>
  element sizes of type sizesType {
    1 of type xs:integer,
    "two" of type xs:string,
    3 of type xs:integer,
    "four" of type xs:string
  }
</pre></div></div></div><div class="div2">
<h3><a id="sec_types" name="sec_types"/>2.4 The [XPath/XQuery] Type System</h3><p>The [XPath/XQuery] type system is used in the specification of the
    dynamic and of the static semantics of [XPath/XQuery]. This section
    introduces formal notations for describing types.</p><div class="div3">
<h4><a id="sec_schema" name="sec_schema"/>2.4.1 XML Schema and the [XPath/XQuery] Type System</h4><p>The [XPath/XQuery] type system is based on <a href="#xmlschema-1">[Schema Part 1]</a> and
      <a href="#xmlschema-2">[Schema Part 2]</a>.  <a href="#xmlschema-1">[Schema Part 1]</a> and <a href="#xmlschema-2">[Schema Part 2]</a> specify
      normatively the type information available in [XPath/XQuery].  We
      define the formal notation that is used in this document to
      describe and manipulate types in inference rules. Formal types
      are used for specification purposes only and are not exposed to
      the [XPath/XQuery] user.</p><p><b>Representation of content models.</b> For the
      purpose of static typing, the [XPath/XQuery] type system only
      describes minOccurs, maxOccurs, and minLength, maxLength on list
      types for the occurrences that correspond to the DTD operators
      <code>+</code>, <code>*</code>, and <code>?</code>. Choices are
      represented using the DTD operator <code>|</code>. <b>All
      groups</b> are represented using the interleaving operator
      (<code>&amp;</code>).</p><p><b>Representation of anonymous types.</b> To clarify
      the semantics, the [XPath/XQuery] type system makes all anonymous
      types explicit.</p><p><b>Representation of XML Schema simple type facets and
      identity constraints.</b> For simplicity, XML Schema simple
      type facets and identity constraints are not formally
      represented in the [XPath/XQuery] type system. However, an
      [XPath/XQuery] implementation supporting XML Schema import and
      validation must take simple type facets and identity constraints
      into account.</p><p>This document describe types in the [XPath/XQuery] types system,
      as well as the operations and properties over those types which
      are used to define the [XPath/XQuery] static typing feature. The two
      most important properties are whether a data instances matches a
      type, and whether a type is a subtype of another. Those
      properties are described in <a href="#sec_type_matching"><b>[8.3 Judgments for type matching]</b></a>. This document does not describe all
      other possible properties over those types.</p><p>The mapping from XML Schema into the [XPath/XQuery] type system
      is given in <a href="#sec_importing_schema"><b>[C Importing Schemas]</b></a>. The rest of
      this section is organized as follows. <a href="#sec_item_types"><b>[2.4.2 Item types]</b></a> describes item types, <a href="#sec_content_models"><b>[2.4.3 Content models]</b></a> describes content models, and
      <a href="#sec_top_level_definitions"><b>[2.4.4 Top level definitions]</b></a> describe top-level
      type declarations.</p></div><div class="div3">
<h4><a id="sec_item_types" name="sec_item_types"/>2.4.2 Item types</h4><p>An item type is either an atomic type, an element type, an
      attribute type, a document node type, a text node type, a
      comment node type, or a processing instruction type.  We
      distinguish between document nodes, attribute nodes, and nodes
      that can occur in element content (elements, comments,
      processing instructions, and text nodes), as we need to refer to
      element content types later in the formal semantics.</p>
<h5><a id="N10C45" name="N10C45"/>Item Types</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-FormalItemType" name="doc-fs-FormalItemType"/>[<small>25 (Formal)</small>]   </td><td><code>FormalItemType</code></td><td>   ::=   </td><td><code><a href="#doc-fs-AtomicTypeName">AtomicTypeName</a>  |  <a href="#doc-fs-NodeType">NodeType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-AtomicTypeName" name="doc-fs-AtomicTypeName"/>[<small>28 (Formal)</small>]   </td><td><code>AtomicTypeName</code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-NodeType" name="doc-fs-NodeType"/>[<small>26 (Formal)</small>]   </td><td><code>NodeType</code></td><td>   ::=   </td><td><code><a href="#doc-fs-DocumentType">DocumentType</a><br/>|  <a href="#doc-fs-AttributeType">AttributeType</a><br/>|  <a href="#doc-fs-ElementContentType">ElementContentType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-ElementContentType" name="doc-fs-ElementContentType"/>[<small>27 (Formal)</small>]   </td><td><code>ElementContentType</code></td><td>   ::=   </td><td><code><a href="#doc-fs-ElementType">ElementType</a><br/>|  "comment"<br/>|  "processing-instruction"<br/>|  "text"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-ElementType" name="doc-fs-ElementType"/>[<small>29 (Formal)</small>]   </td><td><code>ElementType</code></td><td>   ::=   </td><td><code>"element"  <a href="#doc-fs-ElementNameOrWildcard">ElementNameOrWildcard</a>  <a href="#doc-fs-OptTypeSpecifier">OptTypeSpecifier</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-ElementNameOrWildcard" name="doc-fs-ElementNameOrWildcard"/>[<small>4 (Formal)</small>]   </td><td><code>ElementNameOrWildcard</code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-AttributeNameOrWildcard" name="doc-fs-AttributeNameOrWildcard"/>[<small>5 (Formal)</small>]   </td><td><code>AttributeNameOrWildcard</code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-OptTypeSpecifier" name="doc-fs-OptTypeSpecifier"/>[<small>85 (Formal)</small>]   </td><td><code>OptTypeSpecifier</code></td><td>   ::=   </td><td><code><a href="#doc-fs-TypeSpecifier">TypeSpecifier</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-TypeSpecifier" name="doc-fs-TypeSpecifier"/>[<small>30 (Formal)</small>]   </td><td><code>TypeSpecifier</code></td><td>   ::=   </td><td><code><a href="#doc-fs-OptNillable">OptNillable</a>  <a href="#doc-fs-TypeReference">TypeReference</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-AttributeType" name="doc-fs-AttributeType"/>[<small>31 (Formal)</small>]   </td><td><code>AttributeType</code></td><td>   ::=   </td><td><code>"attribute"  <a href="#doc-fs-AttributeNameOrWildcard">AttributeNameOrWildcard</a>  <a href="#doc-fs-OptTypeReference">OptTypeReference</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-OptNillable" name="doc-fs-OptNillable"/>[<small>83 (Formal)</small>]   </td><td><code>OptNillable</code></td><td>   ::=   </td><td><code><a href="#doc-fs-Nillable">Nillable</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-Nillable" name="doc-fs-Nillable"/>[<small>32 (Formal)</small>]   </td><td><code>Nillable</code></td><td>   ::=   </td><td><code>"nillable"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-OptTypeReference" name="doc-fs-OptTypeReference"/>[<small>86 (Formal)</small>]   </td><td><code>OptTypeReference</code></td><td>   ::=   </td><td><code><a href="#doc-fs-TypeReference">TypeReference</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-TypeReference" name="doc-fs-TypeReference"/>[<small>36 (Formal)</small>]   </td><td><code>TypeReference</code></td><td>   ::=   </td><td><code>"of"  "type"  <a href="#doc-fs-TypeName">TypeName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-DocumentType" name="doc-fs-DocumentType"/>[<small>48 (Formal)</small>]   </td><td><code>DocumentType</code></td><td>   ::=   </td><td><code>"document"  ("{"  <a href="#doc-fs-Type">Type</a>  "}")?</code></td></tr></tbody></table><p>An element or attribute type has an optional name and an
      optional type reference. A name alone corresponds to a reference
      to a global element or attribute declaration. A name with a type
      reference corresponds to a local element or attribute
      declaration. The word "element" or "attribute" alone refers to
      the wildcard types for any element or any attribute. In
      addition, an element type has an optional nillable flag that
      indicates whether the element can be nilled or not.</p><p>A document type has an optional content type. If no content
      type is given, then the type is treated as being the wildcard
      type for documents, i.e., a sequence of text and element
      nodes. For consistency with element nodes, PIs and comments are
      not indicated in that wildcard type, but may occur in
      instances.</p><p><b>Note</b></p>
        <p>Generic node types (e.g., <code>node()</code>) such as used
        in the SequenceType production, are interpreted in the type
        system as a union of the corresponding node types (e.g.,
        element,attribute,text,comment and processing-instruction
        nodes) and therefore do not appear in the grammar. The
        semantics of sequence types is described in <a href="#id-sequencetype-matching"><b>[3.5.4 SequenceType Matching]</b></a>.</p>
      <p><b>Examples</b></p>

        <p>The following is a text node type</p>

<div class="exampleInner"><pre>
  text
</pre></div>

        <p>The following is a type for all elements</p>

<div class="exampleInner"><pre>
  element * of type xs:anyType
</pre></div>

        <p>The following is a type for all elements of type string</p>

<div class="exampleInner"><pre>
  element * of type xs:string
</pre></div>

        <p>The following is a type for a nillable element of type
        string and with name <code>size</code></p>

<div class="exampleInner"><pre>
  element size nillable of type xs:string
</pre></div>

        <p>The following is a reference to a global attribute
        declaration</p>

<div class="exampleInner"><pre>
  attribute sizes
</pre></div>

        <p>The following is a type for elements with anonymous type
        <em>fs:</em>anon<sub><font size="2">1</font></sub>:</p>

<div class="exampleInner"><pre>
  element sizes of type fs:anon1
</pre></div>

      </div><div class="div3">
<h4><a id="sec_content_models" name="sec_content_models"/>2.4.3 Content models</h4><p>Following XML Schema, types in [XPath/XQuery] are composed from
      item types by optional, one or more, zero or more, <b>all
      group</b>, <b>sequence</b>, <b>choice</b>, empty
      sequence (written <code>empty</code>), or empty choice (written
      <code>none</code>).</p><p>The type <code>empty</code> matches the empty sequence. The type
      <code>none</code> matches no values. <code>none</code> is the identity for
      choice, that is (<a href="#doc-fs-Type"><em>Type</em></a> | <code>none</code>) =
      <a href="#doc-fs-Type"><em>Type</em></a>. The type <code>none</code> is the static type
      for <a href="#sec_fnerror"><b>[7.2.9 The fn:error function]</b></a>.</p>
<h5><a id="N10D98" name="N10D98"/>Types</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-Type" name="doc-fs-Type"/>[<small>24 (Formal)</small>]   </td><td><code>Type</code></td><td>   ::=   </td><td><code><a href="#doc-fs-FormalItemType">FormalItemType</a><br/>|  (<a href="#doc-fs-Type">Type</a>  <a href="#doc-core-OccurrenceIndicator">OccurrenceIndicator</a>)<br/>|  (<a href="#doc-fs-Type">Type</a>  "&amp;"  <a href="#doc-fs-Type">Type</a>)<br/>|  (<a href="#doc-fs-Type">Type</a>  ","  <a href="#doc-fs-Type">Type</a>)<br/>|  (<a href="#doc-fs-Type">Type</a>  "|"  <a href="#doc-fs-Type">Type</a>)<br/>|  "empty"<br/>|  "none"<br/>|  ("("  <a href="#doc-fs-Type">Type</a>  ")")</code></td></tr></tbody></table><p>The [XPath/XQuery] type system includes three binary operators on
      types: ",", "|" and "&amp;", corresponding respectively to
      sequence, choice and <b>all groups</b> in Schema. The
      [XPath/XQuery] type system includes three unary operators on types:
      "*", "+", and "?", corresponding respectively to zero or more
      instances of the type, one or more instances of the type, or an
      optional instance of the type.</p><p>The "&amp;" operator builds the "interleaved
      product" of two types. The type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> &amp;
      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> matches any sequence that is an interleaving of two
      sequences of items, <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>, with
      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> matching <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> matching
      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>. The interleaving of two sequences of items
      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> is any sequence <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> such
      that there is an ordered partition of <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> into the two
      sub-sequences <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>. The interleaved
      product captures the semantics of <b>all groups</b> in XML
      Schema, but is more general as it applies to arbitrary
      types. <b>All groups</b> in XML Schema are restricted to
      apply only on global or local element declarations with
      minOccurs 0 or 1, and maxOccurs 1.</p><p>For example, consider the types <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> =
      <code>xs:integer</code>,<code>xs:integer</code>,<code>xs:integer</code> and <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> =
      <code>xs:string</code>,<code>xs:string</code>. <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <code>= (1,2,3)</code>
      matches the type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <code>=
      ("a","b")</code> matches the type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>. Any of the
      following <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> are interleavings of <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> and
      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>, and therefore match the type (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> &amp;
      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>):</p><div class="exampleInner"><pre>
Value0 = (1,2,3,"a","b")
Value0 = (1,2,"a",3,"b")
Value0 = (1,2,"a","b",3)
Value0 = (1,"a",2,3,"b")
Value0 = (1,"a",2,"b",3)
Value0 = (1,"a","b",2,3)
Value0 = ("a",1,2,3,"b")
Value0 = ("a",1,2,"b",3)
Value0 = ("a",1,"b",2,3)
Value0 = ("a","b",1,2,3)
</pre></div><p><b>Types precedence order</b>. To improve readability
      when writing types, we assume the following precedence order
      between operators on types.</p><table border="1"><tbody><tr><th>#</th><th>Operator</th></tr><tr><td>1</td><td>| (choice)</td></tr><tr><td>2</td><td>&amp; (interleaving)</td></tr><tr><td>3</td><td>, (sequence)</td></tr><tr><td>4</td><td>*, +, ? (occurrence)</td></tr></tbody></table><p>Parenthesis can be used to enforce precedence. For
      instance</p><div class="exampleInner"><pre>
  xs:string | xs:integer, xs:float*
</pre></div><p>is equivalent to</p><div class="exampleInner"><pre>
  xs:string | (xs:integer, (xs:float*))
</pre></div><p>and a different precedence can be obtained by writing</p><div class="exampleInner"><pre>
  ((xs:string | xs:integer), xs:float)*
</pre></div><p><b>Examples</b></p>
        <p><b>A sequence of elements</b></p>

        <p>The "," operator builds the "sequence" of two
        types. For example,</p>

<div class="exampleInner"><pre>
  element title of type xs:string, element year of type xs:integer
</pre></div>

        <p>is a sequence of an element title of type string followed
        by an element year of type integer.</p>

        <p><b>The union of two element types</b></p>

        <p>The "|" operator builds the "union" of two
        types. For example,</p>

<div class="exampleInner"><pre>
  element editor of type xs:string | element bib:author
</pre></div>

        <p>means either an element editor of type string, or a
        reference to the global element <code>bib:author</code>.</p>

        <p><b>An all group of two elements</b></p>

        <p>The "&amp;" operator builds the "interleaved
        product" of two types. For example,</p>

<div class="exampleInner"><pre>
  (element a &amp; element b) =
    element a, element b
  | element b, element a
</pre></div>

        <p>which specifies that the <code>a</code> and <code>b</code>
        elements can occur in any order.</p>

        <p><b>An empty type</b></p>

        <p>The following type matches the empty sequence.</p>

<div class="exampleInner"><pre>
  empty
</pre></div>

        <p><b>A sequence of zero or more elements</b></p>

        <p>The following type matches zero or more elements each of
        which can be a <code>surgeon</code> or a
        <code>plumber</code>.</p>

<div class="exampleInner"><pre>
  (element surgeon | element plumber)*
</pre></div>

      </div><div class="div3">
<h4><a id="sec_top_level_definitions" name="sec_top_level_definitions"/>2.4.4 Top level definitions</h4><p>Top level definitions correspond to global element
      declarations, global attribute declarations and type definitions
      in XML Schema.</p>
<h5><a id="N10F67" name="N10F67"/>Type Definitions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-Definitions" name="doc-fs-Definitions"/>[<small>40 (Formal)</small>]   </td><td><code>Definitions</code></td><td>   ::=   </td><td><code>(<a href="#doc-fs-Definition">Definition</a>  <a href="#doc-fs-Definitions">Definitions</a>)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-Definition" name="doc-fs-Definition"/>[<small>39 (Formal)</small>]   </td><td><code>Definition</code></td><td>   ::=   </td><td><code>("define"  "element"  <a href="#doc-fs-ElementName">ElementName</a>  <a href="#doc-fs-OptSubstitution">OptSubstitution</a>  <a href="#doc-fs-OptNillable">OptNillable</a>  <a href="#doc-fs-TypeReference">TypeReference</a>)<br/>|  ("define"  "attribute"  <a href="#doc-fs-AttributeName">AttributeName</a>  <a href="#doc-fs-TypeReference">TypeReference</a>)<br/>|  ("define"  "type"  <a href="#doc-fs-TypeName">TypeName</a>  <a href="#doc-fs-TypeDerivation">TypeDerivation</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-OptSubstitution" name="doc-fs-OptSubstitution"/>[<small>84 (Formal)</small>]   </td><td><code>OptSubstitution</code></td><td>   ::=   </td><td><code><a href="#doc-fs-Substitution">Substitution</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-Substitution" name="doc-fs-Substitution"/>[<small>41 (Formal)</small>]   </td><td><code>Substitution</code></td><td>   ::=   </td><td><code>"substitutes"  "for"  <a href="#doc-fs-ElementName">ElementName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-TypeDerivation" name="doc-fs-TypeDerivation"/>[<small>33 (Formal)</small>]   </td><td><code>TypeDerivation</code></td><td>   ::=   </td><td><code><a href="#doc-fs-ComplexTypeDerivation">ComplexTypeDerivation</a>  |  <a href="#doc-fs-AtomicTypeDerivation">AtomicTypeDerivation</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-ComplexTypeDerivation" name="doc-fs-ComplexTypeDerivation"/>[<small>34 (Formal)</small>]   </td><td><code>ComplexTypeDerivation</code></td><td>   ::=   </td><td><code><a href="#doc-fs-Derivation">Derivation</a>?  <a href="#doc-fs-OptMixed">OptMixed</a>  "{"  <a href="#doc-fs-Type">Type</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-AtomicTypeDerivation" name="doc-fs-AtomicTypeDerivation"/>[<small>35 (Formal)</small>]   </td><td><code>AtomicTypeDerivation</code></td><td>   ::=   </td><td><code>"restricts"  <a href="#doc-fs-AtomicTypeName">AtomicTypeName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-Derivation" name="doc-fs-Derivation"/>[<small>37 (Formal)</small>]   </td><td><code>Derivation</code></td><td>   ::=   </td><td><code>("restricts"  <a href="#doc-fs-TypeName">TypeName</a>)<br/>|  ("extends"  <a href="#doc-fs-TypeName">TypeName</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-OptMixed" name="doc-fs-OptMixed"/>[<small>82 (Formal)</small>]   </td><td><code>OptMixed</code></td><td>   ::=   </td><td><code><a href="#doc-fs-Mixed">Mixed</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-Mixed" name="doc-fs-Mixed"/>[<small>38 (Formal)</small>]   </td><td><code>Mixed</code></td><td>   ::=   </td><td><code>"mixed"</code></td></tr></tbody></table><p>A type definition has a name (possibly anonymous) and a type
       derivation. In the case of a complex type, the derivation
       indicates whether it is derived by extension or restriction, its
       base type, and its content model, with an optional flag
       indicating if it has mixed content.</p><p><b>Example</b></p>

       <p>For instance, the following complex type</p>

<div class="exampleInner"><pre>
 &lt;complexType name="UKAddress"&gt;
   &lt;complexContent&gt;
     &lt;extension base="ipo:Address"&gt;
       &lt;sequence&gt;
         &lt;element name="postcode" type="ipo:UKPostcode"/&gt;
       &lt;/sequence&gt;
       &lt;attribute name="exportCode" type="positiveInteger" fixed="1"/&gt;
     &lt;/extension&gt;
   &lt;/complexContent&gt;
 &lt;/complexType&gt;
</pre></div>

       <p>is represented as follows</p>

<div class="exampleInner"><pre>
  define type UKAddress extends ipo:Address {
    attribute exportCode of type ipo:UKPostcode,
    element postcode of type positiveInteger
  };
</pre></div>

       <p><b>Example</b></p>

       <p>In the case of simple types derived by union or list, the
       derivation is always a restriction from the base type
       <code>xs:anySimpleType</code>, and has a content which is a union of the
       member types, or a repetition of the item type. For instance,
       the two following simple type declarations</p>

<div class="exampleInner"><pre>
&lt;xsd:simpleType name="listOfMyIntType"&gt;
  &lt;xsd:list itemType="myInteger"/&gt;
&lt;/xsd:simpleType&gt;

&lt;xsd:simpleType name="zipUnion"&gt;
  &lt;xsd:union memberTypes="USState FrenchRegion"/&gt;
&lt;/xsd:simpleType&gt;
</pre></div>

       <p>are represented as follows</p>

<div class="exampleInner"><pre>
define type listOfMyIntType restricts xs:anySimpleType {
  myInteger*
}

define type zipUnion restricts xs:anySimpleType {
  USState | FrenchRegion
}
</pre></div>

       <p><b>Example</b></p>

       <p>In the case of an atomic type, it just indicates its base
       type. For instance, the following type definition</p>

<div class="exampleInner"><pre>
&lt;xsd:simpleType name="SKU"&gt;
 &lt;xsd:restriction base="xsd:string"&gt;
  &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
 &lt;/xsd:restriction&gt;
&lt;/xsd:simpleType&gt;
</pre></div>

       <p>is represented as follow</p>

<div class="exampleInner"><pre>
  define type SKU restrict xsd:string;
</pre></div>

       <p><b>Example</b></p>

       <p>When the type derivation is omitted, the type derives by
       restriction from <code>xs:anyType</code>. For instance:</p>

<div class="exampleInner"><pre>
  define type Bib { element book* } =
  define type Bib restricts xs:anyType { element book* }
</pre></div>

       <p><b>Example</b></p>

       <p>Empty content can be indicated with the explicit empty
       sequence, or omitted, as in:</p>

<div class="exampleInner"><pre>
  define type Bib { } =
  define type Bib { empty }
</pre></div>

       <p>Global element and attribute declarations always have a name
       and a reference to a (possibly anonymous) type.  A global
       element declaration also may declare a substitution group for
       the element and whether the element is nillable.</p><p><b>Example</b></p>
         <p>A type declaration with one element name of type
         <code>xs:string</code> follows by one or more elements street of type
         <code>xs:string</code>.</p>

<div class="exampleInner"><pre>
  define type Address {
    element name of type xs:string,
    element street of type xs:string*
  }
</pre></div>

       <p><b>Example</b></p>

         <p>A type declaration with complex content derived by
         extension</p>

<div class="exampleInner"><pre>
  define type USAddress extends Address {
    element zip name of type xs:integer
  }
</pre></div>

       <p><b>Example</b></p>

         <p>A type declaration with mixed content</p>

<div class="exampleInner"><pre>
  define type Section mixed {
    (element h1 of type xs:string |
     element p of type xs:string |
     element div of type Section)*
  }
</pre></div>

       <p><b>Example</b></p>

         <p>A type declaration with simple content derived by
         restriction</p>

<div class="exampleInner"><pre>
  define type SKU restricts xs:string
</pre></div>

       <p><b>Example</b></p>

         <p>An element declaration</p>

<div class="exampleInner"><pre>
  define element address of type Address
</pre></div>

       <p><b>Example</b></p>

         <p>An element declaration with a substitution
         group</p>

<div class="exampleInner"><pre>
  define element usaddress substitutes for address of type USAddress
</pre></div>

       <p><b>Example</b></p>

         <p>An element declaration which is nillable</p>

<div class="exampleInner"><pre>
  define element zip nillable of type xs:integer
</pre></div>

       </div><div class="div3">
<h4><a id="sec_types_example" name="sec_types_example"/>2.4.5 Example of a complete Schema</h4><p>Here is a schema describing purchase orders from
       <a href="#xmlschema-0">[XML Schema Part 0]</a>.</p><div class="exampleInner"><pre>
  &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
  
   &lt;xsd:annotation&gt;
    &lt;xsd:documentation xml:lang="en"&gt;
     Purchase order schema for Example.com.
     Copyright 2000 Example.com. All rights reserved.
    &lt;/xsd:documentation&gt;
   &lt;/xsd:annotation&gt;
  
   &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt;
  
   &lt;xsd:element name="comment" type="xsd:string"/&gt;
  
   &lt;xsd:complexType name="PurchaseOrderType"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="shipTo" type="USAddress"/&gt;
     &lt;xsd:element name="billTo" type="USAddress"/&gt;
     &lt;xsd:element ref="comment" minOccurs="0"/&gt;
     &lt;xsd:element name="items"  type="Items"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;xsd:complexType name="USAddress"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="name"   type="xsd:string"/&gt;
     &lt;xsd:element name="street" type="xsd:string"/&gt;
     &lt;xsd:element name="city"   type="xsd:string"/&gt;
     &lt;xsd:element name="state"  type="xsd:string"/&gt;
     &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;xsd:attribute name="country" type="xsd:NMTOKEN" fixed="US"/&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;xsd:complexType name="Items"&gt;
    &lt;xsd:sequence&gt;
     &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xsd:complexType&gt;
  	&lt;xsd:sequence&gt;
  	 &lt;xsd:element name="productName" type="xsd:string"/&gt;
  	 &lt;xsd:element name="quantity"&gt;
  	  &lt;xsd:simpleType&gt;
  	   &lt;xsd:restriction base="xsd:positiveInteger"&gt;
  	    &lt;xsd:maxExclusive value="100"/&gt;
  	   &lt;/xsd:restriction&gt;
  	  &lt;/xsd:simpleType&gt;
  	 &lt;/xsd:element&gt;
  	 &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
  	 &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
  	 &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
  	&lt;/xsd:sequence&gt;
  	&lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;
      &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
   &lt;/xsd:complexType&gt;
  
   &lt;!-- Stock Keeping Unit, a code for identifying products --&gt;
   &lt;xsd:simpleType name="SKU"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
     &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
    &lt;/xsd:restriction&gt;
   &lt;/xsd:simpleType&gt;
  
  &lt;/xsd:schema&gt;
</pre></div><p>Here is the mapping of the above schema into the [XPath/XQuery] type
system.</p><div class="exampleInner"><pre>
  declare namespace xsd = "http://www.w3.org/2001/XMLSchema";

  define element purchaseOrder of type PurchaseOrderType;
 
  define element comment of type xsd:string;
  
  define type PurchaseOrderType {
    attribute orderDate of type xsd:date?,
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element comment?,
    element items of type Items
  };

  define type USAddress {
    attribute country of type xsd:NMTOKEN,
    element name of type xsd:string,
    element street of type xsd:string,
    element city of type xsd:string,
    element state of type xsd:string,
    element zip of type xsd:decimal
  };

  define type Items {
    attribute partNum of type SKU,
    element item of type fs:anon1*
  };

  define type fs:anon1 {
    element productName of type xsd:string,
    element quantity of type fs:anon2,
    element USPrice of type xsd:decimal,
    element comment?,
    element shipDate of type xsd:date?
  };

  define type fs:anon2 restricts xsd:positiveInteger;

  define type SKU restrict xsd:string;
</pre></div><p>Note that the two anonymous types in the <code>item</code>
      element declarations are mapping to types with names <em>fs:</em>anon<sub><font size="2">1</font></sub>
      and <em>fs:</em>anon<sub><font size="2">2</font></sub>.</p><p>The following additional definitions illustrate how more
      advanced XML Schema features (a complex type derived by
      extension, an anonymous simple type derived by restriction, and
      substitution groups) are represented in the [XPath/XQuery] type
      system.</p><div class="exampleInner"><pre>
  &lt;complexType name="NYCAddress"&gt;
    &lt;complexContent&gt;
     &lt;extension base="USAddress"&gt;
      &lt;sequence&gt;
       &lt;element ref="apt"/&gt;
      &lt;/sequence&gt;
     &lt;/extension&gt;
    &lt;/complexContent&gt;
  &lt;/complexType&gt;

  &lt;element name="apt"&gt;
    &lt;xsd:simpleType&gt;
     &lt;xsd:restriction base="xsd:positiveInteger"&gt;
      &lt;xsd:maxExclusive value="10000"/&gt;
     &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/element&gt;

  &lt;element name="usaddress" substitutionGroup="address" type="USAddress"/&gt;
  &lt;element name="nycaddress" substitutionGroup="usaddress" type="NYCAddress"/&gt;
</pre></div><p>The above definitions are mapped into the [XPath/XQuery] type system as
follows:</p><div class="exampleInner"><pre>
  define type NYCAddress extends USAddress {
    element apt
  }

  define element apt of type fs:anon3

  define type fs:anon3 restricts xsd:positiveInteger

  define element usaddress  substitutes for address of type USAddress
  define element nycaddress substitutes for usaddress of type NYCAddress
</pre></div></div></div><div class="div2">
<h3><a id="sec_fando" name="sec_fando"/>2.5 Functions and operators</h3><p>The <a href="#xpath-functions">[Functions and Operators]</a> document defines built-in functions
    available in [XPath/XQuery]. A number of these functions are used to
    define the [XPath/XQuery] semantics; those functions are listed in
    <a href="#sec_used_functions"><b>[B.1 Functions and Operators used in the Formal Semantics]</b></a>.</p><p>Many functions in the <a href="#xpath-functions">[Functions and Operators]</a> document are
    <em>generic</em>: they perform operations on arbitrary
    components of the data model, e.g., any kind of node, or any
    sequence of items. For instance, the <code>fn:unordered</code>
    returns its input sequence in an implementation-dependent
    order. The signature of the <code>fn:unordered</code> function
    takes arbitrary items as input and output:</p><div class="exampleInner"><pre>
  fn:unordered($sourceSeq as item()*) as item()*
</pre></div><p>As defined, this signature provides little useful type
    information. For such functions, better type information can often
    be obtained by having the output type depend on the type of input
    parameters. For instance, if the function
    <code>fn:unordered</code> is applied on a sequence of
    <code>a</code> elements, the result is also a sequence of
    <code>a</code> elements.</p><p>In order to provide better static typing for those functions,
    specific typing rules are given in <a href="#sec_special_functions"><b>[7 Additional Semantics of Functions]</b></a>.</p></div></div><div class="div1">
<h2><a id="id-basics" name="id-basics"/>3 Basics</h2><p>The organization of this section parallels the organization of
  <a href="http://www.w3.org/TR/xquery#id-basics">Section 
2      Basics</a><sup><small>XQ</small></sup>.</p><div class="div2">
<h3><a id="sec_context" name="sec_context"/>3.1 Expression Context</h3><p><b>Introduction</b></p>
      <p>The expression context for a given expression consists of all
      the information that can affect the result of the
      expression. This information is organized into the <em>static
      context</em> and the <em>dynamic context</em>.  This
      section specifies the environments that represent the context
      information used by [XPath/XQuery] expressions.</p>
    <div class="div3">
<h4><a id="static_context" name="static_context"/>3.1.1 Static Context</h4><p><b>Notation</b></p>
        <p>We introduce the following auxiliary grammar production to
        describe function signatures.</p>

      
<h5><a id="N1113C" name="N1113C"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-FunctionSig" name="doc-fs-FunctionSig"/>[<small>94 (Formal)</small>]   </td><td><code>FunctionSig</code></td><td>   ::=   </td><td><code>DefineFunction  <a href="#prod-core-QName">QName</a>  "("  <a href="#doc-fs-TypeList">TypeList</a>?  ")"  "as"  <a href="#doc-core-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-TypeList" name="doc-fs-TypeList"/>[<small>95 (Formal)</small>]   </td><td><code>TypeList</code></td><td>   ::=   </td><td><code><a href="#doc-core-SequenceType">SequenceType</a>  (","  <a href="#doc-core-SequenceType">SequenceType</a>)*</code></td></tr></tbody></table>
      <p id="xq_stat_env"><a href="#xq_stat_env_def" class="env">statEnv</a> denotes the environment
      available during static analysis.  Static analysis may extend
      parts of the static environment. The static environment is also
      available during dynamic evaluation.</p><p>If analysis of an expression relies on some component of the
      static context that has not been assigned a value, a static
      error is raised.</p><p id="xq_stat_env_def">The following environment components are
      part of the static environment:</p><table summary="" class="figure" cellpadding="5"><col width="10%" span="1"/><col width="15%" span="1"/><col width="65%" align="justify" span="1"/><col width="10%" span="1"/><tbody><tr><td/><td id="xq_xpath_compat_flag" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_xpath_compat_flag" class="env">xpath1.0_compatibility</a></td><td>
             <table summary=""><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_xpath_compat_flag" class="env">xpath1.0_compatibility</a> environment
               component corresponds to the <b>XPath 1.0
               compatibility flag</b> in the [XPath/XQuery] static
               context. It specifies whether the semantic rules for
               backward compatibility with XPath 1.0 are in
               effect. This document defines the formal semantics for
               XPath 2.0 only when the XPath 1.0 backward
               compatibility rules are not in effect.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_ns_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a></td><td>
            <a id="term_active" name="term_active"/><table summary=""><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> environment component
                corresponds to <b>statically known
                namespaces</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> environment component maps a
                namespace prefix (<em>NCName</em>) onto a <b>namespace
                kind</b> and a namespace URI (<em>URI</em>), the null
                namespace (#NULL-NAMESPACE), or (#UNDECLARED). The
                namespace kind is either <b>passive</b> or
                <b>active</b>.  The namespace kind determines
                whether a namespace node is created for an element
                during element construction. The (#UNDECLARED) value
                may be used to indicate that the prefix has been
                undeclared, and may be occur only in the case the
                implementation supports <a href="#XMLNAMES11">[XML Names 1.1]</a>.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_default_elem_ns_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a> environment
                component corresponds to the <b>default
                element/type namespace</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a> environment
                component contains a namespace URI (a <em>URI</em>) or the
                null namespace (#NULL-NAMESPACE) and is used for any
                unprefixed QName appearing in a position where an
                element or type name is expected.  </td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_default_fn_ns_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a> environment
                component corresponds to the <b>default function
                namespace</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a> environment
                component contains a namespace URI (a <em>URI</em>) or the
                null namespace (#NULL-NAMESPACE) and is used for any
                unprefixed QName appearing as the function name in a
                function call.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_type_defn" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a> environment component
                corresponds to the <b>in-scope schema types</b>
                in the [XPath/XQuery] static context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a> environment component maps
                expanded type names (expanded <a href="#doc-fs-TypeName"><em>TypeName</em></a>s) onto
                their type definition (<a href="#sec_top_level_definitions"><em>Definition</em></a>).  A type name
                may be globally declared or anonymous.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_elem_decl" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a> environment component
                corresponds to the <b>in-scope element
                declarations</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a> environment component maps
                expanded element names (expanded <a href="#doc-fs-ElementName"><em>ElementName</em></a>s)
                onto their declaration (<a href="#sec_top_level_definitions"><em>Definition</em></a>).</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_attr_decl" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a> environment component
                corresponds to the <b>in-scope attribute
                declarations</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a> environment component maps
                expanded attribute names (expanded
                <a href="#doc-fs-AttributeName"><em>AttributeName</em></a>s) onto their declaration
                (<a href="#sec_top_level_definitions"><em>Definition</em></a>).</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_type_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a> environment component
                corresponds to the <b>in-scope variables</b> in
                the [XPath/XQuery] static context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a> environment component maps
                expanded variable names (expanded <em>Variable</em>s) to
                their static type (<a href="#doc-fs-Type"><em>Type</em></a>).</td></tr><tr><td>The <b>context item static type</b> in
                the [XPath/XQuery] static context is represented by the
                binding of the variable <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> to its corresponding
                type in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_functy_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> environment component
                corresponds to the <b>function signatures</b>
                part of the [XPath/XQuery] static context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> environment component
                stores the static type signatures of
                functions. Because [XPath/XQuery] allows multiple
                functions with the same name differing only in the
                number and signature of the parameters, this
                environment component maps an expanded <em>QName</em> and
                an arity to a function signatures of the form
                "<code>define function</code> <em>QName</em>
                (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>) <code>return</code>
                <a href="#doc-fs-Type"><em>Type</em></a>".</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_collations_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a> environment component
                corresponds to the <b>statically known
                collations</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a> environment component maps a
                unique namespace URI (a <em>URI</em>) to a pair of
                functions: the first function takes a set of strings
                and returns a sequence containing those strings in
                sorted order; and the second function takes two
                strings, returns true if they are considered equal,
                and false if not.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_default_collation_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a> environment
                component corresponds to the <b>default
                collation</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collation_env" class="env">defaultCollation</a> environment
                component is a pair of functions as described in
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a> above.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_construction_mode_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> environment
                component corresponds to the <b>construction
                mode</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> environment
                component is one of <b>preserve</b> or
                <b>strip</b>.  </td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_ordering_mode_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> environment
                component corresponds to the <b>ordering
                mode</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> environment
                component is one of <b>ordered</b> or
                <b>unordered</b>.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_default_empty_order" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a> environment
                component corresponds to the <b>default order for
                empty sequences</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td> The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_empty_order" class="env">defaultEmptySequenceOrder</a> environment
                component controls whether an empty sequence is
                interpreted as the greatest value or as the least
                value during processing of an <code>order by</code>
                clause in a FLWOR expression. Its value may be
                <code>greatest</code> or <code>least</code>.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_boundary_space" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_boundary_space" class="env">boundarySpace</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_boundary_space" class="env">boundarySpace</a> environment component
                corresponds to the <b>boundary-space policy</b>
                in the [XPath/XQuery] static context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_boundary_space" class="env">boundarySpace</a> environment component
                controls the processing of boundary whitespace by
                element constructors. Its value may be
                <code>preserve</code> or <code>strip</code>.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_copy_namespaces_mode" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a> environment
                component corresponds to the <b>copy-namespaces
                mode</b> in the [XPath/XQuery] static
                context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_copy_namespaces_mode" class="env">copyNamespacesMode</a> environment
                component controls the namespace bindings that are
                assigned when an existing element node is copied by an
                element constructor. Its value consists of two parts:
                <code>preserve</code> or <code>no-preserve</code>, and
                <code>inherit</code> or
                <code>no-inherit</code>.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_base_uri_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a> environment component
                corresponds to the <b>base URI</b> in the
                [XPath/XQuery] static context.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_base_uri_env" class="env">baseURI</a> environment component
                contains a unique namespace URI (a
                <em>URI</em>).</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_doc_type_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a> environment component
                corresponds to the <b>statically known
                documents</b> in the [XPath/XQuery] static context.  It
                contains the static type for the input documents, and
                is used to provide the static type to the <code>fn:doc</code>
                function.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a> environment component
                contains bindings from input URIs (a <em>URI</em>) to
                types (a <a href="#doc-fs-Type"><em>Type</em></a>).</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_collection_type_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a> environment
                component corresponds to the <b>statically known
                collections</b> in the [XPath/XQuery] static context.
                It contains the static type for the input collections,
                and is used to provide the static type to the
                <code>fn:collection</code> function.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a> environment
                component contains bindings from input URIs (a
                <em>URI</em>) to types (a <a href="#doc-fs-Type"><em>Type</em></a>).</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_default_collection_type_env" valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collection_type_env" class="env">defaultCollectionType</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collection_type_env" class="env">defaultCollectionType</a>
                environment component corresponds to the
                <b>statically known default collection type</b>
                in the [XPath/XQuery] static context. It contains the
                static type for the default collection, and is used to
                provide the static type to the <code>fn:collection</code>
                function when called with no arguments.</td></tr><tr><td>The <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_collection_type_env" class="env">defaultCollectionType</a>
                environment component contains type (a
                <a href="#doc-fs-Type"><em>Type</em></a>).</td></tr></tbody></table>
          </td><td/></tr></tbody></table><p>Note that the boundary-space behavior is not formally
      specified in this document.</p><p id="xq_default_stat_env">Environments have an initial state
      when [expression/query] processing begins, containing, for example,
      the function signatures of all built-in functions.  The initial
      values for the static context are defined in <a href="http://www.w3.org/TR/xquery#id-xq-context-components">Section 
C Context Components</a><sup><small>XQ</small></sup> and <a href="http://www.w3.org/TR/xpath20/#id-xp-context-components">Section 
C Context Components</a><sup><small>XP</small></sup> and is denoted by
      <a href="#xq_default_stat_env" class="env">statEnvDefault</a> in the Formal Semantics.</p><p>Here is an example that shows how the static environment is
      modified in response to a namespace definition.</p><div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td>
          
            
              <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em> =&gt; (passive, <em>URI</em>)) 
            <b> |- </b>
            <em>Expr</em>*
          
          </td></tr>
         </table></td></tr></table></td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <code>declare namespace</code> <em>NCName</em> = <em>URI</em> <em>Expr</em>*
          
         </td></tr>
        </table><br/>
      </div><p>This rule reads as follows: "the phrase on the bottom
      (a namespace declaration in the query prolog followed by a
      sequence of expressions) is well-typed (accepted by the static
      type inference rules) within an environment <a href="#xq_stat_env_def" class="env">statEnv</a>
      <em>if</em> the sequence of expressions above the line is
      well-typed in the environment obtained from <a href="#xq_stat_env_def" class="env">statEnv</a> by
      adding the namespace declaration".</p><p id="fs_activeNS">The helper function
      <a href="#fs_activeNS">fs:<code>active_ns</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>) returns all the active in-scope
      namespaces in the given static environment.</p><p id="fs_ns_from_items">For each attribute and element node in
      <a href="#doc-fs-Value"><em>Value</em></a>, such that the node has name <a href="#id-expanded-qnames"><em>expanded-QName</em></a> in the
      namespace <em>URI</em>, the helper function
      <a href="#fs_ns_from_items">fs:<code>get_static_ns_from_items</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <a href="#doc-fs-Value"><em>Value</em></a>) returns the
      in-scope namespace that corresponds to <em>URI</em>.  This is a
      reverse-lookup on <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> by <em>URI</em>.</p><div class="div4">
<h5><a id="id-expanded-qnames" name="id-expanded-qnames"/>3.1.1.1 Resolving QNames to Expanded QNames</h5><p>A common use of the static environment is to expand a
      <em>QName</em> by looking up the URI that corresponds to the QName's
      namespace prefix in the <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> environment component and by
      constructing an <a href="http://www.w3.org/TR/xpath-datamodel/#dt-expanded-qname">expanded-QName</a><sup><small>DM</small></sup>,
      which contains the URI and the QName's local part. Element and
      type names may be in the null namespace, that is, there is no
      URI associated with their namespace prefix.  The null namespace
      is denoted by the special value
      <code>#NULL-NAMESPACE</code>.</p><p>The auxiliary judgments below expand an element, type,
      attribute, variable, or function <em>QName</em> by looking up the
      namespace prefix in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a> or, if the QName is unqualified,
      by using the appropriate default namespace. </p><p><b>Notation</b></p>
        <p id="jd_elem_qname_expands_to">The judgment</p>
        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <em>QName</em> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
          
        </div>
        <p>holds when the element or type QName expands to the 
        given expanded QName.</p>
        <p id="jd_attr_qname_expands_to">The judgment</p>
        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <em>QName</em> <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
          
        </div>
        <p>holds when the attribute QName expands to the 
        given expanded QName.</p>

        <p id="jd_var_qname_expands_to">The judgment</p>
        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <em>QName</em> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
          
        </div>
        <p>holds when the variable QName expands to the 
        given expanded QName.</p>

        <p id="jd_func_qname_expands_to">The judgment</p>
        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <em>QName</em> <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
          
        </div>
        <p>holds when the function QName expands to the 
        given expanded QName.</p>
    <p><b>Semantics</b></p>
      <p>Note that none of the inference rules can infer a resolved
      name in the case a given namespace prefix is bound to the
      (#UNDECLARED) value. As a result, namespace resolution will fail
      if the implementation supports <a href="#XMLNAMES11">[XML Names 1.1]</a> and a
      given namespace prefixed as been undeclared.</p>

      <p>An element or type QName consisting of a prefix NCName and a
      local part NCName expands to the URI (or the null namespace)
      corresponding to that prefix and the local part.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
         
         <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em><sub><font size="2">1</font></sub>) = <em>URI-or-#NULL-NAMESPACE</em>
         
         </td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <em>NCName</em><sub><font size="2">1</font></sub>:<em>NCName</em><sub><font size="2">2</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a>
           (<em>URI-or-#NULL-NAMESPACE</em>, <em>NCName</em><sub><font size="2">2</font></sub>)
          
         </td></tr>
        </table><br/>
      </div>

      <p>An element or type QName consisting only of a local part
      NCName expands to the default element/type namespace and the
      local part.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
         
         <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a> = <em>URI-or-#NULL-NAMESPACE</em>
         
         </td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <em>NCName</em> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a>
           (<em>URI-or-#NULL-NAMESPACE</em>, <em>NCName</em>)
          
         </td></tr>
        </table><br/>
      </div>

      <p>An attribute QName consisting of a prefix NCName and a local
      part NCName expands to the URI (or the null namespace)
      corresponding to the prefix and the local part.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
         
         <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em><sub><font size="2">1</font></sub>) = <em>URI-or-#NULL-NAMESPACE</em>
         
         </td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <em>NCName</em><sub><font size="2">1</font></sub>:<em>NCName</em><sub><font size="2">2</font></sub>
           <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a> (<em>URI-or-#NULL-NAMESPACE</em>, <em>NCName</em><sub><font size="2">2</font></sub>)
          
         </td></tr>
        </table><br/>
      </div>

      <p>An attribute QName consisting only of a local part NCName
      expands to the null namespace and the local part.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <em>NCName</em> <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a>
           (#NULL-NAMESPACE, <em>NCName</em>)
          
         </td></tr>
        </table><br/>
      </div>

      <p>A variable QName consisting of a prefix NCName and a local
      part NCName expands to the URI that corresponds to the prefix
      and the local part.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
         
         <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em><sub><font size="2">1</font></sub>) = <em>URI</em>
         
         </td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <em>NCName</em><sub><font size="2">1</font></sub>:<em>NCName</em><sub><font size="2">2</font></sub>
           <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a> (<em>URI</em>, <em>NCName</em><sub><font size="2">2</font></sub>)
          
         </td></tr>
        </table><br/>
      </div>

      <p>A variable QName consisting only of a local part NCName
      expands to the null namespace and the local part.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <em>NCName</em> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
           (#NULL-NAMESPACE, <em>NCName</em>)
          
         </td></tr>
        </table><br/>
      </div>

      <p>A function QName consisting of a prefix NCName and a local
      part NCName expands to the URI that corresponds to the prefix
      and the local part.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
         
         <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em><sub><font size="2">1</font></sub>) = <em>URI</em>
         
         </td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <em>NCName</em><sub><font size="2">1</font></sub>:<em>NCName</em><sub><font size="2">2</font></sub>
           <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<em>URI</em>, <em>NCName</em><sub><font size="2">2</font></sub>)
          
         </td></tr>
        </table><br/>
      </div>

      <p>A function QName consisting only of a local part NCName
      expands to the default function namespace URI and the local
      part.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
         
         <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a> = <em>URI</em>
         
         </td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <em>NCName</em> <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a>
           (<em>URI</em>, <em>NCName</em>)
          
         </td></tr>
        </table><br/>
      </div>
    </div></div><div class="div3">
<h4><a id="eval_context" name="eval_context"/>3.1.2 Dynamic Context</h4><p id="xq_dyn_env_def"><a href="#xq_dyn_env_def" class="env">dynEnv</a> denotes the environment
      available during dynamic evaluation. Dynamic evaluation may
      extend parts of the dynamic environment.</p><p>If evaluation of an expression relies on some component of
      the dynamic context that has not been assigned a value, a
      dynamic error is raised.</p><p>The following environment components are part of the dynamic
      environment:</p><table summary="" class="figure" cellpadding="5"><col width="10%" span="1"/><col width="15%" span="1"/><col width="65%" align="justify" span="1"/><col width="10%" span="1"/><tbody><tr><td/><td id="xq_val_env" valign="top"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a></td><td>
           <table><tbody><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a> environment component corresponds to the
            <b>variable values</b>, the <b>context
            item</b>, the <b>context position</b> and the
            <b>context size</b> in the [XPath/XQuery] evaluation
            context.</td></tr><tr><td>The dynamic value environment component maps an expanded
            variable name (expanded <em>Variable</em>) to the variable's
            value (<a href="#doc-fs-Value"><em>Value</em></a>) or to the value
            <code>#IMPORTED</code>(<em>URI</em>), if the variable is
            defined in the imported module with namespace
            <em>URI</em>.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_func_env" valign="top"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a> environment component corresponds to
               the <b>function implementations</b> (or
               definition) part of the [XPath/XQuery] dynamic
               context.</td></tr><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a> environment component maps an expanded
               function name and parameter signature of the form
               "<a href="#id-expanded-qnames"><em>expanded-QName</em></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)"
               to the remainder of the corresponding function
               definition, which is either the value
               <code>#BUILT-IN</code> for functions defined in
               <a href="#xpath-functions">[Functions and Operators]</a>; the value <code>#EXTERNAL</code> for
               externally defined functions; the value
               <code>#IMPORTED</code>(<em>URI</em>), if the function is
               defined in the imported module with namespace <em>URI</em>;
               or, if the function is locally declared, the function's
               body and a list of variables, which are the function's
               formal parameters, of the form "(<em>Expr</em>,
               <em>Variable</em><sub><font size="2">1</font></sub>,..., <em>Variable</em><sub><font size="2">n</font></sub>)".</td></tr><tr><td> The initial function environment component
               (<a href="#xq_default_dyn_env" class="env">dynEnvDefault</a>.funcDefn) maps the signatures of
               the internal functions defined in <a href="#sec_operators"><b>[B.2 Mapping of Overloaded Internal Functions]</b></a> and the signatures of the
               functions defined in <a href="#xpath-functions">[Functions and Operators]</a> to
               <code>#BUILT-IN</code>.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_date_time_env" valign="top"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_date_time_env" class="env">dateTime</a></td><td>
           <table><tbody><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_date_time_env" class="env">dateTime</a> environment component corresponds to
            the <b>current dateTime</b> in the [XPath/XQuery]
            dynamic context.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_timezone_env" valign="top"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_timezone_env" class="env">timezone</a></td><td>
           <table><tbody><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_timezone_env" class="env">timezone</a> environment component corresponds to
            the <b>implicit timezone</b> in the [XPath/XQuery]
            dynamic context and is used by the timezone related
            functions in <a href="#xpath-functions">[Functions and Operators]</a>.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_doc_value_env" valign="top"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_doc_value_env" class="env">docValue</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_doc_value_env" class="env">docValue</a> environment component corresponds
                to the <b>available documents</b> in the
                [XPath/XQuery] dynamic context.  It contains the document
                nodes corresponding to input documents, and is used to
                provide the dynamic value of the <code>fn:doc</code>
                function.</td></tr><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_doc_value_env" class="env">docValue</a> environment component contains
                bindings from input URIs (a <em>URI</em>) to documents (a
                <a href="#doc-fs-DocumentValue"><em>DocumentValue</em></a>).</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_collection_value_env" valign="top"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_collection_value_env" class="env">collectionValue</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_collection_value_env" class="env">collectionValue</a> environment component
                corresponds to the <b>available collections</b>
                in the [XPath/XQuery] dynamic context.  It contains the
                root nodes corresponding to the input collections, and
                is used to provide the dynamic value of the
                <code>fn:collection</code> function.</td></tr><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_collection_value_env" class="env">collectionValue</a> environment component
                contains bindings from input URIs (a <em>URI</em>) to
                a sequence of nodes.</td></tr></tbody></table>
          </td><td/></tr><tr><td/><td id="xq_default_collection_value_env" valign="top"><a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_default_collection_value_env" class="env">defaultCollectionValue</a></td><td>
            <table><tbody><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_default_collection_value_env" class="env">defaultCollectionValue</a>
                environment component corresponds to the <b>default
                collection</b> in the [XPath/XQuery] dynamic context.
                It contains the sequence of nodes corresponding to the
                default collection, and is used to provide the dynamic
                value of the <code>fn:collection</code> function when called with
                no arguments.</td></tr><tr><td>The <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_default_collection_value_env" class="env">defaultCollectionValue</a>
                environment component contains a sequence of nodes.</td></tr></tbody></table>
          </td><td/></tr></tbody></table><p id="xq_default_dyn_env">The initial values for the dynamic
      context are defined in <a href="http://www.w3.org/TR/xquery#id-xq-context-components">Section 
C Context Components</a><sup><small>XQ</small></sup> and <a href="http://www.w3.org/TR/xpath20/#id-xp-context-components">Section 
C Context Components</a><sup><small>XP</small></sup> and is denoted by
      <a href="#xq_default_dyn_env" class="env">dynEnvDefault</a> in the Formal Semantics.</p><p id="fs_builtin_vars">The following Formal Semantics variables
      represent the <b>context item</b>, <b>context
      position</b>, and <b>context size</b> properties of the
      dynamic context:</p><table summary="" border="1"><tbody><tr><td>Built-in Variable  </td><td>Represents:</td></tr><tr><td><a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a></td><td>context item</td></tr><tr><td><a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a></td><td>context position </td></tr><tr><td><a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a></td><td>context size</td></tr></tbody></table><p>Variables with the "fs" prefix are reserved for use in the
      definition of the Formal Semantics. Since there is no namespace
      URI associated to the "fs" prefix, users cannot refer to those
      variables directly using a variable expression.</p><p>Values of <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a> and <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a> can be obtained by
      invoking the <code>fn:position</code> and <code>fn:last</code> functions,
      respectively.</p></div></div><div class="div2">
<h3><a id="id-processing-model" name="id-processing-model"/>3.2 Processing Model</h3><p>This section reviews the processing model for [XPath/XQuery], and
    defines the main judgments that are used in this
    specification. The [XPath/XQuery] processing model is defined
    normatively in <a href="http://www.w3.org/TR/xquery#id-processing-model">Section 
2.2 Processing
                         Model</a><sup><small>XQ</small></sup>.
    This section also explains how the main judgments (normalization
    rules, static type inference, and dynamic evaluation) relate to
    the phases in that processing model.</p><div class="div3">
<h4><a id="id-fs-processing-model" name="id-fs-processing-model"/>3.2.1 Processing model</h4><p>The following figure depicts the [XPath/XQuery] processing
      model</p><img src="ProcMod-XQuery.gif" alt="Processing Model Overview"/><p>Figure 1: Processing Model Overview</p><p>This processing model is not intended to describe an actual
      implementation, although a naive implementation might be based
      upon it. It does not prescribe an implementation technique, but
      any implementation should produce the same results as obtained
      by following this processing model and applying the rest of the
      Formal Semantics specification.</p><p>Query processing consists of two phases: a static analysis
      phase and a dynamic evaluation phase. Static analysis is further
      divided into four sub-phases.  Each phase consumes the result of
      the previous phase and generates output for the next phase. For
      each processing phase, we point to the relevant notations
      introduced later in the document.</p><p>[<a title="static analysis       phase" id="dt-static-analysis" name="dt-static-analysis">Definition</a>: The <b>static analysis phase</b> depends on the
      expression itself and on the static context. The <b>static
      analysis phase</b> does not depend on input data (other than
      schemas).]</p><p>The purpose of the static analysis phase is to detect errors,
      e.g., syntax errors or type errors, at compile time rather than
      at run-time. If no error occurs, the result of static analysis
      could be some compiled form of [expression/query], suitable for
      execution by a compiled-[expression/query] processor. Static analysis
      consists of the following sub-phases:</p><ol class="enumar"><li><p id="processing_parsing"><b>Parsing.</b> (Step SQ1
          in Figure 1). The grammar for the [XPath/XQuery] syntax is
          defined in <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a>.  Parsing may generate syntax
          errors.  If no error occurs, an internal operation tree of
          the parsed query is created.</p></li><li><p id="processing_context"><b>Static Context
          Processing.</b> (Steps SQ2, SQ3, and SQ4 in Figure
          1). The static semantics of [expression/query] depends on the
          input static context. The input static context needs to be
          generated before the [expression/query] can be analysed. In
          XQuery, the input static context may be defined by the
          processing environment and by declarations in the Query
          Prolog (See <a href="#id-query-prolog"><b>[5 Modules and Prologs]</b></a>). In XPath, the
          input static context is defined by the processing
          environment. The static context is denoted by
          <a href="#xq_stat_env_def" class="env">statEnv</a>. </p></li><li><p id="processing_normalization"><b>Normalization.</b>
          (Step SQ5 in Figure 1). To simplify the semantics
          specification, some normalization is performed on the
          [expression/query]. The [XPath/XQuery] language provides many powerful
          features that make [expression/query]s simpler to write and use,
          but are also redundant. For instance, a complex
          <code>for</code> expression might be rewritten as a
          composition of several simple <code>for</code>
          expressions. The language composed of these simpler
          [expression/query] is called the [XPath/XQuery] <em>Core
          language</em> and is described by a grammar which is a
          subset of the XQuery grammar. The grammar of the [XPath/XQuery]
          Core language is given in <a href="#sec_core"><b>[A Normalized core grammar]</b></a>.</p><p>During the normalization phase, each [XPath/XQuery]
          [expression/query] is mapped into its equivalent [expression/query] in
          the Core. (Note that this has nothing to do with Unicode
          Normalization, which works on character strings.)
          Normalization works by bottom-up application of
          normalization rules over expressions, starting with
          normalization of literal expressions and variables.</p><p>Specifically the normalization phase is defined in terms
          of the static part of the context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and a
          [expression/query] (<em>Expr</em>) abstract syntax tree. Formal
          notations for the normalization phase are introduced in
          <a href="#sec_normalization"><b>[3.2.2 Normalization judgment]</b></a>.</p><p>After normalization, the full semantics is obtained by
          giving a semantics to the normalized Core [expression/query]. This
          is done during the last two phases.</p></li><li><p id="processing_static"><b>Static type analysis.</b>
          (Step SQ6 in Figure 1).  Static type analysis is optional.
          If this phase is not supported, then normalization is
          followed directly by dynamic evaluation.  </p><p>Static
          type analysis checks whether each [expression/query] is type safe,
          and if so, determines its static type. Static type analysis
          is defined only for Core [expression/query]. Static type analysis
          works by bottom-up application of type inference rules over
          expressions, taking the type of literals and of input
          documents into account.</p><p>If the [expression/query] is not
          type-safe, static type analysis yields a <em>type
          error</em>. For instance, a comparison between an integer
          value and a string value might be detected as an type error
          during the static type analysis. If static type analysis
          succeeds, it yields an abstract syntax tree where each
          sub-expression is associated with its static type.</p><p>More precisely, the static analysis phase is defined in
          terms of the static context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and a Core
          [expression/query] (<em>CoreExpr</em>).  Formal notations for
          the static analysis phase are introduced in <a href="#sec_static"><b>[3.2.3 Static typing judgment]</b></a>.</p><p>Static typing does not imply that the content of XML
          documents must be rigidly fixed or even known in advance.
          The [XPath/XQuery] type system accommodates
          "flexible" types, such as elements that can
          contain any content.  Schema-less documents are handled in
          [XPath/XQuery] by associating a standard type with the document,
          such that it may include any legal XML content.</p></li></ol><p>If the static analysis phase succeeds, the dynamic evaluation
      phase (sometimes also called "execution") evaluates
      a query on input document(s).</p><ol class="enumar"><li><p id="dyn_processing_context"><b>Dynamic Context
          Processing.</b> (Steps DQ2 and DQ3 in Figure 1).The
          dynamic semantics of [expression/query] depends on the dynamic
          input context. The dynamic input context needs to be
          generated before the [expression/query] can be evaluated. The
          dynamic input context may be defined by the processing
          environment and by statements in the Query Prolog (See
          <a href="#id-query-prolog"><b>[5 Modules and Prologs]</b></a>). In XPath, the dynamic
          input context is defined by the processing environment. The
          static input context is denoted by <a href="#xq_dyn_env_def" class="env">dynEnv</a>.</p></li><li><p id="processing_dynamic"><b>Dynamic Evaluation.</b>
          (Steps DQ4 and DQ5 in Figure 1). This phase computes the
          value of an [expression/query].  The semantics of evaluation is
          defined only for Core [expression/query] terms. The formal
          description of evaluation works by bottom-up application of
          evaluation rules over expressions, starting with evaluation
          of literals and variables. (Note that in practice some
          implementations may prefer top-down evaluation strategies.)
          Evaluation may result in a value OR a dynamic error, which
          may be a non-type error or a type error.  If static typing
          of an expression does not raise a type error, then dynamic
          evaluation of the same expression will not raise a type
          error (and thus dynamic type checking can be avoided when
          static typing is enabled). Dynamic evaluation may still
          raise a non-type error.</p><p>The dynamic evaluation phase is defined in terms of the
          static context (<a href="#xq_stat_env_def" class="env">statEnv</a>) and evaluation context
          (<a href="#xq_dyn_env_def" class="env">dynEnv</a>), and a Core [expression/query]
          (<em>CoreExpr</em>). Formal notations for the dynamic
          evaluation phase are introduced in <a href="#sec_evaluation"><b>[3.2.4 Dynamic evaluation judgment]</b></a>.</p></li></ol><p>Static type analysis catches only certain classes of
      errors. For instance, it can detect a comparison operation
      applied between incompatible types (e.g., <code>xs:int</code>
      and <code>xs:date</code>). Some other classes of errors cannot
      be detected by the static analysis and are only detected at
      evaluation time. For instance, whether an arithmetic expression
      on 32 bits integers (<code>xs:int</code>) yields an out-of-bound
      value can only be detected at run-time by looking at the
      data.</p><p>While implementations are free to implement different
      processing models, the [XPath/XQuery] static semantics relies on the
      existence of a static type analysis phase that precedes any
      access to the input data.</p><p>The above processing phases are all internal to the
      [XPath/XQuery] processor. They do not deal with how the [XPath/XQuery]
      processor interacts with the outside world, notably how it
      accesses actual documents and types. A typical [expression/query]
      engine would support at least three other important processing
      phases:</p><ol class="enumar"><li><p><b>Schema Import Processing.</b> The [XPath/XQuery]
          type system is based on XML Schema. In order to perform
          dynamic or static typing, the [XPath/XQuery] processor needs to
          build type descriptions that correspond to the schema(s) of
          the input documents. This phase is achieved by mapping all
          schemas required by the [expression/query] into the [XPath/XQuery]
          type system. The XML Schema import phase is described in
          <a href="#sec_importing_schema"><b>[C Importing Schemas]</b></a>.</p></li><li><p><b>Data Model Generation.</b> Expressions are
          evaluated on values in the <a href="#xpath-datamodel">[Data Model]</a>. XML documents
          must be loaded into the <a href="#xpath-datamodel">[Data Model]</a> before the evaluation
          phase. This is described in the <a href="#xpath-datamodel">[Data Model]</a> and is not
          discussed further here.</p></li><li><p><b>Serialization.</b> Once the [expression/query] is
          evaluated, processors might want to serialize the result of
          the [expression/query] as actual XML documents. Serialization of
          data model instances is described in
          <a href="#xslt-xquery-serialization">[Data Model Serialization]</a> and is not discussed further
          here.</p></li></ol><p>The parsing phase is not specified formally; the formal
      semantics does not define a formal model for the syntax trees,
      but uses the [XPath/XQuery] concrete syntax directly.  More details
      about parsing for XQuery 1.0 can be found in the <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a>
      document and more details about parsing for XPath 2.0 can be
      found in the <a href="#xpath20">[XML Path Language (XPath) 2.0]</a> document. No further discussion of
      parsing is included here.</p></div><div class="div3">
<h4><a id="sec_normalization" name="sec_normalization"/>3.2.2 Normalization judgment</h4><p>Normalization is specified using <em>mapping</em> rules,
      which describe how a [XPath/XQuery] expression is rewritten into an
      expression in the [XPath/XQuery] Core. Mapping rules are also used
      in <a href="#sec_importing_schema"><b>[C Importing Schemas]</b></a> to specify how XML
      Schemas are imported into the [XPath/XQuery] type system.</p><p><b>Notation</b></p>
        <p>Mapping rules are written using a square bracket notation,
          as follows:</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>Object<font size="6">]</font><sub><font size="2">Subscript</font></sub>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <em>Mapped Object</em>
            
          </td></tr>
        </table></div>
        
        <p>The original "object" is written above the
        <b>==</b> sign. The rewritten "object" is written
        beneath the <b>==</b> sign. The subscript is used to indicate
        what kind of "object" is mapped, and sometimes to
        pass some information between mapping rules.</p>
        
        <p>Since normalization is always applied in the presence of a 
          static context, the above rule is a shorthand for:</p>

        <div align="center">
          
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
              <font size="6">[</font>Object<font size="6">]</font>
              <sub><font size="2">Subscript</font></sub>
              ==
              Mapped Object
            
          
        </div>

        <p>The static environment is used in certain normalization
        rules (e.g. for normalization of function calls).  To keep the
        notation simpler, the static environment is not written in the
        normalization rules, but it is assumed to be available.</p>

        <p id="jd_map_expr">The normalization rule that is used to map
          "top-level" expressions in the [XPath/XQuery]
          syntax into expressions in the [XPath/XQuery] Core is:</p>

      	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
      	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      	    
      	  </td></tr>
      	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <em>CoreExpr</em>
      	    
      	  </td></tr>
      	</table></div>

        <p>which indicates that the expression <em>Expr</em> is normalized
        to the expression <em>CoreExpr</em> in the [XPath/XQuery] Core
        (with the implied <a href="#xq_stat_env_def" class="env">statEnv</a>).</p>
      <p><b>Example</b></p>
        <p>For instance, the following [expression/query]</p>

<div class="exampleInner"><pre>
    for $i in (1, 2),
        $j in (3, 4)
    return
      element pair { ($i,$j) }
</pre></div>

        <p>is normalized to the Core expression</p>

<div class="exampleInner"><pre>
    for $i in (1, 2) return
      for $j in (3, 4) return
          element pair { ($i,$j) }
</pre></div>

        <p>in which the "FWLR" expression is
        mapped into a composition of two simpler "for" expressions.</p>
      </div><div class="div3">
<h4><a id="sec_static" name="sec_static"/>3.2.3 Static typing judgment</h4><p>The static semantics is specified using <em>type inference
      rules</em>, which relate [XPath/XQuery] expressions to types and
      specify under what conditions an expression is well typed.</p><p><b>Notation</b></p>
        <p id="jd_has_type">The judgment</p>

        <div align="center">
        
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
        
        </div>

        <p>holds when, in the static environment <a href="#xq_stat_env_def" class="env">statEnv</a>, the
        expression <em>Expr</em> has type <a href="#doc-fs-Type"><em>Type</em></a>.</p>
      <p><b>Example</b></p>
        <p>The result of static type inference is to associate a
        static type with every [expression/query], such that any evaluation
        of that [expression/query] is guaranteed to yield a value that
        belongs to that type.</p>

        <p>For instance, the following expression.</p>

<div class="exampleInner"><pre>
   let $v := 3 return $v+5
</pre></div>

        <p>has type <code>xs:integer</code>. This can be inferred as follows: the
        input literals '3' and '5' have type integer, so the variable
        $v also has type integer. Since the sum of two integers is an
        integer, the complete expression has type integer.</p>
      <p><b>Note</b></p>
        <p>The type of an expression is computed by
        inference. <em>Static type inference rules</em> define for
        each kind of expression how to compute the type of the
        expression given the types of its sub-expressions.  Here is a
        simple example:</p>

      	<div align="center">
      	  <table cellpadding="0" cellspacing="0" summary="">
      	   <tr valign="middle" align="center"><td>
      	    
      	     <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
      	      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code> 
      	        
      	    
      	     <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
      	      <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>   
      	        
      	    
      	     <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
      	      <em>Expr</em><sub><font size="2">3</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>    
      	    
      	   </td></tr>
      	   <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
      	    
      	     <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
      	     
      	  <code>if</code> <em>Expr</em><sub><font size="2">1</font></sub>
      	  <code>then</code> <em>Expr</em><sub><font size="2">2</font></sub>
      	  <code>else</code> <em>Expr</em><sub><font size="2">3</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> ( <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub> )
      	    
      	    
      	   </td></tr>
      	  </table><br/>
      	</div>
  
      	<p>This rule states that if the conditional expression of an
      	"if" expression has type boolean, then the
      	type of the entire expression is one of the two types of its
      	"then" and "else" clauses.  Note
      	that the resulting type is represented as a union:
      	'(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>)'.</p>

        <p>The "left half" (the part before the
        <b>:</b>) of the expression <em>below</em> the line
        corresponds to some [expression/query], for which a type is
        computed. If the [expression/query] has been parsed into an internal
        abstract syntax tree, this usually corresponds to some node in
        that tree.  The expression usually has
        <em>pattern</em>s in it (here <em>Expr</em><sub><font size="2">1</font></sub>, <em>Expr</em><sub><font size="2">2</font></sub>,
        and <em>Expr</em><sub><font size="2">3</font></sub>) that need to be matched against the children
        of the node in the abstract syntax tree. The expressions
        <em>above</em> the line indicate things that need to be
        computed to use this rule; in this case, the types of the
        condition expression and the two branches of the if-then-else
        expression.  Once those types are computed (by further
        applying static inference rules recursively to the expressions
        on each side), then the type of the expression below the line
        can be computed.  This example illustrates a general feature
        of the [XPath/XQuery] type system: the type of an expression
        depends only on the type of its sub-expressions.  The overall
        static type inference algorithm is recursive, following the
        abstract syntax of the [expression/query].  At each point in the
        recursion, an appropriate matching inference rule is sought;
        if at any point there is no applicable rule, then static type
        inference has failed and the [expression/query] is not type
        correct.</p>

     </div><div class="div3">
<h4><a id="sec_evaluation" name="sec_evaluation"/>3.2.4 Dynamic evaluation judgment</h4><p>The dynamic, or operational, semantics is specified using
      <em>value inference rules</em>, which relate [XPath/XQuery]
      expressions to values, and in some cases specify the order in
      which an [XPath/XQuery] expression is evaluated.</p><p><b>Notation</b></p>
        <p id="jd_yields">The judgment</p>

        <div align="center">
        
          <a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
          <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
        
        </div>

        <p>holds when, in the static environment <a href="#xq_stat_env_def" class="env">statEnv</a> and
        dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>, the expression <em>Expr</em>
        yields the value <a href="#doc-fs-Value"><em>Value</em></a>.</p>

      <p>The static environment is used in certain cases (e.g. for
      type matching) during evaluation. To keep the notation simpler,
      the static environment is not written in the dynamic inference
      rules, but it is assumed to be available.</p><p><b>Example</b></p>
        <p>For instance, the following expression.</p>

<div class="exampleInner"><pre>
   let $v := 3 return $v+5
</pre></div>

        <p>yields the integer value 8. This can be inferred as
        follows: the input literals '3' and '5' denote the values 3
        and 5, respectively, so the variable $v has the value 3. Since
        the sum of 3 and 5 is 8, the complete expression has the value
        8.</p>
      <p><b>Note</b></p>
        <p>As with static type inference, logical inference rules are
        used to determine the value of each expression, given the
        dynamic environment and the values of its sub-expressions.</p>

       <p>The inference rules used for dynamic evaluation, like those
       for static type inference, follow a bottom-up recursive
       structure, computing the value of expressions from the values
       of their sub-expressions.</p>

      </div></div><div class="div2">
<h3><a id="sec_errors" name="sec_errors"/>3.3 Error Handling</h3><p>Expressions can raise errors during static analysis or dynamic
    evaluation.  The <a href="#xpath-functions">[Functions and Operators]</a> <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a>, and <a href="#xpath20">[XML Path Language (XPath) 2.0]</a>
    specify the conditions under which an expression or operator
    raises an error.  The user may raise an error explicitly by
    calling the <code>fn:error</code> function, which takes an optional item as
    an argument.</p><p>This document does not describe formally the conditions under
    which dynamic errors are raised. Notably, it does not specify the
    error codes or the rules about errors and optimization, as
    described in <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a>. Instead, this document
    describe the rules necessary to statically detect the subset of
    the [XPath/XQuery] dynamic errors known as <a href="http://www.w3.org/TR/xquery#dt-type-error">type error</a><sup><small>XQ</small></sup>.</p></div><div class="div2">
<h3><a id="id-important-concepts" name="id-important-concepts"/>3.4 Concepts</h3><p>[XPath/XQuery] is most generally used to process
    <b>documents</b>. The representation of a document is
    normatively defined in <a href="#xpath-datamodel">[Data Model]</a>. The functions used to
    access documents and collections are normatively defined in
    <a href="#xpath-functions">[Functions and Operators]</a>. </p><div class="div3">
<h4><a id="id-doc-order" name="id-doc-order"/>3.4.1 Document Order</h4><p>Document order is defined in <a href="#xpath-datamodel">[Data Model]</a>.</p></div><div class="div3">
<h4><a id="id-atomization" name="id-atomization"/>3.4.2 Atomization</h4><p>Atomization converts an item sequence into a sequence of
        atomic values and is implemented by the <code>fn:data</code> function.
        Atomization is applied to a value when the value is used in a
        context in which a sequence of atomic values is required.</p></div><div class="div3">
<h4><a id="id-ebv" name="id-ebv"/>3.4.3 Effective Boolean Value</h4><p>If a sequence of items is encountered where a boolean value
      is expected, the item sequence's effective boolean value is
      used. The <code>fn:boolean</code> function returns the effective boolean
      value of an item sequence.</p></div><div class="div3">
<h4><a id="id-input-sources" name="id-input-sources"/>3.4.4 Input Sources</h4><p>[XPath/XQuery] has a set of functions that provide access to
      input data. These functions are of particular importance because
      they provide a way in which an expression can reference a
      document or a collection of documents. The dynamic semantics of
      these three input functions are described in more detail in
      <a href="#xpath-functions">[Functions and Operators]</a>.</p></div><div class="div3">
<h4><a id="id-uri-literals" name="id-uri-literals"/>3.4.5 URI Literals</h4><p>In certain places in the XQuery grammar, a statically known
      valid absolute URI is required. These places are denoted by the
      grammatical symbol <em>URILiteral</em>, and are treated as described
      in <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a>.</p></div></div><div class="div2">
<h3><a id="id-type-conversion" name="id-type-conversion"/>3.5 Types</h3><div class="div3">
<h4><a id="id-predefined-types" name="id-predefined-types"/>3.5.1 Predefined Schema Types</h4><p>All the built-in types of XML Schema are recognized by
      [XPath/XQuery]. In addition, [XPath/XQuery] recognizes the predefined
      types <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>, <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> and <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a>
      and the duration subtypes <a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a> and
      <a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      . The definition of those types in the
      [XPath/XQuery] type system is given below.</p><p>[<a title="xs:anyType" id="dt-xs_anyType" name="dt-xs_anyType">Definition</a>:  The following
      type definition of <b><span><code>xs:anyType</code></span></b>
      reflects the semantics of the Ur type from Schema in the
      [XPath/XQuery] type system.]</p><div class="exampleInner"><pre>
  define type xs:anyType restricts xs:anyType {
    attribute * of type xs:anySimpleType*,
    ( xdt:anyAtomicType* | ( element * of type xs:anyType | text | comment | processing-instruction )* )
  }
</pre></div><p>[<a title="xs:anySimpleType" id="dt-xs_anySimpleType" name="dt-xs_anySimpleType">Definition</a>: 
      The following type definition of
      <b><span><code>xs:anySimpleType</code></span></b> reflects the
      semantics of the Ur simple type from Schema in the [XPath/XQuery]
      type system.]</p><div class="exampleInner"><pre>
  define type xs:anySimpleType restricts xs:anyType {
    xdt:anyAtomicType*
  }
</pre></div><p>The name of the Ur simple type is <code>xs:anySimpleType</code>. It is
      derived by restriction from <code>xs:anyType</code>, its content is a
      sequence any atomic types.</p><p>[<a title="xdt:anyAtomicType" id="dt-xdt_anyAtomicType" name="dt-xdt_anyAtomicType">Definition</a>: <span>The following type definition
      of <b><span><a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a></span></b> reflects
      the semantics of <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a> in the [XPath/XQuery] type
      system.</span>]</p><div class="exampleInner"><pre>
  define type xdt:anyAtomicType restricts xs:anySimpleType {
    ( xs:string
    | xs:boolean
    | xs:decimal
    | xs:float
    | xs:double
    | xs:duration
    | xs:dateTime
    | xs:time
    | xs:date
    | xs:gYearMonth
    | xs:gYear
    | xs:gMonthDay
    | xs:gDay
    | xs:gMonth
    | xs:hexBinary
    | xs:base64Binary
    | xs:anyURI
    | xs:QName
    | xs:NOTATION
    | xdt:untypedAtomic )
  }
</pre></div><p>[<a title="primitive types" id="dt-primitive-types" name="dt-primitive-types">Definition</a>:  The
      following type definitions of <b> the XML Schema primitive
      types</b> reflect the semantics of the primitive types from
      Schema in the [XPath/XQuery] type system.]</p><div class="exampleInner"><pre>
  define type xs:string       restricts xdt:anyAtomicType
  define type xs:boolean      restricts xdt:anyAtomicType
  define type xs:decimal      restricts xdt:anyAtomicType
  define type xs:float        restricts xdt:anyAtomicType
  define type xs:double       restricts xdt:anyAtomicType
  define type xs:duration     restricts xdt:anyAtomicType
  define type xs:dateTime     restricts xdt:anyAtomicType
  define type xs:time         restricts xdt:anyAtomicType
  define type xs:date         restricts xdt:anyAtomicType
  define type xs:gYearMonth   restricts xdt:anyAtomicType
  define type xs:gYear        restricts xdt:anyAtomicType
  define type xs:gMonthDay    restricts xdt:anyAtomicType
  define type xs:gDay         restricts xdt:anyAtomicType
  define type xs:gMonth       restricts xdt:anyAtomicType
  define type xs:hexBinary    restricts xdt:anyAtomicType
  define type xs:base64Binary restricts xdt:anyAtomicType
  define type xs:anyURI       restricts xdt:anyAtomicType
  define type xs:QName        restricts xdt:anyAtomicType
  define type xs:NOTATION     restricts xdt:anyAtomicType
</pre></div><p>All of those primitive types derive from
      <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>. Note that the value space of each atomic
      type (such as <code>xs:string</code>) does not appear. The value space for
      each type is built-in and is as defined in <a href="#xmlschema-2">[Schema Part 2]</a>.</p><p>[<a title="xdt:untypedAtomic" id="dt-xdt_untypedAtomic" name="dt-xdt_untypedAtomic">Definition</a>: The type
      <b><span><a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a></span></b> is defined as
      follows.]</p><div class="exampleInner"><pre>
  define type xdt:untypedAtomic restricts xdt:anyAtomicType
</pre></div><p>Note that this rule does not indicate the value space of
      <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>. By definition, <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> has the
      same value space as <code>xs:string</code>.</p><p>The following example shows two atomic values. The first one
      is a value of type string containing "Database". The second one
      is an untyped atomic value containing "Database".</p><div class="exampleInner"><pre>
  "Databases" of type xs:string
  "Databases" of type xdt:untypedAtomic
</pre></div><p>[<a title="xdt:untyped" id="dt-xdt_untyped" name="dt-xdt_untyped">Definition</a>: The type
      <b><span><a href="#dt-xdt_untyped"><code>xdt:untyped</code></a></span></b> is defined as
      follows.]</p><div class="exampleInner"><pre>
  define type xdt:untyped restricts xs:anyType {
    attribute * of type xdt:untypedAtomic*,
    ( element * of type xdt:untyped | text | comment | processing-instruction )*
  }
</pre></div><p>[<a title="derived types" id="dt-derived-types" name="dt-derived-types">Definition</a>: The
      following type definitions of the <b>XML Schema derived
      types</b> reflect the semantics of the XML Schema types
      derived by restriction from another atomic type.]</p><div class="exampleInner"><pre>
  define type xs:normalizedString   restricts xs:string
  define type xs:token              restricts xs:normalizedString
  define type xs:language           restricts xs:token
  define type xs:NMTOKEN            restricts xs:token
  define type xs:Name               restricts xs:token
  define type xs:NCName             restricts xs:Name
  define type xs:ID                 restricts xs:Name
  define type xs:IDREF              restricts xs:Name
  define type xs:ENTITY             restricts xs:Name
  define type xs:integer            restricts xs:decimal
  define type xs:nonPositiveInteger restricts xs:integer
  define type xs:negativeInteger    restricts xs:nonPositiveInteger
  define type xs:long               restricts xs:integer
  define type xs:int                restricts xs:long
  define type xs:short              restricts xs:int
  define type xs:byte               restricts xs:short
  define type xs:nonNegativeInteger restricts xs:integer
  define type xs:unsignedLong       restricts xs:nonNegativeInteger
  define type xs:unsignedInt        restricts xs:unsignedLong
  define type xs:unsignedShort      restricts xs:unsignedInt
  define type xs:unsignedByte       restricts xs:unsignedShort
  define type xs:positiveInteger    restricts xs:nonNegativeInteger
</pre></div><p>Three XML Schema built-in derived types are derived by list,
      as follows. Note that those derive directly from
      <code>xs:anySimpleType</code>, since they are derived by list, and that
      their value space is defined using a "one or more"
      occurrence indicator.</p><div class="exampleInner"><pre>
  define type xs:NMTOKENS restricts xs:anySimpleType { xs:NMTOKEN+ }
  define type xs:IDREFS   restricts xs:anySimpleType { xs:IDREF+ }
  define type xs:ENTITIES restricts xs:anySimpleType { xs:ENTITY+ }
</pre></div><p>For example, here is an element whose content is of type
     <code>xs:IDREFS</code>.</p><div class="exampleInner"><pre>
  element a of type xs:IDREFS {
    "id1" of type xs:IDREF,
    "id2" of type xs:IDREF,
    "id3" of type xs:IDREF
  }
</pre></div><p>Note that the type name <code>xs:IDREFS</code> derives from
      <code>xs:anySimpleType</code>, but not from <code>xs:IDREF</code>. As a consequence,
      calling the following three XQuery functions with the element
      <code>a</code> as a parameter succeeds for <code>f1</code> and
      <code>f2</code>, but raises a type error for
      <code>f3</code>.</p><div class="exampleInner"><pre>
  declare function f1($x as element(*,xs:anySimpleType)) { $x }
  declare function f2($x as element(*,xs:IDREFS)) { $x }
  declare function f3($x as element(*,xs:IDREF)) { $x }
</pre></div><p>[<a title="Totally ordered duration       types" id="dt-xdt_durations" name="dt-xdt_durations">Definition</a>: <span>The <b>totally ordered duration types</b>,
      <a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a> and <a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      , are derived
      by restriction from <code>xs:duration</code>.</span>]</p><div class="exampleInner"><pre>
  define type xdt:yearMonthDuration restricts xs:duration
  define type xdt:dayTimeDuration   restricts xs:duration
</pre></div><p>[<a title="fs:numeric" id="dt-fs_numeric" name="dt-fs_numeric">Definition</a>: In addition,
      the Formal Semantics uses the additional type <em>fs:</em><code>numeric</code>. This
      type is necessary for the specification of some of XPath type
      conversion rules.  It is defined as follows.]</p><div class="exampleInner"><pre>
  define type fs:numeric restricts xs:anyAtomicType { xs:decimal | xs:float | xs:double }
</pre></div></div><div class="div3">
<h4><a id="id-typed-value" name="id-typed-value"/>3.5.2 Typed Value and String Value</h4><p>The typed value of a node is computed by the <code>fn:data</code>
      function, and the string value of a node is computed by the
      <code>fn:string</code> function, defined in <a href="#xpath-functions">[Functions and Operators]</a>.
The normative definitions of typed value and string value are defined in <a href="#xpath-datamodel">[Data Model]</a>.
</p></div><div class="div3">
<h4><a id="id-sequencetype" name="id-sequencetype"/>3.5.3 SequenceType Syntax</h4><p><b>Introduction</b></p>
        <p>Sequence types can be used in [XPath/XQuery] to refer to an XML
        Schema type. Sequence types are used to declare the types of
        function parameters and in several [XPath/XQuery] expressions.</p>
  
        <p>The syntax of sequence types is described by the following
        grammar productions.</p>

    
<h5><a id="N1216D" name="N1216D"/>SequenceType</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-SequenceType" name="doc-xquery-SequenceType"/>[<small>119 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-SequenceType">SequenceType</a></code></td><td>   ::=   </td><td><code>("empty-sequence"  "("  ")")<br/>|  (<a href="#doc-xquery-ItemType">ItemType</a>  <a href="#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ItemType" name="doc-xquery-ItemType"/>[<small>121 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ItemType">ItemType</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-KindTest">KindTest</a>  |  ("item"  "("  ")")  |  <a href="#doc-xquery-AtomicType">AtomicType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-OccurrenceIndicator" name="doc-xquery-OccurrenceIndicator"/>[<small>120 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-OccurrenceIndicator">OccurrenceIndicator</a></code></td><td>   ::=   </td><td><code>"?"  |  "*"  |  "+"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AtomicType" name="doc-xquery-AtomicType"/>[<small>122 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AtomicType">AtomicType</a></code></td><td>   ::=   </td><td><code>QName</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-KindTest" name="doc-xquery-KindTest"/>[<small>123 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-KindTest">KindTest</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-DocumentTest">DocumentTest</a><br/>|  <a href="#doc-xquery-ElementTest">ElementTest</a><br/>|  <a href="#doc-xquery-AttributeTest">AttributeTest</a><br/>|  <a href="#doc-xquery-SchemaElementTest">SchemaElementTest</a><br/>|  <a href="#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</a><br/>|  <a href="#doc-xquery-PITest">PITest</a><br/>|  <a href="#doc-xquery-CommentTest">CommentTest</a><br/>|  <a href="#doc-xquery-TextTest">TextTest</a><br/>|  <a href="#doc-xquery-AnyKindTest">AnyKindTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DocumentTest" name="doc-xquery-DocumentTest"/>[<small>125 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DocumentTest">DocumentTest</a></code></td><td>   ::=   </td><td><code>"document-node"  "("  (<a href="#doc-xquery-ElementTest">ElementTest</a>  |  <a href="#doc-xquery-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ElementTest" name="doc-xquery-ElementTest"/>[<small>133 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ElementTest">ElementTest</a></code></td><td>   ::=   </td><td><code>"element"  "("  (<a href="#doc-xquery-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#doc-xquery-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-SchemaElementTest" name="doc-xquery-SchemaElementTest"/>[<small>135 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-SchemaElementTest">SchemaElementTest</a></code></td><td>   ::=   </td><td><code>"schema-element"  "("  <a href="#doc-xquery-ElementDeclaration">ElementDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ElementDeclaration" name="doc-xquery-ElementDeclaration"/>[<small>136 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ElementDeclaration">ElementDeclaration</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ElementName">ElementName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AttributeTest" name="doc-xquery-AttributeTest"/>[<small>129 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AttributeTest">AttributeTest</a></code></td><td>   ::=   </td><td><code>"attribute"  "("  (<a href="#doc-xquery-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#doc-xquery-TypeName">TypeName</a>)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-SchemaAttributeTest" name="doc-xquery-SchemaAttributeTest"/>[<small>131 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>   ::=   </td><td><code>"schema-attribute"  "("  <a href="#doc-xquery-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AttributeDeclaration" name="doc-xquery-AttributeDeclaration"/>[<small>132 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AttributeDeclaration">AttributeDeclaration</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-AttributeName">AttributeName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ElementNameOrWildcard" name="doc-xquery-ElementNameOrWildcard"/>[<small>134 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ElementName">ElementName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ElementName" name="doc-xquery-ElementName"/>[<small>138 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ElementName">ElementName</a></code></td><td>   ::=   </td><td><code>QName</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AttribNameOrWildcard" name="doc-xquery-AttribNameOrWildcard"/>[<small>130 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-AttributeName">AttributeName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AttributeName" name="doc-xquery-AttributeName"/>[<small>137 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AttributeName">AttributeName</a></code></td><td>   ::=   </td><td><code>QName</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-TypeName" name="doc-xquery-TypeName"/>[<small>139 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-TypeName">TypeName</a></code></td><td>   ::=   </td><td><code>QName</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-PITest" name="doc-xquery-PITest"/>[<small>128 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-PITest">PITest</a></code></td><td>   ::=   </td><td><code>"processing-instruction"  "("  (NCName  |  <a href="#doc-xquery-StringLiteral">StringLiteral</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-CommentTest" name="doc-xquery-CommentTest"/>[<small>127 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CommentTest">CommentTest</a></code></td><td>   ::=   </td><td><code>"comment"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-TextTest" name="doc-xquery-TextTest"/>[<small>126 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-TextTest">TextTest</a></code></td><td>   ::=   </td><td><code>"text"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AnyKindTest" name="doc-xquery-AnyKindTest"/>[<small>124 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AnyKindTest">AnyKindTest</a></code></td><td>   ::=   </td><td><code>"node"  "("  ")"</code></td></tr></tbody></table> 

        <p><b>Core Grammar</b></p>
          <p>The Core grammar productions for sequence types are:</p>
      
  
<h5><a id="N122BC" name="N122BC"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-SequenceType" name="doc-core-SequenceType"/>[<small>83 (Core)</small>]   </td><td><code><a href="#prod-core-SequenceType">SequenceType</a></code></td><td>   ::=   </td><td><code>("empty-sequence"  "("  ")")<br/>|  (<a href="#doc-core-ItemType">ItemType</a>  <a href="#doc-core-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ItemType" name="doc-core-ItemType"/>[<small>85 (Core)</small>]   </td><td><code><a href="#prod-core-ItemType">ItemType</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-KindTest">KindTest</a>  |  ("item"  "("  ")")  |  <a href="#doc-core-AtomicType">AtomicType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-OccurrenceIndicator" name="doc-core-OccurrenceIndicator"/>[<small>84 (Core)</small>]   </td><td><code><a href="#prod-core-OccurrenceIndicator">OccurrenceIndicator</a></code></td><td>   ::=   </td><td><code>"?"  |  "*"  |  "+"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-AtomicType" name="doc-core-AtomicType"/>[<small>86 (Core)</small>]   </td><td><code><a href="#prod-core-AtomicType">AtomicType</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-KindTest" name="doc-core-KindTest"/>[<small>87 (Core)</small>]   </td><td><code><a href="#prod-core-KindTest">KindTest</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-DocumentTest">DocumentTest</a><br/>|  <a href="#doc-core-ElementTest">ElementTest</a><br/>|  <a href="#doc-core-AttributeTest">AttributeTest</a><br/>|  <a href="#doc-core-SchemaElementTest">SchemaElementTest</a><br/>|  <a href="#doc-core-SchemaAttributeTest">SchemaAttributeTest</a><br/>|  <a href="#doc-core-PITest">PITest</a><br/>|  <a href="#doc-core-CommentTest">CommentTest</a><br/>|  <a href="#doc-core-TextTest">TextTest</a><br/>|  <a href="#doc-core-AnyKindTest">AnyKindTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-DocumentTest" name="doc-core-DocumentTest"/>[<small>89 (Core)</small>]   </td><td><code><a href="#prod-core-DocumentTest">DocumentTest</a></code></td><td>   ::=   </td><td><code>"document-node"  "("  (<a href="#doc-core-ElementTest">ElementTest</a>  |  <a href="#doc-core-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ElementTest" name="doc-core-ElementTest"/>[<small>97 (Core)</small>]   </td><td><code><a href="#prod-core-ElementTest">ElementTest</a></code></td><td>   ::=   </td><td><code>"element"  "("  (<a href="#doc-core-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#doc-core-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-SchemaElementTest" name="doc-core-SchemaElementTest"/>[<small>99 (Core)</small>]   </td><td><code><a href="#prod-core-SchemaElementTest">SchemaElementTest</a></code></td><td>   ::=   </td><td><code>"schema-element"  "("  <a href="#doc-core-ElementDeclaration">ElementDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ElementDeclaration" name="doc-core-ElementDeclaration"/>[<small>100 (Core)</small>]   </td><td><code><a href="#prod-core-ElementDeclaration">ElementDeclaration</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ElementName">ElementName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-AttributeTest" name="doc-core-AttributeTest"/>[<small>93 (Core)</small>]   </td><td><code><a href="#prod-core-AttributeTest">AttributeTest</a></code></td><td>   ::=   </td><td><code>"attribute"  "("  (<a href="#doc-core-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#doc-core-TypeName">TypeName</a>)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-SchemaAttributeTest" name="doc-core-SchemaAttributeTest"/>[<small>95 (Core)</small>]   </td><td><code><a href="#prod-core-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>   ::=   </td><td><code>"schema-attribute"  "("  <a href="#doc-core-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-AttributeDeclaration" name="doc-core-AttributeDeclaration"/>[<small>96 (Core)</small>]   </td><td><code><a href="#prod-core-AttributeDeclaration">AttributeDeclaration</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-AttributeName">AttributeName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ElementNameOrWildcard" name="doc-core-ElementNameOrWildcard"/>[<small>98 (Core)</small>]   </td><td><code><a href="#prod-core-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ElementName">ElementName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ElementName" name="doc-core-ElementName"/>[<small>102 (Core)</small>]   </td><td><code><a href="#prod-core-ElementName">ElementName</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-AttribNameOrWildcard" name="doc-core-AttribNameOrWildcard"/>[<small>94 (Core)</small>]   </td><td><code><a href="#prod-core-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-AttributeName">AttributeName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-AttributeName" name="doc-core-AttributeName"/>[<small>101 (Core)</small>]   </td><td><code><a href="#prod-core-AttributeName">AttributeName</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-TypeName" name="doc-core-TypeName"/>[<small>103 (Core)</small>]   </td><td><code><a href="#prod-core-TypeName">TypeName</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-PITest" name="doc-core-PITest"/>[<small>92 (Core)</small>]   </td><td><code><a href="#prod-core-PITest">PITest</a></code></td><td>   ::=   </td><td><code>"processing-instruction"  "("  (<a href="#prod-core-NCName">NCName</a>  |  <a href="#doc-core-StringLiteral">StringLiteral</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-CommentTest" name="doc-core-CommentTest"/>[<small>91 (Core)</small>]   </td><td><code><a href="#prod-core-CommentTest">CommentTest</a></code></td><td>   ::=   </td><td><code>"comment"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-TextTest" name="doc-core-TextTest"/>[<small>90 (Core)</small>]   </td><td><code><a href="#prod-core-TextTest">TextTest</a></code></td><td>   ::=   </td><td><code>"text"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-AnyKindTest" name="doc-core-AnyKindTest"/>[<small>88 (Core)</small>]   </td><td><code><a href="#prod-core-AnyKindTest">AnyKindTest</a></code></td><td>   ::=   </td><td><code>"node"  "("  ")"</code></td></tr></tbody></table>
        

        <p>The semantics of SequenceTypes is defined by means of
        normalization rules from SequenceTypes into types in the
        [XPath/XQuery] type system (See <a href="#sec_types"><b>[2.4 The [XPath/XQuery] Type System]</b></a>).</p>

        <p>However, the [XPath/XQuery] type system not being part of the
        [XPath/XQuery] syntax, the SequenceType syntax is still part of
        the [XPath/XQuery] Core. Normalization from SequenceTypes to types
        is not applied during the normalization phase but whenever a
        dynamic or static rule requires it. Normalization of
        SequenceTypes is the only example of normalization that does
        not yield an expression in the [XPath/XQuery] Core and that occurs
        on-demand in dynamic or static rules.</p>

      </div><div class="div3">
<h4><a id="id-sequencetype-matching" name="id-sequencetype-matching"/>3.5.4 SequenceType Matching</h4><p><b>Introduction</b></p>
          <p>During processing of a query, it is sometimes necessary
          to determine whether a given value matches a type that was
          declared using the SequenceType syntax. This process is
          known as SequenceType matching, and is formally specified in
          <a href="#sec_type_matching"><b>[8.3 Judgments for type matching]</b></a>.</p>
        <p><b>Notation</b></p>
          <p id="jd_map_sequencetype">To define normalization of
          SequenceTypes to the [XPath/XQuery] type system, the following
          auxiliary mapping rule is used.</p>
        
            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font><em>SequenceType</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <a href="#doc-fs-Type"><em>Type</em></a>
              
             </td></tr>
            </table></div>
        
          <p>specifies that <em>SequenceType</em> is mapped to a <a href="#doc-fs-Type"><em>Type</em></a>,
          in the [XPath/XQuery] type system.</p>
        <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
          <p>OccurenceIndicators are left unchanged when normalizing
          SequenceTypes into [XPath/XQuery] types. Each kind of
          SequenceType component is normalized separately into the
          [XPath/XQuery] type system.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font><a href="#doc-core-ItemType"><em>ItemType</em></a> <em>OccurrenceIndicator</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font><a href="#doc-core-ItemType"><em>ItemType</em></a><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a> <em>OccurrenceIndicator</em>
              
             </td></tr>
            </table></div>
        
            <p>The "empty-sequence()" sequence type is
            mapped to the empty type.</p>
        
            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>empty-sequence()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
               empty
              
             </td></tr>
            </table></div>

            <p>An atomic type is normalized to itself in the
            [XPath/XQuery] type system.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font><a href="#doc-core-AtomicType"><em>AtomicType</em></a><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <a href="#doc-core-AtomicType"><em>AtomicType</em></a>
              
             </td></tr>
            </table></div>

            <p>An "element" SequenceType without content
            or with a wildcard and no type name is normalized into a
            wildcard element type.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>element()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                element * of type <code>xs:anyType</code>
              
             </td></tr>
            </table></div>
        
            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>element(*)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                element * of type <code>xs:anyType</code>
              
             </td></tr>
            </table></div>

            <p>An "element" SequenceType with a wildcard
            and a type name is normalized into a wildcard element type
            with a corresponding type name. The presence of a
            "?" after the type name indicates a nillable
            element.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>element(*,<a href="#doc-fs-TypeName"><em>TypeName</em></a>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                element * of type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
              
             </td></tr>
            </table></div>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>element(*,<a href="#doc-fs-TypeName"><em>TypeName</em></a>?)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                element * nillable of type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
              
             </td></tr>
            </table></div>

            <p>An "element" SequenceType with a name and
            a type name is normalized into an element type with a
            corresponding type name. The presence of a
            "?" after the type name indicates a nillable
            element.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>element(<a href="#doc-fs-ElementName"><em>ElementName</em></a>,<a href="#doc-fs-TypeName"><em>TypeName</em></a>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                element <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
              
             </td></tr>
            </table></div>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>element(<a href="#doc-fs-ElementName"><em>ElementName</em></a>,<a href="#doc-fs-TypeName"><em>TypeName</em></a>?)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                element <a href="#doc-fs-ElementName"><em>ElementName</em></a> nillable of type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
              
             </td></tr>
            </table></div>

            <p>An "element" SequenceType with only a name
            is normalized into a <em>nillable</em> element type
            with a corresponding name. The reason for the
            normalization to allow nillable elements is because the
            semantics of SequenceTypes in that case allows it to match
            every possible element with that names, regardless of its
            type or nilled property.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>element(<a href="#doc-fs-ElementName"><em>ElementName</em></a>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                element <a href="#doc-fs-ElementName"><em>ElementName</em></a> nillable of type <code>xs:anyType</code>
              
             </td></tr>
            </table></div>
       
            <p>A "schema-element" SequenceType with an
            element declaration is normalized into a reference to the
            corresponding global element declaration.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>schema-element(<a href="#doc-fs-ElementName"><em>ElementName</em></a>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                element <a href="#doc-fs-ElementName"><em>ElementName</em></a>
              
             </td></tr>
            </table></div>
        
            <p>An "attribute" SequenceType without
            content or with a wildcard and no type name is normalized
            into a wildcard attribute type.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>attribute()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                attribute * of type <code>xs:anySimpleType</code> 
              
             </td></tr>
            </table></div>
        
            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>attribute(*)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                attribute * of type <code>xs:anySimpleType</code> 
              
             </td></tr>
            </table></div>

            <p>An "attribute" SequenceType with a
            wildcard and a type name is normalized into a wildcard
            attribute type with a corresponding type name.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>attribute(*,<a href="#doc-fs-TypeName"><em>TypeName</em></a>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                attribute * of type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
              
             </td></tr>
            </table></div>

            <p>An "attribute" SequenceType with a name
            and a type name is normalized into an attribute type with
            a corresponding type name.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>attribute(<a href="#doc-fs-AttributeName"><em>AttributeName</em></a>,<a href="#doc-fs-TypeName"><em>TypeName</em></a>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> of type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
              
             </td></tr>
            </table></div>

            <p>A "schema-attribute" SequenceType with an
            attribute declaration is normalized into a reference to
            the corresponding global attribute declaration.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>schema-attribute(<a href="#doc-fs-AttributeName"><em>AttributeName</em></a>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a>
              
             </td></tr>
            </table></div>

            <p>A "document-node()" sequence types is
            normalized into the corresponding document type.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>document-node()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                document { (element * of type <code>xs:anyType</code> | text | comment | processing-instruction)* }
              
             </td></tr>
            </table></div>

            <p>A "document-node" sequence type with an
            element test (resp. a schema element test) is normalized
            into the corresponding document type, whose content is the
            normalization of the element test (resp. schema element
            test), interleaved with an arbitrary sequence of
            processing instruction, comment, and text nodes.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>document-node(<em>ElementTest</em>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                document {
                <font size="6">[</font><em>ElementTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a> &amp;
                ( processing-instruction | comment ) *}
              
             </td></tr>
            </table></div>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>document-node(<em>SchemaElementTest</em>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                document {
                <font size="6">[</font><em>SchemaElementTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a> &amp;
                ( processing-instruction | comment ) *}
              
             </td></tr>
            </table></div>

            <p>A "processing-instruction()" SequenceType
            is normalized into the corresponding
            processing-instruction type.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>processing-instruction()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              processing-instruction
             </td></tr>
            </table></div>

            <p>The [XPath/XQuery] type system does not model the target of
            a processing-instruction, which is treated as a dynamic
            property. Therefore a
            "processing-instruction" SequenceType with a
            string or NCName parameter is normalized into an optional
            processing-instruction type.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>processing-instruction(<em>StringLiteral</em>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              processing-instruction?
             </td></tr>
            </table></div>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>processing-instruction(<em>NCName</em>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              processing-instruction?
             </td></tr>
            </table></div>

            <p>A "comment()" SequenceType is normalized
            into the corresponding comment type.</p>
        
            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>comment()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              comment
             </td></tr>
            </table></div>

            <p>A "text()" SequenceType is normalized into
            the corresponding text type.</p>
        
            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>text()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                text
              
             </td></tr>
            </table></div>

            <p>The "node()" SequenceType denotes any
            node. It is normalized into a choice between the
            corresponding wildcard types for each kind of node.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>node()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                (element * of type <code>xs:anyType</code> | attribute * of type
                <code>xs:anySimpleType</code> | text | document { (element * of
                type <code>xs:anyType</code> | text | comment |
                processing-instruction)* } | comment | processing-instruction)
              
             </td></tr>
            </table></div>

            <p>The "item()" SequenceType denotes any node
            or atomic value. It is normalized into a choice between
            the corresponding wildcard types for each kind of nodes or
            atomic values.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font>item()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                (element * of type <code>xs:anyType</code> | attribute * of type <code>xs:anySimpleType</code> | text | document { (element * of
                type <code>xs:anyType</code> | text | comment |
                processing-instruction)* } | comment |
                processing-instruction | <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a> )
              
             </td></tr>
            </table></div>

        </div></div><div class="div2">
<h3><a id="comments" name="comments"/>3.6 Comments</h3>
<h5><a id="N127FB" name="N127FB"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-Comment" name="doc-xquery-Comment"/>[<small>151 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Comment">Comment</a></code></td><td>   ::=   </td><td><code>"(:"  (<a href="#doc-xquery-CommentContents">CommentContents</a>  |  <a href="#doc-xquery-Comment">Comment</a>)*  ":)"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-CommentContents" name="doc-xquery-CommentContents"/>[<small>159 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CommentContents">CommentContents</a></code></td><td>   ::=   </td><td><code>(Char+ - (Char* ('(:' | ':)') Char*))</code></td></tr></tbody></table><p>Comments are lexical constructs only, and have no effect on the
    meaning of the query, and therefore do not have any formal
    semantics.</p></div></div><div class="div1">
<h2><a id="id-expressions" name="id-expressions"/>4 Expressions</h2><p>This section gives the semantics of all the [XPath/XQuery]
  expressions. The organization of this section parallels the
  organization of <a href="http://www.w3.org/TR/xquery#id-expressions">Section 
3 Expressions</a><sup><small>XQ</small></sup>.</p>
<h5><a id="N1282A" name="N1282A"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-Expr" name="doc-xquery-Expr"/>[<small>31 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Expr">Expr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xquery-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ExprSingle" name="doc-xquery-ExprSingle"/>[<small>32 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ExprSingle">ExprSingle</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-FLWORExpr">FLWORExpr</a><br/>|  <a href="#doc-xquery-QuantifiedExpr">QuantifiedExpr</a><br/>|  <a href="#doc-xquery-TypeswitchExpr">TypeswitchExpr</a><br/>|  <a href="#doc-xquery-IfExpr">IfExpr</a><br/>|  <a href="#doc-xquery-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-XPath" name="doc-xpath-XPath"/>[<small>1 (XPath)</small>]   </td><td><code><a href="http://www.w3.org/TR/xpath20/#prod-xpath-XPath">XPath</a></code></td><td>   ::=   </td><td><code>Expr</code></td></tr></tbody></table><p>For each expression, a short description and the relevant grammar
  productions are given. The semantics of an expression includes the
  normalization, static analysis, and dynamic evaluation
  phases. Recall that normalization rules translate [XPath/XQuery] syntax
  into Core syntax. In the sections that contain normalization rules,
  the Core grammar productions into which the expression is normalized
  are also provided. After normalization, sections on static type
  inference and dynamic evaluation define the static type and dynamic
  value for the Core expression.</p><p><b>Core Grammar</b></p>
    <p>The Core grammar productions for expressions are:</p>

    
<h5><a id="N12878" name="N12878"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-Expr" name="doc-core-Expr"/>[<small>30 (Core)</small>]   </td><td><code><a href="#prod-core-Expr">Expr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ExprSingle">ExprSingle</a>  (","  <a href="#doc-core-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ExprSingle" name="doc-core-ExprSingle"/>[<small>31 (Core)</small>]   </td><td><code><a href="#prod-core-ExprSingle">ExprSingle</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-FLWORExpr">FLWORExpr</a><br/>|  <a href="#doc-core-TypeswitchExpr">TypeswitchExpr</a><br/>|  <a href="#doc-core-IfExpr">IfExpr</a><br/>|  <a href="#doc-core-OrExpr">OrExpr</a></code></td></tr></tbody></table>
  <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
    <p>It is a static type error for any expression to have the empty
    type, except for the following expressions and functions:

    </p><ul><li><p>Empty parenthesis <code>()</code>, which denote the
      empty sequence.</p></li><li><p>The <code>fn:data</code> function and all functions in the
      <em>fs</em> namespace applied to empty
      parenthesis<code>()</code>.</p></li><li><p>Any function which returns the empty type.</p></li></ul><p>

    The reason for those exception is that they are typically part of
    the result of normalizing a larger user-level expression and are
    used to capture the semantics of the user-level expression when
    applied to the empty sequence.</p>

    <p>The rule below enforces the above constraints. It is a static
    type error, if the following conditions hold for a given
    expression <em>Expr</em>.</p>

      <div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		      <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
 	      
 	    </td></tr>
 	    <tr valign="middle" align="center"><td>
              <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <code>empty</code>
 	    </td></tr>
 	    <tr valign="middle" align="center"><td>
              <a href="#jd_not" class="judgment"><b>not</b></a>(<em>Expr</em> is empty
              parenthesis () or <code>fn:data</code> or any <em>fs</em>
              function applied to empty parenthesis ())
 	    </td></tr>
          </table></td></tr></table></td></tr>
 	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
              
               A static type error is raised for expression <em>Expr</em>
              
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
    	</table><br/>
      </div>

      <p>In general, static type errors are raised whenever there is
      no static type inference rules which can compute the type of a
      given expression. This is the reason for the absence of a formal
      post-condition in this rules. There is indeed a rule that infers
      the type for expression <em>Expr</em>, however the inferred type is
      empty and still a static type error must be raised.</p>

      <p><b>Example</b></p>
        <p>The above rule is useful in catching common mistakes, such
        as the misspelling of an element or attribute name or
        referencing of an element or attribute that does not
        exist. For instance, the following path expression</p>
<div class="exampleInner"><pre>  $x/title
</pre></div>
    <p>raises a static type error if the type of variable
    <code>$x</code> does not include any
    <code>title</code> children elements.</p>
  
  <div class="div2">
<h3><a id="id-primary-expressions" name="id-primary-expressions"/>4.1 Primary Expressions</h3><p><b>Primary expressions</b> are the basic primitives of
    the language. They include literals, variables, function calls,
    and the parenthesized expressions.</p>
<h5><a id="N1294B" name="N1294B"/>Primary Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-PrimaryExpr" name="doc-xquery-PrimaryExpr"/>[<small>84 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-PrimaryExpr">PrimaryExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-Literal">Literal</a>  |  <a href="#doc-xquery-VarRef">VarRef</a>  |  <a href="#doc-xquery-ParenthesizedExpr">ParenthesizedExpr</a>  |  <a href="#doc-xquery-ContextItemExpr">ContextItemExpr</a>  |  <a href="#doc-xquery-FunctionCall">FunctionCall</a>  |  <a href="#doc-xquery-OrderedExpr">OrderedExpr</a>  |  <a href="#doc-xquery-UnorderedExpr">UnorderedExpr</a>  |  <a href="#doc-xquery-Constructor">Constructor</a></code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The Core grammar production for primary expressions is:</p>
  
      
<h5><a id="N12989" name="N12989"/>Primary Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-PrimaryExpr" name="doc-core-PrimaryExpr"/>[<small>63 (Core)</small>]   </td><td><code><a href="#prod-core-PrimaryExpr">PrimaryExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-Literal">Literal</a>  |  <a href="#doc-core-VarRef">VarRef</a>  |  <a href="#doc-core-ParenthesizedExpr">ParenthesizedExpr</a>  |  <a href="#doc-core-FunctionCall">FunctionCall</a>  |  <a href="#doc-core-Constructor">Constructor</a></code></td></tr></tbody></table>
    <div class="div3">
<h4><a id="id-literals" name="id-literals"/>4.1.1 Literals</h4><p><b>Introduction</b></p>
        <p>A <b>literal</b> is a direct syntactic representation
        of an atomic value.  [XPath/XQuery] supports two kinds of literals:
        string literals and numeric literals.</p>
      
<h5><a id="N129BD" name="N129BD"/>Literals</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-Literal" name="doc-xquery-Literal"/>[<small>85 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Literal">Literal</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-NumericLiteral">NumericLiteral</a>  |  <a href="#doc-xquery-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-NumericLiteral" name="doc-xquery-NumericLiteral"/>[<small>86 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-NumericLiteral">NumericLiteral</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-IntegerLiteral">IntegerLiteral</a>  |  <a href="#doc-xquery-DecimalLiteral">DecimalLiteral</a>  |  <a href="#doc-xquery-DoubleLiteral">DoubleLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-IntegerLiteral" name="doc-xquery-IntegerLiteral"/>[<small>141 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-IntegerLiteral">IntegerLiteral</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DecimalLiteral" name="doc-xquery-DecimalLiteral"/>[<small>142 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DecimalLiteral">DecimalLiteral</a></code></td><td>   ::=   </td><td><code>("."  <a href="#doc-xquery-Digits">Digits</a>)  |  (<a href="#doc-xquery-Digits">Digits</a>  "."  [0-9]*)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DoubleLiteral" name="doc-xquery-DoubleLiteral"/>[<small>143 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DoubleLiteral">DoubleLiteral</a></code></td><td>   ::=   </td><td><code>(("."  <a href="#doc-xquery-Digits">Digits</a>)  |  (<a href="#doc-xquery-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#doc-xquery-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-StringLiteral" name="doc-xquery-StringLiteral"/>[<small>144 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-StringLiteral">StringLiteral</a></code></td><td>   ::=   </td><td><code>('"'  (<a href="#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</a>  |  CharRef  |  <a href="#doc-xquery-EscapeQuot">EscapeQuot</a>  |  [^"&amp;])*  '"')  |  ("'"  (<a href="#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</a>  |  CharRef  |  <a href="#doc-xquery-EscapeApos">EscapeApos</a>  |  [^'&amp;])*  "'")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-PredefinedEntityRef" name="doc-xquery-PredefinedEntityRef"/>[<small>145 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</a></code></td><td>   ::=   </td><td><code>"&amp;"  ("lt"  |  "gt"  |  "amp"  |  "quot"  |  "apos")  ";"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-Digits" name="doc-xquery-Digits"/>[<small>158 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Digits">Digits</a></code></td><td>   ::=   </td><td><code>[0-9]+</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
        <p>The Core grammar productions for literals are:</p>


<h5><a id="N12A5D" name="N12A5D"/>Literals</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-Literal" name="doc-core-Literal"/>[<small>64 (Core)</small>]   </td><td><code><a href="#prod-core-Literal">Literal</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-NumericLiteral">NumericLiteral</a>  |  <a href="#doc-core-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-NumericLiteral" name="doc-core-NumericLiteral"/>[<small>65 (Core)</small>]   </td><td><code><a href="#prod-core-NumericLiteral">NumericLiteral</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-IntegerLiteral">IntegerLiteral</a>  |  <a href="#doc-core-DecimalLiteral">DecimalLiteral</a>  |  <a href="#doc-core-DoubleLiteral">DoubleLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-IntegerLiteral" name="doc-core-IntegerLiteral"/>[<small>105 (Core)</small>]   </td><td><code><a href="#prod-core-IntegerLiteral">IntegerLiteral</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-DecimalLiteral" name="doc-core-DecimalLiteral"/>[<small>106 (Core)</small>]   </td><td><code><a href="#prod-core-DecimalLiteral">DecimalLiteral</a></code></td><td>   ::=   </td><td><code>("."  <a href="#doc-core-Digits">Digits</a>)  |  (<a href="#doc-core-Digits">Digits</a>  "."  [0-9]*)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-DoubleLiteral" name="doc-core-DoubleLiteral"/>[<small>107 (Core)</small>]   </td><td><code><a href="#prod-core-DoubleLiteral">DoubleLiteral</a></code></td><td>   ::=   </td><td><code>(("."  <a href="#doc-core-Digits">Digits</a>)  |  (<a href="#doc-core-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#doc-core-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-StringLiteral" name="doc-core-StringLiteral"/>[<small>108 (Core)</small>]   </td><td><code><a href="#prod-core-StringLiteral">StringLiteral</a></code></td><td>   ::=   </td><td><code>('"'  (<a href="#prod-core-EscapeQuot">EscapeQuot</a>  |  [^"])*  '"')  |  ("'"  (<a href="#prod-core-EscapeApos">EscapeApos</a>  |  [^'])*  "'")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-Digits" name="doc-core-Digits"/>[<small>119 (Core)</small>]   </td><td><code>Digits</code></td><td>   ::=   </td><td><code>[0-9]+</code></td></tr></tbody></table>
      <p><b>Notation</b></p>
         <p>To define the dynamic semantics of literals, we introduce
         the following auxiliary judgments.</p>

        <p id="jd_has_atomic_value">The judgment</p>
        <div align="center">
          
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
          <em>LiteralExpr</em> <a href="#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a> <a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>
          
        </div>

          <p>Holds if the literal expression <em>LiteralExpr</em>
          corresponds to the value <a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>. This judgment
          yields an atomic value, according to the rules described in
          <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a>. Notably, this judgment deals with
          handling of literal overflows for numeric literals, and
          handling of character references, and predefined entity
          references for string literals.</p>
      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>Literals are left unchanged through normalization.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
         <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          
           <font size="6">[</font><em>IntegerLiteral</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
         </td></tr>
         <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
            <em>IntegerLiteral</em>
          
         </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
         <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          
           <font size="6">[</font><em>DecimalLiteral</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
          
         </td></tr>
         <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
            <em>DecimalLiteral</em>
          
         </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
         <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          
           <font size="6">[</font><em>DoubleLiteral</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
         </td></tr>
         <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
            <em>DoubleLiteral</em>
          
         </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
         <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          
           <font size="6">[</font><em>StringLiteral</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
         </td></tr>
         <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
            <em>StringLiteral</em>
          
         </td></tr>
        </table></div>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>In the static semantics, the type of an integer literal is
        simply xs:integer:</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
			<em>IntegerLiteral</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> xs:integer
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>In the dynamic semantics, an integer literal is evaluated
        by constructing an atomic value in the data model, which
        consists of the literal value and its type:</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	      <tr valign="middle" align="center"><td>
 	        
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 	        <em>IntegerLiteral</em> <a href="#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a> <em>Integer</em>
 	        
 	        
 	      </td></tr>
 	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
			<em>IntegerLiteral</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <em>Integer</em>
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>
      <p>The formal definitions of decimal, double, and string
      literals are analogous to those for integer.</p><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		<em>DecimalLiteral</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> xs:decimal
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>  
	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	      <tr valign="middle" align="center"><td>
 	        
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 	        <em>DecimalLiteral</em> <a href="#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a> <em>Decimal</em>
 	        
 	        
 	      </td></tr>
 	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		<a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		<em>DecimalLiteral</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <em>Decimal</em>
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
        <em>DoubleLiteral</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> xs:double
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>
<p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	      <tr valign="middle" align="center"><td>
 	        
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 	        <em>DoubleLiteral</em> <a href="#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a> <em>Double</em>
 	        
 	        
 	      </td></tr>
 	    </table></td></tr></table></td></tr>
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
        <em>DoubleLiteral</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <em>Double</em>
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>
<p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
        <em>StringLiteral</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> xs:string
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>
<p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	      <tr valign="middle" align="center"><td>
 	        
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 	        <em>StringLiteral</em> <a href="#jd_has_atomic_value" class="judgment"><b>has atomic value</b></a> <em>String</em>
 	        
 	        
 	      </td></tr>
 	    </table></td></tr></table></td></tr>
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
        <em>StringLiteral</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <em>String</em>
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>
</div><div class="div3">
<h4><a id="id-variables" name="id-variables"/>4.1.2 Variable References</h4><p><b>Introduction</b></p>
      <p>A <b>variable</b> evaluates to the value to which the
      variable's QName is bound in the <b>dynamic
      context</b>.</p>
    
<h5><a id="N12D1B" name="N12D1B"/>Variable References</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-VarRef" name="doc-xquery-VarRef"/>[<small>87 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-VarRef">VarRef</a></code></td><td>   ::=   </td><td><code>"$"  <a href="#doc-xquery-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-VarName" name="doc-xquery-VarName"/>[<small>88 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-VarName">VarName</a></code></td><td>   ::=   </td><td><code>QName</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The Core grammar productions for variable references are:</p>
  
      
<h5><a id="N12D3B" name="N12D3B"/>Primary Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-VarRef" name="doc-core-VarRef"/>[<small>66 (Core)</small>]   </td><td><code><a href="#prod-core-VarRef">VarRef</a></code></td><td>   ::=   </td><td><code>"$"  <a href="#doc-core-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-VarName" name="doc-core-VarName"/>[<small>67 (Core)</small>]   </td><td><code><a href="#prod-core-VarName">VarName</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Variable references are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><a href="#prod-core-VarRef"><em>VarRef</em></a><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <a href="#prod-core-VarRef"><em>VarRef</em></a>
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>In the static semantics, the type of a variable is simply its
      type in the static environment <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>:</p>

      <div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
 	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 	      <em>VarName</em> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
 	      
 	      
 	    </td></tr>
 	    <tr valign="middle" align="center"><td>
 	      
 	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) =
 	      <a href="#doc-fs-Type"><em>Type</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
 	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		      $ <em>VarName</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
    	</table><br/>
      </div>

      <p>If the variable is not bound in the static environment, a
      static type error is raised.</p>
    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>In the dynamic semantics, a locally declared variable is
      evaluated by "looking up" its value in <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>:</p>
    
      <div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
 	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 	      <em>VarName</em> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
 	      
 	      
 	    </td></tr>
 	    <tr valign="middle" align="center"><td>
 	      
 		<a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = <a href="#doc-fs-Value"><em>Value</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
 	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 		      $ <em>VarName</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
    	</table><br/>
      </div>

      <p>In the dynamic semantics, a reference to a variable imported
      from a module is evaluated by accessing the dynamic context of
      the module in which the variable is declared.</p>

      <div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
 	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 	      <em>VarName</em> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
 	      
 	    </td></tr>
 	    <tr valign="middle" align="center"><td>
 	      
 		<a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = <code>#IMPORTED</code>(<em>URI</em>)
 	      
 	    </td></tr>
 	    <tr valign="middle" align="center"><td>
 	      
 	      <em>URI</em> <a href="#jd_module_dynEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
 	      
 	    </td></tr>
 	    <tr valign="middle" align="center"><td>
 	      
 		<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>.<a href="#xq_val_env" class="env">varValue</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = <a href="#doc-fs-Value"><em>Value</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
 	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 		      $ <em>VarName</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
    	</table><br/>
      </div>
    </div><div class="div3">
<h4><a id="id-paren-expressions" name="id-paren-expressions"/>4.1.3 Parenthesized Expressions</h4>
<h5><a id="N12EF4" name="N12EF4"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ParenthesizedExpr" name="doc-xquery-ParenthesizedExpr"/>[<small>89 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>   ::=   </td><td><code>"("  <a href="#doc-xquery-Expr">Expr</a>?  ")"</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The Core grammar production for parenthesized expressions is:</p>

      
<h5><a id="N12F09" name="N12F09"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-ParenthesizedExpr" name="doc-core-ParenthesizedExpr"/>[<small>68 (Core)</small>]   </td><td><code><a href="#prod-core-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>   ::=   </td><td><code>"("  <a href="#doc-core-Expr">Expr</a>?  ")"</code></td></tr></tbody></table>
    <p>Empty parenthesis <code>()</code> always have the empty
    type. Remember that it is a static type error for most expressions
    other than <code>()</code> to have the empty type (see <a href="#id-expressions"><b>[4 Expressions]</b></a> for the complete rule.)</p><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
 	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		      () <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
    	</table><br/>
      </div>

      <div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
 	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 	      <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
 	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		      ( <em>Expr</em> ) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
    	</table><br/>
      </div>
    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>Empty parenthesis <code>()</code> evaluate to the empty
      sequence.</p>

      <div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
 	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 		      () <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> ()
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
    	</table><br/>
      </div>

      <div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
 	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 	      <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
 	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 		      ( <em>Expr</em> ) <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
 	      
 	    </td></tr>
 	  </table></td></tr></table></td></tr>
    	</table><br/>
      </div>
    </div><div class="div3">
<h4><a id="id-context-item-expression" name="id-context-item-expression"/>4.1.4 Context Item Expression</h4>
<h5><a id="N12FF1" name="N12FF1"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ContextItemExpr" name="doc-xquery-ContextItemExpr"/>[<small>90 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ContextItemExpr">ContextItemExpr</a></code></td><td>   ::=   </td><td><code>"."</code></td></tr></tbody></table><p><b>Introduction</b></p>
             <p>A <b>context item expression</b> evaluates to
             the context item, which may be either a node or an atomic
             value.</p>
           <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
           <p>A context item expression is normalized to the built-in
           variable <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>. Because it can only be bound through the
           external context or a path expression, there is no need for
           a specific typing rule to enforce that its value is a
           singleton item.</p>

           <div align="center"><table cellpadding="0" cellspacing="0" summary="">
            <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              <font size="6">[</font>.<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            </td></tr>
            <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
            </td></tr>
           </table></div>
         </div><div class="div3">
<h4><a id="id-function-calls" name="id-function-calls"/>4.1.5 Function Calls</h4><p><b>Introduction</b></p>
      <p>A function call consists of a QName followed by a
      parenthesized list of zero or more expressions.  In [XPath/XQuery],
      the actual argument to a function is called an
      <b>argument</b> and the formal argument of a function is
      called a <b>parameter</b>.  We use the same terminology
      here. </p>
      
      
<h5><a id="N1303C" name="N1303C"/>Function Calls</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-FunctionCall" name="doc-xquery-FunctionCall"/>[<small>93 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-FunctionCall">FunctionCall</a></code></td><td>   ::=   </td><td><code>QName  "("  (<a href="#doc-xquery-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xquery-ExprSingle">ExprSingle</a>)*)?  ")"</code></td></tr></tbody></table>

      <p>Because [XPath/XQuery] implicitly converts the values of function
      arguments, a normalization step is required.</p>
    <p><b>Core Grammar</b></p>
      <p>The Core grammar production for function calls is:</p>

      
<h5><a id="N13061" name="N13061"/>Function Calls</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-FunctionCall" name="doc-core-FunctionCall"/>[<small>71 (Core)</small>]   </td><td><code><a href="#prod-core-FunctionCall">FunctionCall</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a>  "("  (<a href="#doc-core-ExprSingle">ExprSingle</a>  (","  <a href="#doc-core-ExprSingle">ExprSingle</a>)*)?  ")"</code></td></tr></tbody></table>
    <p><b>Notation</b></p>
      <p id="jd_map_function_argument">Normalization of function calls
      uses an auxiliary mapping <font size="6">[</font><font size="6">]</font><a href="#jd_map_function_argument" class="judgment"><sub><font size="2">FunctionArgument(SequenceType)</font></sub></a>
      used to insert conversions of function arguments that depend
      only on the expected SequenceType of the corresponding
      parameters. It is defined as follows:</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_function_argument" class="judgment"><sub><font size="2">FunctionArgument(SequenceType)</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font><font size="6">[</font><font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a><font size="6">]</font><a href="#jd_map_function_argument" class="judgment"><sub><font size="2">AtomizeAtomic(SequenceType)</font></sub></a><font size="6">]</font><a href="#jd_map_function_argument" class="judgment"><sub><font size="2">Convert(SequenceType)</font></sub></a>
       </td></tr>
      </table></div>

      <p>where</p>

        <ul><li><p><font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_function_argument" class="judgment"><sub><font size="2">AtomizeAtomic(SequenceType)</font></sub></a> denotes</p><table><tbody><tr><td><code>fn:data</code>(<em>Expr</em>)</td><td>  </td><td>If
                  <font size="6">[</font><em>SequenceType</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                  <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>*</td></tr><tr><td><em>Expr</em></td><td>  </td><td>Otherwise</td></tr></tbody></table><p>which specifies that if the function expects atomic
            parameters, then <code>fn:data</code> is called to obtain them.</p></li><li><p><font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_function_argument" class="judgment"><sub><font size="2">Convert(SequenceType)</font></sub></a> denotes</p><table><tbody><tr><td><a href="#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a>(<em>Expr</em>,<em>PrototypicalValue</em>)</td><td>If
                  <font size="6">[</font><em>SequenceType</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                  <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>*</td></tr><tr><td><em>Expr</em></td><td>Otherwise</td></tr></tbody></table><p>where <em>PrototypicalValue</em> is a built-in atomic
          value used to encode the expected atomic type (for instance
          the value <code>1.0</code> if the expected type is
          <code>xs:decimal</code>). A value is used here since [XPath/XQuery]
          expressions cannot operate directly on types. Which value is
          chosen does not have any impact on the actual semantics,
          only its actual atomic type matters.</p></li></ul>

    <p><b>Note</b></p>
        <p>The <a href="#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a> function takes a 
        <em>PrototypicalValue</em>, which is a value of the target
        type, to ensure that conversion to base types is possible
        even though types are not first class objects in
        [XPath/XQuery].</p>
      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>Each argument expression in a function call is normalized
        to its corresponding Core expression by applying
        <font size="6">[</font><font size="6">]</font><a href="#jd_map_function_argument" class="judgment"><sub><font size="2">FunctionArgument(SequenceType)</font></sub></a> for each argument with
        the expected <em>SequenceType</em> for the argument inserted.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
                <em>QName</em> (<em>Expr</em><sub><font size="2">1</font></sub>, ..., <em>Expr</em><sub><font size="2">n</font></sub>)
              <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <em>QName</em>
              ( <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_function_argument" class="judgment"><sub><font size="2">FunctionArgument(SequenceType1)</font></sub></a>, ...,
                <font size="6">[</font><em>Expr</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_function_argument" class="judgment"><sub><font size="2">FunctionArgument(SequenceTypen)</font></sub></a> )
            
          </td></tr>
        </table></div>

        <p>Note that this normalization rule depends on the function
        signatures, which is used to get the types of the function
        parameters (<em>SequenceType</em><sub><font size="2">1</font></sub>,...,<em>SequenceType</em><sub><font size="2">n</font></sub>). For
        user-defined functions, the function signature can be obtained
        from the XQuery prolog where the function is declared.  For
        built-in functions, the signature is given in the
        <a href="#xpath-functions">[Functions and Operators]</a> document. For overloaded built-in functions,
        several signatures may exists, however, because they all
        correspond to sequences of atomic values, they all result in
        the same normalization.</p>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>Different sets of static typing rules are used to type
        check function calls depending on which of the following
        categories the belong to: overloaded internal functions,
        built-in functions with a specific typing rule, and other
        built-in and user-defined functions.</p>

        <p>The following rule is common to all those categories, and
        is used to bootstrap type inference, by first looking-up the
        expanded QName for the function, then applying the appropriate
        set of inference rule depending on the category in which the
        function is.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>QName</em>
                  <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b> 
                  
                    <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                  
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    ...
                  
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b> 
                  
                    <em>Expr</em><sub><font size="2">n</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
                  
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                    <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                  
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                    <em>QName</em> (<em>Expr</em><sub><font size="2">1</font></sub>,...,<em>Expr</em><sub><font size="2">n</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                  
                
              </td></tr>
            </table></td></tr></table></td></tr>
          </table><br/>
        </div>

        <p>The following depends on the kind of function call.</p>

        <ol class="enumar"><li><p>If the expanded QName for the function corresponds to
            one of the overloaded internal <em>fs:</em> functions
            listed in <a href="#sec_operators"><b>[B.2 Mapping of Overloaded Internal Functions]</b></a>, the rules in
            <a href="#sec_operators"><b>[B.2 Mapping of Overloaded Internal Functions]</b></a> are applied.</p></li><li><p>If the expanded QName for the function corresponds to
            one of the built-in functions with a specialized typing
            rule, listed in <a href="#sec_special_functions"><b>[7 Additional Semantics of Functions]</b></a>,
            the rules in <a href="#sec_special_functions"><b>[7 Additional Semantics of Functions]</b></a> are
            applied.</p></li><li><p>Otherwise, the following general rule is
          applied.</p></li></ol>

        <p>The rule looks up the function in the static environment
        and checks that some signature for the function satisfies the
        following constraint: the type of each actual argument is a
        subtype of some type that can be promoted to the type of the
        corresponding function parameter.  In this case, the function
        call is well typed and the result type is the return type
        specified in the function's signature. </p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>,n) =
                    declare function <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>', ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>') as <a href="#doc-fs-Type"><em>Type</em></a>'
                  
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>'
              </td></tr>
              <tr valign="middle" align="center"><td>
                ...
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>'
              </td></tr>

            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                    <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>'
                  
                
              </td></tr>
            </table></td></tr></table></td></tr>
          </table><br/>
        </div>

        <p>The function body itself is not analyzed for each
        invocation: static typing of the function definition itself
        guarantees that the function body always returns a value of
        the declared return type.</p>

        <p>Notice that the static context contains at most one
        function declaration for each function. This is possible since
        the treatment of overloaded operators is done through a set of
        specific rules which do not require access to the
        environment. See <a href="#sec_operators"><b>[B.2 Mapping of Overloaded Internal Functions]</b></a>.</p>
      <p><b>Notation</b></p>
        <p id="jd_function_with_types">The following auxiliary
        judgment</p>

        <div align="center">
         
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
          
           <a href="#jd_function_with_types" class="judgment"><b>function</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           <a href="#jd_function_with_types" class="judgment"><b>with types</b></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>on values</b></a>
           (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
          
         
        </div>

        <p>holds when applying the function with expanded QName
        <a href="#id-expanded-qnames"><em>expanded-QName</em></a>, and parameters of type (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
        on the values (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>) yields the value
        <a href="#doc-fs-Value"><em>Value</em></a>.</p>

        <p>That judgment is defined below for each kind of function
        (user-defined, built-in, external, and imported
        functions).</p>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>The following rule applies to all the different kinds of
        functions using the previously defined judgment.</p>

    <div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
          <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        ...
       </td></tr>
       <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
          <em>Expr</em><sub><font size="2">n</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         <em>QName</em> <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = <em>FunctionSig</em>
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         
          <em>FunctionSig</em>
          =
          declare function <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>) as <a href="#doc-fs-Type"><em>Type</em></a>
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_promotes_to" class="judgment"><b>against</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>'
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        ...
       </td></tr>
       <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub> <a href="#jd_promotes_to" class="judgment"><b>against</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> <a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>'
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
           <a href="#jd_function_with_types" class="judgment"><b>function</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           <a href="#jd_function_with_types" class="judgment"><b>with types</b></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>on values</b></a>
           (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>',...,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>')
           <a href="#jd_function_with_types" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_promotes_to" class="judgment"><b>against</b></a> <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a> <a href="#doc-fs-Value"><em>Value</em></a>'
        
       </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
         
          <em>QName</em> ( <em>Expr</em><sub><font size="2">1</font></sub>, ...,  <em>Expr</em><sub><font size="2">n</font></sub> ) <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>'
         
        
       </td></tr>
      </table></td></tr></table></td></tr>
     </table><br/>
    </div>

    <p>First the function name is expanded, and the expanded name is
    used to retrieve the function signature from the static
    environment. Then, the rule evaluates each function argument
    expression, and the resulting values are promoted according to the
    expected type for the function. The result of evaluating the
    function is obtained through the auxiliary judgment previously
    defined, and the resulting value is promoted according to the
    expected return type.</p>

    <p>In case the function is a user defined function in a main
    module, the expression body is retrieved from the dynamic
    environment and used to compute the value of the function. The
    rule extends <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a> by binding each formal variable to its
    corresponding value, and evaluates the body of the function in the
    new environment. The resulting value is the value of the function
    call.</p>

    <div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        
         
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>))
          =
          (<em>Expr</em>, <em>Variable</em><sub><font size="2">1</font></sub>, ... , <em>Variable</em><sub><font size="2">n</font></sub>)
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
 	
 	 #MAIN <a href="#jd_module_dynEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
 	
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> + <a href="#xq_val_env" class="env">varValue</a>(
            <em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>;
            ...;
            <em>Variable</em><sub><font size="2">n</font></sub> =&gt; <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>) 
         <b> |- </b>
         <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a> 
        
       </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
           <a href="#jd_function_with_types" class="judgment"><b>function</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           <a href="#jd_function_with_types" class="judgment"><b>with types</b></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>on values</b></a>
           (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
         
        
       </td></tr>
      </table></td></tr></table></td></tr>
     </table><br/>
    </div>

    <p>Note that the function body is evaluated in the dynamic
    environment containing the main module declarations.</p>

    <p>The rule for evaluating an function imported from a module is
    similar to that for evaluating a user-defined function in a main
    module, except that the function call is evaluated in the dynamic
    context of the module in which it is declared, and that the
    appropriate additional type matching must be performed.</p>

    <div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        
         
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>))
          = <code>#IMPORTED</code>(<em>URI</em>)
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
 	
 	 <em>URI</em> <a href="#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
 	
       </td></tr>
       <tr valign="middle" align="center"><td>
 	
 	 <em>URI</em> <a href="#jd_module_dynEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
 	
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a><sub><font size="2">1</font></sub>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = <em>FunctionSig</em>'
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         
          <em>FunctionSig</em>'
          =
          declare function <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>', ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>') as <a href="#doc-fs-Type"><em>Type</em></a>'
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>'
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        ...
       </td></tr>
       <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>'
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>', ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>'))
          =
          (<em>Expr</em>, <em>Variable</em><sub><font size="2">1</font></sub>, ... , <em>Variable</em><sub><font size="2">n</font></sub>)
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> + <a href="#xq_val_env" class="env">varValue</a>(
            <em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>;
            ...;
            <em>Variable</em><sub><font size="2">n</font></sub> =&gt; <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>) 
         <b> |- </b>
         <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a> 
        
       </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
           <a href="#jd_function_with_types" class="judgment"><b>function</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           <a href="#jd_function_with_types" class="judgment"><b>with types</b></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>on values</b></a>
           (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
         
        
       </td></tr>
      </table></td></tr></table></td></tr>
     </table><br/>
    </div>

    <p>If the function is a built-in function (resp. special formal
    semantics function), the value returned by the function is the one
    specified in <a href="#xpath-functions">[Functions and Operators]</a> (resp. <a href="#sec_special_functions"><b>[7 Additional Semantics of Functions]</b></a>).</p>

    <div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        
         
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>))
          = <code>#BUILT-IN</code>
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         
           The built-in function <a href="#id-expanded-qnames"><em>expanded-QName</em></a> (See <a href="#xpath-functions">[Functions and Operators]</a> or
           <a href="#sec_special_functions"><b>[7 Additional Semantics of Functions]</b></a>) applied to values
           (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>) yields the value <a href="#doc-fs-Value"><em>Value</em></a>
          
        
       </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
           <a href="#jd_function_with_types" class="judgment"><b>function</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           <a href="#jd_function_with_types" class="judgment"><b>with types</b></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>on values</b></a>
           (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
         
        
       </td></tr>
      </table></td></tr></table></td></tr>
     </table><br/>
    </div>

    <p>If the function is an external function, the value returned by
    the function is implementation-defined.</p>

    <div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        
         
          <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>))
          = <code>#EXTERNAL</code>
         
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         
           The external function <a href="#id-expanded-qnames"><em>expanded-QName</em></a> applied to values
           (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>) yields the value <a href="#doc-fs-Value"><em>Value</em></a>
          
        
       </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
           <a href="#jd_function_with_types" class="judgment"><b>function</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           <a href="#jd_function_with_types" class="judgment"><b>with types</b></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>on values</b></a>
           (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>)
           <a href="#jd_function_with_types" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
         
        
       </td></tr>
      </table></td></tr></table></td></tr>
     </table><br/>
    </div>
   </div></div><div class="div2">
<h3><a id="id-path-expressions" name="id-path-expressions"/>4.2 Path Expressions</h3><p><b>Introduction</b></p>
      <p>Path expressions are used to locate nodes within a
      tree. There are two kinds of path expressions, absolute path
      expressions and relative path expressions. An absolute path
      expression is a rooted relative path expression. A relative path
      expression is composed of a sequence of steps.</p>
  
      
<h5><a id="N139BD" name="N139BD"/>Path Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-PathExpr" name="doc-xquery-PathExpr"/>[<small>68 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-PathExpr">PathExpr</a></code></td><td>   ::=   </td><td><code>("/"  <a href="#doc-xquery-RelativePathExpr">RelativePathExpr</a>?)<br/>|  ("//"  <a href="#doc-xquery-RelativePathExpr">RelativePathExpr</a>)<br/>|  <a href="#doc-xquery-RelativePathExpr">RelativePathExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-RelativePathExpr" name="doc-xquery-RelativePathExpr"/>[<small>69 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-RelativePathExpr">RelativePathExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-StepExpr">StepExpr</a>  (("/"  |  "//")  <a href="#doc-xquery-StepExpr">StepExpr</a>)*</code></td></tr></tbody></table>

    <p><b>Core Grammar</b></p>
      <p>PathExpr and RelativePathExpr are fully normalized, therefore
      they have no corresponding productions in the Core. The grammar
      for path expressions in the Core starts with the StepExpr
      production.</p>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Absolute path expressions are path expressions starting with
      the <code>/</code> or <code>//</code> symbols, indicating that
      the expression must be applied on the root node in the current
      context.  The root node in the current context is the greatest
      ancestor of the context node. The following two rules normalize
      absolute path expressions to relative ones. They use the
      <code>fn:root</code> function, which returns the greatest ancestor of its
      argument node. The treat expressions guarantee that the value
      bound to the context variable <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> is a document node.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font>/<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         (<code>fn:root</code>(self::node()) treat as document-node())
       </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font>/ <em>RelativePathExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font>((<code>fn:root</code>(self::node())) treat as document-node()) /
         <em>RelativePathExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font>// <em>RelativePathExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font>((<code>fn:root</code>(self::node())) treat as document-node) /
         <code>descendant-or-self::node()</code> /
         <em>RelativePathExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font> <em>StepExpr</em> // <em>RelativePathExpr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
           <font size="6">[</font><em>StepExpr</em> / descendant-or-self::node() / <em>RelativePathExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
        </td></tr>
      </table></div>

      <p>A composite relative path expression (using <code>/</code>)
      is normalized into a <code>for</code> expression by
      concatenating the sequences obtained by mapping each node of the
      left-hand side in document order to the sequence it generates on
      the right-hand side.  The call to the <a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>
      function ensures that the result is in document order without
      duplicates.  The dynamic context is defined by binding the
      <code>$</code><em>fs:</em><code>dot</code>,
      <code>$</code><em>fs:</em><code>sequence</code>,
      <code>$</code><em>fs:</em><code>position</code> and
      <code>$</code><em>fs:</em><code>last</code> variables.</p>

      <p>Note that sorting by document order enforces the restriction
      that input and output sequences contains only nodes, and that
      the last step in a path expression may actually return atomic
      values.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font><em>StepExpr</em> / <em>RelativePathExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <table><tbody><tr><td><a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a> (</td></tr><tr><td><a href="#sec_distinct_docorder_or_atomic_sequence"><em>fs:</em><code>distinct-doc-order-or-atomic-sequence</code></a> (</td></tr><tr><td>  let <code>$</code><em>fs:</em><code>sequence</code> as node()* := <font size="6">[</font><em>StepExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>   return</td></tr><tr><td>  let <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a> := fn:count(<code>$</code><em>fs:</em><code>sequence</code>)   return</td></tr><tr><td>  for <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> at <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a> in <code>$</code><em>fs:</em><code>sequence</code> return</td></tr><tr><td>    <font size="6">[</font><em>RelativePathExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a></td></tr><tr><td>))</td></tr></tbody></table>
        
       </td></tr>
      </table></div>

    <div class="div3">
<h4><a id="id-axis-steps" name="id-axis-steps"/>4.2.1 Steps</h4><p>Note that this section uses some auxiliary judgments which
      are defined in <a href="#sec_auxiliary_xpath"><b>[8.2 Judgments for step expressions and filtering]</b></a>.</p><p><b>Introduction</b></p>
        
<h5><a id="N13B58" name="N13B58"/>Steps</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-StepExpr" name="doc-xquery-StepExpr"/>[<small>70 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-StepExpr">StepExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-FilterExpr">FilterExpr</a>  |  <a href="#doc-xquery-AxisStep">AxisStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AxisStep" name="doc-xquery-AxisStep"/>[<small>71 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AxisStep">AxisStep</a></code></td><td>   ::=   </td><td><code>(<a href="#doc-xquery-ReverseStep">ReverseStep</a>  |  <a href="#doc-xquery-ForwardStep">ForwardStep</a>)  <a href="#doc-xquery-PredicateList">PredicateList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ForwardStep" name="doc-xquery-ForwardStep"/>[<small>72 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ForwardStep">ForwardStep</a></code></td><td>   ::=   </td><td><code>(<a href="#doc-xquery-ForwardAxis">ForwardAxis</a>  <a href="#doc-xquery-NodeTest">NodeTest</a>)  |  <a href="#doc-xquery-AbbrevForwardStep">AbbrevForwardStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ReverseStep" name="doc-xquery-ReverseStep"/>[<small>75 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ReverseStep">ReverseStep</a></code></td><td>   ::=   </td><td><code>(<a href="#doc-xquery-ReverseAxis">ReverseAxis</a>  <a href="#doc-xquery-NodeTest">NodeTest</a>)  |  <a href="#doc-xquery-AbbrevReverseStep">AbbrevReverseStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-PredicateList" name="doc-xquery-PredicateList"/>[<small>82 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-PredicateList">PredicateList</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-Predicate">Predicate</a>*</code></td></tr></tbody></table>
      <p><b>Core Grammar</b></p>
        <p>The Core grammar productions for XPath steps are:</p>
    
        
<h5><a id="N13BC7" name="N13BC7"/>Steps</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-StepExpr" name="doc-core-StepExpr"/>[<small>54 (Core)</small>]   </td><td><code><a href="#prod-core-StepExpr">StepExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-PrimaryExpr">PrimaryExpr</a>  |  <a href="#doc-core-AxisStep">AxisStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-AxisStep" name="doc-core-AxisStep"/>[<small>55 (Core)</small>]   </td><td><code><a href="#prod-core-AxisStep">AxisStep</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ReverseStep">ReverseStep</a>  |  <a href="#doc-core-ForwardStep">ForwardStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ForwardStep" name="doc-core-ForwardStep"/>[<small>56 (Core)</small>]   </td><td><code><a href="#prod-core-ForwardStep">ForwardStep</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ForwardAxis">ForwardAxis</a>  <a href="#doc-core-NodeTest">NodeTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ReverseStep" name="doc-core-ReverseStep"/>[<small>58 (Core)</small>]   </td><td><code><a href="#prod-core-ReverseStep">ReverseStep</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ReverseAxis">ReverseAxis</a>  <a href="#doc-core-NodeTest">NodeTest</a></code></td></tr></tbody></table>
      <p><b>Note</b></p>
        <p>Step expressions can be followed by
        predicates. Normalization of predicates uses the following
        auxiliary mapping rule: <font size="6">[</font><font size="6">]</font><a href="#jd_map_predicates" class="judgment"><sub><font size="2">Predicates</font></sub></a>, which
        is specified in <a href="#id-predicates"><b>[4.2.2 Predicates]</b></a>. Normalization
        for step expressions also uses the following auxiliary mapping
        rule: <font size="6">[</font><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>, which is specified in <a href="#sec_axes"><b>[4.2.1.1 Axes]</b></a>.</p>
      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>Normalization of predicates need to distinguish between
        forward steps, reverse steps, and primary expressions.</p>
  
        <p>As explained in the [XPath/XQuery] document, applying a step in
        XPath changes the focus (or context). The change of focus is
        made explicit by the normalization rule below, which binds the
        variable <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> to the node currently being processed, and
        the variable <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a> to the position (i.e., the position
        within the input sequence) of that node.</p>

        <p>There are two sets of normalization rules for Predicates.
        The first set of rules apply when the predicate is a numeric
        literal or the expression <code>last()</code>.  The second set
        of rules apply to all predicate expressions other than numeric
        literals and the expression <code>last()</code>.  In the first
        case, the normalization rules provides a more precise static
        type than if the general rules were applied.</p>

        <p>When the predicate expression is a numeric literal or the
        <code>fn:last</code> function, the following normalization rules
        apply.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>ForwardStep</em> <em>PredicateList</em> [
            <em>NumericLiteral</em> ]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <table><tbody><tr><td>let <code>$</code><em>fs:</em><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>( <font size="6">[</font><em>ForwardStep</em>
                <em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> )) return</td></tr><tr><td><code>fn:subsequence</code>(<code>$</code><em>fs:</em><code>sequence</code>,<em>NumericLiteral</em>,1)</td></tr></tbody></table>
            
          </td></tr>
        </table></div>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>ForwardStep</em> <em>PredicateList</em> [
            <code>fn:last</code>() ]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <table><tbody><tr><td>let <code>$</code><em>fs:</em><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>( <font size="6">[</font><em>ForwardStep</em>
                <em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> )) return</td></tr><tr><td>let <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a> := <code>fn:count</code>(<code>$</code><em>fs:</em><code>sequence</code>) return</td></tr><tr><td><code>fn:subsequence</code>(<code>$</code><em>fs:</em><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>,1)</td></tr></tbody></table>
            
          </td></tr>
        </table></div>
  
        <p>When predicates are applied on a reverse step, the position
        variable is bound in reverse document order. </p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>ReverseStep</em> <em>PredicateList</em> [
            <em>NumericLiteral</em> ]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
             <table><tbody><tr><td>let <code>$</code><em>fs:</em><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>( <font size="6">[</font><em>ReverseStep</em> <em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> )) return</td></tr><tr><td>let <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a> := fn:count(<code>$</code><em>fs:</em><code>sequence</code>) return</td></tr><tr><td>let <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a> := <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a> - <em>NumericLiteral</em> + 1 return</td></tr><tr><td>   then <code>fn:subsequence</code>(<code>$</code><em>fs:</em><code>sequence</code>,<a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>,1)</td></tr></tbody></table>
           
          </td></tr>
        </table></div>

        <p>When the step is a reverse axis, then the last item in the
        context sequence is the first in document order.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>ReverseStep</em> <em>PredicateList</em> [
            <code>fn:last</code>() ]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
             <table><tbody><tr><td>let <code>$</code><em>fs:</em><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>( <font size="6">[</font><em>ReverseStep</em> <em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> )) return</td></tr><tr><td>   then <code>fn:subsequence</code>(<code>$</code><em>fs:</em><code>sequence</code>,1,1)</td></tr></tbody></table>
           
          </td></tr>
        </table></div>
  
        <p>The normalization rules above all use the function
        <code>fn:subsequence</code> to select a particular item.  The static
        typing rules for this function are defined in <a href="#sec_fn_subsequence"><b>[7.2.13 The fn:subsequence function]</b></a>.</p>
  
        <p>When predicates are applied on a forward step, the input
        sequence is first sorted in document order and duplicates are
        removed. The context is changed by binding the <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
        variable to each node in document order.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>ForwardStep</em> <em>PredicateList</em> [
            <em>Expr</em> ]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <table><tbody><tr><td>let <code>$</code><em>fs:</em><code>sequence</code> :=
                <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>( <font size="6">[</font><em>ForwardStep</em>
                <em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> )) return</td></tr><tr><td>let <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a> := fn:count(<code>$</code><em>fs:</em><code>sequence</code>) return</td></tr><tr><td>for <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> at <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a> in <code>$</code><em>fs:</em><code>sequence</code> return</td></tr><tr><td>   if <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_predicates" class="judgment"><sub><font size="2">Predicates</font></sub></a> then <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> else ()</td></tr></tbody></table>
            
          </td></tr>
        </table></div>
  
        <p>When predicates are applied on a reverse step, the input
        sequence is first sorted in document order and duplicates are
        removed. The context is changed by binding the <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>
        variable to each node in document order. </p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>ReverseStep</em> <em>PredicateList</em> [
            <em>Expr</em> ]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
             <table><tbody><tr><td>let <code>$</code><em>fs:</em><code>sequence</code> := <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>(
               <font size="6">[</font><em>ReverseStep</em> <em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> )) return</td></tr><tr><td>let <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a> := fn:count(<code>$</code><em>fs:</em><code>sequence</code>) return</td></tr><tr><td>for <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> at $<em>fs:</em>new in <code>$</code><em>fs:</em><code>sequence</code> return</td></tr><tr><td>let <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a> := <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a> - $<em>fs:</em>new + 1 return </td></tr><tr><td>  if <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_predicates" class="judgment"><sub><font size="2">Predicates</font></sub></a>
                            then <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> else ()</td></tr></tbody></table>
           
          </td></tr>
        </table></div>
  

        <p>Finally, a stand-alone forward or reverse step is
        normalized by the auxiliary normalization rule for <em>Axis</em>.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>ForwardStep</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<font size="6">[</font><em>ForwardStep</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>)
          </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>ReverseStep</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<font size="6">[</font><em>ReverseStep</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>)
          </td></tr>
        </table></div>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static semantics of an <em>Axis</em> <em>NodeTest</em> pair is
        obtained by retrieving the type of the context node, and
        applying the two filters (the <em>Axis</em>, and then the
        <em>NodeTest</em> with a <em>PrincipalNodeKind</em>) on the
        result.</p>

        <div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a>(<a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>) = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
            
           </td></tr>
           <tr valign="middle" align="center"><td>
            
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <font size="6">[</font>node()<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
            
           </td></tr>
           <tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_axis_type" class="judgment"><b>:</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             
            
           </td></tr>
           <tr valign="middle" align="center"><td>
            
             <em>Axis</em> <a href="#jd_principal" class="judgment"><b>principal</b></a> <em>PrincipalNodeKind</em>
            
           </td></tr>
           <tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
             
            
           </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <em>Axis</em> <em>NodeTest</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
            
           
          </td></tr>
         </table><br/>
        </div>

        <p><b>Note</b></p>
          <p>Note that the second judgment in the inference rule
          requires that the context item be a node, guaranteeing that
          a type error is raised when the context item is an atomic
          value.</p>
        
      
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>The dynamic semantics of an <em>Axis</em> <em>NodeTest</em> pair is
        obtained by retrieving the context node, and applying the two
        filters (<em>Axis</em>, then <em>NodeTest</em>) on the result. The
        application of each filter is expressed through the filter
        judgment as follows.</p>
      
        <div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_dyn_env_def" class="env">dynEnv</a>.<a href="#xq_val_env" class="env">varValue</a>(<a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a>) = <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
            
           </td></tr>
           <tr valign="middle" align="center"><td>
            
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> node
            
           </td></tr>
           <tr valign="middle" align="center"><td>
            <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
             
              <a href="#jd_axis" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
              <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
            
           </td></tr>
           <tr valign="middle" align="center"><td>
            
             <em>Axis</em> <a href="#jd_principal" class="judgment"><b>principal</b></a> <em>PrincipalNodeKind</em>
            
           </td></tr>
           <tr valign="middle" align="center"><td>
            <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
             
              <a href="#jd_test" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
              <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_test" class="judgment"><b>=&gt;</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
            
           </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            
             <em>Axis</em> <em>NodeTest</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a>(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>)
            
           
          </td></tr>
         </table><br/>
        </div>
      
        <p><b>Note</b></p>
          <p>Note that the second judgment in the inference rule
          guarantees that the context item is bound to a node.</p>
        
      
      <div class="div4">
<h5><a id="sec_axes" name="sec_axes"/>4.2.1.1 Axes</h5><p><b>Introduction</b></p>
          <p>The XQuery grammar for forward and reverse axis is as
          follows.</p>

          
<h5><a id="N141BE" name="N141BE"/>Axes</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ForwardAxis" name="doc-xquery-ForwardAxis"/>[<small>73 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ForwardAxis">ForwardAxis</a></code></td><td>   ::=   </td><td><code>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ReverseAxis" name="doc-xquery-ReverseAxis"/>[<small>76 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ReverseAxis">ReverseAxis</a></code></td><td>   ::=   </td><td><code>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("preceding-sibling"  "::")<br/>|  ("preceding"  "::")<br/>|  ("ancestor-or-self"  "::")</code></td></tr></tbody></table>

          <p>In the case of XPath, forward axis also contain the
          <code>namespace::</code> axis.</p>

          
<h5><a id="N141EB" name="N141EB"/>Axes</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="noid_N1418A.doc-xpath-ForwardAxis" name="noid_N1418A.doc-xpath-ForwardAxis"/>[<small>30 (XPath)</small>]   </td><td><code><a href="http://www.w3.org/TR/xpath20/#prod-xpath-ForwardAxis">ForwardAxis</a></code></td><td>   ::=   </td><td><code>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("following-sibling"  "::")<br/>|  ("following"  "::")<br/>|  ("namespace"  "::")</code></td></tr></tbody></table>

        <p><b>Core Grammar</b></p>
          <p>The Core grammar productions for XPath axis are:</p>
      
            
<h5><a id="N1420A" name="N1420A"/>Axes</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-ForwardAxis" name="doc-core-ForwardAxis"/>[<small>57 (Core)</small>]   </td><td><code><a href="#prod-core-ForwardAxis">ForwardAxis</a></code></td><td>   ::=   </td><td><code>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("namespace"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ReverseAxis" name="doc-core-ReverseAxis"/>[<small>59 (Core)</small>]   </td><td><code><a href="#prod-core-ReverseAxis">ReverseAxis</a></code></td><td>   ::=   </td><td><code>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("ancestor-or-self"  "::")</code></td></tr></tbody></table>
        <p><b>Notation</b></p>
          <p id="jd_map_axis">The normalization of axes uses the
          following auxiliary mapping rule:
          <font size="6">[</font><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>.</p>
        <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
          <p>The normalization for all axes is specified as
          follows.</p>

          <p>The semantics of the following(-sibling) and
          preceding(-sibling) axes are expressed by mapping them to
          Core expressions. All other axes are part of the Core and
          therefore are left unchanged through normalization.</p>
           
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
            <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              <font size="6">[</font><code>following-sibling::</code>
              <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
            </td></tr>
            <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              <font size="6">[</font>let $e := . return $e/parent::node()/child:: <em>NodeTest</em> [.&gt;&gt;$e]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            </td></tr>
          </table></div>
    
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><code>following::</code>
            <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><code>ancestor-or-self::node()/following-sibling::node()/descendant-or-self::</code><em>NodeTest</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          </table></div>
    
          <p>All other forward axes are part of the Core [XPath/XQuery]
          and handled by the normalization rules below:</p>
    
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><code>child::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <code>child::</code> <em>NodeTest</em>
          </td></tr>
          </table></div>
          
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><code>attribute::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <code>attribute::</code> <em>NodeTest</em>
          </td></tr>
          </table></div>
          
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><code>self::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <code>self::</code> <em>NodeTest</em>
          </td></tr>
          </table></div>
          
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><code>descendant::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <code>descendant::</code> <em>NodeTest</em>
          </td></tr>
          </table></div>
          
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><code>descendant-or-self::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <code>descendant-or-self::</code> <em>NodeTest</em>
          </td></tr>
          </table></div>
          
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><code>namespace::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <code>namespace::</code> <em>NodeTest</em>
          </td></tr>
          </table></div>
    
          <p>Reverse axes:</p>
          
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><code>preceding-sibling::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font>let $e := . return $e/parent::node()/child:: <em>NodeTest</em> [.&lt;&lt;$e]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          </table></div>
          
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font><code>preceding::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font><code>ancestor-or-self::node()/preceding-sibling::node()/descendant-or-self::</code><em>NodeTest</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          </table></div>
           
          <p>All other reverse axes are part of the Core [XPath/XQuery]
          and handled by the normalization rules below:</p>
           
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font><code>parent::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          <code>parent::</code> <em>NodeTest</em>
          </td></tr>
          </table></div>
          
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font><code>ancestor::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          <code>ancestor::</code> <em>NodeTest</em>
          </td></tr>
          </table></div>
          
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font><code>ancestor-or-self::</code> <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          <code>ancestor-or-self::</code> <em>NodeTest</em>
          </td></tr>
          </table></div>
    
        </div><div class="div4">
<h5><a id="node-tests" name="node-tests"/>4.2.1.2 Node Tests</h5><p><b>Introduction</b></p>
          <p>A node test is a condition applied on the nodes selected
          by an axis step. Node tests are described by the following
          grammar productions.</p>
    
          
<h5><a id="N143DF" name="N143DF"/>Node Tests</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-NodeTest" name="doc-xquery-NodeTest"/>[<small>78 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-NodeTest">NodeTest</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-KindTest">KindTest</a>  |  <a href="#doc-xquery-NameTest">NameTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-NameTest" name="doc-xquery-NameTest"/>[<small>79 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-NameTest">NameTest</a></code></td><td>   ::=   </td><td><code>QName  |  <a href="#doc-xquery-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-Wildcard" name="doc-xquery-Wildcard"/>[<small>80 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Wildcard">Wildcard</a></code></td><td>   ::=   </td><td><code>"*"<br/>|  (NCName  ":"  "*")<br/>|  ("*"  ":"  NCName)</code></td></tr></tbody></table>
        <p><b>Core Grammar</b></p>
          <p>The Core grammar productions for node tests are:</p>

          
<h5><a id="N14422" name="N14422"/>Node Tests</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-NodeTest" name="doc-core-NodeTest"/>[<small>60 (Core)</small>]   </td><td><code><a href="#prod-core-NodeTest">NodeTest</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-KindTest">KindTest</a>  |  <a href="#doc-core-NameTest">NameTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-NameTest" name="doc-core-NameTest"/>[<small>61 (Core)</small>]   </td><td><code><a href="#prod-core-NameTest">NameTest</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a>  |  <a href="#doc-core-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-Wildcard" name="doc-core-Wildcard"/>[<small>62 (Core)</small>]   </td><td><code><a href="#prod-core-Wildcard">Wildcard</a></code></td><td>   ::=   </td><td><code>"*"<br/>|  (<a href="#prod-core-NCName">NCName</a>  ":"  "*")<br/>|  ("*"  ":"  <a href="#prod-core-NCName">NCName</a>)</code></td></tr></tbody></table>
        <p><b>Notation</b></p>
          <p>For convenience, we will use the grammar non-terminals
          <em>Prefix</em>, and <em>LocalPart</em>, both of which are
          <em>NCName</em>s, in some of the inference rules. They are
          defined by the following grammar productions.</p>

          
<h5><a id="N1446E" name="N1446E"/>Prefix and LocalPart</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-Prefix" name="doc-fs-Prefix"/>[<small>18 (Formal)</small>]   </td><td><code>Prefix</code></td><td>   ::=   </td><td><code><a href="#prod-core-NCName">NCName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-LocalPart" name="doc-fs-LocalPart"/>[<small>19 (Formal)</small>]   </td><td><code>LocalPart</code></td><td>   ::=   </td><td><code><a href="#prod-core-NCName">NCName</a></code></td></tr></tbody></table>

        </div></div><div class="div3">
<h4><a id="id-predicates" name="id-predicates"/>4.2.2 Predicates</h4><p><b>Introduction</b></p>
        <p>A predicate consists of an expression, called a <b>predicate
        expression</b>, enclosed in square brackets.</p>
  
        
<h5><a id="N14495" name="N14495"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-Predicate" name="doc-xquery-Predicate"/>[<small>83 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Predicate">Predicate</a></code></td><td>   ::=   </td><td><code>"["  <a href="#doc-xquery-Expr">Expr</a>  "]"</code></td></tr></tbody></table>
  
      <p><b>Notation</b></p>
        <p id="jd_map_predicates">Normalization of predicates uses the
        following auxiliary mapping rule:
        <font size="6">[</font><font size="6">]</font><a href="#jd_map_predicates" class="judgment"><sub><font size="2">Predicates</font></sub></a>.</p>
      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>Predicates in path expressions are normalized with a
        special mapping rule:</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_predicates" class="judgment"><sub><font size="2">Predicates</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <table><tbody><tr><td>typeswitch (<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)</td></tr><tr><td>  case $v as <em>fs:</em><code>numeric</code> return <em>op:</em>numeric-equal($v, <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>)</td></tr><tr><td>  default $v return <code>fn:boolean</code>($v)</td></tr></tbody></table>
            
          </td></tr>
        </table></div>
  
        <p>Note that the semantics of predicates whose input
        expression returns a numeric value also work if that value is
        not an integer. In those cases the
        <code>op:numeric-equal</code> returns false when compared to a
        position. For example the expression <code>//a[3.4]</code>
        returns the empty sequence)</p>
      </div><div class="div3">
<h4><a id="unabbrev" name="unabbrev"/>4.2.3 Unabbreviated Syntax</h4><p>The corresponding Section in the [XPath/XQuery] document just
      contains examples.</p></div><div class="div3">
<h4><a id="abbrev" name="abbrev"/>4.2.4 Abbreviated Syntax</h4>
<h5><a id="N14510" name="N14510"/>Abbreviated Syntax</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-AbbrevForwardStep" name="doc-xquery-AbbrevForwardStep"/>[<small>74 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AbbrevForwardStep">AbbrevForwardStep</a></code></td><td>   ::=   </td><td><code>"@"?  <a href="#doc-xquery-NodeTest">NodeTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AbbrevReverseStep" name="doc-xquery-AbbrevReverseStep"/>[<small>77 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AbbrevReverseStep">AbbrevReverseStep</a></code></td><td>   ::=   </td><td><code>".."</code></td></tr></tbody></table><p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>Here are normalization rules for the abbreviated
        syntax.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font> .. <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font>parent::node()<font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
        </td></tr>
        </table></div>
        
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font> @ NameTest <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          attribute :: NameTest
        </td></tr>
        </table></div>
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font> <em>NodeTest</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font>child :: <em>NodeTest</em><font size="6">]</font><a href="#jd_map_axis" class="judgment"><sub><font size="2">Axis</font></sub></a>
        </td></tr>
        </table></div>

      </div></div><div class="div2">
<h3><a id="id-sequence-expressions" name="id-sequence-expressions"/>4.3 Sequence Expressions</h3><p><b>Introduction</b></p>
      <p>[XPath/XQuery] supports operators to construct and combine
      sequences.  A <b>sequence</b> is an ordered collection of
      zero or more items. An <b>item</b> is either an atomic
      value or a node.</p>
    <div class="div3">
<h4><a id="sec_constructing_sequences" name="sec_constructing_sequences"/>4.3.1 Constructing Sequences</h4>
<h5><a id="N1458F" name="N1458F"/>Constructing Sequences</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="noid_N144DA.doc-xquery-Expr" name="noid_N144DA.doc-xquery-Expr"/>[<small>31 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Expr">Expr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a>  (","  <a href="#doc-xquery-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-RangeExpr" name="doc-xquery-RangeExpr"/>[<small>49 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-RangeExpr">RangeExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-AdditiveExpr">AdditiveExpr</a> ( "to"  <a href="#doc-xquery-AdditiveExpr">AdditiveExpr</a> )?</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
        <p>The Core grammar production for sequence expressions is:</p>

        
<h5><a id="N145BC" name="N145BC"/>Core Sequence Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="noid_N144EF.doc-core-Expr" name="noid_N144EF.doc-core-Expr"/>[<small>30 (Core)</small>]   </td><td><code><a href="#prod-core-Expr">Expr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ExprSingle">ExprSingle</a>  (","  <a href="#doc-core-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody></table>
      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>A sequence expression is normalized into a sequence of
        normalized single expressions:</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> , <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>, <font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            
          </td></tr>
        </table></div>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>
        The type of the sequence expression is the sequence over the
        types of the individual expressions.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                    
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <em>Expr</em><sub><font size="2">1</font></sub> , <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
                
              </td></tr>
            </table></td></tr></table></td></tr>
          </table><br/>
        </div>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>  
        <p>
        Each expression in the sequence is evaluated and the resulting
        values are concatenated into one sequence.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>    
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                <em>Expr</em><sub><font size="2">1</font></sub>, <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
              </td></tr>
            </table></td></tr></table></td></tr>
          </table><br/>
        </div>

      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>The range operator is normalized to the <em>fs:</em><code>to</code>
        function.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <code>to</code> <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <em>fs:</em><code>to</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>),(<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>))
            
          </td></tr>
        </table></div>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static semantics of the <em>fs:</em><code>to</code> function is defined in
        <a href="#xpath-functions">[Functions and Operators]</a>.</p>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>The dynamic semantics of the <em>op:</em>to operator is
        defined in <a href="#xpath-functions">[Functions and Operators]</a>.</p>
      </div><div class="div3">
<h4><a id="sec_filter_exprs" name="sec_filter_exprs"/>4.3.2 Filter Expressions</h4><p><b>Introduction</b></p>
        
<h5><a id="N1475C" name="N1475C"/>Filter Expression</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-FilterExpr" name="doc-xquery-FilterExpr"/>[<small>81 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-FilterExpr">FilterExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-PrimaryExpr">PrimaryExpr</a>  <a href="#doc-xquery-PredicateList">PredicateList</a></code></td></tr></tbody></table>
      <p><b>Core Grammar</b></p>
        <p>There are no Core grammar productions for filter
        expressions as they are normalized to other Core
        expressions. </p>
      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>When a predicate with a numeric literal or the
        <code>last()</code> expression is applied on a primary
        expression, it is normalized using the <code>fn:subsequence</code>
        function. This results in a more precise static type for those
        cases.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>PrimaryExpr</em> <em>PredicateList</em> [ <em>NumericLiteral</em> ]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <table><tbody><tr><td>let <code>$</code><em>fs:</em><code>sequence</code> := <font size="6">[</font><em>PrimaryExpr</em> <em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> return</td></tr><tr><td><code>fn:subsequence</code>(<code>$</code><em>fs:</em><code>sequence</code>,<em>NumericLiteral</em>,1)</td></tr></tbody></table>
            
          </td></tr>
        </table></div>
        
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>PrimaryExpr</em> <em>PredicateList</em> [ last() ]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <table><tbody><tr><td>let <code>$</code><em>fs:</em><code>sequence</code> := <font size="6">[</font><em>PrimaryExpr</em> <em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> return</td></tr><tr><td><code>fn:subsequence</code>(<code>$</code><em>fs:</em><code>sequence</code>,<em>NumericLiteral</em>,<a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>)</td></tr></tbody></table>
            
          </td></tr>
        </table></div>
        
        <p>In the general case, when a predicate is applied on a
        primary expression, it is normalized to a FLWOR expression as
        follows. The input sequence is processed in sequence order and
        the context item is bound to each item in the input
        sequence.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>PrimaryExpr</em> <em>PredicateList</em> [ <em>Expr</em> ]<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <table><tbody><tr><td>let <code>$</code><em>fs:</em><code>sequence</code> := <font size="6">[</font><em>PrimaryExpr</em> <em>PredicateList</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> return</td></tr><tr><td>let <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a> := fn:count(<code>$</code><em>fs:</em><code>sequence</code>) return</td></tr><tr><td>for <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> at <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a> in <code>$</code><em>fs:</em><code>sequence</code> return</td></tr><tr><td>   if (<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_predicates" class="judgment"><sub><font size="2">Predicates</font></sub></a>) then <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>dot</code></a> else ()</td></tr></tbody></table>
            
          </td></tr>
        </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>There are no additional static type rules for filter expressions.</p>
    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>There are no additional dynamic evaluation rules for filter expressions.</p>
    </div><div class="div3">
<h4><a id="sec_combining_sequences" name="sec_combining_sequences"/>4.3.3 Combining Node Sequences</h4><p>[XPath/XQuery] provides several operators for combining
      sequences of nodes.</p>
<h5><a id="N148AF" name="N148AF"/>Combining Sequences</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-UnionExpr" name="doc-xquery-UnionExpr"/>[<small>52 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-UnionExpr">UnionExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-IntersectExceptExpr">IntersectExceptExpr</a> ( ("union"  |  "|")  <a href="#doc-xquery-IntersectExceptExpr">IntersectExceptExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-IntersectExceptExpr" name="doc-xquery-IntersectExceptExpr"/>[<small>53 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-IntersectExceptExpr">IntersectExceptExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-InstanceofExpr">InstanceofExpr</a> ( ("intersect"  |  "except")  <a href="#doc-xquery-InstanceofExpr">InstanceofExpr</a> )*</code></td></tr></tbody></table><p><b>Notation</b></p>
      <p id="jd_map_sequenceop">The union, intersect, and except
      expressions are normalized into function calls to the
      appropriate functions. The mapping function
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_sequenceop" class="judgment"><sub><font size="2">SequenceOp</font></sub></a> is defined by the following
      table:</p>

      <table border="1"><tbody><tr><td>SequenceOp</td><td><font size="6">[</font><em>SequenceOp</em><font size="6">]</font><a href="#jd_map_sequenceop" class="judgment"><sub><font size="2">SequenceOp</font></sub></a></td></tr><tr><td>"union"</td><td><em>op:</em>union</td></tr><tr><td>"|"</td><td><em>op:</em>union</td></tr><tr><td>"intersect"</td><td><em>op:</em>intersect</td></tr><tr><td>"except"</td><td><em>op:</em>except</td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Operators for combining node sequences are normalized as
      follows.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
        <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <em>SequenceOp</em> <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
        <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a> (<font size="6">[</font><em>SequenceOp</em><font size="6">]</font><a href="#jd_map_sequenceop" class="judgment"><sub><font size="2">SequenceOp</font></sub></a> (
        <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>, <font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> ))
        
       </td></tr>
      </table></div>

    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The static semantics of the operators that combine sequences
      are defined in <a href="#sec_op_union_intersect_except"><b>[7.2.14 The op:union, op:intersect, and
      op:except operators]</b></a>.</p>
    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>The dynamic semantics for function calls is given in <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>
    </div></div><div class="div2">
<h3><a id="sec_arithmetic" name="sec_arithmetic"/>4.4 Arithmetic Expressions</h3><p>[XPath/XQuery] provides arithmetic operators for addition,
    subtraction, multiplication, division, and modulus, in their usual
    binary and unary forms.</p>
<h5><a id="N14987" name="N14987"/>Arithmetic Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-AdditiveExpr" name="doc-xquery-AdditiveExpr"/>[<small>50 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AdditiveExpr">AdditiveExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-MultiplicativeExpr">MultiplicativeExpr</a> ( ("+"  |  "-")  <a href="#doc-xquery-MultiplicativeExpr">MultiplicativeExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-MultiplicativeExpr" name="doc-xquery-MultiplicativeExpr"/>[<small>51 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-MultiplicativeExpr">MultiplicativeExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-UnionExpr">UnionExpr</a> ( ("*"  |  "div"  |  "idiv"  |  "mod")  <a href="#doc-xquery-UnionExpr">UnionExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-UnaryExpr" name="doc-xquery-UnaryExpr"/>[<small>58 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-UnaryExpr">UnaryExpr</a></code></td><td>   ::=   </td><td><code>("-"  |  "+")* <a href="#doc-xquery-ValueExpr">ValueExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ValueExpr" name="doc-xquery-ValueExpr"/>[<small>59 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ValueExpr">ValueExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ValidateExpr">ValidateExpr</a>  |  <a href="#doc-xquery-PathExpr">PathExpr</a>  |  <a href="#doc-xquery-ExtensionExpr">ExtensionExpr</a></code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The Core grammar production for arithmetic expressions
      is:</p>

      
<h5><a id="N149D7" name="N149D7"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-ValueExpr" name="doc-core-ValueExpr"/>[<small>48 (Core)</small>]   </td><td><code><a href="#prod-core-ValueExpr">ValueExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ValidateExpr">ValidateExpr</a>  |  <a href="#doc-core-StepExpr">StepExpr</a>  |  <a href="#doc-core-ExtensionExpr">ExtensionExpr</a></code></td></tr></tbody></table>
    <p><b>Notation</b></p>
      <p id="jd_map_arithop">The mapping functions
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_arithop" class="judgment"><sub><font size="2">ArithOp</font></sub></a> and <a href="#jd_map_arithop" class="judgment"><sub><font size="2">UnaryArithOp</font></sub></a> are
      defined by the following tables:</p>

      <table border="1"><tbody><tr><td><em>ArithOp</em></td><td><font size="6">[</font><em>ArithOp</em><font size="6">]</font><a href="#jd_map_arithop" class="judgment"><sub><font size="2">ArithOp</font></sub></a></td></tr><tr><td>"+"</td><td><em>fs:</em><code>plus</code></td></tr><tr><td>"-"</td><td><em>fs:</em><code>minus</code></td></tr><tr><td>"*"</td><td><em>fs:</em><code>times</code></td></tr><tr><td>"div"</td><td><em>fs:</em><code>div</code></td></tr><tr><td>"mod"</td><td><em>fs:</em><code>mod</code></td></tr></tbody></table>

      <table border="1"><tbody><tr><td><em>UnaryArithOp</em></td><td><font size="6">[</font><em>UnaryArithOp</em><font size="6">]</font><a href="#jd_map_arithop" class="judgment"><sub><font size="2">UnaryArithOp</font></sub></a></td></tr><tr><td>"+"</td><td><em>fs:</em><code>unary-plus</code></td></tr><tr><td>"-"</td><td><em>fs:</em><code>unary-minus</code></td></tr></tbody></table>

   <p><b>Core Grammar</b></p>
    <p>There are no Core grammar productions for arithmetic
    expressions as they are normalized to other Core expressions. </p>
  <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
     <p>The normalization rules for all the arithmetic operators
     except <code>idiv</code> first atomize each argument by applying
     <code>fn:data</code> and then apply the internal function
     <a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a> to each argument.  If the first argument to
     this function has type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, then the first
     argument is cast to a double, otherwise it is returned unchanged.
     The overloaded internal function corresponding to the arithmetic
     operator is then applied to the two converted arguments.  The
     table above maps the operators to the corresponding internal
     function.  The mapping from the overloaded internal functions to
     the corresponding non-overloaded function is given in <a href="#sec_operators"><b>[B.2 Mapping of Overloaded Internal Functions]</b></a>.</p>

   <div align="center"><table cellpadding="0" cellspacing="0" summary="">
    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <em>ArithOp</em>  <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
     
    </td></tr>
    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <table summary=""><tbody><tr><td><font size="6">[</font><em>ArithOp</em><font size="6">]</font><a href="#jd_map_arithop" class="judgment"><sub><font size="2">ArithOp</font></sub></a>
          (</td><td><a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)), 1.0E0),
         </td></tr><tr><td/><td><a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)), 1.0E0))
         </td></tr></tbody></table>
     
    </td></tr>
   </table></div>

   <p>The normalization rules for the <code>idiv</code> operator are similar,
   but instead of casting arguments with type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> to
   <code>xs:double</code>, they are cast to <code>xs:integer</code>.</p>

   <div align="center"><table cellpadding="0" cellspacing="0" summary="">
    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <code>idiv</code>  <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
     
    </td></tr>
    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <table summary=""><tbody><tr valign="baseline"><td><em>fs:</em><code>idiv</code>
          (</td><td><a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)), 1),
         </td></tr><tr><td/><td><a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)), 1))
         </td></tr></tbody></table>
     
    </td></tr>
   </table></div>
  

   <p>The unary operators are mapped similarly.</p>

   <div align="center"><table cellpadding="0" cellspacing="0" summary="">
    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <font size="6">[</font><code>+</code> <em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
     
    </td></tr>
    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
     
            <em>fs:</em><code>unary-plus</code>(<a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)), 1.0E0))
     
    </td></tr>
   </table></div>

   <div align="center"><table cellpadding="0" cellspacing="0" summary="">
    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <font size="6">[</font><code>-</code> <em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
     
    </td></tr>
    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
     
        <em>fs:</em><code>unary-minus</code>(0, <a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)), 1.0E0))
     
    </td></tr>
   </table></div>

<p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
  <p>The static semantics for function calls is given in
  <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>
<p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
  <p>The dynamic semantics for
  function calls is given in <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>
</div><div class="div2">
<h3><a id="sec_comparisons" name="sec_comparisons"/>4.5 Comparison Expressions</h3><p><b>Introduction</b></p>

      <p>Comparison expressions allow two values to be
      compared. [XPath/XQuery] provides three kinds of comparison
      expressions, called value comparisons, general comparisons, and
      node comparisons.</p>

      
<h5><a id="N14C00" name="N14C00"/>Comparison Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ComparisonExpr" name="doc-xquery-ComparisonExpr"/>[<small>48 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ComparisonExpr">ComparisonExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-RangeExpr">RangeExpr</a> ( (<a href="#doc-xquery-ValueComp">ValueComp</a><br/>|  <a href="#doc-xquery-GeneralComp">GeneralComp</a><br/>|  <a href="#doc-xquery-NodeComp">NodeComp</a>)  <a href="#doc-xquery-RangeExpr">RangeExpr</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ValueComp" name="doc-xquery-ValueComp"/>[<small>61 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ValueComp">ValueComp</a></code></td><td>   ::=   </td><td><code>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-GeneralComp" name="doc-xquery-GeneralComp"/>[<small>60 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-GeneralComp">GeneralComp</a></code></td><td>   ::=   </td><td><code>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-NodeComp" name="doc-xquery-NodeComp"/>[<small>62 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-NodeComp">NodeComp</a></code></td><td>   ::=   </td><td><code>"is"  |  "&lt;&lt;"  |  "&gt;&gt;"</code></td></tr></tbody></table>
    <div class="div3">
<h4><a id="sec_value_comparisons" name="sec_value_comparisons"/>4.5.1 Value Comparisons</h4><p><b>Notation</b></p>
      <p id="jd_map_valueop">The mapping function
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_valueop" class="judgment"><sub><font size="2">ValueOp</font></sub></a> is defined by the following
      table:</p>

      <table border="1"><tbody><tr><td>ValueOp</td><td><font size="6">[</font>ValueOp<font size="6">]</font><a href="#jd_map_valueop" class="judgment"><sub><font size="2">ValueOp</font></sub></a></td></tr><tr><td>"<code>eq</code>"</td><td><em>fs:</em>eq</td></tr><tr><td>"<code>ne</code>"</td><td><em>fs:</em>ne</td></tr><tr><td>"<code>lt</code>"</td><td><em>fs:</em>lt</td></tr><tr><td>"<code>le</code>"</td><td><em>fs:</em>le</td></tr><tr><td>"<code>gt</code>"</td><td><em>fs:</em>gt</td></tr><tr><td>"<code>ge</code>"</td><td><em>fs:</em>ge</td></tr></tbody></table>
    <p><b>Core Grammar</b></p>
      <p>There are no Core grammar productions for value comparisons
      as they are normalized to other Core expressions. </p>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>The normalization rules for the value comparison operators
      first atomize each argument by applying <code>fn:data</code> and then apply
      the internal function <a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a> defined in <a href="#sec_convert_operand"><b>[7.1.1 The fs:convert-operand function]</b></a>.  If the first argument to this
      function has type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, then the first argument
      is cast to a string, otherwise it is returned unchanged.  The
      overloaded internal function corresponding to the value
      comparison operator is then applied to the two converted
      arguments.  The table above maps the value operators to the
      corresponding internal function.  The mapping from the
      overloaded internal functions to the corresponding
      non-overloaded function is given in <a href="#sec_operators"><b>[B.2 Mapping of Overloaded Internal Functions]</b></a>.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <em>ValueOp</em>  <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <table summary=""><tbody><tr><td><font size="6">[</font><em>ValueOp</em><font size="6">]</font><a href="#jd_map_valueop" class="judgment"><sub><font size="2">ValueOp</font></sub></a>
             (</td><td><a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)), "string"),
            </td></tr><tr><td/><td><a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)), "string") )
            </td></tr></tbody></table>
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The static semantics for function calls is given in <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.  The comparison functions all have
      return type <code>xs:boolean</code>, as specified in <a href="#xpath-functions">[Functions and Operators]</a>. </p>
    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>The dynamic semantics for function calls is given in <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>
    </div><div class="div3">
<h4><a id="sec_general_comparisons" name="sec_general_comparisons"/>4.5.2 General Comparisons</h4><p><b>Introduction</b></p>
      <p>General comparisons are defined by adding existential
      semantics to value comparisons. The operands of a general
      comparison may be sequences of any length. The result of a
      general comparison is always <code>true</code> or
      <code>false</code>.</p>
    <p><b>Notation</b></p>

      <p>For convenience, GeneralOp denotes the operators "<code>=</code>",
      "<code>!=</code>", "<code>&lt;</code>", "<code>&lt;=</code>", "<code>&gt;</code>", or "<code>&gt;=</code>".</p>

      <p id="jd_map_generalop">The function
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_generalop" class="judgment"><sub><font size="2">GeneralOp</font></sub></a> is defined by the following
      table:</p>

      <table border="1"><tbody><tr><td><em>GeneralOp</em></td><td><font size="6">[</font><em>GeneralOp</em><font size="6">]</font><a href="#jd_map_generalop" class="judgment"><sub><font size="2">GeneralOp</font></sub></a></td></tr><tr><td>"<code>=</code>"</td><td><em>fs:</em>eq</td></tr><tr><td>"<code>!=</code>"</td><td><em>fs:</em>ne</td></tr><tr><td>"<code>&lt;</code>"</td><td><em>fs:</em>lt</td></tr><tr><td>"<code>&lt;=</code>"</td><td><em>fs:</em>le</td></tr><tr><td>"<code>&gt;</code>"</td><td><em>fs:</em>gt</td></tr><tr><td>"<code>&gt;=</code>"</td><td><em>fs:</em>ge</td></tr></tbody></table>

    <p><b>Core Grammar</b></p>
      <p>There are no Core grammar productions for general comparisons
      as they are normalized to existentially quantified Core
      expressions.</p>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>The normalization rule for a general comparison expression
      first atomizes each argument by applying <code>fn:data</code> and then
      applies the existentially quantified some expression to
      each sequence.  The internal function <a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a> is
      applied to each pair of atomic values.  If the first argument to
      this function has type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, then the first
      argument is cast to type of the second argument.  If the second
      argument has type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, the first argument is
      cast to a string.  The overloaded internal function
      corresponding to the general comparison operator is then applied
      to the two converted values.</p>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
            <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
                <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <em>GeneralOp</em> <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
              
            </td></tr>
            <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                <table summary=""><tbody><tr><td>some $v1 in <code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) satisfies</td></tr><tr><td>some $v2 in <code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) satisfies</td></tr><tr><td>let $u1 := <a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>($v1, $v2) return </td></tr><tr><td>let $u2 := <a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a>($v2, $v1) return </td></tr><tr><td><font size="6">[</font><em>GeneralOp</em><font size="6">]</font><a href="#jd_map_generalop" class="judgment"><sub><font size="2">GeneralOp</font></sub></a> ($u1, $u2)</td></tr></tbody></table>
              
            </td></tr>
          </table></div>
      </div><div class="div3">
<h4><a id="sec_node-comparisons" name="sec_node-comparisons"/>4.5.3 Node Comparisons</h4><p><b>Core Grammar</b></p>
  <p>There are no Core grammar productions for node comparisons as
  they are normalized to other Core expressions.</p>
<p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
  <p>The normalization rules for node comparisons map each argument
  expression and then apply the internal function corresponding to the
  node comparison operator. The internal function are defined in
  <a href="#sec_operators"><b>[B.2 Mapping of Overloaded Internal Functions]</b></a>.</p>

<div align="center"><table cellpadding="0" cellspacing="0" summary="">
<tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">

<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <code>is</code> <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>

</td></tr>
<tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
     
       <table summary=""><tbody><tr><td>   <em>fs:</em><code>is-same-node</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>), (<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>))</td></tr></tbody></table>
     
</td></tr>
</table></div>

<div align="center"><table cellpadding="0" cellspacing="0" summary="">
<tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">

<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> &lt;&lt; <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>

</td></tr>
<tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">

       <table summary=""><tbody><tr><td><em>fs:</em><code>node-before</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>), (<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>))</td></tr></tbody></table>

</td></tr>
</table></div>

<div align="center"><table cellpadding="0" cellspacing="0" summary="">
<tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">

<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> &gt;&gt; <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>

</td></tr>
<tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">

       <table summary=""><tbody><tr><td><em>fs:</em><code>node-after</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>), (<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>))</td></tr></tbody></table>

</td></tr>
</table></div>

<p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
  <p>The static semantics for the internal functions are defined in
  <a href="#sec_operators"><b>[B.2 Mapping of Overloaded Internal Functions]</b></a>. </p>
<p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
  <p>The dynamic semantics for internal function is defined in
  <a href="#sec_operators"><b>[B.2 Mapping of Overloaded Internal Functions]</b></a>.</p>
</div></div><div class="div2">
<h3><a id="id-logical-expressions" name="id-logical-expressions"/>4.6 Logical Expressions</h3><p><b>Introduction</b></p>
      <p>A <b>logical expression</b> is either an
      <b>and-expression</b> or an
      <b>or-expression</b>. The value of a logical expression is
      always one of the boolean values: <code>true</code> or
      <code>false</code>.</p>
    
<h5><a id="N14F81" name="N14F81"/>Logical Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-OrExpr" name="doc-xquery-OrExpr"/>[<small>46 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-OrExpr">OrExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-AndExpr">AndExpr</a> ( "or"  <a href="#doc-xquery-AndExpr">AndExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AndExpr" name="doc-xquery-AndExpr"/>[<small>47 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AndExpr">AndExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ComparisonExpr">ComparisonExpr</a> ( "and"  <a href="#doc-xquery-ComparisonExpr">ComparisonExpr</a> )*</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The Core grammar productions for logical expressions are:</p>

      
<h5><a id="N14FAE" name="N14FAE"/>Core Logical Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-OrExpr" name="doc-core-OrExpr"/>[<small>44 (Core)</small>]   </td><td><code><a href="#prod-core-OrExpr">OrExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-AndExpr">AndExpr</a> ( "or"  <a href="#doc-core-AndExpr">AndExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-AndExpr" name="doc-core-AndExpr"/>[<small>45 (Core)</small>]   </td><td><code><a href="#prod-core-AndExpr">AndExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-CastableExpr">CastableExpr</a> ( "and"  <a href="#doc-core-CastableExpr">CastableExpr</a> )*</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>The normalization rules for "<code>and</code>" and "<code>or</code>" first
      get the effective boolean value of each argument, then apply the
      appropriate Core operator.</p>

   <div align="center"><table cellpadding="0" cellspacing="0" summary="">
    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <code>and</code> <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
     
    </td></tr>
    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <code>fn:boolean</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) <code>and</code> <code>fn:boolean</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>))
     
    </td></tr>
   </table></div>

   <div align="center"><table cellpadding="0" cellspacing="0" summary="">
    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <code>or</code> <em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
     
    </td></tr>
    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <code>fn:boolean</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) <code>or</code> <code>fn:boolean</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>))
     
    </td></tr>
   </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The logical expressions require that each subexpression have
type <code>xs:boolean</code>.  The result type is also <code>xs:boolean</code>.</p>

<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code>
            
        <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">n</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code>
        
      </td></tr>
    </table></td></tr></table></td></tr>
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <em>Expr</em><sub><font size="2">1</font></sub> <code>and</code> <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code>
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>

<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code>
            
        <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">n</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code>
        
      </td></tr>
    </table></td></tr></table></td></tr>
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <em>Expr</em><sub><font size="2">1</font></sub> <code>or</code> <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code>
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>

    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>The dynamic semantics of logical expressions is
non-deterministic.   This non-determinism permits implementations to use
short-circuit evaluation strategies when evaluating logical expressions. In the expression, <em>Expr</em><sub><font size="2">1</font></sub> <code>and</code> <em>Expr</em><sub><font size="2">2</font></sub>,
if either expression raises an error or evaluates to false, the entire
expression may raise an error or evaluate to false. 
In the expression, <em>Expr</em><sub><font size="2">1</font></sub> <code>or</code> <em>Expr</em><sub><font size="2">2</font></sub>,
if either expression raises an error or evaluates to true, the entire
expression may raise an error or evaluate to true. </p>

<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">i</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false
            
         1 &lt;= i &lt;= 2
      </td></tr>
    </table></td></tr></table></td></tr>
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
                <em>Expr</em><sub><font size="2">1</font></sub> <code>and</code> <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                false
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>

<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true
            
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true
        

      </td></tr>
    </table></td></tr></table></td></tr>
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
                <em>Expr</em><sub><font size="2">1</font></sub> <code>and</code> <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                true
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>

<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">i</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true
            
         1 &lt;= i &lt;= 2
      </td></tr>
    </table></td></tr></table></td></tr>
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
                <em>Expr</em><sub><font size="2">1</font></sub> <code>or</code> <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                true
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>

<div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false
            
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
          <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false
        

      </td></tr>
    </table></td></tr></table></td></tr>
    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
                <em>Expr</em><sub><font size="2">1</font></sub> <code>or</code> <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                false
        
      </td></tr>
    </table></td></tr></table></td></tr>
  </table><br/>
</div>

    </div><div class="div2">
<h3><a id="sec_constructors" name="sec_constructors"/>4.7 Constructors</h3><p>[XPath/XQuery] supports two forms of constructors. <b>Direct
    constructors</b> support literal XML syntax for elements,
    attributes, text nodes, processing-instructions and
    comments. <b>Computed constructors</b> can be used to
    construct elements, attributes, text nodes,
    processing-instructions, comments, and document nodes.  All direct
    constructors are normalized into computed constructors, i.e.,
    there are no direct-constructor expressions in the Core.</p><div class="div3">
<h4><a id="id_element_constructor" name="id_element_constructor"/>4.7.1 Direct Element Constructors</h4><p><b>Introduction</b></p>
      <p>The static and dynamic semantics of the direct forms of
      element and attribute constructors are specified on the
      equivalent computed element and attribute constructors.</p>

    
<h5><a id="N152B3" name="N152B3"/>Constructors</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-Constructor" name="doc-xquery-Constructor"/>[<small>94 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Constructor">Constructor</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-DirectConstructor">DirectConstructor</a><br/>|  <a href="#doc-xquery-ComputedConstructor">ComputedConstructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DirectConstructor" name="doc-xquery-DirectConstructor"/>[<small>95 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DirectConstructor">DirectConstructor</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-DirElemConstructor">DirElemConstructor</a><br/>|  <a href="#doc-xquery-DirCommentConstructor">DirCommentConstructor</a><br/>|  <a href="#doc-xquery-DirPIConstructor">DirPIConstructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DirElemConstructor" name="doc-xquery-DirElemConstructor"/>[<small>96 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DirElemConstructor">DirElemConstructor</a></code></td><td>   ::=   </td><td><code>"&lt;"  QName  <a href="#doc-xquery-DirAttributeList">DirAttributeList</a>  ("/&gt;"  |  ("&gt;"  <a href="#doc-xquery-DirElemContent">DirElemContent</a>*  "&lt;/"  QName  S?  "&gt;"))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DirElemContent" name="doc-xquery-DirElemContent"/>[<small>101 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DirElemContent">DirElemContent</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-DirectConstructor">DirectConstructor</a><br/>|  <a href="#doc-xquery-CDataSection">CDataSection</a><br/>|  <a href="#doc-xquery-CommonContent">CommonContent</a><br/>|  <a href="#doc-xquery-ElementContentChar">ElementContentChar</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ElementContentChar" name="doc-xquery-ElementContentChar"/>[<small>148 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ElementContentChar">ElementContentChar</a></code></td><td>   ::=   </td><td><code>Char - [{}&lt;&amp;]</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-CommonContent" name="doc-xquery-CommonContent"/>[<small>102 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CommonContent">CommonContent</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</a>  |  CharRef  |  "{{"  |  "}}"  |  <a href="#doc-xquery-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-CDataSection" name="doc-xquery-CDataSection"/>[<small>107 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CDataSection">CDataSection</a></code></td><td>   ::=   </td><td><code>"&lt;![CDATA["  <a href="#doc-xquery-CDataSectionContents">CDataSectionContents</a>  "]]&gt;"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-CDataSectionContents" name="doc-xquery-CDataSectionContents"/>[<small>108 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CDataSectionContents">CDataSectionContents</a></code></td><td>   ::=   </td><td><code>(Char* - (Char* ']]&gt;' Char*))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DirAttributeList" name="doc-xquery-DirAttributeList"/>[<small>97 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DirAttributeList">DirAttributeList</a></code></td><td>   ::=   </td><td><code>(S  (QName  S?  "="  S?  <a href="#doc-xquery-DirAttributeValue">DirAttributeValue</a>)?)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DirAttributeValue" name="doc-xquery-DirAttributeValue"/>[<small>98 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DirAttributeValue">DirAttributeValue</a></code></td><td>   ::=   </td><td><code>('"'  (<a href="#doc-xquery-EscapeQuot">EscapeQuot</a>  |  <a href="#doc-xquery-QuotAttrValueContent">QuotAttrValueContent</a>)*  '"')<br/>|  ("'"  (<a href="#doc-xquery-EscapeApos">EscapeApos</a>  |  <a href="#doc-xquery-AposAttrValueContent">AposAttrValueContent</a>)*  "'")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-QuotAttrValueContent" name="doc-xquery-QuotAttrValueContent"/>[<small>99 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-QuotAttrValueContent">QuotAttrValueContent</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-QuotAttrContentChar">QuotAttrContentChar</a><br/>|  <a href="#doc-xquery-CommonContent">CommonContent</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AposAttrValueContent" name="doc-xquery-AposAttrValueContent"/>[<small>100 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AposAttrValueContent">AposAttrValueContent</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-AposAttrContentChar">AposAttrContentChar</a><br/>|  <a href="#doc-xquery-CommonContent">CommonContent</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-QuotAttrContentChar" name="doc-xquery-QuotAttrContentChar"/>[<small>149 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-QuotAttrContentChar">QuotAttrContentChar</a></code></td><td>   ::=   </td><td><code>Char - ["{}&lt;&amp;]</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-AposAttrContentChar" name="doc-xquery-AposAttrContentChar"/>[<small>150 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-AposAttrContentChar">AposAttrContentChar</a></code></td><td>   ::=   </td><td><code>Char - ['{}&lt;&amp;]</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-EscapeQuot" name="doc-xquery-EscapeQuot"/>[<small>146 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-EscapeQuot">EscapeQuot</a></code></td><td>   ::=   </td><td><code>'""'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-EscapeApos" name="doc-xquery-EscapeApos"/>[<small>147 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-EscapeApos">EscapeApos</a></code></td><td>   ::=   </td><td><code>"''"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-EnclosedExpr" name="doc-xquery-EnclosedExpr"/>[<small>29 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-EnclosedExpr">EnclosedExpr</a></code></td><td>   ::=   </td><td><code>"{"  <a href="#doc-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody></table>

    <p><b>Notation</b></p>
      <p id="jd_map_element_content">The auxiliary mapping rules
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_element_content" class="judgment"><sub><font size="2">ElementContent</font></sub></a>, and
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_element_content_unit" class="judgment"><sub><font size="2">ElementContent-unit</font></sub></a> are defined in this
      section and are used for the normalization of the content of
      direct element constructors.</p>
    <p><b>Core Grammar</b></p>
      <p>The Core grammar productions for constructors are:</p>


<h5><a id="N1541B" name="N1541B"/>Constructors</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-Constructor" name="doc-core-Constructor"/>[<small>72 (Core)</small>]   </td><td><code><a href="#prod-core-Constructor">Constructor</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ComputedConstructor">ComputedConstructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ComputedConstructor" name="doc-core-ComputedConstructor"/>[<small>73 (Core)</small>]   </td><td><code><a href="#prod-core-ComputedConstructor">ComputedConstructor</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-CompDocConstructor">CompDocConstructor</a><br/>|  <a href="#doc-core-CompElemConstructor">CompElemConstructor</a><br/>|  <a href="#doc-core-CompAttrConstructor">CompAttrConstructor</a><br/>|  <a href="#doc-core-CompTextConstructor">CompTextConstructor</a><br/>|  <a href="#doc-core-CompCommentConstructor">CompCommentConstructor</a><br/>|  <a href="#doc-core-CompPIConstructor">CompPIConstructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-EnclosedExpr" name="doc-core-EnclosedExpr"/>[<small>28 (Core)</small>]   </td><td><code><a href="#prod-core-EnclosedExpr">EnclosedExpr</a></code></td><td>   ::=   </td><td><code>"{"  <a href="#doc-core-Expr">Expr</a>  "}"</code></td></tr></tbody></table>

      <p>There are no Core grammar productions for direct XML element
      or attribute constructors as they are normalized to computed
      constructors.</p>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>We start with the rules for normalizing a direct element
      constructors' content. Literal XML character data (CDATA) is
      assumed to be processed directly at parsing level so it does not
      require any formal treatment. We distinguish between direct
      element constructors that contain only one element-content unit
      and those that contain more than one element-content unit.  An
      element-content unit is a contiguous sequence of literal
      characters (character references, escaped braces, and predefined
      entity references), one enclosed expression, one direct element
      constructor, one XML comment, or one XML processing instruction.
      Here are three direct element constructors that each contain one
      element-content unit:</p>

<div class="exampleInner"><pre>
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;

&lt;name&gt;Dizzy Gillespe&lt;/name&gt;

&lt;comment&gt;&lt;!-- Just a comment --&gt;&lt;/comment&gt;
</pre></div>

     <p>The first contains one enclosed expression, the second
     contains one contiguous sequence of characters, and the third
     contains one XML comment.</p>

     <p>After boundary-space is stripped, the next example contains
     six element-content units: </p> <div class="exampleInner"><pre>
&lt;address&gt;
  &lt;!-- Dizzy's address --&gt;
  { 123 }-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY { 11368 }
&lt;/address&gt;
</pre></div>

     <p>It contains one XML comment, followed by one enclosed
     expression that contains the integer 123, one contiguous sequence
     of characters ("-0A "), one direct XML element constructor, one
     contiguous sequence of characters (" Flushing, NY "), and one
     enclosed expression that contains the integer 11368. Evaluation
     of that constructor will result in the following element.</p>

<div class="exampleInner"><pre>
&lt;address&gt;&lt;!-- Dizzy's address --&gt;123-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY 11368&lt;/address&gt;
</pre></div>

    <p>Adjacent element-content units are convenient because they
    permit arbitrary interleaving of text and atomic data.  During
    evaluation, atomic values are converted to text nodes containing
    the string representations of the atomic values, and then adjacent
    text nodes are concatenated together.  In the example above, the
    integer 123 is converted to a string and concatenated with "-0A"
    and the result is a single text node containing "123-0A".</p>

    <p>In general, we do not want to convert all atomic values to text
    nodes, especially when performing static-type analysis, because we
    lose useful type information.  For example, if we normalize the
    first example above as follows, we lose the important information
    that the user constructed a date value, not just a text node
    containing an arbitrary string: </p>

<div class="exampleInner"><pre>
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;
 (normalization that loses type information) == 
element date { text { "2003-03-18" } } 
</pre></div>

    <p>To preserve useful type information, we distinguish between
    direct element constructors that contain one element-content unit
    and those that contain more than one (because multiple
    element-content units commonly denote concatenation of atomic data
    and text). Below are two examples of normalization for element
    constructors.</p>

<div class="exampleInner"><pre>
&lt;date&gt;{ xs:date("2003-03-18") }&lt;/date&gt;
 ==
element date { xs:date("2003-03-18") } 

&lt;address&gt;
  &lt;!-- Dizzy's address --&gt;
  { 123 }-0A &lt;street&gt;Roosevelt Ave.&lt;/street&gt; Flushing, NY { 11368 }
&lt;/address&gt;
 ==
element address {
  fs:item-sequence-to-node-sequence(
    comment { " Dizzy's address "},
    123, 
    text { "-0A "}, 
    element street {"Roosevelt Ave."},
    text { " Flushing, NY "  },
    11368
  )
}
</pre></div>

    <p><b>Notation</b></p>
      <p>We introduce the following auxiliary grammar productions.</p>

      
<h5><a id="N15499" name="N15499"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-ElementContentUnit" name="doc-fs-ElementContentUnit"/>[<small>92 (Formal)</small>]   </td><td><code>ElementContentUnit</code></td><td>   ::=   </td><td><code>DirectConstructor  |  <a href="#doc-core-EnclosedExpr">EnclosedExpr</a>  |  <a href="#doc-fs-DirCharsUnit">DirCharsUnit</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-DirCharsUnit" name="doc-fs-DirCharsUnit"/>[<small>93 (Formal)</small>]   </td><td><code>DirCharsUnit</code></td><td>   ::=   </td><td><code>(<a href="#prod-core-ElementContentChar">ElementContentChar</a>  |  PredefinedEntityRef  |  CharRef  |  "{{"  |  "}}")+</code></td></tr></tbody></table>
    

    <p id="jd_map_element_content_unit">Given the distinction between
    direct element constructors that we made above, we give two
    normalization rules for a direct element constructor's content.
    If the direct element constructor contains exactly one
    element-content unit, we simply normalize that unit by applying
    the normalization rule for the element content:</p>

    <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font>
          <a href="#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a>
        <font size="6">]</font><a href="#jd_map_element_content_unit" class="judgment"><sub><font size="2">ElementContent-unit</font></sub></a>
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font> <a href="#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a> <font size="6">]</font><a href="#jd_map_element_content" class="judgment"><sub><font size="2">ElementContent</font></sub></a> 
        
      </td></tr>
    </table></div>

    <p>If the direct element constructor contains more than one
    element-content unit, we normalize each unit individually and
    construct a sequence of the normalized results interleaved with
    empty text nodes.  The empty text nodes guarantee that the results
    of evaluating consecutive element-content units can be
    distinguished.  Then we apply the function
    <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>.  <a href="http://www.w3.org/TR/xquery#id-element-constructor">Section 
3.7.1 Direct Element Constructors</a><sup><small>XQ</small></sup> specifies the rules for converting
    a sequence of atomic values and nodes into a sequence of nodes
    before element construction.  The Formal Semantics function
    <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a> implements these conversion rules.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font><a href="#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">1</font></sub> ...,  <a href="#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_element_content_unit" class="judgment"><sub><font size="2">ElementContent-unit</font></sub></a>, n &gt; 1
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>(<font size="6">[</font> <a href="#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">1</font></sub> <font size="6">]</font><a href="#jd_map_element_content" class="judgment"><sub><font size="2">ElementContent</font></sub></a> , text { "" }, ..., text { "" }, <font size="6">[</font> <a href="#doc-fs-ElementContentUnit"><em>ElementContentUnit</em></a><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_element_content" class="judgment"><sub><font size="2">ElementContent</font></sub></a>)
          
        </td></tr>
      </table></div>

    <p>We need to distinguish between multiple element-content units,
    because the rule for converting sequences of atomic values into
    strings apply to sequences within distinct enclosed expressions.
    The empty text nodes are eliminated during evaluation of
    <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a> when consecutive text nodes are
    coalesced into a single text node.  The text node guarantees that
    a whitespace character will not be inserted between atomic values
    computed by distinct enclosed expressions.  For example, here is
    an expression, its normalization, and the resulting XML value:</p>

<div class="exampleInner"><pre>
&lt;example&gt;{ 1 }{ 2 }&lt;/example&gt;
 ==
element example { fs:item-sequence-to-node-sequence ((1, text {""}, 2)) }
 ==&gt;
&lt;example&gt;12&lt;/example&gt;
</pre></div>

      <p>In the absence of the empty text node, the expression would
      evaluate to the following incorrect value:</p>

<div class="exampleInner"><pre>
&lt;example&gt;{ 1 }{ 2 }&lt;/example&gt;
 (incorrect normalization) ==
element example { fs:item-sequence-to-node-sequence ((1, 2)) }
 (incorrect value) ==&gt;
&lt;example&gt;1 2&lt;/example&gt;
</pre></div>

      <p>Now that we have explained the normalization rules for direct
      element content, we give the rules for the two forms of direct
      XML element constructors.  Note that the direct attribute
      constructors are normalized twice: the
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttrs</font></sub></a> normalizes the
      namespace-declaration attributes and
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_attribute" class="judgment"><sub><font size="2">Attribute</font></sub></a> normalizes all other attributes
      that are not namespace-declaration attributes. </p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font> &lt; <em>QName</em> <em>AttributeList</em> &gt;
          <em>DirElemContent</em>* &lt;/ <em>QName</em> S? &gt;
          <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        element <em>QName</em> { <font size="6">[</font>
          <em>AttributeList</em> <font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttrs</font></sub></a> , <font size="6">[</font>
          <em>AttributeList</em> <font size="6">]</font><a href="#jd_map_attribute" class="judgment"><sub><font size="2">Attribute</font></sub></a> , <font size="6">[</font>
          <em>DirElemContent</em>* <font size="6">]</font><a href="#jd_map_element_content" class="judgment"><sub><font size="2">ElementContent</font></sub></a> }
        
      </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font> &lt; <em>QName</em> <em>AttributeList</em> /&gt;
          <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        element <em>QName</em> { <font size="6">[</font>
          <em>AttributeList</em> <font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttrs</font></sub></a> , <font size="6">[</font>
        <em>AttributeList</em> <font size="6">]</font><a href="#jd_map_attribute" class="judgment"><sub><font size="2">Attribute</font></sub></a> }
        
      </td></tr>
      </table></div>

      <p>Next, we give the normalization rules for each
      element-content unit.  The normalization rule for a contiguous
      sequence of characters assumes:</p>

      <ol class="enumar"><li><p>
             that the significant whitespace characters in 
             element constructors have been preserved, as described in
             <a href="#sec_whitespace"><b>[4.7.1.4 Whitespace in Element Content]</b></a>; 
      </p></li><li><p>that character
            references have been resolved to individual characters and
             predefined entity references have been resolved to sequences of 
            characters, and 
      </p></li><li><p>that the rule is applied to the longest
            contiguous sequence of characters.</p></li></ol>

      <p>The following normalization rule takes the longest
      consecutive sequence of individual characters that include
      literal characters, escaped curly braces, character references,
      and predefined entity references and normalizes the character
      sequence as a text node containing the string of characters.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
       <font size="6">[</font><a href="#doc-fs-DirCharsUnit"><em>DirCharsUnit</em></a><font size="6">]</font><a href="#jd_map_element_content" class="judgment"><sub><font size="2">ElementContent</font></sub></a>
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
       text { <code>fn:codepoints-to-string</code>(<a href="#doc-fs-DirCharsUnit"><em>DirCharsUnit</em></a>) }
        </td></tr>
      </table></div>

    <p>XML processing instructions and comments in element content are
    normalized by applying the standard normalization rules for
    expressions, which appear in <a href="#sec_other_constructors"><b>[4.7.2 Other Direct Constructors]</b></a>.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font>DirPIConstructor<font size="6">]</font><a href="#jd_map_element_content" class="judgment"><sub><font size="2">ElementContent</font></sub></a>
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font>DirPIConstructor<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font>DirCommentConstructor<font size="6">]</font><a href="#jd_map_element_content" class="judgment"><sub><font size="2">ElementContent</font></sub></a>
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font>DirCommentConstructor<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
      </td></tr>
      </table></div>

    <p>An enclosed expression in element content is normalized by
    normalizing each individual expression in its expression sequence
    and then constructing a sequence of the normalized values:</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font>
            { <em>Expr</em><sub><font size="2">1</font></sub>, ..., <em>Expr</em><sub><font size="2">n</font></sub> }
          <font size="6">]</font><a href="#jd_map_element_content" class="judgment"><sub><font size="2">ElementContent</font></sub></a>
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font> <em>Expr</em><sub><font size="2">1</font></sub> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> , ..., <font size="6">[</font> <em>Expr</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
        </td></tr>
      </table></div>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>There are no additional static type rules for direct XML
        element or attribute constructors.</p>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>There are no additional dynamic evaluation rules for direct
        XML element or attribute constructors.</p>
      <div class="div4">
<h5><a id="sec_direct_attributes" name="sec_direct_attributes"/>4.7.1.1 Attributes</h5><p>Like literal XML element constructors, literal XML attribute
      constructors are normalized to computed attribute
      constructors.</p><p><b>Notation</b></p>
        <p>The auxiliary mapping rules <font size="6">[</font><font size="6">]</font><a href="#jd_map_attribute" class="judgment"><sub><font size="2">Attribute</font></sub></a>,
        <font size="6">[</font><font size="6">]</font><a href="#jd_map_attr_content" class="judgment"><sub><font size="2">AttributeContent</font></sub></a>, and
        <font size="6">[</font><font size="6">]</font><a href="#jd_map_attr_content_unit" class="judgment"><sub><font size="2">AttributeContent-unit</font></sub></a>, are defined in
        this section and are used for the normalization of the content
        of direct attribute constructors.</p>
      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p id="sec_attribute_normalization">Direct attributes may
        contain namespace-declaration attributes.  The normalization
        rules for attributes ignore namespace-declaration attributes
        -- they are handled by the normalization rules in <a href="#sec_namespace_attrs"><b>[4.7.1.2 Namespace Declaration Attributes]</b></a>.</p>

        <p>An <em>AttributeList</em> is normalized by the following rule,
        which maps each of the individual attribute-value expressions
        in the attribute list and constructs a sequence of the
        normalized values.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
      <font size="6">[</font><table><tbody><tr><td>
          <em>QName</em><sub><font size="2">1</font></sub> S? = S? '"' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><sub><font size="2">0</font></sub> '"'
      </td></tr><tr><td>
          <em>QName</em><sub><font size="2">n</font></sub> S? = S? '""' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><sub><font size="2">n</font></sub> '"'
      </td></tr></tbody></table><font size="6">]</font><a href="#jd_map_attribute" class="judgment"><sub><font size="2">Attribute</font></sub></a>
        
        </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      
      <table><tbody><tr><td>
        (<font size="6">[</font><em>QName</em><sub><font size="2">1</font></sub> S? = S? '"' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><sub><font size="2">0</font></sub> '"'<font size="6">]</font><a href="#jd_map_attribute" class="judgment"><sub><font size="2">Attribute</font></sub></a>
      </td></tr><tr><td>
         ..., 
      </td></tr><tr><td>
        <font size="6">[</font><em>QName</em><sub><font size="2">n</font></sub> S? = S? '"' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><sub><font size="2">n</font></sub> '"'<font size="6">]</font><a href="#jd_map_attribute" class="judgment"><sub><font size="2">Attribute</font></sub></a>)
      </td></tr></tbody></table>
      
      </td></tr>
      </table></div>

      <p id="jd_map_attribute">Namespace-declaration attributes, i.e.,
      those attributes whose prefix is <code>xmlns</code> are ignored
      by mapping them to the empty sequence.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
<table><tbody><tr><td>
      <font size="6">[</font><em>Prefix</em>:<em>LocalPart</em> S? = S? '"'
      <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a> '"'<font size="6">]</font><a href="#jd_map_attribute" class="judgment"><sub><font size="2">Attribute</font></sub></a>
</td></tr><tr><td>
      (<em>Prefix</em> = <code>xmlns</code>)
</td></tr></tbody></table>
        
        </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      
        ()
      
      </td></tr>
      </table></div>

<p>All attributes that are not namespace-declaration attributes are
mapped to computed attribute constructors. 

</p>
      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
<table><tbody><tr><td>
      <font size="6">[</font><em>Prefix</em>:<em>LocalPart</em> S? = S? '"'
      <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a> '"'<font size="6">]</font><a href="#jd_map_attribute" class="judgment"><sub><font size="2">Attribute</font></sub></a>
</td></tr><tr><td>
      <a href="#jd_not" class="judgment"><b>not</b></a>(<em>Prefix</em> = <code>xmlns</code>)
</td></tr></tbody></table>
        
        </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      
        attribute <font size="6">[</font><em>Prefix</em>:<em>LocalPart</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> { <font size="6">[</font><a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><font size="6">]</font><a href="#jd_map_attr_content" class="judgment"><sub><font size="2">AttributeContent</font></sub></a>}
      
      </td></tr>
      </table></div>

      <p id="jd_map_attr_content_unit">As with literal XML elements, we need to distinguish between
      direct attribute constructors that contain one attribute-content
      unit and those that contain multiple attribute-content units,
      because the rule for converting sequences of atomic values into
      strings are applied to sequences within distinct enclosed
      expressions.  If the direct attribute constructor contains
      exactly one attribute-content unit, we simply normalize that
      unit by applying the normalization rule for the attribute
      content:
      </p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font> <em>AttributeValueContent</em><sub><font size="2">1</font></sub>
          <font size="6">]</font><a href="#jd_map_attr_content_unit" class="judgment"><sub><font size="2">AttributeContent-unit</font></sub></a>
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <font size="6">[</font><em>AttributeValueContent</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_attr_content" class="judgment"><sub><font size="2">AttributeContent</font></sub></a>
        
      </td></tr>
      </table></div>

      <p id="jd_map_attr_content">If the direct attribute constructor
      contains more than one attribute-content unit, we normalize each
      unit individually and construct a sequence of the normalized
      results interleaved with empty text nodes.  The empty text nodes
      guarantee that the results of evaluating consecutive
      attribute-content units can be distinguished.  Then we apply the
      function <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>, which applies the
      appropriate conversion rules to the normalized attribute
      content:</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font> <em>AttributeValueContent</em><sub><font size="2">1</font></sub> ...,
          <em>AttributeValueContent</em><sub><font size="2">n</font></sub>
          <font size="6">]</font><a href="#jd_map_attr_content_unit" class="judgment"><sub><font size="2">AttributeContent-unit</font></sub></a>, n &gt; 1
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>((<font size="6">[</font> <em>AttributeValueContent</em><sub><font size="2">1</font></sub>
          <font size="6">]</font><a href="#jd_map_attr_content" class="judgment"><sub><font size="2">AttributeContent</font></sub></a> , text { "" }, ..., text
          {""}, <font size="6">[</font>
          <em>AttributeValueContent</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_attr_content" class="judgment"><sub><font size="2">AttributeContent</font></sub></a>))
        
      </td></tr>
      </table></div>

      <p>Literal characters, escaped curly braces, character
      references, and predefined entity references in attribute
      content are treated as in element content.  In addition, the
      normalization rule for characters in attributes assumes:</p>

      <ol class="enumar"><li><p>that an escaped single or double quote is converted
        to an individual single or double quote.</p></li></ol>

      <p>The following normalization rules take the longest
      consecutive sequence of individual characters that include
      literal characters, escaped curly braces, escaped quotes,
      character references, predefined entity references, and escaped
      single and double quotes and normalizes the character sequence
      as a string. </p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font>( <em>Char</em> | <em>CharRef</em> |
          <em>EscapeQuot</em> | <em>EscapeApos</em> | <em>PredefinedEntityRef</em>
          ) +<font size="6">]</font><a href="#jd_map_attr_content" class="judgment"><sub><font size="2">AttributeContent</font></sub></a>
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          <code>fn:codepoints-to-string</code>(( <em>Char</em> | <em>CharRef</em> |
          <em>EscapeQuot</em> | <em>EscapeApos</em> | <em>PredefinedEntityRef</em>
          )+)
        </td></tr>
      </table></div>

      <p>We normalize an enclosed expression in attribute content by
      normalizing each individual expression in its expression
      sequence and then construct a sequence of the normalized
      values:</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        <font size="6">[</font> { <em>Expr</em><sub><font size="2">0</font></sub>, ..., <em>Expr</em><sub><font size="2">n</font></sub> }
          <font size="6">]</font><a href="#jd_map_attr_content" class="judgment"><sub><font size="2">AttributeContent</font></sub></a>
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        (<font size="6">[</font> <em>Expr</em><sub><font size="2">0</font></sub> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> , ..., <font size="6">[</font>
        <em>Expr</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)
        
      </td></tr>
      </table></div>
    </div><div class="div4">
<h5><a id="sec_namespace_attrs" name="sec_namespace_attrs"/>4.7.1.2 Namespace Declaration Attributes</h5><p><b>Notation</b></p><p id="jd_map_namespace_attr">
The auxiliary mapping rules  <font size="6">[</font><font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttr</font></sub></a>, and
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttrs</font></sub></a> are defined in this section
and 
      are used for the
      normalization of namespace declaration attributes.
</p><p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Direct attributes may contain namespace-declaration
      attributes.  The normalization rules for namespace-declaration
      attributes ignore all non-namespace attributes -- they are
      handled by the normalization rules in <a href="#sec_direct_attributes"><b>[4.7.1.1 Attributes]</b></a>.</p>

      <p>An <em>AttributeList</em> containing namespace-declaration
      attributes is normalized by the following rule, which maps each
      of the individual namespace-declaration attributes in the
      attribute list and constructs a sequence of the normalized
      namespace attribute values.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
      <font size="6">[</font><table><tbody><tr><td>
          <em>QName</em><sub><font size="2">1</font></sub> S? = S? '"' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><sub><font size="2">0</font></sub> '"'
      </td></tr><tr><td>
          <em>QName</em><sub><font size="2">n</font></sub> S? = S? '""' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><sub><font size="2">n</font></sub> '"'
      </td></tr></tbody></table><font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttrs</font></sub></a>
        
        </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      
      <table><tbody><tr><td>
        (<font size="6">[</font><em>QName</em><sub><font size="2">1</font></sub> S? = S? '"' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><sub><font size="2">0</font></sub> '"'<font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttr</font></sub></a>
      </td></tr><tr><td>
         ..., 
      </td></tr><tr><td>
        <font size="6">[</font><em>QName</em><sub><font size="2">n</font></sub> S? = S? '"' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><sub><font size="2">n</font></sub> '"'<font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttr</font></sub></a>)
      </td></tr></tbody></table>
      
      </td></tr>
      </table></div>

      <p>Attributes whose prefix is not <code>xmlns</code> are ignored
      by mapping them to the empty sequence.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
<table><tbody><tr><td>
      <font size="6">[</font><em>Prefix</em>:<em>LocalPart</em> S? = S? '"' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a> '"'<font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttr</font></sub></a>
</td></tr><tr><td>
      not (<em>Prefix</em> = <code>xmlns</code>)
</td></tr></tbody></table>

        </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      
        ()
      
      </td></tr>
      </table></div>

<p>Namespace-declaration attributes are normalized to local
namespace declarations (<em>CompElemNamespace</em>). 
</p>
      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
<table><tbody><tr><td>
      <font size="6">[</font><em>Prefix</em>:<em>LocalPart</em> S? = S? '"' <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a> '"'<font size="6">]</font><a href="#jd_map_namespace_attr" class="judgment"><sub><font size="2">NamespaceAttr</font></sub></a>
</td></tr><tr><td>
      (<em>Prefix</em> = <code>xmlns</code>)
</td></tr></tbody></table>
        
        </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      
        namespace <em>LocalPart</em> { <font size="6">[</font><a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a><font size="6">]</font><a href="#jd_map_attr_content" class="judgment"><sub><font size="2">AttributeContent</font></sub></a>}
      
      </td></tr>
      </table></div>

    </div><div class="div4">
<h5><a id="sec_content" name="sec_content"/>4.7.1.3 Content</h5><p>The rules for normalizing element content are given above in
<a href="#id_element_constructor"><b>[4.7.1 Direct Element Constructors]</b></a>.</p></div><div class="div4">
<h5><a id="sec_whitespace" name="sec_whitespace"/>4.7.1.4 Whitespace in Element Content</h5><p><a href="http://www.w3.org/TR/xquery#id-whitespace">Section 
3.7.1.4 Boundary Whitespace</a><sup><small>XQ</small></sup> describes
      how whitespace in element and attribute constructors is
      processed depending on the value of the <code>xmlspace</code>
      declaration in the query prolog.  the Formal Semantics assumes
      that the rules for handling whitespace are applied prior to
      normalization rules, for example, during parsing of a query.
      Therefore, there are no formal rules for handling
      whitespace.</p></div></div><div class="div3">
<h4><a id="sec_other_constructors" name="sec_other_constructors"/>4.7.2 Other Direct Constructors</h4>
<h5><a id="N159FF" name="N159FF"/>Other Constructors</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-DirPIConstructor" name="doc-xquery-DirPIConstructor"/>[<small>105 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DirPIConstructor">DirPIConstructor</a></code></td><td>   ::=   </td><td><code>"&lt;?"  PITarget  (S  <a href="#doc-xquery-DirPIContents">DirPIContents</a>)?  "?&gt;"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DirPIContents" name="doc-xquery-DirPIContents"/>[<small>106 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DirPIContents">DirPIContents</a></code></td><td>   ::=   </td><td><code>(Char* - (Char* '?&gt;' Char*))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DirCommentConstructor" name="doc-xquery-DirCommentConstructor"/>[<small>103 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DirCommentConstructor">DirCommentConstructor</a></code></td><td>   ::=   </td><td><code>"&lt;!--"  <a href="#doc-xquery-DirCommentContents">DirCommentContents</a>  "--&gt;"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-DirCommentContents" name="doc-xquery-DirCommentContents"/>[<small>104 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DirCommentContents">DirCommentContents</a></code></td><td>   ::=   </td><td><code>((Char - '-')  |  ('-'  (Char - '-')))*</code></td></tr></tbody></table><p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>

      <p>A literal XML processing instruction is normalized into a
      computed processing-instruction constructor; its character
      content is converted to a string as in attribute content.</p>

   <div align="center"><table cellpadding="0" cellspacing="0" summary="">
    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <font size="6">[</font>&lt;? <em>NCName</em> <em>Char</em>* ?&gt;"<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
     
    </td></tr>
    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
     
      <font size="6">[</font>processing-instruction <em>NCName</em> { <em>Char</em>* }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
     
    </td></tr>
   </table></div>

    <p>A literal XML comment is normalized into a computed comment
    constructor; its character content is converted to a string as in
    attribute content.</p>

    <div align="center"><table cellpadding="0" cellspacing="0" summary="">
    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
    
     <font size="6">[</font>&lt;!-- <em>Char</em>* --&gt;<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
    
    </td></tr>
    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
    
     <font size="6">[</font>comment { <em>Char</em>* }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
    
    </td></tr>
    </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>There are no additional static type rules for direct
      processing-instruction or comment constructors.</p>
    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>There are no additional dynamic evaluation rules for direct
      processing-instruction or comment constructors.</p>
    </div><div class="div3">
<h4><a id="sec_computedConstructors" name="sec_computedConstructors"/>4.7.3 Computed Constructors</h4>
<h5><a id="N15AAF" name="N15AAF"/>Computed Constructors</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ComputedConstructor" name="doc-xquery-ComputedConstructor"/>[<small>109 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ComputedConstructor">ComputedConstructor</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-CompDocConstructor">CompDocConstructor</a><br/>|  <a href="#doc-xquery-CompElemConstructor">CompElemConstructor</a><br/>|  <a href="#doc-xquery-CompAttrConstructor">CompAttrConstructor</a><br/>|  <a href="#doc-xquery-CompTextConstructor">CompTextConstructor</a><br/>|  <a href="#doc-xquery-CompCommentConstructor">CompCommentConstructor</a><br/>|  <a href="#doc-xquery-CompPIConstructor">CompPIConstructor</a></code></td></tr></tbody></table><div class="div4">
<h5><a id="sec_comp_elem_constructor" name="sec_comp_elem_constructor"/>4.7.3.1 Computed Element Constructors</h5><p><b>Introduction</b></p><p>This section describes the semantics of computed
    element constructors. Remember that direct element constructors
    are normalized into computed element constructors. This document
    does not formally specify how namespaces are copied. The semantics
    of namespaces copying in element constructors can be found in
    <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a>.</p>
<h5><a id="N15AEB" name="N15AEB"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-CompElemConstructor" name="doc-xquery-CompElemConstructor"/>[<small>111 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CompElemConstructor">CompElemConstructor</a></code></td><td>   ::=   </td><td><code>"element"  (QName  |  ("{"  <a href="#doc-xquery-Expr">Expr</a>  "}"))  "{"  <a href="#doc-xquery-ContentExpr">ContentExpr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ContentExpr" name="doc-xquery-ContentExpr"/>[<small>112 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ContentExpr">ContentExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-Expr">Expr</a></code></td></tr></tbody></table><p><b>Notation</b></p>
      <p id="jd_split_namespaces">Local namespace declarations may
      occur explicitly in a computed element constructor or may be the
      result of normalizing namespace-declaration attributes contained
      in direct element constructors.  For local element declarations
      that occur explicitly in a query, the immediately enclosing
      expression of the local namespace declaration
      (<em>CompElemNamespace</em>) must be a computed element constructor;
      otherwise, as specified in [XPath/XQuery], a static error is
      raised.</p>
    <p><b>Core Grammar</b></p>
      <p>The Core grammar productions for computed element
      constructors are:</p>

      
<h5><a id="N15B20" name="N15B20"/>Computed Element Constructors</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-CompElemConstructor" name="doc-core-CompElemConstructor"/>[<small>75 (Core)</small>]   </td><td><code><a href="#prod-core-CompElemConstructor">CompElemConstructor</a></code></td><td>   ::=   </td><td><code>"element"  (<a href="#prod-core-QName">QName</a>  |  ("{"  <a href="#doc-core-Expr">Expr</a>  "}"))  "{"  <a href="#doc-core-ContentExpr">ContentExpr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ContentExpr" name="doc-core-ContentExpr"/>[<small>76 (Core)</small>]   </td><td><code><a href="#prod-core-ContentExpr">ContentExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-Expr">Expr</a></code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>If the content expression is missing, the computed element
      constructor is normalized as if its content expression was the
      empty sequence.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>element <em>QName</em> { }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font>element <em>QName</em> { () }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
      </table></div>

      <p>Computed element constructors using the
      <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a> function over their content
      expression.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>element <em>QName</em> { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
         element <em>QName</em> { <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) }
        
       </td></tr>
      </table></div>

      <p>When the name of the element is also computed, the
      normalization rule applies atomization to the name
      expression.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>element { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          element { <code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) }{ <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) }
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The normalization rules of direct element and attribute
      constructors leave us with only the computed forms of
      constructors. The static semantic for constructors is defined on
      all the computed forms. The computed element constructor itself
      has two forms: one in which the element name is a literal
      <em>QName</em>, and the other in which the element name is a
      computed expression.</p>

      <p>A computed element constructor creates a new element with
      either the <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup>
      <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a> (in strip construction mode), or with the
      <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> <code>xs:anyType</code> (in
      preserve construction mode). The content expression must return
      a sequence of nodes with attribute nodes at the beginning.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      
 	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = preserve
 	      
 	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                      attribute *, (element | text | comment | processing-instruction) * 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	    <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	             element <em>QName</em> { <em>Expr</em> }
	            <a href="#jd_has_type" class="judgment"><b>:</b></a> element <em>QName</em> of type <code>xs:anyType</code>
	      
	    
	  </td></tr>
	</table><br/>
      </div>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      
 	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = strip
 	      
 	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                      attribute *, (element | text | comment | processing-instruction) * 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	    <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	             element <em>QName</em> { <em>Expr</em> }
	            <a href="#jd_has_type" class="judgment"><b>:</b></a> element <em>QName</em> of type <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a>
	      
	    
	  </td></tr>
	</table><br/>
      </div>

      <p>In case the element name is computed as well, the name
      expression must be of type <code>xs:QName</code>, <code>xs:string</code>, or
      <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      
 	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = preserve
 	      
 	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                      (<code>xs:QName</code> | <code>xs:string</code> | <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>) 
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                      attribute *, (element | text | comment | processing-instruction) * 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	    <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	             element { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }
	            <a href="#jd_has_type" class="judgment"><b>:</b></a> element of type <code>xs:anyType</code>
	      
	    
	  </td></tr>
	</table><br/>
      </div>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      
 	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = strip
 	      
 	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                      (<code>xs:QName</code> | <code>xs:string</code> | <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>) 
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
              
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	       <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                      attribute *, (element | text | comment | processing-instruction) * 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	    <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	             element { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }
	            <a href="#jd_has_type" class="judgment"><b>:</b></a> element of type <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a>
	      
	    
	  </td></tr>
	</table><br/>
      </div>

     <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
       <p>The following rules take a computed element constructor
       expression and construct an element node.  The dynamic
       semantics for computed element constructors is the most complex
       of all expressions in XQuery.  Here is how to read the rule
       below.</p>

       <p>First, the element's content expression is partitioned into
       the local namespace declarations and all other expressions, and
       the local namespace declarations are evaluated, yielding a
       sequence of namespace bindings.  The static environment is
       extended to include the new namespace bindings, which are all
       <a href="#term_active">active</a>.  In <a href="http://www.w3.org/TR/xquery#id-namespaces">Section 
3.7.1.2 Namespace Declaration Attributes</a><sup><small>XQ</small></sup>, it is implementation-defined whether
       undeclaration of namespace prefixes (by setting the namespace
       prefix to the zero-length string) in an element constructor is
       supported.  In the dynamic semantics below, we assume all local
       namespace declarations declare a binding of a prefix to a
       URI.</p>

      <p>Second, the function <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a> is applied to
      the element's content expression (excluding local namespace
      declarations); this function call is evaluated in the new static
      and dynamic environment.  Recall from <a href="#id_element_constructor"><b>[4.7.1 Direct Element Constructors]</b></a> that during normalization, we do
      not convert the content of direct element constructors that
      contain one element-content unit.  This guarantees that useful
      type information is preserved for static analysis.  Since the
      conversion function <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a> was not applied to
      all element constructors during normalization, we have to apply
      it at evaluation time.  (Obviously, it is possible to elide the
      application of <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a> injected during
      normalization and the application injected during evaluation.)
      The resulting value <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> must match zero-or-more
      attributes followed by zero-or-more element, text,
      processing-instruction or comment nodes.</p>

      <p>Third, The namespace bindings are concatenated with the list
      of active namespaces in the namespace environment <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>
      and the namespaces corresponding to the element's name and all
      attributes names.  The resulting sequence is the sequence of
      namespace bindings for the element.</p>

       <div align="center">
	 <table cellpadding="0" cellspacing="0" summary="">
	   <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	       
		  <em>Expr</em> = <em>CompElemNamespace</em><sub><font size="2">1</font></sub>, ..., <em>CompElemNamespace</em><sub><font size="2">n</font></sub>, (<em>Expr</em><sub><font size="2">0</font></sub>) 
	       
	     </td></tr>

            <tr valign="middle" align="center"><td> 
                      
            <em>CompElemNamespace</em><sub><font size="2">1</font></sub> = namespace <em>NCName</em><sub><font size="2">1</font></sub> { <em>URI</em><sub><font size="2">1</font></sub> }
            
            </td></tr>
	     <tr valign="middle" align="center"><td>
               ...
             </td></tr>
            <tr valign="middle" align="center"><td>
                      
            <em>CompElemNamespace</em><sub><font size="2">n</font></sub> = namespace  <em>NCName</em><sub><font size="2">n</font></sub> { <em>URI</em><sub><font size="2">n</font></sub> }
            
            </td></tr>
            <tr valign="middle" align="center"><td>
            
            
              <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> = 
              <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em><sub><font size="2">1</font></sub> =&gt; (active, <em>URI</em><sub><font size="2">1</font></sub>)) 
            
            
            </td></tr>
            <tr valign="middle" align="center"><td>
            ...
            </td></tr>
            <tr valign="middle" align="center"><td>
            
            
              <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub> = 
              <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n-1</font></sub> + <a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em><sub><font size="2">n</font></sub> =&gt; (active, <em>URI</em><sub><font size="2">n</font></sub>)) 
            
            
            </td></tr>

	     <tr valign="middle" align="center"><td>
	       
		 <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>; <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		  <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>(<em>Expr</em><sub><font size="2">0</font></sub>) <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> 
	       
	     </td></tr>
	     <tr valign="middle" align="center"><td>
	       
		  <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> (attribute*, (element | text | processing-instruction | comment)*)
	       
	     </td></tr>

	     <tr valign="middle" align="center"><td>
	       
		 <a href="#doc-fs-NamespaceBindings"><em>NamespaceBindings</em></a> = 
		 <em>CompElemNamespace</em><sub><font size="2">1</font></sub>,
		 ..., <em>CompElemNamespace</em><sub><font size="2">n</font></sub>,
		 <a href="#fs_activeNS">fs:<code>active_ns</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>),
		 <a href="#fs_ns_from_items">fs:<code>get_static_ns_from_items</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub>)
	       
	     </td></tr>

	   </table></td></tr></table></td></tr>
	   <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	     <a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
	       
		     element <em>QName</em> { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub>
	       
	     
	   </td></tr>
	 </table><br/>
       </div>

       <p>The dynamic evaluation of an element constructor with a
       computed name is similar.  There is one additional rule that
       checks that the value of the element's name expression matches
       <code>xs:QName</code>.</p>

       <div align="center">
	 <table cellpadding="0" cellspacing="0" summary="">
	   <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	       
		 <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b><em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub>
		 
	           
	       
                 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		 <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <code>xs:QName</code>
		 
	       
	     </td></tr>
	     <tr valign="middle" align="center"><td>
	       
		  <em>Expr</em><sub><font size="2">2</font></sub> = <em>CompElemNamespace</em><sub><font size="2">1</font></sub>, ..., <em>CompElemNamespace</em><sub><font size="2">n</font></sub>, (<em>Expr</em><sub><font size="2">3</font></sub>) 
	       
	     </td></tr>

            <tr valign="middle" align="center"><td> 
                      
            <em>CompElemNamespace</em><sub><font size="2">1</font></sub> = namespace
            <em>NCName</em><sub><font size="2">1</font></sub> { <em>URI</em><sub><font size="2">1</font></sub> }
            
            </td></tr>
            <tr valign="middle" align="center"><td>
            ...
            </td></tr>

            <tr valign="middle" align="center"><td>
                      
            <em>CompElemNamespace</em><sub><font size="2">n</font></sub> = namespace  <em>NCName</em><sub><font size="2">n</font></sub> { <em>URI</em><sub><font size="2">n</font></sub> }
            
            </td></tr>

            <tr valign="middle" align="center"><td>
            
            
              <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> = 
              <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em> =&gt; (active, <em>URI</em><sub><font size="2">1</font></sub>)) 
            
            
            </td></tr>
            <tr valign="middle" align="center"><td>
            ...
            </td></tr>
            <tr valign="middle" align="center"><td>
            
            
              <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub> = 
              <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n-1</font></sub> + <a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em> =&gt; (active, <em>URI</em><sub><font size="2">n</font></sub>)) 
            
            
            </td></tr>

	     <tr valign="middle" align="center"><td>
	       
		 <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>, <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		  <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>(<em>Expr</em><sub><font size="2">3</font></sub>) <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> 
	       
	     </td></tr>
	     <tr valign="middle" align="center"><td>
	       
                 <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub><b> |- </b>
		  <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> (attribute*, (element | text | processing-instruction | comment)*)
	       
	     </td></tr>

	     <tr valign="middle" align="center"><td>
	       
		 <a href="#doc-fs-NamespaceBindings"><em>NamespaceBindings</em></a> = 
		 <em>CompElemNamespace</em><sub><font size="2">1</font></sub>,
		 ..., <em>CompElemNamespace</em><sub><font size="2">n</font></sub>,
		 <a href="#fs_activeNS">fs:<code>active_ns</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>),
		 <a href="#fs_ns_from_items">fs:<code>get_static_ns_from_items</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)
	       
	     </td></tr>

	   </table></td></tr></table></td></tr>
	   <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	     <a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
	       
		     element { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }  <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
	       
	     
	   </td></tr>
	 </table><br/>
       </div>

    </div><div class="div4">
<h5><a id="sec_attribute_constructor" name="sec_attribute_constructor"/>4.7.3.2 Computed Attribute Constructors</h5>
<h5><a id="N161B1" name="N161B1"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-CompAttrConstructor" name="doc-xquery-CompAttrConstructor"/>[<small>113 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CompAttrConstructor">CompAttrConstructor</a></code></td><td>   ::=   </td><td><code>"attribute"  (QName  |  ("{"  <a href="#doc-xquery-Expr">Expr</a>  "}"))  "{"  <a href="#doc-xquery-Expr">Expr</a>?  "}"</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
        <p>The Core grammar production for computed attribute
        constructors is:</p>

      
<h5><a id="N161D2" name="N161D2"/>Computed Attribute Constructors</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-CompAttrConstructor" name="doc-core-CompAttrConstructor"/>[<small>77 (Core)</small>]   </td><td><code><a href="#prod-core-CompAttrConstructor">CompAttrConstructor</a></code></td><td>   ::=   </td><td><code>"attribute"  (<a href="#prod-core-QName">QName</a>  |  ("{"  <a href="#doc-core-Expr">Expr</a>  "}"))  "{"  <a href="#doc-core-Expr">Expr</a>  "}"</code></td></tr></tbody></table>
      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>Computed attribute constructors are normalized by mapping
        their name and content expression in a similar way as computed
        element constructors. The normalization rule uses the
        <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a> function.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
         <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          
           <font size="6">[</font>attribute <em>QName</em> { }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
         </td></tr>
         <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
           <font size="6">[</font>attribute <em>QName</em> { () }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
         </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
         <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          
           <font size="6">[</font>attribute <em>QName</em> { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
         </td></tr>
         <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          attribute <em>QName</em> { <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) }
          
         </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
         <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          
           <font size="6">[</font>attribute { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
         </td></tr>
         <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
            attribute { <code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) } { <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) }
          
         </td></tr>
        </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The normalization rules for direct attribute constructors
      leave us with only the computed form of the attribute
      constructors.  Like in a computed element constructor, a
      computed attribute constructor has two forms: one in which the
      attribute name is a literal <em>QName</em>, and the other in which
      the attribute name is a computed expression.</p>

      <p>In the case of attribute constructors, the <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> is always
      <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.</p>

     <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
              
	        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>
              
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	    
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	       attribute <em>QName</em> { <em>Expr</em> } <a href="#jd_has_type" class="judgment"><b>:</b></a> attribute <em>QName</em> of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>
	      
	    
	  </td></tr>
	</table><br/>
       </div>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
              
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	       <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                      (<code>xs:QName</code> | <code>xs:string</code> | <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>) 
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
              
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	       <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	    <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	             attribute { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }
	            <a href="#jd_has_type" class="judgment"><b>:</b></a> attribute of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>
	      
	    
	  </td></tr>
	</table><br/>
     </div>

     <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
       <p>The following rules take a computed attribute constructor
       expression and construct an attribute node.  The rules are
       similar to those rules for element constructors.  First, the
       attribute's name is expanded into a qualified name.  Second,
       the function <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a> is applied to the
       content expression and this function call is evaluated in the
       dynamic environment.  Recall from <a href="#sec_attribute_constructor"><b>[4.7.3.2 Computed Attribute Constructors]</b></a> that during normalization, we
       do not convert the content of direct attribute constructors
       that contain one attribute-content unit.  This guarantees that
       useful type information is preserved for static analysis.
       Since the conversion function <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>
       was not applied to all attribute constructors during
       normalization, we have to apply it at evaluation time.  (As
       before, it is possible to elide the application of
       <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a> injected during normalization
       and the application injected during evaluation.)</p>

       <div align="center">
	 <table cellpadding="0" cellspacing="0" summary="">
	   <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <em>QName</em> <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>

	     </td></tr>
	     <tr valign="middle" align="center"><td>
	       
		 <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		 <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>(<em>Expr</em>) <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a> 
	       
	     </td></tr>
	   </table></td></tr></table></td></tr>
	   <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	     <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
	       
		     attribute <em>QName</em> { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
		     attribute <a href="#id-expanded-qnames"><em>expanded-QName</em></a> of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> { <a href="#doc-fs-Value"><em>Value</em></a> }
	       
	     
	   </td></tr>
	 </table><br/>
       </div>

       <div align="center">
	 <table cellpadding="0" cellspacing="0" summary="">
	   <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	       
		 <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
		 
	       
	     </td></tr>
	     <tr valign="middle" align="center"><td>
	       
                 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		 <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <code>xs:QName</code>
		 
	       
	     </td></tr>
	     <tr valign="middle" align="center"><td>
	       
                 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		 <em>QName</em><sub><font size="2">1</font></sub> = <code>xs:QName</code>(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)
		 
	       
	     </td></tr>
	     <tr valign="middle" align="center"><td>
	       
		 <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		  <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a>(<em>Expr</em><sub><font size="2">2</font></sub>) <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
	       
	     </td></tr>
	   </table></td></tr></table></td></tr>
	   <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	     <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
	       
		 attribute { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
		 attribute <em>QName</em><sub><font size="2">1</font></sub> of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> { <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> }
	       
	     
	   </td></tr>
	 </table><br/>
       </div>
    </div><div class="div4">
<h5><a id="sec_documentConstructors" name="sec_documentConstructors"/>4.7.3.3 Document Node Constructors</h5>
<h5><a id="N16509" name="N16509"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-CompDocConstructor" name="doc-xquery-CompDocConstructor"/>[<small>110 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CompDocConstructor">CompDocConstructor</a></code></td><td>   ::=   </td><td><code>"document"  "{"  <a href="#doc-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The Core grammar production for a computed document
      constructor is:</p>

      
<h5><a id="N1651E" name="N1651E"/>Core computed document constructor</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-CompDocConstructor" name="doc-core-CompDocConstructor"/>[<small>74 (Core)</small>]   </td><td><code><a href="#prod-core-CompDocConstructor">CompDocConstructor</a></code></td><td>   ::=   </td><td><code>"document"  "{"  <a href="#doc-core-Expr">Expr</a>  "}"</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>A document node constructor contains an expression, which
      must evaluate to a sequence of element, text, comment, or
      processing-instruction nodes.  <a href="http://www.w3.org/TR/xquery#id-documentConstructors">Section 
3.7.3.3 Document Node Constructors</a><sup><small>XQ</small></sup> specifies the rules for
      converting a sequence of atomic values and nodes into a sequence
      of nodes before document construction.  The built-in function
      <a href="#sec_items_to_nodes"><b>[7.1.5 The fs:item-sequence-to-node-sequence function]</b></a> implements this
      conversion.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>document { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          document { <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) }
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The static semantics checks that the type of the argument
      expression is a sequence of element, text,
      processing-instruction, and comment nodes. The type of the
      entire expression is the most general <code>document</code>
      type, because the document constructor erases all <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> on its content nodes.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
              
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
		  <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (element | text | processing-instruction | comment)* 
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  document { <em>Expr</em> } <a href="#jd_has_type" class="judgment"><b>:</b></a> document { <a href="#doc-fs-Type"><em>Type</em></a> }
		
	      
	    </td></tr>
	  </table><br/>
	</div>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>The dynamic semantics checks that the argument expression
      evaluates to a value that is a sequence of element, text,
      processing-instruction, or comment nodes. The entire expression
      evaluates to a new document node value. If the construction mode
      is set to <code>strip</code>, the <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> for all the nodes in content of a
      document node are erased.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      
 	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = preserve
 	      
 	    </td></tr>
             <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a> 
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> (element | text | processing-instruction | comment)* 
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      document { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> document { <a href="#doc-fs-Value"><em>Value</em></a> }
		
	      
	    </td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_construction_mode_env" class="env">constructionMode</a> = strip
	      
	    </td></tr>
             <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      
		
		      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> 
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> (element | text | processing-instruction | comment)* 
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      document { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> document { <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> }
		
	      
	    </td></tr>
	  </table><br/>
	</div>
    </div><div class="div4">
<h5><a id="sec_textConstructors" name="sec_textConstructors"/>4.7.3.4 Text Node Constructors</h5>
<h5><a id="N166DA" name="N166DA"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-CompTextConstructor" name="doc-xquery-CompTextConstructor"/>[<small>114 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CompTextConstructor">CompTextConstructor</a></code></td><td>   ::=   </td><td><code>"text"  "{"  <a href="#doc-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The Core grammar production for a computed text constructor
      is:</p>

      
<h5><a id="N166EF" name="N166EF"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-CompTextConstructor" name="doc-core-CompTextConstructor"/>[<small>78 (Core)</small>]   </td><td><code><a href="#prod-core-CompTextConstructor">CompTextConstructor</a></code></td><td>   ::=   </td><td><code>"text"  "{"  <a href="#doc-core-Expr">Expr</a>  "}"</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>A text node constructor contains an expression, which must
      evaluate to an <code>xs:string</code> value. <a href="http://www.w3.org/TR/xquery#id-textConstructors">Section 
3.7.3.4 Text Node Constructors</a><sup><small>XQ</small></sup> specifies the rules for converting a
      sequence of atomic values into a string prior to construction of
      a text node.  Each node is replaced by its string value. For
      each adjacent sequence of one or more atomic values returned by
      an enclosed expression, a untyped atomic value is constructed,
      containing the canonical lexical representation of all the
      atomic values, with a single blank character inserted between
      adjacent values.  As formal specification of these conversion
      rules is not instructive, <a href="#sec_item_seq_to_untypedAtomic"><b>[7.1.6 The fs:item-sequence-to-untypedAtomic function]</b></a> implements this
      conversion.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>text { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
         text {
         (<a href="#sec_item_seq_to_untypedAtomic_text"><em>fs:</em><code>item-sequence-to-untypedAtomic-text</code></a>(<code>fn:data</code>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>))))
         cast as <code>xs:string</code>? }
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The static semantics checks that the argument expression has
      type <code>xs:string</code> or <code>empty</code>. The type of the entire
      expression is an optional text node type, as the text node
      constructor returns the empty sequence if its argument is the
      empty sequence.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:string</code>?
		
	      
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      text { <em>Expr</em> } <a href="#jd_has_type" class="judgment"><b>:</b></a> text?
		
	      
	    </td></tr>
	  </table><br/>
	</div>
    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>If the argument expression returns the empty sequence, the
      text node constructor returns the empty sequence.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
                  <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <code>()</code>
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		  text { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <code>()</code>
		
	      
	    </td></tr>
	  </table><br/>
	</div>

      <p>If the argument expression returns a value of type
      <code>xs:string</code>, the text node constructor returns a text node with
      that string as content.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
                  <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a> 
		
	          
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <code>xs:string</code> 
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		  text { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> text { <a href="#doc-fs-Value"><em>Value</em></a> }
		
	      
	    </td></tr>
	  </table><br/>
	</div>
    </div><div class="div4">
<h5><a id="sec_computed-pis" name="sec_computed-pis"/>4.7.3.5 Computed Processing Instruction Constructors</h5>
<h5><a id="N16827" name="N16827"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-CompPIConstructor" name="doc-xquery-CompPIConstructor"/>[<small>116 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CompPIConstructor">CompPIConstructor</a></code></td><td>   ::=   </td><td><code>"processing-instruction"  (NCName  |  ("{"  <a href="#doc-xquery-Expr">Expr</a>  "}"))  "{"  <a href="#doc-xquery-Expr">Expr</a>?  "}"</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The Core grammar production for computed
      processing-instruction constructors is:</p>

      
<h5><a id="N16848" name="N16848"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-CompPIConstructor" name="doc-core-CompPIConstructor"/>[<small>80 (Core)</small>]   </td><td><code><a href="#prod-core-CompPIConstructor">CompPIConstructor</a></code></td><td>   ::=   </td><td><code>"processing-instruction"  (<a href="#prod-core-NCName">NCName</a>  |  ("{"  <a href="#doc-core-Expr">Expr</a>  "}"))  "{"  <a href="#doc-core-Expr">Expr</a>?  "}"</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Computed processing-instruction constructors are normalized
      by mapping their name and content expression in the same way
      that computed element and attribute constructors are
      normalized.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>processing-instruction  <em>NCName</em> { }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>processing-instruction  <em>NCName</em> { () }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>processing-instruction  <em>NCName</em> { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        processing-instruction <em>NCName</em> { <a href="#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) } 
        
       </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>processing-instruction  { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         processing-instruction  { <code>fn:data</code>((<font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) } { <a href="#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a>((<font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) }
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The static typing rules for processing-instruction
      constructors are straightforward.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> 
		
	      
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      processing-instruction  <em>NCName</em> { <em>Expr</em> }
		      <a href="#jd_has_type" class="judgment"><b>:</b></a> processing-instruction
		
	      
	    </td></tr>
	  </table><br/>
	</div>
	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
	      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> (<code>xs:NCName</code> | <code>xs:string</code> | <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>)
		
	          
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
	      <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> 
		
	      
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      processing-instruction  { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }
		      <a href="#jd_has_type" class="judgment"><b>:</b></a> processing-instruction
		
	      
	    </td></tr>
	  </table><br/>
	</div>
    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>The dynamic evaluation rules for computed processing
      instructions are straightforward.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
	      <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
		
	          
       	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
	      <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
	      processing-instruction  <em>NCName</em> { <em>Expr</em> }
	      <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> processing-instruction <em>NCName</em> { <a href="#doc-fs-Value"><em>Value</em></a> }
		
	      
	    </td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
		
	      
              </td></tr>
              <tr valign="middle" align="center"><td>
       	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <code>xs:NCName</code> 
		
	      
              </td></tr>
              <tr valign="middle" align="center"><td>
       	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <code>xs:NCName</code>(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>) <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <em>NCName</em><sub><font size="2">1</font></sub>
		
	      
              </td></tr>
              <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
		
	          
       	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> 
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      processing-instruction  { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }
		      <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> processing-instruction <em>NCName</em><sub><font size="2">1</font></sub> { <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> }
		
	      
	    </td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
		
	      
              </td></tr>
              <tr valign="middle" align="center"><td>
       	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <code>xs:string</code> 
		
	      
              </td></tr>
              <tr valign="middle" align="center"><td>
       	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <code>xs:NCName</code>(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>); <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <em>NCName</em><sub><font size="2">1</font></sub>
		
	      
              </td></tr>
              <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
		
	          
       	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> 
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      processing-instruction  { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }
		      <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> processing-instruction <em>NCName</em><sub><font size="2">1</font></sub> { <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> }
		
	      
	    </td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
		
	      
              </td></tr>
              <tr valign="middle" align="center"><td>
       	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>
		
	      
              </td></tr>
              <tr valign="middle" align="center"><td>
       	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <code>xs:NCName</code>(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>) <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <em>NCName</em><sub><font size="2">1</font></sub>
		
	      
              </td></tr>
              <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
		
	          
       	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> 
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      processing-instruction  { <em>Expr</em><sub><font size="2">1</font></sub> } { <em>Expr</em><sub><font size="2">2</font></sub> }
		      <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> processing-instruction <em>NCName</em><sub><font size="2">1</font></sub> { <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> }
		
	      
	    </td></tr>
	  </table><br/>
	</div>
    </div><div class="div4">
<h5><a id="sec_computed-comments" name="sec_computed-comments"/>4.7.3.6 Computed Comment Constructors</h5>
<h5><a id="N16C85" name="N16C85"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-CompCommentConstructor" name="doc-xquery-CompCommentConstructor"/>[<small>115 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CompCommentConstructor">CompCommentConstructor</a></code></td><td>   ::=   </td><td><code>"comment"  "{"  <a href="#doc-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The Core grammar production for computed comment constructors
      is:</p>


<h5><a id="N16C9A" name="N16C9A"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-CompCommentConstructor" name="doc-core-CompCommentConstructor"/>[<small>79 (Core)</small>]   </td><td><code><a href="#prod-core-CompCommentConstructor">CompCommentConstructor</a></code></td><td>   ::=   </td><td><code>"comment"  "{"  <a href="#doc-core-Expr">Expr</a>  "}"</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Computed comment constructors are normalized by mapping their
      content expression.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
 	
         <font size="6">[</font>comment { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        comment { (<a href="#sec_item_seq_to_untypedAtomic_comment"><em>fs:</em><code>item-sequence-to-untypedAtomic-comment</code></a>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>))) cast as <code>xs:string</code> } 
        
       </td></tr>
      </table></div>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static typing rule for computed comment constructors is
        straightforward.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:string</code> 
		
	      
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      comment { <em>Expr</em> }
		      <a href="#jd_has_type" class="judgment"><b>:</b></a> comment
		
	      
	    </td></tr>
	  </table><br/>
	</div>
<p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
<p>
The dynamic evaluation rule for computed comment constructors is
straightforward. 
</p>
	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a> 
		
	          
       	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		      <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <code>xs:string</code> 
		
	      
            </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
		
		      comment { <em>Expr</em> }
		      <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> comment { <a href="#doc-fs-Value"><em>Value</em></a> }
		
	      
	    </td></tr>
	  </table><br/>
	</div>
</div></div><div class="div3">
<h4><a id="id-ns-nodes-on-elements" name="id-ns-nodes-on-elements"/>4.7.4 In-scope Namespaces of a Constructed Element</h4><p>The effect of in-scope namespaces on constructed elements is
      specified in <a href="#id_element_constructor"><b>[4.7.1 Direct Element Constructors]</b></a> and
      <a href="#sec_comp_elem_constructor"><b>[4.7.3.1 Computed Element Constructors]</b></a>. </p></div></div><div class="div2">
<h3><a id="sec_for-expressions" name="sec_for-expressions"/>4.8 [For/FLWOR] Expressions</h3><p><b>Introduction</b></p>
      <p>[XPath/XQuery] provides [For/FLWOR] expressions for iteration, for
      binding variables to intermediate results, and filtering bound
      variables according to a predicate.</p>

      <p>A <em>FLWORExpr</em> in XQuery 1.0 consists of a sequence of
      <em>ForClause</em>s and <em>LetClause</em>s, followed by an optional
      <em>WhereClause</em>, followed by the , as described by the
      following grammar productions. Each variable binding is preceded
      by an optional type declaration which specify the type expected
      for the variable.</p>

      <p>The dynamic semantics of the ordering mode in FLWOR
      expressions is not specified formally. The dynamic semantics is
      not specified formally as it would require the introduction of
      tuples, which are not supported in the [XPath/XQuery] data
      model.</p>

      
<h5><a id="N16D9F" name="N16D9F"/>[For/FLWOR] Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-FLWORExpr" name="doc-xquery-FLWORExpr"/>[<small>33 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-FLWORExpr">FLWORExpr</a></code></td><td>   ::=   </td><td><code>(<a href="#doc-xquery-ForClause">ForClause</a>  |  <a href="#doc-xquery-LetClause">LetClause</a>)+  <a href="#doc-xquery-WhereClause">WhereClause</a>?  <a href="#doc-xquery-OrderByClause">OrderByClause</a>?  "return"  <a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ForClause" name="doc-xquery-ForClause"/>[<small>34 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ForClause">ForClause</a></code></td><td>   ::=   </td><td><code>"for"  "$"  <a href="#doc-xquery-VarName">VarName</a>  <a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>?  <a href="#doc-xquery-PositionalVar">PositionalVar</a>?  "in"  <a href="#doc-xquery-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#doc-xquery-VarName">VarName</a>  <a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>?  <a href="#doc-xquery-PositionalVar">PositionalVar</a>?  "in"  <a href="#doc-xquery-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-LetClause" name="doc-xquery-LetClause"/>[<small>36 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-LetClause">LetClause</a></code></td><td>   ::=   </td><td><code>"let"  "$"  <a href="#doc-xquery-VarName">VarName</a>  <a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>?  ":="  <a href="#doc-xquery-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#doc-xquery-VarName">VarName</a>  <a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>?  ":="  <a href="#doc-xquery-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-TypeDeclaration" name="doc-xquery-TypeDeclaration"/>[<small>118 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-TypeDeclaration">TypeDeclaration</a></code></td><td>   ::=   </td><td><code>"as"  <a href="#doc-xquery-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-PositionalVar" name="doc-xquery-PositionalVar"/>[<small>35 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-PositionalVar">PositionalVar</a></code></td><td>   ::=   </td><td><code>"at"  "$"  <a href="#doc-xquery-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-WhereClause" name="doc-xquery-WhereClause"/>[<small>37 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-WhereClause">WhereClause</a></code></td><td>   ::=   </td><td><code>"where"  <a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-OrderByClause" name="doc-xquery-OrderByClause"/>[<small>38 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-OrderByClause">OrderByClause</a></code></td><td>   ::=   </td><td><code>(("order"  "by")  |  ("stable"  "order"  "by"))  <a href="#doc-xquery-OrderSpecList">OrderSpecList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-OrderSpecList" name="doc-xquery-OrderSpecList"/>[<small>39 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-OrderSpecList">OrderSpecList</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-OrderSpec">OrderSpec</a>  (","  <a href="#doc-xquery-OrderSpec">OrderSpec</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-OrderSpec" name="doc-xquery-OrderSpec"/>[<small>40 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-OrderSpec">OrderSpec</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ExprSingle">ExprSingle</a>  <a href="#doc-xquery-OrderModifier">OrderModifier</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-OrderModifier" name="doc-xquery-OrderModifier"/>[<small>41 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-OrderModifier">OrderModifier</a></code></td><td>   ::=   </td><td><code>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  URILiteral)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-ForExpr" name="doc-xpath-ForExpr"/>[<small>4 (XPath)</small>]   </td><td><code><a href="http://www.w3.org/TR/xpath20/#prod-xpath-ForExpr">ForExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xpath-SimpleForClause">SimpleForClause</a>  "return"  ExprSingle</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xpath-SimpleForClause" name="doc-xpath-SimpleForClause"/>[<small>5 (XPath)</small>]   </td><td><code><a href="http://www.w3.org/TR/xpath20/#prod-xpath-SimpleForClause">SimpleForClause</a></code></td><td>   ::=   </td><td><code>"for"  "$"  VarName  "in"  ExprSingle  (","  "$"  VarName  "in"  ExprSingle)*</code></td></tr></tbody></table>
    <p><b>Core Grammar</b></p>
        <p>The Core grammar productions for FLWOR expressions are:</p>
      	
<h5><a id="N16EBF" name="N16EBF"/>For Expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-FLWORExpr" name="doc-core-FLWORExpr"/>[<small>32 (Core)</small>]   </td><td><code><a href="#prod-core-FLWORExpr">FLWORExpr</a></code></td><td>   ::=   </td><td><code>(<a href="#doc-core-ForClause">ForClause</a>  |  <a href="#doc-core-LetClause">LetClause</a>)  "return"  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ForClause" name="doc-core-ForClause"/>[<small>33 (Core)</small>]   </td><td><code><a href="#prod-core-ForClause">ForClause</a></code></td><td>   ::=   </td><td><code>"for"  "$"  <a href="#doc-core-VarName">VarName</a>  <a href="#doc-core-TypeDeclaration">TypeDeclaration</a>?  <a href="#doc-core-PositionalVar">PositionalVar</a>?  "in"  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-LetClause" name="doc-core-LetClause"/>[<small>35 (Core)</small>]   </td><td><code><a href="#prod-core-LetClause">LetClause</a></code></td><td>   ::=   </td><td><code>"let"  "$"  <a href="#doc-core-VarName">VarName</a>  <a href="#doc-core-TypeDeclaration">TypeDeclaration</a>?  ":="  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-PositionalVar" name="doc-core-PositionalVar"/>[<small>34 (Core)</small>]   </td><td><code><a href="#prod-core-PositionalVar">PositionalVar</a></code></td><td>   ::=   </td><td><code>"at"  "$"  <a href="#doc-core-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-TypeDeclaration" name="doc-core-TypeDeclaration"/>[<small>82 (Core)</small>]   </td><td><code><a href="#prod-core-TypeDeclaration">TypeDeclaration</a></code></td><td>   ::=   </td><td><code>"as"  <a href="#doc-core-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-OrderByClause" name="doc-core-OrderByClause"/>[<small>36 (Core)</small>]   </td><td><code><a href="#prod-core-OrderByClause">OrderByClause</a></code></td><td>   ::=   </td><td><code>(("order"  "by")  |  ("stable"  "order"  "by"))  <a href="#doc-core-OrderSpecList">OrderSpecList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-OrderSpecList" name="doc-core-OrderSpecList"/>[<small>37 (Core)</small>]   </td><td><code><a href="#prod-core-OrderSpecList">OrderSpecList</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-OrderSpec">OrderSpec</a>  (","  <a href="#doc-core-OrderSpec">OrderSpec</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-OrderSpec" name="doc-core-OrderSpec"/>[<small>38 (Core)</small>]   </td><td><code><a href="#prod-core-OrderSpec">OrderSpec</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ExprSingle">ExprSingle</a>  <a href="#doc-core-OrderModifier">OrderModifier</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-OrderModifier" name="doc-core-OrderModifier"/>[<small>39 (Core)</small>]   </td><td><code><a href="#prod-core-OrderModifier">OrderModifier</a></code></td><td>   ::=   </td><td><code>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <a href="#prod-core-URILiteral">URILiteral</a>)?</code></td></tr></tbody></table>
      <div class="div3">
<h4><a id="sec_flwor-expressions" name="sec_flwor-expressions"/>4.8.1 FLWOR expressions</h4><p><b>Notation</b></p>
        <p>For convenience, we introduce the following auxiliary
        grammar productions.</p>

        
<h5><a id="N16F6F" name="N16F6F"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-OptTypeDeclaration" name="doc-fs-OptTypeDeclaration"/>[<small>87 (Formal)</small>]   </td><td><code>OptTypeDeclaration</code></td><td>   ::=   </td><td><code><a href="#doc-core-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-OptPositionalVar" name="doc-fs-OptPositionalVar"/>[<small>88 (Formal)</small>]   </td><td><code>OptPositionalVar</code></td><td>   ::=   </td><td><code><a href="#doc-core-PositionalVar">PositionalVar</a>?</code></td></tr></tbody></table>
      <p><b>Notation</b></p>
    	<p id="jd_map_flwor">Individual [For/FLWOR] clauses are
    	normalized by means of the auxiliary normalization rules:</p>

       	<div align="center">
 	  
 	    <font size="6">[</font><em>FLWORClause</em><font size="6">]</font><a href="#jd_map_flwor" class="judgment"><sub><font size="2">FLWOR</font></sub></a>(<em>Expr</em>)
 	  
       	</div>

        <p>Where <em>FLWORClause</em> can be any either a <em>ForClause</em>,
        a <em>LetClause</em>, a <em>WhereClause</em>, or an
        <em>OrderByClause</em>.  The <em>OrderByClause</em> is discussed in
        <a href="#id_orderby_clause"><b>[4.8.4 Order By and Return Clauses]</b></a>.</p>

        <p>Normalized FLWOR expressions restrict a For and Let clause
        to bind only one variable.  Otherwise, the Core FLWOR
        expression is the same as the XQuery FLWOR expression.</p>
      <p><b>Notation</b></p>
        <p>The auxiliary rule <font size="6">[</font><font size="6">]</font><a href="#jd_map_flwor" class="judgment"><sub><font size="2">FLWOR</font></sub></a>(<em>Expr</em>)
        normalizes a For, Let, or Where clause in a <em>FLWORExpr</em>
        expression.  Note that the rule takes the remainder of the
        FLWOR expression (other For, Let, or Where clauses and the
        Return clause) as a parameter in <em>Expr</em>.</p>
      <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>The [For/FLWOR] expressions include the <em>FLWORExpr</em> of
    	XQuery and the <em>ForExpr</em> of XPath.  The normalization rule
    	for <em>ForExpr</em> is simple: It simply unrolls a <em>ForExpr</em>
    	that binds multiple variables into nested <em>ForExpr</em>s, each
    	of which bind one variable.</p>

    	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
    	 <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
    	  
    	   <font size="6">[</font>for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">0</font></sub> in <em>Expr</em><sub><font size="2">0</font></sub>, ...,  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub>
    	    in <em>Expr</em><sub><font size="2">n</font></sub> return <em>Expr</em> 
    	    <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
    	  
    	 </td></tr>
    	 <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
          <table><tbody><tr><td>
    	  for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">0</font></sub> in  <font size="6">[</font><em>Expr</em><sub><font size="2">0</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> return</td></tr><tr><td>...</td></tr><tr><td>
    	  for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> in  <font size="6">[</font><em>Expr</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
    	  return</td></tr><tr><td><font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a></td></tr></tbody></table>
          
    	 </td></tr>
    	</table></div>

    	<p>Full <em>FLWORExpr</em> expressions are normalized to nested
    	Core expressions using two sets of normalization rules. Note
    	that some of the rules also accept ungrammatical
    	<em>FLWORExpr</em>s such as "where <em>Expr</em><sub><font size="2">1</font></sub> return
    	<em>Expr</em><sub><font size="2">2</font></sub>". This does not matter, as normalization is always
    	applied on parsed [XPath/XQuery] expressions, and ungrammatical
    	<em>FLWORExpr</em>s would be rejected by the parser
    	beforehand.</p>
   
        <p>The first set of rules is applied on a full [For/FLWOR]
        expression, splitting it at the clause level, then applying
        further normalization on each separate clause.</p>

    	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
    	 <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
    	  
    	   <font size="6">[</font>
    	    (<em>ForClause</em> | <em>LetClause</em> | <em>WhereClause</em> | <em>OrderByClause</em>) <em>FLWORExpr</em> 
    	   <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
    	  
    	 </td></tr>
    	 <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
    	  <font size="6">[</font>(<em>ForClause</em> | <em>LetClause</em> |
    	  <em>WhereClause</em> | <em>OrderByClause</em>)<font size="6">]</font><a href="#jd_map_flwor" class="judgment"><sub><font size="2">FLWOR</font></sub></a>(<font size="6">[</font><em>FLWORExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)
          
    	 </td></tr>
    	</table></div>
  
    	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
    	 <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
    	  
    	   <font size="6">[</font>
    	    (<em>ForClause</em> | <em>LetClause</em> | <em>WhereClause</em> | <em>OrderByClause</em>) return <em>Expr</em> 
    	   <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
    	  
    	 </td></tr>
    	 <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
    	  <font size="6">[</font>(<em>ForClause</em> | <em>LetClause</em> |
    	  <em>WhereClause</em> | <em>OrderByClause</em>)<font size="6">]</font><a href="#jd_map_flwor" class="judgment"><sub><font size="2">FLWOR</font></sub></a>(<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)
    	 </td></tr>
    	</table></div>
  
    	<p>Then each [For/FLWOR] clause is normalized separately. A
    	<em>ForClause</em> may bind more than one variable, whereas a For
    	expression in the [XPath/XQuery] Core binds and iterates over only
    	one variable. Therefore, a <em>ForClause</em> is normalized to
    	nested for expressions:</p>

	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
	 <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
	  
	   <font size="6">[</font>
            <table><tbody><tr><td>
	    for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <em>OptTypeDeclaration</em><sub><font size="2">1</font></sub>
	    <em>OptPositionalVar</em><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub>, </td></tr><tr><td>···,</td></tr><tr><td><a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> <em>OptTypeDeclaration</em><sub><font size="2">n</font></sub>
	    <em>OptPositionalVar</em><sub><font size="2">n</font></sub> in <em>Expr</em><sub><font size="2">n</font></sub></td></tr></tbody></table>
	   <font size="6">]</font>
           <a href="#jd_map_flwor" class="judgment"><sub><font size="2">FLWOR</font></sub></a>(<em>Expr</em>)
          
         </td></tr>
	 <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
	  
	   <table><tbody><tr><td> for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <em>OptTypeDeclaration</em><sub><font size="2">1</font></sub> <em>OptPositionalVar</em><sub><font size="2">1</font></sub> in <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> return</td></tr><tr><td>  ···</td></tr><tr><td>     for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> <em>OptTypeDeclaration</em><sub><font size="2">n</font></sub>
              <em>OptPositionalVar</em><sub><font size="2">n</font></sub>
              in <font size="6">[</font> <em>Expr</em><sub><font size="2">n</font></sub> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> return <em>Expr</em></td></tr></tbody></table>
	  
	 </td></tr>
	</table></div>

        <p>Note that the additional <em>Expr</em> parameter of the
        auxiliary normalization rule is used as the final return
        expression.</p>

        <p>Likewise, a <em>LetClause</em> clause is normalized to nested
        let expressions, each of which binds one variable:</p>

	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
	 <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
	  
	   <font size="6">[</font>
<table><tbody><tr><td>let <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <em>OptTypeDeclaration</em><sub><font size="2">1</font></sub> := <em>Expr</em><sub><font size="2">1</font></sub>,</td></tr><tr><td>···,</td></tr><tr><td><a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> <em>OptTypeDeclaration</em><sub><font size="2">n</font></sub> := <em>Expr</em><sub><font size="2">n</font></sub></td></tr></tbody></table><font size="6">]</font><a href="#jd_map_flwor" class="judgment"><sub><font size="2">FLWOR</font></sub></a>(<em>Expr</em>)
  	  
	 </td></tr>
	 <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
	  
	   <table><tbody><tr><td>let <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <em>OptTypeDeclaration</em><sub><font size="2">1</font></sub> := <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> return</td></tr><tr><td>  ···</td></tr><tr><td>    let <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> <em>OptTypeDeclaration</em><sub><font size="2">n</font></sub> := <font size="6">[</font><em>Expr</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> return <em>Expr</em></td></tr></tbody></table>
	  
	 </td></tr>
	</table></div>

        <p>A <em>WhereClause</em> is normalized to an <em>IfExpr</em>, with
        the else-branch returning the empty sequence:</p>

	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
	 <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
	  
	   <font size="6">[</font> where <em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_flwor" class="judgment"><sub><font size="2">FLWOR</font></sub></a>(<em>Expr</em>)
	  
	 </td></tr>
	 <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
	  
	   if ( <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> ) then <em>Expr</em> else ()
	  
	 </td></tr>
	</table></div>

      <p><b>Example</b></p>

        <p>The following simple example illustrates, how a
        <em>FLWORExpr</em> is normalized. The <code>for</code> expression
        in the example below is used to iterate over two collections,
        binding variables <code>$i</code> and <code>$j</code> to items
        in these collections. It uses a <code>let</code> clause to
        binds the local variable <code>$k</code> to the sum of both
        numbers, and a <code>where</code> clause to select only those
        numbers that have a sum equal to or greater than the integer
        <code>5</code>.</p>

<div class="exampleInner"><pre>  for $i as xs:integer in (1, 2),
      $j in (3, 4)
  let $k := $i + $j
  where $k &gt;= 5
  return
    &lt;tuple&gt;
       &lt;i&gt; { $i } &lt;/i&gt;
       &lt;j&gt; { $j } &lt;/j&gt;
    &lt;/tuple&gt;
</pre></div>

        <p>By the first set of rules, this is normalized to (except
        for the operators and element constructor which are not
        treated here):</p>

<div class="exampleInner"><pre>  for $i as xs:integer in (1, 2) return
    for $j in (3, 4) return
      let $k := $i + $j return
        if ($k &gt;= 5) then 
          &lt;tuple&gt;
            &lt;i&gt; { $i } &lt;/i&gt;
            &lt;j&gt; { $j } &lt;/j&gt;
          &lt;/tuple&gt;
        else
          ()
</pre></div>

        <p>For each binding of <code>$i</code> to an item in the
        sequence <code>(1 , 2)</code> the inner <code>for</code>
        expression iterates over the sequence <code>(3 , 4)</code> to
        produce tuples ordered by the ordering of the outer sequence
        and then by the ordering of the inner sequence. This Core
        expression eventually results in the following document
        fragment:</p>

<div class="exampleInner"><pre>
  (&lt;tuple&gt;
      &lt;i&gt;1&lt;/i&gt;
      &lt;j&gt;4&lt;/j&gt;
   &lt;/tuple&gt;,
   &lt;tuple&gt;
      &lt;i&gt;2&lt;/i&gt;
      &lt;j&gt;3&lt;/j&gt;
   &lt;/tuple&gt;,
   &lt;tuple&gt;
      &lt;i&gt;2&lt;/i&gt;
      &lt;j&gt;4&lt;/j&gt;
   &lt;/tuple&gt;)
</pre></div>

      </div><div class="div3">
<h4><a id="id-for-expression" name="id-for-expression"/>4.8.2 For expression</h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>

        <p>A single <code>for</code> expression is typed as follows:
        First <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> of the iteration expression <em>Expr</em><sub><font size="2">1</font></sub> is
        inferred. Then the prime type of <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
        <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>), is computed. This is a union over all
        item types in <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> (See <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>). With the variable component of the static
        environment <a href="#xq_stat_env_def" class="env">statEnv</a> extended with <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as type
        <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>), the type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> of <em>Expr</em><sub><font size="2">2</font></sub> is
        inferred. Because the <code>for</code> expression iterates
        over the result of <em>Expr</em><sub><font size="2">1</font></sub>, the final type of the iteration
        is <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> multiplied with the possible number of items in
        <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> (one, <code>?</code>, <code>*</code>, or
        <code>+</code>).  This number is determined by the auxiliary
        type-function <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>).</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub> return
                    <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                
              
            </td></tr>
          </table><br/>
        </div>

        <p>When a positional variable <em>Variable</em><sub><font size="2">pos</font></sub> is present, the
        static environment is also extended with the positional
        variable typed as an <code>xs:integer</code>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>);<a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub> =&gt; <code>xs:integer</code>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> at <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub> return
                    <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                
              
            </td></tr>
          </table><br/>
        </div>

        <p>When a type declaration is present, the static semantics
        also checks that the type of the input expression is a subtype
        of the declared type and extends the static environment by
        typing <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> with type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>. This semantics is
        specified by the following typing rule.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                  <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> 
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> in <em>Expr</em><sub><font size="2">1</font></sub> return
                    <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                
              
            </td></tr>
          </table><br/>
        </div>

<p>The last rule contains a For expression that contains a type
 declaration and a positional variable.  When the positional variable
 is present, the static environment is also extended with the
 positional variable typed as an integer.
</p>
        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> 
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>; <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub> =&gt; <code>xs:integer</code>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> at <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub> return
                    <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                
              
            </td></tr>
          </table><br/>
        </div>

      <p><b>Example</b></p>

        <p>For example, if <code>$example</code> is bound to the
        sequence <code>10.0, 1.0E1, 10</code> of type
        <code>xs:decimal, xs:float, xs:integer</code>, then the query</p>

<div class="exampleInner"><pre>  for $s in $example
  return $s * 2</pre></div>

        <p>is typed as follows:</p>

<div class="exampleInner"><pre>  (1) prime(xs:decimal, xs:float, xs:integer) =
      xs:decimal | xs:float | xs:integer
  (2) quantifier(xs:decimal, xs:float, xs:integer) = +
  (3) $s : xs:decimal | xs:float | xs:integer
  (4) $s * 2 : 
      xs:decimal | xs:float | xs:integer
  (5) result-type :
      ( xs:decimal | xs:float | xs:integer ) +
</pre></div>

        <p>This result-type is not the most specific type possible. It
        does not take into account the order of elements in the input
        type, and it ignores the individual and overall number
        of elements in the input type. The most specific type possible
        is: <code>element out {element one {}}, element out {element
        two {}}, element out {element three {}}</code>.  However,
        inferring such a specific type for arbitrary input types and
        arbitrary return clauses requires significantly more
        complex type inference rules. In addition, if put into the
        context of an element, the specific type violates the
        "unique particle attribution" restriction of XML schema, which requires
        that an element must have a unique content model within a
        particular context.</p>

      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>

        <p>The evaluation of a <code>for</code> expression
        distinguishes two cases: If the iteration expression
        <em>Expr</em><sub><font size="2">1</font></sub> evaluates to the empty sequence, then the entire
        expression evaluates to the empty sequence:</p>

         <div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td>
 	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 		<em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> ()
 	      
 	    </td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
 		for <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <em>OptTypeDeclaration</em> in <em>Expr</em><sub><font size="2">1</font></sub> return <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> ()
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>Otherwise, the iteration expression <em>Expr</em><sub><font size="2">1</font></sub>, is
        evaluated to produce the sequence <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>, ...,
        <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>.  For each item <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub> in this
        sequence, the body of the <code>for</code> expression
        <em>Expr</em><sub><font size="2">2</font></sub> is evaluated in the dynamic environment
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> extended with <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> bound to
        <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>. This produces values <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">i</font></sub>, ...,
        <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub> which are concatenated to produce the result
        sequence. </p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                   
                      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub> ,..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>
                  
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  ···
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                
                  for <a href="#prod-core-VarRef"><em>VarRef</em></a> in <em>Expr</em><sub><font size="2">1</font></sub> return <em>Expr</em><sub><font size="2">2</font></sub> 
                  <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                  <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> ,..., <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>
                
              
            </td></tr>
          </table><br/>
        </div>

        <p>The following rule is the same as the rule above, but
        includes the optional positional variable <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub>.  If
        present, <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub> is bound to the position of the item
        in the input sequence, i.e., the value <em>i</em>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                   
                      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub> ,..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>
                  
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                    
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">pos</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>; <em>Variable</em><sub><font size="2">pos</font></sub> =&gt; 1) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  ···
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>; <em>Variable</em><sub><font size="2">pos</font></sub> =&gt; n) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                
                  for <a href="#prod-core-VarRef"><em>VarRef</em></a> at <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub> return <em>Expr</em><sub><font size="2">2</font></sub> 
                  <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                  <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> ,..., <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>
                
              
            </td></tr>
          </table><br/>
        </div>

        <p>When a type declaration is present, the dynamic
        semantics also checks that each item in the result of
        evaluating <em>Expr</em><sub><font size="2">1</font></sub> matches the
        declared type.  This semantics is specified by the following
        dynamic rule.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                   
                      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub> ,..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>
                  
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>  <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                    
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  ···
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>  <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                
                  for <a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> in <em>Expr</em><sub><font size="2">1</font></sub>
                  return <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                  <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> ,..., <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>
                
              
            </td></tr>
          </table><br/>
        </div>

        <p>The last rule covers a <code>for</code> expression that
        contains a type declaration and a positional variable.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                   
                      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub> ,..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>
                  
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>  <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                    
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">pos</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>; <em>Variable</em><sub><font size="2">pos</font></sub> =&gt; 1) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  ···
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>  <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>; <em>Variable</em><sub><font size="2">pos</font></sub> =&gt; n) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                
                  for <a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> at <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">pos</font></sub>  in <em>Expr</em><sub><font size="2">1</font></sub>
                  return <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                  <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> ,..., <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">n</font></sub>
                
              
            </td></tr>
          </table><br/>
        </div>

      <p>Note that this definition allows
      <em>non-deterministic</em> evaluation of the resulting
      sequence, since the judgments above the inference rule can be
      evaluated in any order.</p>

    <p><b>Example</b></p>

        <p>Note that if the expression in the <code>return</code> clause 
        results in a sequence, sequences are never nested in the
        [XPath/XQuery] data model. For instance, in the following for
        expression:</p>

<div class="exampleInner"><pre>  
  for $i in (1,2)
    return (&lt;i&gt; {$i} &lt;/i&gt;, &lt;negi&gt; {-$i} &lt;/negi&gt;)
</pre></div>

        <p>each iteration in the <code>for</code> results in a sequence of two
        elements, which are then concatenated and flattened in the
        resulting sequence:</p>

<div class="exampleInner"><pre>  
  (&lt;i&gt;1&lt;/i&gt;,
   &lt;negi&gt;-1&lt;/negi&gt;,
   &lt;i&gt;2&lt;/i&gt;,
   &lt;negi&gt;-2&lt;/negi&gt;)
</pre></div>

      </div><div class="div3">
<h4><a id="sec_lets" name="sec_lets"/>4.8.3 Let Expression</h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>A <code>let</code> expression extends the static
        environment <a href="#xq_stat_env_def" class="env">statEnv</a> with <em>Variable</em><sub><font size="2">1</font></sub> of type
        <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> inferred from <em>Expr</em><sub><font size="2">1</font></sub>, and infers the type of
        <em>Expr</em><sub><font size="2">2</font></sub> in the extended environment to produce the result
        type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.</p>

        <div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	   <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
 	    
 	     <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 	      <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
 	        
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                    
 	    
 	     
                        <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) 
                      <b> |- </b>
                       <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
                    
              </td></tr>
                  </table></td></tr></table></td></tr>
                  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
                    
                      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      let <a href="#prod-core-VarRef"><em>VarRef</em></a> :=  <em>Expr</em><sub><font size="2">1</font></sub>
 		    return <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
                      
                    
                  </td></tr>
                </table><br/>
              </div>

        <p>When a type declaration is present, the static semantics
        also checks that the type of the input expression is a subtype
        of the declared type and extends the static environment by
        typing <em>Variable</em><sub><font size="2">1</font></sub> with type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>.  This semantics is
        specified by the following static rule.</p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
 	        
 	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 	          <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
 	        
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> 
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                    
 	        
 	          
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> ) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                let <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> :=  <em>Expr</em><sub><font size="2">1</font></sub>
 	      return <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
                
              
            </td></tr>
          </table><br/>
        </div>

      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>

        <p>A <code>let</code> expression extends the dynamic environment
        <a href="#xq_dyn_env_def" class="env">dynEnv</a> with <em>Variable</em> bound to <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> returned by
        <em>Expr</em><sub><font size="2">1</font></sub>, and evaluates <em>Expr</em><sub><font size="2">2</font></sub> in the extended
        environment to produce <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                    
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                let <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> := <em>Expr</em><sub><font size="2">1</font></sub> return
                    <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
                
              
            </td></tr>
          </table><br/>
        </div>

        <p>When a type declaration is present, the dynamic
        semantics also checks that the result of evaluating <em>Expr</em><sub><font size="2">1</font></sub>
        matches the
        declared type. This semantics is specified as the following
        dynamic rule.</p>


        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>  <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                    
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>) 
                  <b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                let <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> := <em>Expr</em><sub><font size="2">1</font></sub> return
                    <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
                
              
            </td></tr>
          </table><br/>
        </div>
      <p><b>Example</b></p>
        <p>Note the use of the environments to define the scope of
        each variable. For instance, in the following nested
        <code>let</code> expression:</p>

<div class="exampleInner"><pre>  let $k := 5 return
    let $k := $k + 1 return
      $k+1
</pre></div>

        <p>the outermost <code>let</code> expression binds variable 
        <code>$k</code> to the
        integer <code>5</code> in the environment, then the expression
        <code>$k+1</code> is computed, yielding value <code>6</code>, to 
        which the second variable <code>$k</code> is bound. 
        The expression then results in 
        the final integer <code>7</code>.</p>
      </div><div class="div3">
<h4><a id="id_orderby_clause" name="id_orderby_clause"/>4.8.4 Order By and Return Clauses</h4><p><b>Introduction</b></p>
        <p>The dynamic semantics of the <em>OrderByClause</em> is not
        specified formally. The dynamic semantics is not specified
        formally as it would require the introduction of tuples, which
        are not supported in the [XPath/XQuery] data model. The dynamic
        semantics of the order-by clause can be found in <a href="http://www.w3.org/TR/xquery#id-orderby-return">Section 
3.8.3 Order By and Return Clauses</a><sup><small>XQ</small></sup>.</p>

        <p>Because an <em>OrderByClause</em> does not effect the type of a
        <em>FLWORExpr</em> expression, the static semantics of a
        <em>FLWORExpr</em> expression with an <em>OrderByClause</em> is
        equivalent to the static semantics of an equivalent
        <em>FLWORExpr</em> in which the <em>OrderByClause</em> is omitted but a
        <code>gt</code> comparison is applied.</p>
      <p><b>Notation</b></p>
          <p id="jd_map_orderspeclist">To define normalization of
          OrderBy, the following auxiliary mapping rule is used.</p>
        
            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font><em>OrderSpecList</em><font size="6">]</font><a href="#jd_map_orderspeclist" class="judgment"><sub><font size="2">OrderSpecList</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font><em>LetClause</em> ... <em>LetClause</em><font size="6">]</font>
              
             </td></tr>
            </table></div>
       
          <p>which specify that <em>OrderSpecList</em> is mapped to <em>Expr</em>.</p>
        <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>An <em>OrderByClause</em> is normalized to a Let clause, nested
        For expressions, and atomization, which guarantees that the
        <em>OrderSpecList</em> is well typed. Note that if evaluated
        dynamically, the normalization of <em>OrderByClause</em> given
        here does not express the required sorting semantics, but this
        normalization does provide the correct static type. Notably,
        the normalization rule uses the <code>gt</code> operation,
        which implies that the ordering criteria is typed using the
        same static typing rules, taking into account existential
        quantification, and atomization.</p>

	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
	 <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
	  
	   <font size="6">[</font> stable? order by
	   <em>OrderSpecList</em><font size="6">]</font><a href="#jd_map_flwor" class="judgment"><sub><font size="2">FLWOR</font></sub></a>(<em>Expr</em>)
	  
	 </td></tr>
	 <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
	  
	    <font size="6">[</font><em>OrderSpecList</em><font size="6">]</font><a href="#jd_map_orderspeclist" class="judgment"><sub><font size="2">OrderSpecList</font></sub></a> return <em>Expr</em>
	  
	 </td></tr>
	</table></div>

        <p>Each <em>OrderSpec</em> is normalized the auxiliary atomization
        normalization rule.</p>

	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
	 <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
	  
           <font size="6">[</font><em>Expr</em> OrderModifier, <em>OrderSpecList</em><font size="6">]</font><a href="#jd_map_orderspeclist" class="judgment"><sub><font size="2">OrderSpecList</font></sub></a>
	  
	 </td></tr>
	 <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
	  
            <table summary=""><tbody><tr><td>let $<em>fs:</em>new<sub><font size="2">0</font></sub> := </td></tr><tr><td>   for $<em>fs:</em>new<sub><font size="2">1</font></sub> in <em>Expr</em></td></tr><tr><td>   for $<em>fs:</em>new<sub><font size="2">2</font></sub> in <em>Expr</em> return</td></tr><tr><td>     <font size="6">[</font>$<em>fs:</em>new<sub><font size="2">1</font></sub> gt $<em>fs:</em>new<sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a></td></tr><tr><td><font size="6">[</font><em>OrderSpecList</em><font size="6">]</font><a href="#jd_map_orderspeclist" class="judgment"><sub><font size="2">OrderSpecList</font></sub></a></td></tr></tbody></table>
	  
	 </td></tr>
	</table></div>

      </div></div><div class="div2">
<h3><a id="sec_unordered-expressions" name="sec_unordered-expressions"/>4.9 Ordered and Unordered Expressions</h3><p><b>Introduction</b></p>
      <p>The purpose of <code>ordered</code> and
      <code>unordered</code> expressions is to set the ordering mode
      in the static context to <code>ordered</code> or
      <code>unordered</code> for a certain region in a query. The
      specified ordering mode applies to the expression nested inside
      the curly braces.</p>

      
<h5><a id="N1812F" name="N1812F"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-OrderedExpr" name="doc-xquery-OrderedExpr"/>[<small>91 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-OrderedExpr">OrderedExpr</a></code></td><td>   ::=   </td><td><code>"ordered"  "{"  <a href="#doc-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-UnorderedExpr" name="doc-xquery-UnorderedExpr"/>[<small>92 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-UnorderedExpr">UnorderedExpr</a></code></td><td>   ::=   </td><td><code>"unordered"  "{"  <a href="#doc-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody></table>

    <p><b>Core Grammar</b></p>
      <p>The Core grammar productions for ordered/unordered
      expressions are:</p>

      
<h5><a id="N18152" name="N18152"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-OrderedExpr" name="doc-core-OrderedExpr"/>[<small>69 (Core)</small>]   </td><td><code><a href="#prod-core-OrderedExpr">OrderedExpr</a></code></td><td>   ::=   </td><td><code>"ordered"  "{"  <a href="#doc-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-UnorderedExpr" name="doc-core-UnorderedExpr"/>[<small>70 (Core)</small>]   </td><td><code><a href="#prod-core-UnorderedExpr">UnorderedExpr</a></code></td><td>   ::=   </td><td><code>"unordered"  "{"  <a href="#doc-core-Expr">Expr</a>  "}"</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p><em>OrderedExpr</em> (resp. <em>UnorderedExpr</em>) expressions are
      normalized to <em>OrderedExpr</em> (resp. <em>UnorderedExpr</em>)
      expressions in the [XPath/XQuery] Core.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font>ordered { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         ordered { <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> }
       </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font>unordered { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         unordered { <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> }
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
     <p><em>OrderedExpr</em> and <em>UnorderedExpr</em> expressions set the
     ordering mode in the static context to <code>ordered</code> or
     <code>unordered</code>.</p>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          
           
             <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
             <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_ordering_mode_env" class="env">orderingMode</a>(<code>ordered</code>) 
           
          
        </td></tr>
        <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub><b> |- </b>
           
             <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
           
          
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          ordered { <em>Expr</em> } <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
         
        
       </td></tr>
      </table><br/>
     </div>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          
           
             <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
             <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_ordering_mode_env" class="env">orderingMode</a>(<code>unordered</code>) 
           
          
        </td></tr>
        <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub><b> |- </b>
           
             <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
           
          
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          unordered { <em>Expr</em> } <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
         
        
       </td></tr>
      </table><br/>
     </div>

   <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
     <p><em>OrderedExpr</em> and <em>UnorderedExpr</em> expressions only have
     an effect on the static context. The effect on the evaluation of
     its subexpression(s) is captured using the
     <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a> function, which introduced during
     normalization of axis steps, <code>union</code>,
     <code>intersect</code>, and <code>except</code> expressions, and
     FLWOR expressions that have no <code>order by</code> clause.</p>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
           
             <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
           
          
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
          ordered { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
         
        
       </td></tr>
      </table><br/>
     </div>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
           
             <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
           
          
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
          unordered { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
         
        
       </td></tr>
      </table><br/>
     </div>

   </div><div class="div2">
<h3><a id="sec_conditionals" name="sec_conditionals"/>4.10 Conditional Expressions</h3><p><b>Introduction</b></p>

     <p>A conditional expression supports conditional evaluation of
      one of two expressions.</p>

      
<h5><a id="N1834C" name="N1834C"/>Conditional Expression</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-IfExpr" name="doc-xquery-IfExpr"/>[<small>45 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-IfExpr">IfExpr</a></code></td><td>   ::=   </td><td><code>"if"  "("  <a href="#doc-xquery-Expr">Expr</a>  ")"  "then"  <a href="#doc-xquery-ExprSingle">ExprSingle</a>  "else"  <a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody></table>
    <p><b>Core Grammar</b></p>
      <p>The Core grammar production for the conditional expression
      is:</p>

      
<h5><a id="N1836E" name="N1836E"/>Core Conditional Expression</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-IfExpr" name="doc-core-IfExpr"/>[<small>43 (Core)</small>]   </td><td><code><a href="#prod-core-IfExpr">IfExpr</a></code></td><td>   ::=   </td><td><code>"if"  "("  <a href="#doc-core-Expr">Expr</a>  ")"  "then"  <a href="#doc-core-ExprSingle">ExprSingle</a>  "else"  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Conditional expressions are normalized as follows.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          
            <font size="6">[</font>if (<em>Expr</em><sub><font size="2">1</font></sub>) then <em>Expr</em><sub><font size="2">2</font></sub> else <em>Expr</em><sub><font size="2">3</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
          
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
          <table><tbody><tr><td>    if (<code>fn:boolean</code>((<font size="6">[</font> <em>Expr</em><sub><font size="2">1</font></sub> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>))) then <font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> else <font size="6">[</font><em>Expr</em><sub><font size="2">3</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a></td></tr></tbody></table>
          
        </td></tr>
      </table></div>

    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
       <div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td>
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a>  <code>xs:boolean</code> 
               
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
               
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <em>Expr</em><sub><font size="2">3</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub> 
           
          </td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <code>if</code> (<em>Expr</em><sub><font size="2">1</font></sub>) <code>then </code>
                     <em>Expr</em><sub><font size="2">2</font></sub>  <code>else </code> <em>Expr</em><sub><font size="2">3</font></sub> :
                     (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>)
            
           
          </td></tr>
         </table><br/>
       </div>
    
    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>If the conditional's boolean expression <em>Expr</em><sub><font size="2">1</font></sub> evaluates
      to true, <em>Expr</em><sub><font size="2">2</font></sub> is evaluated and its value is produced.  If
      the conditional's boolean expression evaluates to false,
      <em>Expr</em><sub><font size="2">3</font></sub> is evaluated and its value is produced.  Note that
      the existence of two separate evaluation rules ensures that only
      one branch of the conditional is evaluated.</p>

      <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true
              
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
          
        </td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            if (<em>Expr</em><sub><font size="2">1</font></sub>) then <em>Expr</em><sub><font size="2">2</font></sub> else <em>Expr</em><sub><font size="2">3</font></sub>  <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> 
            
          
        </td></tr>
      </table><br/>

      <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false
              
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            <em>Expr</em><sub><font size="2">3</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub> 
          
        </td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            if (<em>Expr</em><sub><font size="2">1</font></sub>) then <em>Expr</em><sub><font size="2">2</font></sub> 
                        else <em>Expr</em><sub><font size="2">3</font></sub>  <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
            
          
        </td></tr>
      </table><br/>
      </div>

    </div><div class="div2">
<h3><a id="id-quantified-expressions" name="id-quantified-expressions"/>4.11 Quantified Expressions</h3><p><b>Introduction</b></p>
      <p>[XPath/XQuery] defines two quantification expressions:</p>

      
<h5><a id="N18552" name="N18552"/>Quantified Expression</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-QuantifiedExpr" name="doc-xquery-QuantifiedExpr"/>[<small>42 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-QuantifiedExpr">QuantifiedExpr</a></code></td><td>   ::=   </td><td><code>("some"  |  "every")  "$"  <a href="#doc-xquery-VarName">VarName</a>  <a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#doc-xquery-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#doc-xquery-VarName">VarName</a>  <a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#doc-xquery-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="noid_N1818B.doc-xpath-QuantifiedExpr" name="noid_N1818B.doc-xpath-QuantifiedExpr"/>[<small>6 (XPath)</small>]   </td><td><code><a href="http://www.w3.org/TR/xpath20/#prod-xpath-QuantifiedExpr">QuantifiedExpr</a></code></td><td>   ::=   </td><td><code>("some"  |  "every")  "$"  VarName  "in"  ExprSingle  (","  "$"  VarName  "in"  ExprSingle)*  "satisfies"  ExprSingle</code></td></tr></tbody></table>

    <p><b>Core Grammar</b></p>
      <p>The Core grammar production for quantified expressions
      is:</p>

      
<h5><a id="N185B0" name="N185B0"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-QuantifiedExpr" name="doc-core-QuantifiedExpr"/>[<small>40 (Core)</small>]   </td><td><code><a href="#prod-core-QuantifiedExpr">QuantifiedExpr</a></code></td><td>   ::=   </td><td><code>("some"  |  "every")  "$"  <a href="#doc-core-VarName">VarName</a>  <a href="#doc-core-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#doc-core-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#doc-core-VarName">VarName</a>  <a href="#doc-core-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#doc-core-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>The quantified expressions are normalized into nested Core
      quantified expressions, each of which binds one variable.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <font size="6">[</font>some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub>, ..., <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> in
          <em>Expr</em><sub><font size="2">n</font></sub> satisfies <em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <table><tbody><tr><td> some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> satisfies</td></tr><tr><td>    some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">2</font></sub> in <font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> satisfies</td></tr><tr><td>          ...</td></tr><tr><td>      some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> in <font size="6">[</font><em>Expr</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> satisfies</td></tr><tr><td>      <code>fn:boolean</code>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) </td></tr></tbody></table>
        
      </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <font size="6">[</font>every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub>, ..., <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> in
          <em>Expr</em><sub><font size="2">n</font></sub> satisfies <em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
      </td></tr>
      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <table><tbody><tr><td> every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <font size="6">[</font><em>Expr</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>  satisfies</td></tr><tr><td>    every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">2</font></sub> in <font size="6">[</font><em>Expr</em><sub><font size="2">2</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> satisfies</td></tr><tr><td>          ...</td></tr><tr><td>      every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> in <font size="6">[</font><em>Expr</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> satisfies</td></tr><tr><td>      <code>fn:boolean</code>((<font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) </td></tr></tbody></table>
        
      </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The static semantics of the quantified expressions uses the
      <a href="#jd_prime" class="judgment">prime</a> operator on types, which is explained in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>.  These rules are similar to those for For
      expressions in <a href="#id-for-expression"><b>[4.8.2 For expression]</b></a>.</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a> <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code> 
                
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code> 
               
              </td></tr>
             </table><br/>
            </div>

<p>The next rule is for <em>SomeExpr</em> with the optional type declaration.
</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>

              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>

              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> 
              </td></tr>

              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code> 
                
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code> 
               
              </td></tr>
             </table><br/>
            </div>

<p>The next rule is for <em>EveryExpr</em> without the optional type declaration.
</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code> 
                
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub>
                satisfies <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code> 
               
              </td></tr>
       
             </table><br/>
            </div>

<p>The next rule is for <em>EveryExpr</em> with the optional type declaration.
</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>

              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>

              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> 
              </td></tr>

              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code> 
                
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> in <em>Expr</em><sub><font size="2">1</font></sub>
                satisfies <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code> 
               
              </td></tr>
       
             </table><br/>
            </div>

<p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
            <p>The existentially quantified "some" expression yields
            true if any evaluation of the satisfies expression yields
            true.  The existentially quantified "some" expression
            yields false if every evaluation of the satisfies
            expression is false.  A quantified expression may raise an
            error if any evaluation of the satisfies expression raises
            an error.  The dynamic semantics of quantified expressions
            is non-deterministic.  This non-determinism permits
            implementations to use short-circuit evaluation strategies
            when evaluating quantified expressions.</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> 
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
                    
                
                 
                  1 &lt;= <em>i</em> &lt;= <em>n</em>
                 
                
              </td></tr>
              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
               
              </td></tr>
             </table><br/>
            </div>

            <p>The next rule is for <em>SomeExpr</em> with the optional
            type declaration, in which some evaluation of the
            satisfies expression yields true.</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
                  ... <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> 
                
              </td></tr>

              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>


              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
                   
               
                
                 1 &lt;= <em>i</em> &lt;= <em>n</em>
                
               
              </td></tr>


              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
                
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
               
              </td></tr>

             </table><br/>
            </div>

            <p>The next rule is for <em>SomeExpr</em> without the optional
            type declaration, in which all evaluations of the
            satisfies expression yield false.</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
                  ... <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> 
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
                
              </td></tr>
              <tr valign="middle" align="center"><td>...</td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
                
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
               
              </td></tr>
             </table><br/>
            </div>

            <p>The next rule is for <em>SomeExpr</em> with the optional
            type declaration, in which all evaluations of the
            satisfies expression yields false.</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
                  ... <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> 
                
              </td></tr>

              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>


              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>...</td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                some <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
               
              </td></tr>
             </table><br/>
            </div>

            <p>The universally quantified "every" expression yields
            false if any evaluation of the satisfies expression yields
            false.  The universally quantified "every" expression
            yields true if every evaluation of the satisfies
            expression is true.</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
                  ... <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> 
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
                    
                
                 
                  1 &lt;= <em>i</em> &lt;= <em>n</em>
                 
                
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
               
              </td></tr>

             </table><br/>
            </div>

            <p>The next rule is for <em>EveryExpr</em> with the optional
            type declaration, in which some evaluation of the
            satisfies expression yields false.</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
                  ... <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> 
                
              </td></tr>

              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>

              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>

              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">i</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
                    
                
                 
                  1 &lt;= <em>i</em> &lt;= <em>n</em>
                 
                
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false 
               
              </td></tr>

             </table><br/>
            </div>

<p>The next rule is for <em>EveryExpr</em> in which all evaluations of the satisfies expression yields true.</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
                  ... <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> 
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
                
              </td></tr>
              <tr valign="middle" align="center"><td>...</td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
                
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
               
              </td></tr>
             </table><br/>
            </div>

<p>The next rule is for <em>EveryExpr</em> with the optional type
 declaration
 in which all evaluations of the satisfies expression yields true.</p>

            <div align="center">
             <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

              <tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>
                  ... <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> 
                
              </td></tr>

              <tr valign="middle" align="center"><td>
               
                
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
               
              </td></tr>


              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>...</td></tr>
              <tr valign="middle" align="center"><td>
                
                  
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub>) 
                  <b> |- </b>
                   <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                   <a href="#doc-fs-Item"><em>Item</em></a><sub><font size="2">n</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                
               
              </td></tr>

              </table></td></tr></table></td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
               <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                every <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em> in <em>Expr</em><sub><font size="2">1</font></sub> satisfies
                <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true 
               
              </td></tr>
             </table><br/>
            </div>

</div><div class="div2">
<h3><a id="sec_sequencetype-matching" name="sec_sequencetype-matching"/>4.12 Expressions on SequenceTypes</h3><p><b>Introduction</b></p>

      <p>Expressions on SequenceTypes are expressions whose semantics
      depends on the type of some of the sub-expressions to which they
      are applied. The syntax of SequenceType expressions is described
      in <a href="#id-sequencetype"><b>[3.5.3 SequenceType Syntax]</b></a>.</p>

    <div class="div3">
<h4><a id="sec_instance-of" name="sec_instance-of"/>4.12.1 Instance Of</h4>
<h5><a id="N1921E" name="N1921E"/>SequenceType expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-InstanceofExpr" name="doc-xquery-InstanceofExpr"/>[<small>54 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-InstanceofExpr">InstanceofExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-TreatExpr">TreatExpr</a> ( "instance"  "of"  <a href="#doc-xquery-SequenceType">SequenceType</a> )?</code></td></tr></tbody></table><p><b>Introduction</b></p>
        <p>The SequenceType expression "<em>Expr</em> instance of
        <em>SequenceType</em>" is true if and only if the result of
        evaluating expression <em>Expr</em> is an instance of the type
        referred to by <em>SequenceType</em>.</p>

        <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
          <p>An <em>InstanceofExpr</em> expression is normalized into a
          <em>TypeswitchExpr</em> expression. Note that the following
          normalization rule uses a variable $<em>fs:</em>new, which is a
          newly created variable which must not conflict with any
          variables already in scope. This variable is necessary to
          comply with the syntax of typeswitch expressions in the Core
          [XPath/XQuery], but is never used.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
         <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
          <font size="6">[</font><em>Expr</em> instance of <em>SequenceType</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
         </td></tr>
         <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
          
           <table><tbody><tr><td>typeswitch (<font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)</td></tr><tr><td>  case $<em>fs:</em>new as <em>SequenceType</em> return <code>fn:true</code>() </td></tr><tr><td>  default $<em>fs:</em>new return <code>fn:false</code>()</td></tr></tbody></table>
          
         </td></tr>
        </table></div>

        </div><div class="div3">
<h4><a id="sec_typeswitch" name="sec_typeswitch"/>4.12.2 Typeswitch</h4>
<h5><a id="N1929D" name="N1929D"/>SequenceType expressions</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-TypeswitchExpr" name="doc-xquery-TypeswitchExpr"/>[<small>43 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-TypeswitchExpr">TypeswitchExpr</a></code></td><td>   ::=   </td><td><code>"typeswitch"  "("  <a href="#doc-xquery-Expr">Expr</a>  ")"  <a href="#doc-xquery-CaseClause">CaseClause</a>+  "default"  ("$"  <a href="#doc-xquery-VarName">VarName</a>)?  "return"  <a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-CaseClause" name="doc-xquery-CaseClause"/>[<small>44 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CaseClause">CaseClause</a></code></td><td>   ::=   </td><td><code>"case"  ("$"  <a href="#doc-xquery-VarName">VarName</a>  "as")?  <a href="#doc-xquery-SequenceType">SequenceType</a>  "return"  <a href="#doc-xquery-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p><b>Introduction</b></p>
          <p>The <b>typeswitch</b> expression chooses one of
          several expressions to evaluate based on the dynamic type of
          an input value.</p>

          <p>Each branch of a typeswitch expression may have an
          optional <a href="#prod-core-VarRef"><em>VarRef</em></a>, which is bound to the value of the
          input expression. This variable is optional in [XPath/XQuery]
          but mandatory in the [XPath/XQuery] Core.  One of the reasons
          for having this variable is that it is assigned a specific
          type for the corresponding branch.</p>

        <p><b>Core Grammar</b></p>
          <p>The Core grammar productions for <code>typeswitch</code>
          are:</p>
      
          
<h5><a id="N192EF" name="N192EF"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-TypeswitchExpr" name="doc-core-TypeswitchExpr"/>[<small>41 (Core)</small>]   </td><td><code><a href="#prod-core-TypeswitchExpr">TypeswitchExpr</a></code></td><td>   ::=   </td><td><code>"typeswitch"  "("  <a href="#doc-core-Expr">Expr</a>  ")"  <a href="#doc-core-CaseClause">CaseClause</a>+  "default"  ("$"  <a href="#doc-core-VarName">VarName</a>)?  "return"  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-CaseClause" name="doc-core-CaseClause"/>[<small>42 (Core)</small>]   </td><td><code><a href="#prod-core-CaseClause">CaseClause</a></code></td><td>   ::=   </td><td><code>"case"  ("$"  <a href="#doc-core-VarName">VarName</a>  "as")?  <a href="#doc-core-SequenceType">SequenceType</a>  "return"  <a href="#doc-core-ExprSingle">ExprSingle</a></code></td></tr></tbody></table>
        <p><b>Notation</b></p>
          <p>For convenience, we introduce the following auxiliary
          grammar productions.</p>

          
<h5><a id="N1932E" name="N1932E"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-OptVarRef" name="doc-fs-OptVarRef"/>[<small>89 (Formal)</small>]   </td><td><code>OptVarRef</code></td><td>   ::=   </td><td><code><a href="#doc-core-VarRef">VarRef</a>?</code></td></tr></tbody></table>
        <p><b>Notation</b></p>
          <p id="jd_map_case">To define normalization of case clauses
          to the [XPath/XQuery] Core, the following auxiliary mapping rule
          is used.</p>
        
            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <font size="6">[</font><em>CaseClause</em><font size="6">]</font><a href="#jd_map_case" class="judgment"><sub><font size="2">Case</font></sub></a>
              
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <em>CaseClause</em>
              
             </td></tr>
            </table></div>
        
          <p>specifies that <em>CaseClause</em> is mapped to <em>CaseClause</em>,
          in the [XPath/XQuery] type system.</p>
        <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
          <p>Normalization of a typeswitch expression guarantees that
          every branch has an associated <a href="#prod-core-VarRef"><em>VarRef</em></a>.  The following
          normalization rule adds a newly created variable that does
          not appear in the rest of the query. Note that $<em>fs:</em>new
          is a newly generated variable that must not conflict with
          any variables already in scope and that is not used in any
          of the sub-expressions.</p>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
           <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <font size="6">[</font>
                 case <em>SequenceType</em> return <em>Expr</em>
             <font size="6">]</font><a href="#jd_map_case" class="judgment"><sub><font size="2">Case</font></sub></a>
            
           </td></tr>
           <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
                case $<em>fs:</em>new<sub><font size="2">1</font></sub> as <em>SequenceType</em> return <font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            
           </td></tr>
          </table></div>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
           <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <font size="6">[</font>
                 case <a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> return <em>Expr</em>
             <font size="6">]</font><a href="#jd_map_case" class="judgment"><sub><font size="2">Case</font></sub></a>
            
           </td></tr>
           <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
                case <a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> return <font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            
           </td></tr>
          </table></div>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
           <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <font size="6">[</font>
              default return <em>Expr</em>
             <font size="6">]</font><a href="#jd_map_case" class="judgment"><sub><font size="2">Case</font></sub></a>
            
           </td></tr>
           <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              default $<em>fs:</em>new<sub><font size="2">1</font></sub> return <font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            
           </td></tr>
          </table></div>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
           <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <font size="6">[</font>
              default <a href="#prod-core-VarRef"><em>VarRef</em></a> return <em>Expr</em>
             <font size="6">]</font><a href="#jd_map_case" class="judgment"><sub><font size="2">Case</font></sub></a>
            
           </td></tr>
           <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              default <a href="#prod-core-VarRef"><em>VarRef</em></a> return <font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            
           </td></tr>
          </table></div>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
           <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <font size="6">[</font>
              <table><tbody><tr><td>typeswitch ( <em>Expr</em><sub><font size="2">0</font></sub>  ) </td></tr><tr><td>  <em>CaseClause</em><sub><font size="2">1</font></sub> </td></tr><tr><td>    ···</td></tr><tr><td>  <em>CaseClause</em><sub><font size="2">n</font></sub> </td></tr><tr><td>  default <em>OptVarRef</em> return <em>Expr</em><sub><font size="2">n+1</font></sub></td></tr></tbody></table>
             <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
            
           </td></tr>
           <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <table><tbody><tr><td>typeswitch ( <font size="6">[</font> <em>Expr</em><sub><font size="2">0</font></sub> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> )</td></tr><tr><td><font size="6">[</font><em>CaseClause</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_case" class="judgment"><sub><font size="2">Case</font></sub></a></td></tr><tr><td>    ···</td></tr><tr><td><font size="6">[</font><em>CaseClause</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_case" class="judgment"><sub><font size="2">Case</font></sub></a></td></tr><tr><td><font size="6">[</font>  default <em>OptVarRef</em> return <em>Expr</em><sub><font size="2">n+1</font></sub> <font size="6">]</font><a href="#jd_map_case" class="judgment"><sub><font size="2">Case</font></sub></a></td></tr></tbody></table>
            
           </td></tr>
          </table></div>

        <p><b>Notation</b></p>
          <p>The following auxiliary grammar production is used to
          identify branches of the typeswitch.</p>

          
<h5><a id="N194CC" name="N194CC"/>CaseRules</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-CaseRules" name="doc-fs-CaseRules"/>[<small>78 (Formal)</small>]   </td><td><code>CaseRules</code></td><td>   ::=   </td><td><code>("case"  "$"  <a href="#doc-core-VarName">VarName</a>  "as"  <a href="#doc-core-SequenceType">SequenceType</a>  "return"  <a href="#doc-core-Expr">Expr</a>  <a href="#doc-fs-CaseRules">CaseRules</a>)  |  ("default"  "$"  <a href="#doc-core-VarName">VarName</a>  "return"  <a href="#doc-core-Expr">Expr</a>)</code></td></tr></tbody></table>

          <p id="jd_type_case">The following judgment</p>
 
        <div align="center">
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_type_case" class="judgment"><b>case</b></a> <em>CaseRules</em> <a href="#jd_type_case" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
           
        </div>

          <p>is used in the static of typeswitch. It indicates that
          under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a>, and with the
          input type of the typeswitch being <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, the given
          case rule yields the type <a href="#doc-fs-Type"><em>Type</em></a>.</p>

          <p id="jd_against">The following judgment</p>
 
        <div align="center">
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                   <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_against" class="judgment"><b>against</b></a> <em>CaseRules</em> <a href="#jd_against" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
           
        </div>

          <p>is used in the dynamic semantics of typeswitch. It
          indicates that under the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>,
          with the input value of the typeswitch being <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,
          the given case rules yields the value <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>.</p>

        <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>

          <p>The static typing rules for the typeswitch expression are
          simple.  Each case clause and the default clause of the
          typeswitch is typed independently. The type of the entire
          typeswitch expression is the union of the types of all the
          clauses.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                       <em>Expr</em><sub><font size="2">0</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> 
               
              </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                      <a href="#jd_type_case" class="judgment"><b>case</b></a> case <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em><sub><font size="2">1</font></sub> return <em>Expr</em><sub><font size="2">1</font></sub>
                      <a href="#jd_type_case" class="judgment"><b>:</b></a>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
                   ···
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                      <a href="#jd_type_case" class="judgment"><b>case</b></a> case <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> as <em>SequenceType</em><sub><font size="2">n</font></sub> return <em>Expr</em><sub><font size="2">n</font></sub>
                      <a href="#jd_type_case" class="judgment"><b>:</b></a>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                      <a href="#jd_type_case" class="judgment"><b>case</b></a> default <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n+1</font></sub> return <em>Expr</em><sub><font size="2">n</font></sub>
                      <a href="#jd_type_case" class="judgment"><b>:</b></a>
                      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n+1</font></sub>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             
              
               <table><tbody><tr><td valign="top"><a href="#xq_stat_env_def" class="env">statEnv</a> |-  </td><td>
                      <table><tbody><tr><td>(typeswitch (<em>Expr</em><sub><font size="2">0</font></sub>)</td></tr><tr><td>  case <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em><sub><font size="2">1</font></sub> return <em>Expr</em><sub><font size="2">1</font></sub></td></tr><tr><td>    ···</td></tr><tr><td>  case <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> as <em>SequenceType</em><sub><font size="2">n</font></sub> return <em>Expr</em><sub><font size="2">n</font></sub></td></tr><tr><td>  default <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n+1</font></sub> return <em>Expr</em><sub><font size="2">n+1</font></sub>)</td></tr></tbody></table>
                    </td></tr><tr><td/><td><a href="#jd_has_type" class="judgment"><b>:</b></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> | ... | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n+1</font></sub>)</td></tr></tbody></table>
              
             
            </td></tr>
           </table><br/>
          </div>

          <p>To type one case clause, the case variable is assigned
          the type of the case clause <em>Case</em><a href="#doc-fs-Type"><em>Type</em></a> and the body of
          the clause is typed in the extended environment.  Thus, the
          type of a case clause is independent of the type of the
          input expression.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                
                <em>Case</em><a href="#doc-fs-Type"><em>Type</em></a> = <font size="6">[</font> <em>SequenceType</em>
                <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
               
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<em>Variable</em> =&gt;
                       <em>Case</em><a href="#doc-fs-Type"><em>Type</em></a> ) <b> |- </b>
               <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
               
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> <a href="#jd_type_case" class="judgment"><b>case</b></a> case <a href="#prod-core-VarRef"><em>VarRef</em></a> as
              <em>SequenceType</em> return <em>Expr</em> <a href="#jd_type_case" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>

<p>
To type the default clause, the variable is assigned the type of the
input expression and the body of the default clause is typed in the
extended environment.
</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(<a href="#prod-core-VarRef"><em>VarRef</em></a> =&gt;
                       <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> ) <b> |- </b>
               <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
               
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> <a href="#jd_type_case" class="judgment"><b>case</b></a> default <a href="#prod-core-VarRef"><em>VarRef</em></a> 
              return <em>Expr</em> <a href="#jd_type_case" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>

  <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
          <p>The evaluation of a typeswitch proceeds as
          follows. First, the input expression is evaluated, yielding
          an input value.  The <b>effective case</b> is the
          first <code>case</code> clause such that the input value
          matches the SequenceType in the <code>case</code> clause.
          The <code>return</code> clause of the effective case is
          evaluated and the value of the <code>return</code>
          expression is the value of the typeswitch expression.</p>
          
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                     <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub>
             
             </td></tr>
             <tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                     <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> <a href="#jd_against" class="judgment"><b>against</b></a> <em>CaseRules</em> <a href="#jd_against" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
             
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                     typeswitch (<em>Expr</em>) <em>CaseRules</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
             
            </td></tr>
           </table><br/>
          </div>

          <p>If the value matches the sequence type, the following
          rule applies: It extends the dynamic environment by binding
          the variable <em>Variable</em> to <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> and evaluates the
          body of the <code>return</code> clause.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               
                 <em>Case</em><a href="#doc-fs-Type"><em>Type</em></a> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <em>Case</em><a href="#doc-fs-Type"><em>Type</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                 
                   <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub>) 
                 <b> |- </b>
                 
                   <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                 
               
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                     
                     <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> <a href="#jd_against" class="judgment"><b>against</b></a> case <a href="#prod-core-VarRef"><em>VarRef</em></a> as
                     <em>SequenceType</em> return <em>Expr</em> <em>CaseRules</em>
                     <a href="#jd_against" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                     
             
            </td></tr>
           </table><br/>
          </div>

          <p>If the value does not match the sequence type, the
          current case is not evaluated, and the remaining case rules
          are evaluated order by applying the inference rule
          recursively.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
             
              
                <em>Case</em><a href="#doc-fs-Type"><em>Type</em></a> = <font size="6">[</font> <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
              
                 
             
               <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
              <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <em>Case</em><a href="#doc-fs-Type"><em>Type</em></a>)
                 
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                     <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> <a href="#jd_against" class="judgment"><b>against</b></a>
                     <em>CaseRules</em> <a href="#jd_against" class="judgment"><b>=&gt;</b></a>
                     <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
             
            </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> <a href="#jd_against" class="judgment"><b>against</b></a> case
                     <em>SequenceType</em> <a href="#prod-core-VarRef"><em>VarRef</em></a> return <em>Expr</em>
                     <em>CaseRules</em> <a href="#jd_against" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                     
             
            </td></tr>
           </table><br/>
          </div>

          <p>The last rule states that the
          <code>default</code> branch of a typeswitch expression
          always evaluates to the value of its <code>return</code> clause.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
             
               <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(<em>Variable</em> =&gt; <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub>) <b> |- </b>
               <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
             
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                    <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">0</font></sub> <a href="#jd_against" class="judgment"><b>against</b></a> default
                    <a href="#prod-core-VarRef"><em>VarRef</em></a> return <em>Expr</em> <a href="#jd_against" class="judgment"><b>=&gt;</b></a>
                    <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
            
           </td></tr>
          </table><br/>
         </div>

        </div><div class="div3">
<h4><a id="sec_cast" name="sec_cast"/>4.12.3 Cast</h4><p><b>Introduction</b></p>
          <p>The <code>cast</code> expression can be used to convert a
          value to a specific datatype. It changes both the type and
          value of the result of an expression, and can only be
          applied to an atomic value.</p>
        
<h5><a id="N19A8B" name="N19A8B"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-CastExpr" name="doc-xquery-CastExpr"/>[<small>57 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CastExpr">CastExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-UnaryExpr">UnaryExpr</a> ( "cast"  "as"  <a href="#doc-xquery-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-SingleType" name="doc-xquery-SingleType"/>[<small>117 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-SingleType">SingleType</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-AtomicType">AtomicType</a>  "?"?</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
          <p>The Core grammar productions for <code>cast</code>
          expressions are:</p>
      
          
<h5><a id="N19AB4" name="N19AB4"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-CastExpr" name="doc-core-CastExpr"/>[<small>47 (Core)</small>]   </td><td><code><a href="#prod-core-CastExpr">CastExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ValueExpr">ValueExpr</a> ( "cast"  "as"  <a href="#doc-core-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-SingleType" name="doc-core-SingleType"/>[<small>81 (Core)</small>]   </td><td><code><a href="#prod-core-SingleType">SingleType</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-AtomicType">AtomicType</a>  "?"?</code></td></tr></tbody></table>
        <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
          <p>The normalization of cast applies atomization to its
          argument. The type declaration asserts that the result is
          a single atomic value.  The second normalization rule
          applies when the target type is optional.</p>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
           <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>Expr</em> cast as <a href="#doc-core-AtomicType"><em>AtomicType</em></a> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
           </td></tr>
           <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <table><tbody><tr><td>let $v as <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a> := <code>fn:data</code>((<font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) return</td></tr><tr><td>  $v cast as <a href="#doc-core-AtomicType"><em>AtomicType</em></a> </td></tr></tbody></table>
            
           </td></tr>
          </table></div>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
           <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>Expr</em> cast as <a href="#doc-core-AtomicType"><em>AtomicType</em></a>? <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
           </td></tr>
           <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <table><tbody><tr><td>let $v as <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>? := <code>fn:data</code>((<font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) return</td></tr><tr><td>  typeswitch ($v)</td></tr><tr><td>    case $<em>fs:</em>new as empty-sequence() return ()</td></tr><tr><td>    default $<em>fs:</em>new return $v cast as <a href="#doc-core-AtomicType"><em>AtomicType</em></a> </td></tr></tbody></table>
            
           </td></tr>
          </table></div>

        <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
          <p>The static typing rule of <code>cast</code> expression is
          as follows. The type of a Core <code>cast</code> expression
          is always the target type. Note that a <code>cast</code>
          expression can fail at run-time if the given value cannot be
          cast to the target type.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
            </td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <em>Expr</em> cast as <a href="#doc-core-AtomicType"><em>AtomicType</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a>
             
            </td></tr>
           </table><br/>
          </div>
        <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
          <p>The dynamic semantics of <code>cast</code> expressions is
          defined in <a href="http://www.w3.org/TR/xpath-functions/#casting">Section 
17 Casting</a><sup><small>FO</small></sup>. The
          semantics of cast expressions depends on the type of the
          input value and on the target type. For any source and
          target primitive types, the <em>casting table</em> in
          <a href="http://www.w3.org/TR/xpath-functions/#casting">Section 
17 Casting</a><sup><small>FO</small></sup> indicates whether the
          cast from the source type to the target type is permitted.
          When a cast is permitted, the detailed dynamic rules for
          cast in <a href="http://www.w3.org/TR/xpath-functions/#casting">Section 
17 Casting</a><sup><small>FO</small></sup> are applied.
          These rules are not specified further here.</p>
        </div><div class="div3">
<h4><a id="sec_castable" name="sec_castable"/>4.12.4 Castable</h4>
<h5><a id="N19BBE" name="N19BBE"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-CastableExpr" name="doc-xquery-CastableExpr"/>[<small>56 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CastableExpr">CastableExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#doc-xquery-SingleType">SingleType</a> )?</code></td></tr></tbody></table><p>Castable expressions check whether a value can be cast to a
        given type.</p><p><b>Core Grammar</b></p>
          <p>The Core grammar production for castable is:</p>
      
          
<h5><a id="N19BDA" name="N19BDA"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-CastableExpr" name="doc-core-CastableExpr"/>[<small>46 (Core)</small>]   </td><td><code><a href="#prod-core-CastableExpr">CastableExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#doc-core-SingleType">SingleType</a> )?</code></td></tr></tbody></table>
        <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
          <p>The normalization of castable simply maps its expression
          argument.</p>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
           <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>Expr</em> castable as <a href="#doc-core-AtomicType"><em>AtomicType</em></a><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
           </td></tr>
           <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <table><tbody><tr><td>let $v as <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a> := <code>fn:data</code>((<font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) return</td></tr><tr><td>$v castable as <a href="#doc-core-AtomicType"><em>AtomicType</em></a></td></tr></tbody></table>
            
           </td></tr>
          </table></div>

          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
           <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>Expr</em> castable as <a href="#doc-core-AtomicType"><em>AtomicType</em></a>?<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
           </td></tr>
           <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <table><tbody><tr><td>let $v as <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>? := <code>fn:data</code>((<font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)) return</td></tr><tr><td>$v castable as <a href="#doc-core-AtomicType"><em>AtomicType</em></a>?</td></tr></tbody></table>
            
           </td></tr>
          </table></div>

        <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
          <p>The type of a Core <code>castable</code> expression is
          always a boolean.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
            </td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <em>Expr</em> castable as <a href="#doc-core-AtomicType"><em>AtomicType</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code>
             
            </td></tr>
           </table><br/>
          </div>

        <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
          <p>If casting succeeds, then the <code>castable</code>
          expression evaluates to true.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                      <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> cast as <a href="#doc-core-AtomicType"><em>AtomicType</em></a> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                      <em>Expr</em> castable as <a href="#doc-core-AtomicType"><em>AtomicType</em></a> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> true
              
             </td></tr>
            </table></td></tr></table></td></tr>
           </table><br/>
          </div>

          <p>Otherwise, 'castable as' evaluates to false.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                      <a href="#jd_not" class="judgment"><b>not</b></a>(<em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                      <em>Expr</em><sub><font size="2">1</font></sub> castable as <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> false
              
             </td></tr>
            </table></td></tr></table></td></tr>
           </table><br/>
          </div>

        </div><div class="div3">
<h4><a id="sec_constructor-functions" name="sec_constructor-functions"/>4.12.5 Constructor Functions</h4><p>Constructor functions provide an alternative syntax for
        casting.</p><p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
          <p>Constructor functions for atomic types are normalized to
          explicit <code>cast as</code> expressions.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              <font size="6">[</font><a href="#doc-core-AtomicType"><em>AtomicType</em></a>(<em>Expr</em>)<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              <font size="6">[</font><em>Expr</em> cast as <a href="#doc-core-AtomicType"><em>AtomicType</em></a>? <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
             </td></tr>
            </table></div>

        </div><div class="div3">
<h4><a id="sec_treat" name="sec_treat"/>4.12.6 Treat</h4>
<h5><a id="N19D9E" name="N19D9E"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-TreatExpr" name="doc-xquery-TreatExpr"/>[<small>55 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-TreatExpr">TreatExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-CastableExpr">CastableExpr</a> ( "treat"  "as"  <a href="#doc-xquery-SequenceType">SequenceType</a> )?</code></td></tr></tbody></table><p><b>Introduction</b></p>
            <p>The expression "<em>Expr</em> treat as
            <em>SequenceType</em>", can be used to change the
            static type of the result of an expression without
            changing its value.  The treat-as expression raises a
            dynamic error if the dynamic type of the input value does
            not match the specified type.</p>
          <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
            <p>Treat as expressions are normalized to typeswitch
            expressions. Note that the following normalization rule
            uses a variable $<em>fs:</em>new, which is a newly created
            variable that does not conflict with any variables already
            in scope.</p>

            <div align="center"><table cellpadding="0" cellspacing="0" summary="">
             <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              <font size="6">[</font><em>Expr</em> treat as <em>SequenceType</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
             </td></tr>
             <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
               <table><tbody><tr><td>typeswitch (<font size="6">[</font> <em>Expr</em> <font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>)</td></tr><tr><td>  case $<em>fs:</em>new as <em>SequenceType</em> return $<em>fs:</em>new</td></tr><tr><td>  default $<em>fs:</em>new return <code>fn:error</code>()</td></tr></tbody></table>
              
             </td></tr>
            </table></div>
          </div></div><div class="div2">
<h3><a id="sec_validate_expr" name="sec_validate_expr"/>4.13 Validate Expressions</h3>
<h5><a id="N19E10" name="N19E10"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ValidateExpr" name="doc-xquery-ValidateExpr"/>[<small>63 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ValidateExpr">ValidateExpr</a></code></td><td>   ::=   </td><td><code>"validate"  <a href="#doc-xquery-ValidationMode">ValidationMode</a>?  "{"  <a href="#doc-xquery-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ValidationMode" name="doc-xquery-ValidationMode"/>[<small>64 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ValidationMode">ValidationMode</a></code></td><td>   ::=   </td><td><code>"lax"  |  "strict"</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
        <p>The Core grammar productions for validate are:</p>
      
    
<h5><a id="N19E32" name="N19E32"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-ValidateExpr" name="doc-core-ValidateExpr"/>[<small>49 (Core)</small>]   </td><td><code><a href="#prod-core-ValidateExpr">ValidateExpr</a></code></td><td>   ::=   </td><td><code>"validate"  <a href="#doc-core-ValidationMode">ValidationMode</a>?  "{"  <a href="#doc-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ValidationMode" name="doc-core-ValidationMode"/>[<small>50 (Core)</small>]   </td><td><code><a href="#prod-core-ValidationMode">ValidationMode</a></code></td><td>   ::=   </td><td><code>"lax"  |  "strict"</code></td></tr></tbody></table>
      <p>A <code>validate</code> expression validates its argument
      with respect to the <b>in-scope schema definitions</b>,
      using the schema validation process described in
      <a href="#xmlschema-1">[Schema Part 1]</a>. The argument to a validate expression must be
      either an element or a document node. Validation replaces all
      nodes with new nodes that have their own identity, the <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup>, and default values created
      during the validation process.</p><p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
        <p>A validate expression with no validation mode is normalized
        into a validate expression with the validation mode set to
        strict.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <font size="6">[</font>validate { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          validate strict { <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> }
        
        </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
        <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <font size="6">[</font>validate <em>ValidationMode</em> { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
        
        </td></tr>
        <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          validate <em>ValidationMode</em> { <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> }
        
        </td></tr>
        </table></div>

      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>Static typing of the validate operation is defined by the
        following rule.  Note the use of a subtyping check to ensure
        that the type of the expression to validate is either an
        element or a well-formed document node (i.e., with only one
        root element and no text nodes).  The type of the expression
        to validate may be a union of more than one element type.  We
        apply the <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a> judgment to each element type to
        determine the meaning of that element type with the given
        validation mode, which yields a new element type.  The result
        type is the union over all new element types.</p>

        <div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (element | document { <a href="#doc-fs-ElementType"><em>ElementType</em></a> })
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) =  <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">1</font></sub> |
            ... | <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">n</font></sub> 
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">1</font></sub> = element <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a><sub><font size="2">1</font></sub>
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            ···
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">n</font></sub> = element <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">n</font></sub>  <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a><sub><font size="2">n</font></sub>
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub> <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a> <em>ValidationMode</em> 
             <a href="#jd_in_validation_context" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">1</font></sub> 
           
           </td></tr>
           <tr valign="middle" align="center"><td>
           
            ···
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">n</font></sub> <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a> <em>ValidationMode</em> 
             <a href="#jd_in_validation_context" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">n</font></sub> 
           
           </td></tr>


           <tr valign="middle" align="center"><td>
           
            <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> = <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">1</font></sub> | ... | <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">n</font></sub>
           
           </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   validate <em>ValidationMode</em> { <em>Expr</em> } <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                   
           
          </td></tr>
         </table><br/>
        </div>
      <div class="div3">
<h4><a id="sec_validating_element" name="sec_validating_element"/>4.13.1 Validating an Element Node</h4><p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>

        <p>The normative dynamic semantics of validation is specified
        in <a href="http://www.w3.org/TR/xquery#id-validate">Section 
3.13 Validate Expressions</a><sup><small>XQ</small></sup>.  The effect of
        validation of a data model value is equivalent to:

        </p><ul><li><p>serialization of the data model, as described in
          <a href="#xslt-xquery-serialization">[Data Model Serialization]</a>, followed by</p></li><li><p>validation of the serialized value into a Post-Schema
          Validated Infoset, as described in <a href="#xmlschema-1">[Schema Part 1]</a>, followed by</p></li><li><p>construction of a new data model value, as described in
          <a href="#xpath-datamodel">[Data Model]</a>.</p></li></ul>

        <p>The above steps are expressed formally by the "erasure" and
        "annotation" judgments.  Formally, validation removes existing
        type annotations from nodes ("erasure"), and it re-validates
        the corresponding data model instance, possibly adding new
        type annotations to nodes ("annotation"). Both erasure and
        annotation are described formally in <a href="#sec_validation_judgments"><b>[E Auxiliary Judgments for Validation]</b></a>. Indeed, the conjunction of
        erasure and annotation provides a formal model for a large
        part of actual schema validation. The semantics of the
        <code>validate</code> expression is specified as follows.</p>

        <p>In the first premise below, the expression to validate is
        evaluated. The resulting value must be an element or document
        node. The second premise constructs a new value in which all
        existing type annotations have been erased. The third premise
        determines the element type that corresponds to the element
        node's name in the given validation mode. The last premise
        validates erased element node with the type against which it
        is validated, using the <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> judgment, yielding
        the final validated element.</p>

        <div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           
             
               <a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a>
             <b> |- </b>
             
               <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">1</font></sub>
             
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">1</font></sub> <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">2</font></sub> 
            
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            
            <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">2</font></sub> = element <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub> of type <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">2</font></sub> { <a href="#doc-fs-Value"><em>Value</em></a> }

           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub> <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a> <em>ValidationMode</em> 
             <a href="#jd_in_validation_context" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">2</font></sub> 
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">2</font></sub> ( <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">2</font></sub>) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
             <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">3</font></sub> 
           
           </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                   validate <em>ValidationMode</em> { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                   <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">3</font></sub> 
                   
           
          </td></tr>
         </table><br/>
        </div>
</div><div class="div3">
<h4><a id="sec_validating_document" name="sec_validating_document"/>4.13.2 Validating a Document Node</h4><p>The rule for validating a document node is similar to that
      for validating an element node.</p><p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           
             
               <a href="#xq_stat_env_def" class="env">statEnv</a>; <a href="#xq_dyn_env_def" class="env">dynEnv</a>
             <b> |- </b>
             
               <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> document { <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">1</font></sub> }
             
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            document { <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">1</font></sub> } <a href="#jd_erases_to" class="judgment"><b>erases to</b></a>
            document { <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">2</font></sub> }
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            
            <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">2</font></sub> = element <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub> of type <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">2</font></sub> { <a href="#doc-fs-Value"><em>Value</em></a> }

           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub> <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a>
            <em>ValidationMode</em> <a href="#jd_in_validation_context" class="judgment"><b>resolves to</b></a>
            <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">2</font></sub> 
           
           </td></tr>

           <tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> document { <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">2</font></sub> } (document { <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">2</font></sub> }) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
            document { <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">3</font></sub> }
           
           </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                   validate <em>ValidationMode</em> { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a>
                   document { <a href="#doc-fs-ElementValue"><em>ElementValue</em></a><sub><font size="2">3</font></sub> }
                   
           
          </td></tr>
         </table><br/>
        </div>

      </div></div><div class="div2">
<h3><a id="id-extension-expressions" name="id-extension-expressions"/>4.14 Extension Expressions</h3><p><b>Introduction</b></p>
     <p>An extension expression is an expression whose semantics are
     implementation-defined. An extension expression consists of one
     or more pragmas, followed by an expression enclosed in curly
     braces.</p>

     
<h5><a id="N1A218" name="N1A218"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ExtensionExpr" name="doc-xquery-ExtensionExpr"/>[<small>65 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ExtensionExpr" class="xquery">ExtensionExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-Pragma">Pragma</a>+  "{"  <a href="#doc-xquery-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-Pragma" name="doc-xquery-Pragma"/>[<small>66 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Pragma" class="xquery">Pragma</a></code></td><td>   ::=   </td><td><code>"(#"  S?  QName  <a href="#doc-xquery-PragmaContents">PragmaContents</a>  "#)"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-PragmaContents" name="doc-xquery-PragmaContents"/>[<small>67 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-PragmaContents" class="xquery">PragmaContents</a></code></td><td>   ::=   </td><td><code>(Char* - (Char* '#)' Char*))</code></td></tr></tbody></table>
   <p><b>Core Grammar</b></p>
     <p>The Core grammar productions for ExtensionExpr are:</p>

     
<h5><a id="N1A259" name="N1A259"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-ExtensionExpr" name="doc-core-ExtensionExpr"/>[<small>51 (Core)</small>]   </td><td><code><a href="#prod-core-ExtensionExpr" class="xquery">ExtensionExpr</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-Pragma">Pragma</a>+  "{"  <a href="#doc-core-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-Pragma" name="doc-core-Pragma"/>[<small>52 (Core)</small>]   </td><td><code><a href="#prod-core-Pragma" class="xquery">Pragma</a></code></td><td>   ::=   </td><td><code>"(#"  <a href="#prod-core-S">S</a>?  <a href="#prod-core-QName">QName</a>  <a href="#doc-core-PragmaContents">PragmaContents</a>  "#)"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-PragmaContents" name="doc-core-PragmaContents"/>[<small>53 (Core)</small>]   </td><td><code><a href="#prod-core-PragmaContents" class="xquery">PragmaContents</a></code></td><td>   ::=   </td><td><code>(<a href="#prod-core-Char">Char</a>* - (Char* '#)' Char*))</code></td></tr></tbody></table>
   <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Extension expressions are normalized as extension expressions
      in the [XPath/XQuery] Core.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font><em>Pragma</em>+ { <em>Expr</em> }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         <em>Pragma</em>+ { <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> }
       </td></tr>
      </table></div>

      <p>If the extension expression does not contain any expression,
      this is normalized into an extension expression with a call to
      the <code>fn:error</code> function.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font><em>Pragma</em>+ { }<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         <em>Pragma</em>+ { <code>fn:error</code>() }
       </td></tr>
      </table></div>

   <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
     <p>If at least one of the pragmas is recognized, the static
     semantics are implementation-defined.</p>

     <p>If none of the pragmas is recognized, the static semantics
     are the same as for the input expression. In both cases, the
     static typing must be applied on the input expression, possibly
     raising the corresponding type errors.</p>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
           
          
        </td></tr>
        <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             A <em>Pragma</em> is recognized, yielding the
             implementation-defined static type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.
           
          
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <em>Pragma</em>+ { <em>Expr</em> } <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
         
        
       </td></tr>
      </table><br/>
     </div>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
           
          
        </td></tr>
        <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             No <em>Pragma</em> is recognized.
           
          
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <em>Pragma</em>+ { <em>Expr</em> } <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
         
        
       </td></tr>
      </table><br/>
     </div>

   <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
     <p>The QName of a pragma must resolve to a namespace URI and
     local name, using the statically known namespaces. If at least
     one of the pragmas is recognized, the dynamic semantics is
     implementation-defined.</p>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
           
             Some <em>Pragma</em> are recognized, yielding the
             implementation-defined value <a href="#doc-fs-Value"><em>Value</em></a>.
           
          
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
          <em>Pragma</em>+ { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
         
        
       </td></tr>
      </table><br/>
     </div>

     <p>If none of the pragmas is recognized the dynamic semantics of
     an <em>ExtensionExpr</em> are the same as evaluating the given
     expression.</p>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          
           
             No <em>Pragma</em> is recognized.
           
              
          
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
           
             <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
           
          
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         
          <em>Pragma</em>+ { <em>Expr</em> } <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
         
        
       </td></tr>
      </table><br/>
     </div>

   </div></div><div class="div1">
<h2><a id="id-query-prolog" name="id-query-prolog"/>5 Modules and Prologs</h2><p>The organization of this section parallels the organization of
  <a href="http://www.w3.org/TR/xquery#id-query-prolog">Section 
4 Modules and Prologs</a><sup><small>XQ</small></sup>.</p><p><b>Introduction</b></p>
    <p>XQuery supports modules as defined in <a href="http://www.w3.org/TR/xquery#id-query-prolog">Section 
4 Modules and Prologs</a><sup><small>XQ</small></sup>.  A <a href="http://www.w3.org/TR/xquery#dt-main-module">main module</a><sup><small>XQ</small></sup> contains a <a href="http://www.w3.org/TR/xquery#dt-prolog">Prolog</a><sup><small>XQ</small></sup> followed by a <a href="http://www.w3.org/TR/xquery#dt-queryBody">query body</a><sup><small>XQ</small></sup>.  A query has exactly one main module. In a
    main module, the <a href="http://www.w3.org/TR/xquery#dt-queryBody">query body</a><sup><small>XQ</small></sup> can be
    evaluated, and its value is the result of the query. A <a href="http://www.w3.org/TR/xquery#dt-library-module">library module</a><sup><small>XQ</small></sup> contains a module declaration
    followed by a <a href="http://www.w3.org/TR/xquery#dt-prolog">Prolog</a><sup><small>XQ</small></sup>.</p>

    <p>The Prolog is a sequence of declarations that affect query
    processing. The Prolog can be used, for example, to declare
    namespace prefixes, import types from XML Schemas, and declare
    functions and variables.  Namespace declarations and schema
    imports always precede function and variable declarations, as
    specified by the following grammar productions.</p>

    
<h5><a id="N1A471" name="N1A471"/>Query Module</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-Module" name="doc-xquery-Module"/>[<small>1 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Module">Module</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-VersionDecl">VersionDecl</a>?  (<a href="#doc-xquery-LibraryModule">LibraryModule</a>  |  <a href="#doc-xquery-MainModule">MainModule</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-MainModule" name="doc-xquery-MainModule"/>[<small>3 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-MainModule">MainModule</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-Prolog">Prolog</a>  <a href="#doc-xquery-QueryBody">QueryBody</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-LibraryModule" name="doc-xquery-LibraryModule"/>[<small>4 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-LibraryModule">LibraryModule</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-ModuleDecl">ModuleDecl</a>  <a href="#doc-xquery-Prolog">Prolog</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-Prolog" name="doc-xquery-Prolog"/>[<small>6 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Prolog">Prolog</a></code></td><td>   ::=   </td><td><code>((<a href="#doc-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</a>  |  <a href="#doc-xquery-Setter">Setter</a>  |  <a href="#doc-xquery-NamespaceDecl">NamespaceDecl</a>  |  <a href="#doc-xquery-Import">Import</a>)  <a href="#doc-xquery-Separator">Separator</a>)*  ((<a href="#doc-xquery-VarDecl">VarDecl</a>  |  <a href="#doc-xquery-FunctionDecl">FunctionDecl</a>  |  <a href="#doc-xquery-OptionDecl">OptionDecl</a>)  <a href="#doc-xquery-Separator">Separator</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-Setter" name="doc-xquery-Setter"/>[<small>7 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Setter">Setter</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-BoundarySpaceDecl">BoundarySpaceDecl</a>  |  <a href="#doc-xquery-DefaultCollationDecl">DefaultCollationDecl</a>  |  <a href="#doc-xquery-BaseURIDecl">BaseURIDecl</a>  |  <a href="#doc-xquery-ConstructionDecl">ConstructionDecl</a>  |  <a href="#doc-xquery-OrderingModeDecl">OrderingModeDecl</a>  |  <a href="#doc-xquery-EmptyOrderDecl">EmptyOrderDecl</a>  |  <a href="#doc-xquery-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-Import" name="doc-xquery-Import"/>[<small>8 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Import">Import</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-SchemaImport">SchemaImport</a>  |  <a href="#doc-xquery-ModuleImport">ModuleImport</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-Separator" name="doc-xquery-Separator"/>[<small>9 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Separator">Separator</a></code></td><td>   ::=   </td><td><code>";"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-QueryBody" name="doc-xquery-QueryBody"/>[<small>30 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-QueryBody">QueryBody</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-Expr">Expr</a></code></td></tr></tbody></table>

    <p>Function declarations are globally scoped, that is, the use of
    a function name in a function call may precede declaration of the
    function.  Variable declarations are lexically scoped, i.e.,
    variable declarations must precede variable uses.</p>

  <p><b>Core Grammar</b></p>
     <p>The Core grammar productions for the prolog are:</p>

    
<h5><a id="N1A547" name="N1A547"/>Query Module</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-Module" name="doc-core-Module"/>[<small>1 (Core)</small>]   </td><td><code><a href="#prod-core-Module">Module</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-VersionDecl">VersionDecl</a>?  (<a href="#doc-core-LibraryModule">LibraryModule</a>  |  <a href="#doc-core-MainModule">MainModule</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-MainModule" name="doc-core-MainModule"/>[<small>3 (Core)</small>]   </td><td><code><a href="#prod-core-MainModule">MainModule</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-Prolog">Prolog</a>  <a href="#doc-core-QueryBody">QueryBody</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-LibraryModule" name="doc-core-LibraryModule"/>[<small>4 (Core)</small>]   </td><td><code><a href="#prod-core-LibraryModule">LibraryModule</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-ModuleDecl">ModuleDecl</a>  <a href="#doc-core-Prolog">Prolog</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-Prolog" name="doc-core-Prolog"/>[<small>6 (Core)</small>]   </td><td><code><a href="#prod-core-Prolog">Prolog</a></code></td><td>   ::=   </td><td><code>((<a href="#doc-core-DefaultNamespaceDecl">DefaultNamespaceDecl</a>  |  <a href="#doc-core-Setter">Setter</a>  |  <a href="#doc-core-NamespaceDecl">NamespaceDecl</a>  |  <a href="#doc-core-Import">Import</a>)  <a href="#doc-core-Separator">Separator</a>)*  ((<a href="#doc-core-VarDecl">VarDecl</a>  |  <a href="#doc-core-FunctionDecl">FunctionDecl</a>  |  <a href="#doc-core-OptionDecl">OptionDecl</a>)  <a href="#doc-core-Separator">Separator</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-Setter" name="doc-core-Setter"/>[<small>7 (Core)</small>]   </td><td><code><a href="#prod-core-Setter">Setter</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-DefaultCollationDecl">DefaultCollationDecl</a>  |  <a href="#doc-core-BaseURIDecl">BaseURIDecl</a>  |  <a href="#doc-core-ConstructionDecl">ConstructionDecl</a>  |  <a href="#doc-core-OrderingModeDecl">OrderingModeDecl</a>  |  <a href="#doc-core-EmptyOrderDecl">EmptyOrderDecl</a>  |  <a href="#doc-core-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-Import" name="doc-core-Import"/>[<small>8 (Core)</small>]   </td><td><code><a href="#prod-core-Import">Import</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-SchemaImport">SchemaImport</a>  |  <a href="#doc-core-ModuleImport">ModuleImport</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-Separator" name="doc-core-Separator"/>[<small>9 (Core)</small>]   </td><td><code><a href="#prod-core-Separator">Separator</a></code></td><td>   ::=   </td><td><code>";"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-QueryBody" name="doc-core-QueryBody"/>[<small>29 (Core)</small>]   </td><td><code><a href="#prod-core-QueryBody">QueryBody</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-Expr">Expr</a></code></td></tr></tbody></table>

  <p><b>Notation</b></p>
    <p>The XQuery Prolog requires that declarations appear in a
    particular order.  In the Formal Semantics, it is simpler to
    assume the declarations can appear in any order, as it does not
    change their semantics -- we simply assume that an XQuery
    parser has enforced the required order.</p>

    <p>The Prolog contains a variety of declarations that specify the
    initial static and dynamic context of the query.  The following
    formal grammar productions represent any Prolog declaration.</p>
  
    
<h5><a id="N1A617" name="N1A617"/>Prolog Declarations</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-PrologDeclList" name="doc-fs-PrologDeclList"/>[<small>79 (Formal)</small>]   </td><td><code>PrologDeclList</code></td><td>   ::=   </td><td><code>(<a href="#doc-fs-PrologDecl">PrologDecl</a>  <a href="#doc-core-Separator">Separator</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-PrologDecl" name="doc-fs-PrologDecl"/>[<small>80 (Formal)</small>]   </td><td><code>PrologDecl</code></td><td>   ::=   </td><td><code><a href="#doc-core-DefaultCollationDecl">DefaultCollationDecl</a><br/>|  <a href="#doc-core-BaseURIDecl">BaseURIDecl</a><br/>|  <a href="#doc-core-ConstructionDecl">ConstructionDecl</a><br/>|  <a href="#doc-core-OrderingModeDecl">OrderingModeDecl</a><br/>|  <a href="#doc-core-EmptyOrderDecl">EmptyOrderDecl</a><br/>|  <a href="#doc-core-CopyNamespacesDecl">CopyNamespacesDecl</a><br/>|  <a href="#doc-core-SchemaImport">SchemaImport</a><br/>|  <a href="#doc-core-ModuleImport">ModuleImport</a><br/>|  <a href="#doc-core-NamespaceDecl">NamespaceDecl</a><br/>|  <a href="#doc-core-DefaultNamespaceDecl">DefaultNamespaceDecl</a><br/>|  <a href="#doc-core-VarDecl">VarDecl</a><br/>|  <a href="#doc-core-FunctionDecl">FunctionDecl</a><br/>|  <a href="#doc-core-OptionDecl">OptionDecl</a></code></td></tr></tbody></table>

    <p id="jd_map_prolog">The function <font size="6">[</font><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
    takes a prolog declaration and maps it into its equivalent
    declaration in the Core grammar.</p>

    <div align="center"><table cellpadding="0" cellspacing="0" summary="">
     <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      
       <font size="6">[</font><em>PrologDecl</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
      
     </td></tr>
     <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      
       <em>PrologDecl</em><sub><font size="2">2</font></sub>
      
     </td></tr>
    </table></div>

    <p id="jd_yields_context">The following auxiliary judgments are
    applied when statically processing the declarations in the prolog.
    The effect of the judgment is to process each prolog declaration
    in order, constructing a new static environment from the static
    environment constructed from previous prolog declarations.</p>

    <p>The judgment:</p>

    <div align="center">
      
      	<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub><b> |- </b>
        <em>PrologDeclList</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
        <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> <a href="#jd_yields_context" class="judgment"><b>with</b></a> <em>PrologDeclList</em><sub><font size="2">1</font></sub>
        
      
    </div>

    <p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>, the
    sequence of prolog declarations <em>PrologDeclList</em> yields the
    static environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> and the normalized sequence of
    prolog declarations in the Core grammar.</p>

    <p>The judgment:</p>

    <div align="center">
      
        <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub><b> |- </b>
        <em>PrologDecl</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>
      
    </div>

    <p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>, the
    single prolog declaration <em>PrologDecl</em> yields the new static
    environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>.</p>

  <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
    <p>Prolog declarations are processed in the order they are
    encountered.  The normalization of a prolog declaration
    <em>PrologDecl</em> depends on the static context processing of all
    previous prolog declarations.  In turn, static context processing
    of <em>PrologDecl</em> depends on the normalization of the
    <em>PrologDecl</em>.  For example, because variables are lexically
    scoped, the normalization and static context processing of a
    variable declaration depends on the normalization and static
    context processing of all previous variable declarations.
    Therefore, the normalization phase and static context processing
    are interleaved, with normalization preceding static context
    processing for each prolog declaration.</p>

    <p>The following inference rules express this dependency.  The
    first rule specifies that for an empty sequence of prolog
    declarations, the initial static environment is the default static
    context.</p>

    <div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
       
     	   <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         () <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a> <a href="#jd_yields_context" class="judgment"><b>with</b></a> ()
       
      </td></tr>
     </table><br/>
    </div>

    <p>The next rule interleaves normalization and static context
    processing.  The result of static context processing and
    normalization is a static context and the normalized prolog
    declarations.</p>

    <div align="center">
  	<table cellpadding="0" cellspacing="0" summary="">
  	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
  	    <tr valign="middle" align="center"><td>
  	      
              <font size="6">[</font><em>PrologDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
              == <em>PrologDecl</em><sub><font size="2">1</font></sub>
  	      
  	    </td></tr>
  	    <tr valign="middle" align="center"><td>
            
      	<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
      	<em>PrologDecl</em><sub><font size="2">1</font></sub> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
            
  	    </td></tr>
  	    <tr valign="middle" align="center"><td>
  	      
      	<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub><b> |- </b>
              <em>PrologDeclList</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
              <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> <a href="#jd_yields_context" class="judgment"><b>with</b></a> <em>PrologDeclList</em><sub><font size="2">1</font></sub>
  	      
  	    </td></tr>
  	  </table></td></tr></table></td></tr>
  	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
  	      
      	<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <em>PrologDecl</em> ; <em>PrologDeclList</em>
              <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> <a href="#jd_yields_context" class="judgment"><b>with</b></a>
              <em>PrologDecl</em><sub><font size="2">1</font></sub> ; <em>PrologDeclList</em><sub><font size="2">1</font></sub>
  	      
  	  </td></tr>
  	</table><br/>
    </div>
  <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
    <p>Static typing of a main module follows context processing and
    normalization.  Context processing and normalization of a main
    module applies the rules above to the prolog, then using the
    resulting static environment <a href="#xq_stat_env_def" class="env">statEnv</a>, the query body is
    normalized into a Core expression, and the static typing rules are
    applied to this Core expression.</p>

    <div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        
      	 <a href="#xq_default_stat_env" class="env">statEnvDefault</a><b> |- </b>
         <em>PrologDeclList</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a>
         <a href="#xq_stat_env_def" class="env">statEnv</a> <a href="#jd_yields_context" class="judgment"><b>with</b></a> <em>PrologDeclList</em><sub><font size="2">1</font></sub>
        
       </td></tr>
       <tr valign="middle" align="center"><td>
       
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
        <font size="6">[</font><em>QueryBody</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> == <em>Expr</em><sub><font size="2">2</font></sub> 
       
       </td></tr>
       <tr valign="middle" align="center"><td>
       
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
        <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
       
       </td></tr>
      </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
           <em>PrologDeclList</em> <em>QueryBody</em>
           <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
           
       </td></tr>
     </table><br/>
    </div>
  <p><b>Notation</b></p>
    <p id="jd_yields_dyn_context">Similarly, the judgment:</p>

    <div align="center">
      
      	<a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub><b> |- </b>
        <em>PrologDeclList</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub>
      
    </div>

    <p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>, the
    sequence of prolog declarations <em>PrologDeclList</em> yields the
    static environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> and the normalized sequence of
    prolog declarations in the Core grammar.</p>

    <p>The judgment:</p>

    <div align="center">
      
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
        <em>PrologDecl</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
      
    </div>

    <p>holds if under the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>, the single
    prolog declaration <em>PrologDecl</em> yields the new dynamic
    environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>.</p>
  <p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
    <p>The rules for initializing the dynamic context are as follows.
    The first rule specifies for an empty sequence of prolog
    declarations, the initial dynamic environment is the default
    dynamic context.</p>

    <div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         () <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
        
      </td></tr>
     </table><br/>
    </div>

    <p>The second rule simply computes the dynamic environment by
    processing the prolog declarations in order.</p>

    <div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        
         <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         <em>PrologDecl</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
        
       </td></tr>
       <tr valign="middle" align="center"><td>
        
         <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub><b> |- </b>
         <em>PrologDeclList</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub>
        
       </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
         <em>PrologDecl</em> ; <em>PrologDeclList</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub>
        
      </td></tr>
     </table><br/>
    </div>

  <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
    <p>Dynamic evaluation of a main module applies the rules for
    dynamic-context processing to the prolog declarations, then using
    the resulting dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a>, the dynamic
    evaluation rules are applied to the normalized query body.</p>

    <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td>
           
            <a href="#xq_default_dyn_env" class="env">dynEnvDefault</a><b> |- </b>
             <em>PrologDeclList</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a>
           
          </td></tr>
          <tr valign="middle" align="center"><td>
           
            <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            <font size="6">[</font><em>QueryBody</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> <em>Expr</em><sub><font size="2">2</font></sub>
           
          </td></tr>
          <tr valign="middle" align="center"><td>
           
            <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
           
          </td></tr>
        </table></td></tr></table></td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td>
            
              <em>PrologDeclList</em> <em>QueryBody</em>
              <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
            
          </td></tr>
        </table></td></tr></table></td></tr>
      </table><br/>
    </div>
  <p><b>Notation</b></p>
    <p id="jd_module_statEnv">We define a new judgment that maps a
    module's URI (or a main module) to the corresponding module's
    static environment:</p>

    <div align="center">
     
      (<em>URI</em> | #MAIN) <a href="#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a>
     
    </div>

    <p id="jd_module_dynEnv">We also define a new judgment that maps a
    module's URI (or a main module) to the corresponding module's
    dynamic environment:</p>

    <div align="center">
     
      (<em>URI</em> | #MAIN) <a href="#jd_module_dynEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
     
    </div>

    <p>For a main module, those judgments are defined as follows.</p>

    <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
          
     <em>PrologDeclList</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a>
          
          </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
            
     #MAIN <a href="#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a>
            
          </td></tr>
	  </table></td></tr></table></td></tr>
      </table><br/>
    </div>

    <div align="center">
    	<table cellpadding="0" cellspacing="0" summary="">
    	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
    	    <tr valign="middle" align="center"><td>
            
     <em>PrologDeclList</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
            
          </td></tr>
    	  </table></td></tr></table></td></tr>
    	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
    	    <tr valign="middle" align="center"><td>
     #MAIN <a href="#jd_module_dynEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
          </td></tr>
    	  </table></td></tr></table></td></tr>
      </table><br/>
    </div>

    <p>For a library module, those judgments are defined in <a href="#id-module-imports"><b>[5.11 Module Import]</b></a>.</p>
  <div class="div2">
<h3><a id="sec_version-declaration" name="sec_version-declaration"/>5.1 Version Declaration</h3><p><b>Introduction</b></p>
      <p>A version declaration specifies the applicable XQuery syntax
      and semantics for a module.  An XQuery implementation must raise
      a static error when processing a query labeled with a version
      that the implementation does not support.  This document applies
      toXQuery 1.0 only and does not specify this static error
      formally.</p>
    
<h5><a id="N1AADD" name="N1AADD"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-VersionDecl" name="doc-xquery-VersionDecl"/>[<small>2 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-VersionDecl">VersionDecl</a></code></td><td>   ::=   </td><td><code>"xquery"  "version"  <a href="#doc-xquery-StringLiteral">StringLiteral</a>  ("encoding"  <a href="#doc-xquery-StringLiteral">StringLiteral</a>)?  <a href="#doc-xquery-Separator">Separator</a></code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The core grammar production for version declarations is:</p>

      
<h5><a id="N1AAFD" name="N1AAFD"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-VersionDecl" name="doc-core-VersionDecl"/>[<small>2 (Core)</small>]   </td><td><code><a href="#prod-core-VersionDecl">VersionDecl</a></code></td><td>   ::=   </td><td><code>"xquery"  "version"  <a href="#doc-core-StringLiteral">StringLiteral</a>  ("encoding"  <a href="#doc-core-StringLiteral">StringLiteral</a>)?  <a href="#doc-core-Separator">Separator</a></code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Version declaration are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>VersionDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>VersionDecl</em>
        
       </td></tr>
      </table></div>
    </div><div class="div2">
<h3><a id="id-module-declaration" name="id-module-declaration"/>5.2 Module Declaration</h3><p><b>Introduction</b></p>
      
<h5><a id="N1AB3F" name="N1AB3F"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ModuleDecl" name="doc-xquery-ModuleDecl"/>[<small>5 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ModuleDecl">ModuleDecl</a></code></td><td>   ::=   </td><td><code>"module"  "namespace"  NCName  "="  URILiteral  <a href="#doc-xquery-Separator">Separator</a></code></td></tr></tbody></table>

      <p>We assume that the static-context processing and
      dynamic-context processing described in <a href="#id-query-prolog"><b>[5 Modules and Prologs]</b></a> are applied to all library modules
      <em>before</em> the normalization, static context
      processing, and dynamic context processing of the main module.
      That is, at the time an "import module" declaration is
      processed, we assume that the static and dynamic context of the
      imported module is already available.  This assumption does not
      require or assume separate compilation of modules.  An
      implementation might process all or some imported modules
      statically (i.e., before the importing module is identified) or
      dynamically (i.e., when the importing module is identified and
      processed).</p>
    <p><b>Core Grammar</b></p>
      <p>The core grammar production for module declarations is:</p>

      
<h5><a id="N1AB69" name="N1AB69"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-ModuleDecl" name="doc-core-ModuleDecl"/>[<small>5 (Core)</small>]   </td><td><code><a href="#prod-core-ModuleDecl">ModuleDecl</a></code></td><td>   ::=   </td><td><code>"module"  "namespace"  <a href="#prod-core-NCName">NCName</a>  "="  <a href="#prod-core-URILiteral">URILiteral</a>  <a href="#doc-core-Separator">Separator</a></code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Module declarations are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>ModuleDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>ModuleDecl</em>
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
      <p>The effect of a module declaration is to apply the static
      processing rules defined in <a href="#id-query-prolog"><b>[5 Modules and Prologs]</b></a> to
      the module's prolog.  The resulting static context is then
      available to any importing module.</p>

      <p>The module declaration extends the prolog with a namespace
      declaration that binds the module's prefix to its URI, then
      computes the static context for the complete module.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
              declare namespace <em>NCName</em> =
                    <em>URILiteral</em> ; <em>PrologDeclList</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a>
            </td></tr>
	    <tr valign="middle" align="center"><td>
              module namespace <em>NCName</em> = <em>URILiteral</em> <em>PrologDeclList</em>
            </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
              <em>URILiteral</em> <a href="#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a>
            </td></tr>
	  </table></td></tr></table></td></tr>
        </table><br/>
      </div>

      <p>Note that the rule above and the rules for static processing
      of an "import module" declaration in <a href="#id-module-imports"><b>[5.11 Module Import]</b></a> are mutually recursive.</p>

    <p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
      <p>The dynamic context processing of a module declaration is
      similar to that of static processing.  The module declaration
      extends the prolog with a namespace declaration that binds the
      module's prefix to its URI, then computes the dynamic context
      for the complete module.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
              (declare namespace <em>NCName</em> =
                    <em>URILiteral</em> <em>PrologDeclList</em>) <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
            </td></tr>
	    <tr valign="middle" align="center"><td>
              module namespace <em>NCName</em> = <em>URILiteral</em> <em>PrologDeclList</em>
            </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
              <em>URILiteral</em> <a href="#jd_module_dynEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
            </td></tr>
	  </table></td></tr></table></td></tr>
        </table><br/>
      </div>

      <p>Note that the rule above and the rules for dynamic processing
      of an "import module" declaration in <a href="#id-module-imports"><b>[5.11 Module Import]</b></a> are mutually recursive.</p>

    </div><div class="div2">
<h3><a id="sec_boundary-space-decls" name="sec_boundary-space-decls"/>5.3 Boundary-space Declaration</h3>
<h5><a id="N1AC5D" name="N1AC5D"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-BoundarySpaceDecl" name="doc-xquery-BoundarySpaceDecl"/>[<small>11 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-BoundarySpaceDecl">BoundarySpaceDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "boundary-space"  ("preserve"  |  "strip")</code></td></tr></tbody></table><p>The xmlspace declaration is not specified formally as the
    Formal Semantics is defined on the Core language, which is an
    abstract, not concrete, syntax and is typically the result of
    parsing phase described in <a href="#id-fs-processing-model"><b>[3.2.1 Processing model]</b></a>.</p></div><div class="div2">
<h3><a id="sec_default-collation-declaration" name="sec_default-collation-declaration"/>5.4 Default Collation Declaration</h3>
<h5><a id="N1AC70" name="N1AC70"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-DefaultCollationDecl" name="doc-xquery-DefaultCollationDecl"/>[<small>19 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DefaultCollationDecl">DefaultCollationDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "default"  "collation"  URILiteral</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
     <p>The core grammar production for default collation declarations is:</p>

     
<h5><a id="N1AC84" name="N1AC84"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-DefaultCollationDecl" name="doc-core-DefaultCollationDecl"/>[<small>18 (Core)</small>]   </td><td><code><a href="#prod-core-DefaultCollationDecl">DefaultCollationDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "default"  "collation"  <a href="#prod-core-URILiteral">URILiteral</a></code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Default collation declarations are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>DefaultCollationDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>DefaultCollationDecl</em>
        
       </td></tr>
      </table></div>

    <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
      <p>The default collation declaration updates the collations
      environment component within the static environment.  The
      collations environment component is used by several functions in
      <a href="#xpath-functions">[Functions and Operators]</a>, but is not used in the Formal Semantics.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
	      
                
                    <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collations_env" class="env">collations</a>(<em>URILiteral</em>) = <em>Collation</em>
                
	      
            </td></tr>
            <tr valign="middle" align="center"><td>
	      
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_default_collation_env" class="env">defaultCollation</a>(<em>Collation</em>) 
                
	      
            </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare default collation <em>URILiteral</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

    <p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
      <p>The default collation declaration does not affect the dynamic
      context.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                declare default collation <em>URILiteral</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>
</div><div class="div2">
<h3><a id="sec_base-uri-decl" name="sec_base-uri-decl"/>5.5 Base URI Declaration</h3>
<h5><a id="N1AD55" name="N1AD55"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-BaseURIDecl" name="doc-xquery-BaseURIDecl"/>[<small>20 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-BaseURIDecl">BaseURIDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "base-uri"  URILiteral</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
     <p>The core grammar production for base uri declarations is:</p>

      
<h5><a id="N1AD69" name="N1AD69"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-BaseURIDecl" name="doc-core-BaseURIDecl"/>[<small>19 (Core)</small>]   </td><td><code><a href="#prod-core-BaseURIDecl">BaseURIDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "base-uri"  <a href="#prod-core-URILiteral">URILiteral</a></code></td></tr></tbody></table>
  <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
    <p>Base URI declarations are left unchanged through
    normalization.</p>

    <div align="center"><table cellpadding="0" cellspacing="0" summary="">
     <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      
       <font size="6">[</font><em>BaseURIDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
      
     </td></tr>
     <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      
        <em>BaseURIDecl</em>
      
     </td></tr>
    </table></div>
  <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
    <p>A base URI declaration specifies the base URI property of the
    static context, which is used when resolving relative URIs within
    a module.  A static error is raised if more than one base URI
    declaration is declared in a query prolog. </p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
              
                    <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_base_uri_env" class="env">baseURI</a>(<em>URILiteral</em>) 

</td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
declare base-uri <em>URILiteral</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>

</td></tr>
	  </table></td></tr></table></td></tr>
        </table><br/>
      </div>
<p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
<p>The base URI declaration does not affect the dynamic
context. </p>
      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                declare base-uri <em>URILiteral</em>  <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>
</div><div class="div2">
<h3><a id="sec_validation_decl" name="sec_validation_decl"/>5.6 Construction Declaration</h3>
<h5><a id="N1AE1A" name="N1AE1A"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ConstructionDecl" name="doc-xquery-ConstructionDecl"/>[<small>25 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ConstructionDecl">ConstructionDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "construction"  ("strip"  |  "preserve")</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
     <p>The core grammar production for construction declarations is:</p>

       
<h5><a id="N1AE29" name="N1AE29"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-ConstructionDecl" name="doc-core-ConstructionDecl"/>[<small>24 (Core)</small>]   </td><td><code><a href="#prod-core-ConstructionDecl">ConstructionDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "construction"  ("strip"  |  "preserve")</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Construction declarations are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>ConstructionDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>ConstructionDecl</em>
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
      <p>The construction declaration modifies the construction mode
      in the static context.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	      
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_construction_mode_env" class="env">constructionMode</a>(
                      <em>ConstructionMode</em>) 
                
	      
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare construction <em>ConstructionMode</em>
                <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>
<p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
<p>The construction declaration does not have any affect on the dynamic
context.</p>
      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                declare construction <em>ConstructionMode</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>
</div><div class="div2">
<h3><a id="id-default-ordering-decl" name="id-default-ordering-decl"/>5.7 Ordering Mode Declaration</h3>
<h5><a id="N1AED7" name="N1AED7"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-OrderingModeDecl" name="doc-xquery-OrderingModeDecl"/>[<small>14 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-OrderingModeDecl">OrderingModeDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "ordering"  ("ordered"  |  "unordered")</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
     <p>The core grammar production for ordering mode declarations is:</p>

       
<h5><a id="N1AEE6" name="N1AEE6"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-OrderingModeDecl" name="doc-core-OrderingModeDecl"/>[<small>13 (Core)</small>]   </td><td><code><a href="#prod-core-OrderingModeDecl">OrderingModeDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "ordering"  ("ordered"  |  "unordered")</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Ordering mode declarations are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>OrderingModeDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>OrderingModeDecl</em>
        
       </td></tr>
      </table></div>
    </div><div class="div2">
<h3><a id="id-empty-order-decl" name="id-empty-order-decl"/>5.8 Empty Order Declaration</h3>
<h5><a id="N1AF15" name="N1AF15"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-EmptyOrderDecl" name="doc-xquery-EmptyOrderDecl"/>[<small>15 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-EmptyOrderDecl">EmptyOrderDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
     <p>The core grammar production for empty order declarations is:</p>

       
<h5><a id="N1AF24" name="N1AF24"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-EmptyOrderDecl" name="doc-core-EmptyOrderDecl"/>[<small>14 (Core)</small>]   </td><td><code><a href="#prod-core-EmptyOrderDecl">EmptyOrderDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Empty order declarations are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>EmptyOrderDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>EmptyOrderDecl</em>
        
       </td></tr>
      </table></div>
    </div><div class="div2">
<h3><a id="id-copy-namespaces-decl" name="id-copy-namespaces-decl"/>5.9 Copy-Namespaces Declaration</h3>
<h5><a id="N1AF53" name="N1AF53"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-CopyNamespacesDecl" name="doc-xquery-CopyNamespacesDecl"/>[<small>16 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "copy-namespaces"  <a href="#doc-xquery-PreserveMode">PreserveMode</a>  ","  <a href="#doc-xquery-InheritMode">InheritMode</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-PreserveMode" name="doc-xquery-PreserveMode"/>[<small>17 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-PreserveMode">PreserveMode</a></code></td><td>   ::=   </td><td><code>"preserve"  |  "no-preserve"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-InheritMode" name="doc-xquery-InheritMode"/>[<small>18 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-InheritMode">InheritMode</a></code></td><td>   ::=   </td><td><code>"inherit"  |  "no-inherit"</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The core grammar productions for copy-namespaces declarations
      are:</p>

      
<h5><a id="N1AF7B" name="N1AF7B"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-CopyNamespacesDecl" name="doc-core-CopyNamespacesDecl"/>[<small>15 (Core)</small>]   </td><td><code><a href="#prod-core-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "copy-namespaces"  <a href="#doc-core-PreserveMode">PreserveMode</a>  ","  <a href="#doc-core-InheritMode">InheritMode</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-PreserveMode" name="doc-core-PreserveMode"/>[<small>16 (Core)</small>]   </td><td><code><a href="#prod-core-PreserveMode">PreserveMode</a></code></td><td>   ::=   </td><td><code>"preserve"  |  "no-preserve"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-InheritMode" name="doc-core-InheritMode"/>[<small>17 (Core)</small>]   </td><td><code><a href="#prod-core-InheritMode">InheritMode</a></code></td><td>   ::=   </td><td><code>"inherit"  |  "no-inherit"</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Copy-namespace declarations are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>CopyNamespaceDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>CopyNamespaceDecl</em>
        
       </td></tr>
      </table></div>
    </div><div class="div2">
<h3><a id="sec_schema_imports" name="sec_schema_imports"/>5.10 Schema Import</h3>
<h5><a id="N1AFC3" name="N1AFC3"/>Schema Imports</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-SchemaImport" name="doc-xquery-SchemaImport"/>[<small>21 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-SchemaImport">SchemaImport</a></code></td><td>   ::=   </td><td><code>"import"  "schema"  <a href="#doc-xquery-SchemaPrefix">SchemaPrefix</a>?  URILiteral  ("at"  URILiteral  (","  URILiteral)*)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-SchemaPrefix" name="doc-xquery-SchemaPrefix"/>[<small>22 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-SchemaPrefix">SchemaPrefix</a></code></td><td>   ::=   </td><td><code>("namespace"  NCName  "=")  |  ("default"  "element"  "namespace")</code></td></tr></tbody></table><p>The semantics of Schema Import is described in terms of the
    [XPath/XQuery] type system. The process of converting an XML Schema
    into a sequence of type declarations is described in Section
    <a href="#sec_importing_schema"><b>[C Importing Schemas]</b></a>.  This section describes how
    the resulting sequence of type declarations is added into the
    static context when the Prolog is processed.</p><p><b>Core Grammar</b></p>
      <p>The core grammar productions for schema imports are:</p>

      
<h5><a id="N1AFFD" name="N1AFFD"/>Schema Imports</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-SchemaImport" name="doc-core-SchemaImport"/>[<small>20 (Core)</small>]   </td><td><code><a href="#prod-core-SchemaImport">SchemaImport</a></code></td><td>   ::=   </td><td><code>"import"  "schema"  <a href="#doc-core-SchemaPrefix">SchemaPrefix</a>?  <a href="#prod-core-URILiteral">URILiteral</a>  ("at"  <a href="#prod-core-URILiteral">URILiteral</a>  (","  <a href="#prod-core-URILiteral">URILiteral</a>)*)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-SchemaPrefix" name="doc-core-SchemaPrefix"/>[<small>21 (Core)</small>]   </td><td><code><a href="#prod-core-SchemaPrefix">SchemaPrefix</a></code></td><td>   ::=   </td><td><code>("namespace"  <a href="#prod-core-NCName">NCName</a>  "=")  |  ("default"  "element"  "namespace")</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Schema imports are left unchanged through normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>SchemaImport</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>SchemaImport</em>
        
       </td></tr>
      </table></div>
    <p><b>Notation</b></p>
      <p>For convenience, we introduce the following auxiliary
      grammar productions.</p>

      
<h5><a id="N1B053" name="N1B053"/>Location Hints</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-LocationHints" name="doc-fs-LocationHints"/>[<small>16 (Formal)</small>]   </td><td><code>LocationHints</code></td><td>   ::=   </td><td><code>"at"    <a href="#prod-core-URILiteral">URILiteral</a>  (","  <a href="#prod-core-URILiteral">URILiteral</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-OptLocationHints" name="doc-fs-OptLocationHints"/>[<small>90 (Formal)</small>]   </td><td><code>OptLocationHints</code></td><td>   ::=   </td><td><code><a href="#doc-fs-LocationHints">LocationHints</a>?</code></td></tr></tbody></table>

    <p><b>Notation</b></p>
      <p id="jd_yields_type_context">The following auxiliary judgments
      are used when processing schema imports.</p>

      <p>The judgment:</p>

      <div align="center">
        
          <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub><b> |- </b>
          <em>Definitions</em> <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>
        
      </div>

      <p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>, the
      sequence of type definitions <em>Definitions</em> yields the new
      static environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>.</p>

      <p>The judgment:</p>

      <div align="center">
        
          <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub><b> |- </b>
          <a href="#sec_top_level_definitions"><em>Definition</em></a> <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>
        
      </div>

      <p>holds if under the static environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>, the
      single definition <a href="#sec_top_level_definitions"><em>Definition</em></a> yields the new static
      environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>.</p>
    <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>

      <p>A schema imported into a query is first mapped into the
      [XPath/XQuery] type system, which yields a sequence of XQuery type
      definitions.  The rules for mapping the imported schema begins
      in <a href="#sec_schema_as_a_whole"><b>[C.2 Schemas as a whole]</b></a>.  Each type definition
      in an imported schema is then added to the static
      environment.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <em>Definitions</em> = <font size="6">[</font>schema
                <em>URILiteral</em> <em>OptLocationHints</em><font size="6">]</font><a href="#jd_map_schema" class="judgment"><sub><font size="2">Schema</font></sub></a>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
        	<em>Definitions</em> <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
              
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                import schema <em>URILiteral</em> <em>OptLocationHints</em>
                <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>The schema import declaration may also assign an element/type
      namespace prefix to the URI of the imported schema, or assign
      the default element namespace to the URI of the imported
      schema.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <em>Definitions</em> = <font size="6">[</font>schema
                <em>URILiteral</em> <em>OptLocationHints</em><font size="6">]</font><a href="#jd_map_schema" class="judgment"><sub><font size="2">Schema</font></sub></a>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
        	<em>Definitions</em> <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
              
	    </td></tr>
            <tr valign="middle" align="center"><td>
	      
                
                    <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> + <a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em> 
                      =&gt; (passive, <em>URILiteral</em>)) 
                
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                import schema namespace <em>NCName</em> =
                <em>URILiteral</em> <em>OptLocationHints</em>
                <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <em>Definitions</em> = <font size="6">[</font>schema
                <em>URILiteral</em> <em>OptLocationHints</em><font size="6">]</font><a href="#jd_map_schema" class="judgment"><sub><font size="2">Schema</font></sub></a>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
        	<em>Definitions</em> <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
              
	    </td></tr>
            <tr valign="middle" align="center"><td>
	      
                
                    <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> + <a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a>( <em>URILiteral</em>) 
                
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                import schema default element namespace
                <em>URILiteral</em> <em>OptLocationHints</em>
                <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>An empty sequence of type definitions yields the input
      environment.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                () <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>Each type definition is added into the static
      environment.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <em>Definitions</em> <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
                <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
              
        	<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub><b> |- </b>
        	<a href="#sec_top_level_definitions"><em>Definition</em></a><sub><font size="2">1</font></sub> <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
        	<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>
              
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#sec_top_level_definitions"><em>Definition</em></a><sub><font size="2">1</font></sub> <em>Definitions</em>
                <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>Each type, element, or attribute declaration is added
      respectively to the type, element and attribute declarations
      components of the static environment.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      
                
                <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a> =&gt; define type
                      <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#doc-fs-TypeDerivation"><em>TypeDerivation</em></a> ) 
                
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
        	<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                define type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
                <a href="#doc-fs-TypeDerivation"><em>TypeDerivation</em></a> <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
                <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      
                
                <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a> =&gt; define
                      element <a href="#doc-fs-ElementName"><em>ElementName</em></a> <em>OptSubstitution</em>
                      <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>  <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>) 
                
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
        	<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                define element <a href="#doc-fs-ElementName"><em>ElementName</em></a>
                <em>OptSubstitution</em> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>  <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
                <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      
                
                <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a> =&gt; define
                      attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a>
                      <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>) 
                
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
        	<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                define attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a>
                <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_yields_type_context" class="judgment"><b>=&gt;</b><sub><font size="2">type</font></sub></a>
                <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>Note that it is a static error to import two schemas that
      both define the same name in the same symbol space and in the
      same scope, that is multiple top-level definitions of the same
      type, element, or attribute name raises a static error.  For
      instance, a query may not import two schemas that include
      top-level element declarations for two elements with the same
      expanded name.</p>

    <p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
      <p>The schema import declarations do not affect the dynamic
      context.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
      <em>SchemaImport</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>
    </div><div class="div2">
<h3><a id="id-module-imports" name="id-module-imports"/>5.11 Module Import</h3>
<h5><a id="N1B4E3" name="N1B4E3"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-ModuleImport" name="doc-xquery-ModuleImport"/>[<small>23 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ModuleImport">ModuleImport</a></code></td><td>   ::=   </td><td><code>"import"  "module"  ("namespace"  NCName  "=")?  URILiteral  ("at"  URILiteral  (","  URILiteral)*)?</code></td></tr></tbody></table><p><b>Introduction</b></p>
      <p>The effect of an "import module" declaration is to extend the
      importing module's dynamic (and static) context with the global
      variables (and their types) and the functions (and their
      signatures) of the imported module.  Module import is not
      transitive, only the global variables and functions declared
      explicitly in the imported module are available in the importing
      module.  Also, module import does not import schemas, therefore
      the importing module must explicitly import any schemas on which
      the imported global variables or functions depend.</p>
    <p><b>Core Grammar</b></p>
      <p>The core grammar production for module imports is:</p>

      
<h5><a id="N1B50F" name="N1B50F"/>Module Import</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-ModuleImport" name="doc-core-ModuleImport"/>[<small>22 (Core)</small>]   </td><td><code><a href="#prod-core-ModuleImport">ModuleImport</a></code></td><td>   ::=   </td><td><code>"import"  "module"  ("namespace"  <a href="#prod-core-NCName">NCName</a>  "=")?  <a href="#prod-core-URILiteral">URILiteral</a>  ("at"  <a href="#prod-core-URILiteral">URILiteral</a>  (","  <a href="#prod-core-URILiteral">URILiteral</a>)*)?</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Module imports are left unchanged through normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>ModuleImport</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>ModuleImport</em>
        
       </td></tr>
      </table></div>
    <p><b>Notation</b></p>
      <p>The rules below depend on the following auxiliary functions
      which are used to import the proper fragment of the static
      context.</p>

      <p id="fs_local_variables">The function
      <a href="#fs_local_variables"><em>fs:</em><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <em>URI</em>) returns all the
      (<a href="#id-expanded-qnames"><em>expanded-QName</em></a>, <a href="#doc-fs-Type"><em>Type</em></a>) pairs in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_env" class="env">varType</a> such that the URI
      part of the variable's expanded-QName equals the given URI, that
      is, the variables that are declared locally in the module with
      the given namespace URI.</p>

      <p id="fs_local_functions">
      The function <a href="#fs_local_functions"><em>fs:</em><code>local-functions</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a>, <em>URI</em>)
      returns all the function signatures in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_functy_env" class="env">funcType</a> such that
      the URI part of the function's expanded-QName equals the given
      URI, that is, the function signatures that are declared locally
      in the module with the given namespace URI.</p>
    <p><b>Notation</b></p>
      <p>The following auxiliary judgments is used to extend a given
      static environment with the static environment from an imported
      module.</p>

      <p id="jd_extended_with_static_environment">The judgment</p>

      <div align="center">
        
        <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
        <a href="#jd_extended_with_static_environment" class="judgment"><b>extended with static environment</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>
        <a href="#jd_extended_with_static_environment" class="judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">3</font></sub>
        <a href="#jd_extended_with_static_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
        
      </div>

      <p>holds if extending the environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> with the
      environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> yields the environment <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">3</font></sub>
      under the given namespace uri <em>URILiteral</em>.</p>

      <p>This judgment is defined as follows.</p>

      <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
      
        <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">3</font></sub> =
        <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> + <a href="#xq_type_env" class="env">varType</a>(<a href="#fs_local_variables"><em>fs:</em><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>, <em>URILiteral</em>)) 
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">4</font></sub> =
        <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">3</font></sub> + <a href="#xq_type_env" class="env">localFunc</a>(<a href="#fs_local_functions"><em>fs:</em><code>local-functions</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>,
        <em>URILiteral</em>)) 
      
      </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
      
      <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>extended with static environment</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">4</font></sub>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
      
      </td></tr>
      </table></td></tr></table></td></tr>
      </table><br/>
      </div>
    <p><b>Notation</b></p>
        <p>The rules below depend on the following auxiliary
        judgments.</p>

        <p id="jd_import_variables">
        This judgment adds each variable explicitly declared in the
        imported module to the importing module's dynamic variable
        environment.</p>

        <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
        
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub> = <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> + <a href="#xq_val_env" class="env">varValue</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>
          =&gt;
          <code>#IMPORTED</code>(<em>URI</em>)) 
        
        </td></tr>
        <tr valign="middle" align="center"><td>
        
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub> ; <em>URI</em><b> |- </b>
          (<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>), ···, (<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">n</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
        <a href="#jd_import_variables" class="judgment"><b>=&gt;</b><sub><font size="2">import_variables</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">3</font></sub> 
        
        </td></tr>
        </table></td></tr></table></td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> ; <em>URI</em><b> |- </b>
        (<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>), ···, (<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">n</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
        <a href="#jd_import_variables" class="judgment"><b>=&gt;</b><sub><font size="2">import_variables</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">3</font></sub> 
        
        </td></tr>
        </table></td></tr></table></td></tr>
        </table><br/>
        </div>

        <p id="jd_import_functions">This judgment adds each function
        explicitly declared in the imported module to the importing
        module's dynamic function environment.</p>

        <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
        
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub> =
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> + <a href="#xq_func_env" class="env">funcDefn</a>((<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1,1</font></sub>,
          ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1,n</font></sub>)) =&gt;
          <code>#IMPORTED</code>(<em>URI</em>)) 
        
        </td></tr>
        <tr valign="middle" align="center"><td>
        
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub> ; <em>URI</em><b> |- </b>
          (<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2,1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2,n</font></sub>)), ···, (<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">k</font></sub>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">k,1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">k,n</font></sub>))
        <a href="#jd_import_functions" class="judgment"><b>=&gt;</b><sub><font size="2">import_functions</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">3</font></sub> 
        
        </td></tr>
        </table></td></tr></table></td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> ; <em>URI</em><b> |- </b>
        (<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1,1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1,n</font></sub>)), ···, (<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">k</font></sub>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">k,1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">k,n</font></sub>))
        <a href="#jd_import_functions" class="judgment"><b>=&gt;</b><sub><font size="2">import_functions</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">3</font></sub> 
        
        </td></tr>
        </table></td></tr></table></td></tr>
        </table><br/>
        </div>
      <p><b>Notation</b></p>
      <p>The following auxiliary judgments is used to extend a given
      dynamic environment with the dynamic environment from an
      imported module.</p>

      <p id="jd_extended_with_dynamic_environment">The judgment</p>
        <div align="center">
          
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>extended with dynamic environment</b></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>yields</b></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">3</font></sub>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
          
        </div>

      <p>holds if extending the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> with
      the dynamic environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub> yields the dynamic
      environment <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">3</font></sub> under the given namespace uri
      <em>URILiteral</em>.</p>

      <p>This judgment is defined as follows.</p>

      <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
      
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> ; <em>URILiteral</em><b> |- </b>
    	 <a href="#fs_local_variables"><em>fs:</em><code>local-variables</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>,
    	 <em>URILiteral</em>) <a href="#jd_import_variables" class="judgment"><b>=&gt;</b><sub><font size="2">import_variables</font></sub></a>
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">3</font></sub>
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">3</font></sub> ; <em>URILiteral</em><b> |- </b>
    	 <a href="#fs_local_functions"><em>fs:</em><code>local-functions</code></a>(<a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub>,
    	 <em>URILiteral</em>) <a href="#jd_import_functions" class="judgment"><b>=&gt;</b><sub><font size="2">import_functions</font></sub></a>
    	 <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">4</font></sub>
      
      </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
      
      <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>extended with dynamic environment</b></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">2</font></sub>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>yields</b></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">4</font></sub>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
      
      </td></tr>
      </table></td></tr></table></td></tr>
      </table><br/>
      </div>
    <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
      <p>The first set of premises below "look up" the static contexts
      of all the imported modules, as defined in <a href="#id-module-declaration"><b>[5.2 Module Declaration]</b></a>. The second set of premises extend
      the input static context with the global variables and function
      signatures declared in the imported static contexts.</p>

      <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
      
        <em>URILiteral</em><sub><font size="2">1</font></sub> <a href="#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        ...
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        <em>URILiteral</em><sub><font size="2">1</font></sub> <a href="#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        <a href="#xq_stat_env_def" class="env">statEnv</a>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>extended with static environment</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>'
          <a href="#jd_extended_with_static_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        ...
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n-1</font></sub>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>extended with static environment</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>'
          <a href="#jd_extended_with_static_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
      
      </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
      import module <em>URILiteral</em><sub><font size="2">1</font></sub> <em>LocationHints</em>? <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>'
      
      </td></tr>
      </table></td></tr></table></td></tr>
      </table><br/>
      </div>

      <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
      
        <em>URILiteral</em><sub><font size="2">1</font></sub> <a href="#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        ...
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        <em>URILiteral</em><sub><font size="2">1</font></sub> <a href="#jd_module_statEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_statEnv</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        <a href="#xq_stat_env_def" class="env">statEnv</a>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>extended with static environment</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>'
          <a href="#jd_extended_with_static_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        ...
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n-1</font></sub>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>extended with static environment</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>
          <a href="#jd_extended_with_static_environment" class="judgment"><b>yields</b></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>'
          <a href="#jd_extended_with_static_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
      
      </td></tr>
      <tr valign="middle" align="center"><td>
        
          
            <a href="#xq_stat_env_def" class="env">statEnv</a>' =
            <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>' + <a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em> 
              =&gt; (passive, <em>URILiteral</em>)) 
          
        
      </td></tr>
      </table></td></tr></table></td></tr>
      <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
      <tr valign="middle" align="center"><td>
      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
      import module namespace <em>NCName</em> = <em>URILiteral</em><sub><font size="2">1</font></sub> <em>LocationHints</em>? <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">n</font></sub>'
      
      </td></tr>
      </table></td></tr></table></td></tr>
      </table><br/>
      </div>

      <p>Note that the rules above and the rules for processing a
      library module in <a href="#id-module-declaration"><b>[5.2 Module Declaration]</b></a> above
      are mutually recursive. It is possible to define the semantics
      in that way, since XQuery forbids the use of recursive
      modules.</p>
    <p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
      <p>During dynamic context processing, each variable and function
      name is mapped to the special value
      <code>#IMPORTED</code>(<em>URI</em>) to indicate that the variable
      or function is defined in the imported module with the given
      URI.</p>

      <p>The first set of premises below "look up" the dynamic
      contexts of all the imported modules, as defined in <a href="#id-module-declaration"><b>[5.2 Module Declaration]</b></a>. The second set of premises extend
      the input dynamic context with the global variables and
      functions declared in the imported dynamic contexts.</p>

  <div align="center">
  <table cellpadding="0" cellspacing="0" summary="">
  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
  <tr valign="middle" align="center"><td>
  
    <em>URILiteral</em> <a href="#jd_module_dynEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
  
  </td></tr>
  <tr valign="middle" align="center"><td>
  
    ...
  
  </td></tr>
  <tr valign="middle" align="center"><td>
  
    <em>URILiteral</em> <a href="#jd_module_dynEnv" class="judgment"><b>=&gt;</b><sub><font size="2">module_dynEnv</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">n</font></sub>
  
  </td></tr>
      <tr valign="middle" align="center"><td>
      
        <a href="#xq_dyn_env_def" class="env">dynEnv</a>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>extended with dynamic environment</b></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>yields</b></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>'
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        ...
      
      </td></tr>
      <tr valign="middle" align="center"><td>
      
        <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">n-1</font></sub>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>extended with dynamic environment</b></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">n</font></sub>
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>yields</b></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">n</font></sub>'
          <a href="#jd_extended_with_dynamic_environment" class="judgment"><b>for uri</b></a> <em>URILiteral</em>
      
      </td></tr>
  </table></td></tr></table></td></tr>
  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
  <tr valign="middle" align="center"><td>
  <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub><b> |- </b>
  import module (namespace <em>NCName</em> =)? <em>URILiteral</em> <em>LocationHints</em>?
         <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a>  <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">n</font></sub>'
  
  </td></tr>
  </table></td></tr></table></td></tr>
  </table><br/>
  </div>

  <p>Note that the rule above and the rules for processing a library
  module in <a href="#id-module-declaration"><b>[5.2 Module Declaration]</b></a> above are mutually
  recursive. It is possible to define the semantics in that way, since
  XQuery forbids the use of recursive modules.</p>

  </div><div class="div2">
<h3><a id="sec_namespace_decls" name="sec_namespace_decls"/>5.12 Namespace Declaration</h3>
<h5><a id="N1BC02" name="N1BC02"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-NamespaceDecl" name="doc-xquery-NamespaceDecl"/>[<small>10 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-NamespaceDecl">NamespaceDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "namespace"  NCName  "="  URILiteral</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The core grammar production for namespace declarations is:</p>

      
<h5><a id="N1BC1C" name="N1BC1C"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-NamespaceDecl" name="doc-core-NamespaceDecl"/>[<small>10 (Core)</small>]   </td><td><code><a href="#prod-core-NamespaceDecl">NamespaceDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "namespace"  <a href="#prod-core-NCName">NCName</a>  "="  <a href="#prod-core-URILiteral">URILiteral</a></code></td></tr></tbody></table>

     <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Namespace declarations are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>NamespaceDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>NamespaceDecl</em>
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
      <p>A namespace declaration adds a new (prefix,uri) binding in
      the namespace component of the static environment.  All
      namespace declarations in the prolog are <b>passive</b>
      declarations.  Namespace declaration attributes of element
      constructors are <b>active</b> declarations.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	      
                
                    <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_ns_env" class="env">namespace</a>(<em>NCName</em> =&gt; (passive, <em>URILiteral</em>)) 
                
	      
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare namespace <em>NCName</em> = <em>URILiteral</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>
    <p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
      <p>The namespace declaration does not affect the dynamic
      context.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                declare namespace <em>NCName</em> = <em>URILiteral</em> <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>
    </div><div class="div2">
<h3><a id="sec_default_namespace_decls" name="sec_default_namespace_decls"/>5.13 Default Namespace Declaration</h3>
<h5><a id="N1BCE4" name="N1BCE4"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-DefaultNamespaceDecl" name="doc-xquery-DefaultNamespaceDecl"/>[<small>12 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "default"  ("element"  |  "function")  "namespace"  URILiteral</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The core grammar production for default namespace
      declarations is:</p>

     
<h5><a id="N1BCF8" name="N1BCF8"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-DefaultNamespaceDecl" name="doc-core-DefaultNamespaceDecl"/>[<small>11 (Core)</small>]   </td><td><code><a href="#prod-core-DefaultNamespaceDecl">DefaultNamespaceDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "default"  ("element"  |  "function")  "namespace"  <a href="#prod-core-URILiteral">URILiteral</a></code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Default namespace declarations are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>DefaultNamespaceDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>DefaultNamespaceDecl</em>
        
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
      <p>A default element namespace declaration changes the default
      element namespace prefix binding in the namespace component of
      the static environment. If the string literal is the zero-length
      string, the default element namespace is set to the null
      namespace. </p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	      
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a>(#NULL-NAMESPACE) 
                
	      
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare default element namespace "" <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            <a href="#jd_not" class="judgment"><b>not</b></a>(<em>URILiteral</em> = "")    
	    
              
                <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                  <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_default_elem_ns_env" class="env">default_elem_namespace</a>(
                    <em>URILiteral</em>) 
              
	    
           </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare default element namespace <em>URILiteral</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>A default function namespace declaration changes the default
      function namespace prefix binding in the namespace component of
      the static environment. If the URI literal is the zero-length
      string, the default function namespace is set to the null
      namespace.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	      
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a>(#NULL-NAMESPACE) 
                
	      
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare default function namespace "" <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            <a href="#jd_not" class="judgment"><b>not</b></a>(<em>URILiteral</em> = "")    
	    
              
                <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                  <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_default_fn_ns_env" class="env">default_function_namespace</a>(
                    <em>URILiteral</em>) 
              
	    
           </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare default function namespace <em>URILiteral</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>Note that multiple declarations of the same namespace prefix
      in the Prolog result in a static error.  However, a declaration
      of a namespace in the Prolog can override a prefix that has been
      predeclared in the static context.</p>
    <p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
<p>Default namespace declarations do not affect the dynamic
context. </p>
      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                <em>DefaultNamespaceDecl</em>  <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>
</div><div class="div2">
<h3><a id="sec_variable-declarations" name="sec_variable-declarations"/>5.14 Variable Declaration</h3>
<h5><a id="N1BEA8" name="N1BEA8"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-VarDecl" name="doc-xquery-VarDecl"/>[<small>24 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-VarDecl">VarDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "variable"  "$"  QName  <a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>?  ((":="  <a href="#doc-xquery-ExprSingle">ExprSingle</a>)  |  "external")</code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The core grammar production for variable declarations is:</p>

      
<h5><a id="N1BEC9" name="N1BEC9"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-VarDecl" name="doc-core-VarDecl"/>[<small>23 (Core)</small>]   </td><td><code><a href="#prod-core-VarDecl">VarDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "variable"  "$"  <a href="#prod-core-QName">QName</a>  <a href="#doc-core-TypeDeclaration">TypeDeclaration</a>?  ((":="  <a href="#doc-core-ExprSingle">ExprSingle</a>)  |  "external")</code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Normalization of a variable declaration normalizes the
      variable and its corresponding expression, if it is present.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	 <font size="6">[</font>
  	   declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> := <em>Expr</em>
  	 <font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
  	   declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> :=
  	   <font size="6">[</font><em>Expr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a> 
  	 
       </td></tr>
      </table></div>

      <p>If an external variable declaration does not have a type
      declaration it is treated as if the type declaration was
      <code>item()*</code>.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	<font size="6">[</font>
  	  declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a> external
  	<font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	
  	  declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a> as item()* external
  	
       </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	 <font size="6">[</font>
  	   declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> external
  	 <font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
  	   declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> external
  	 
       </td></tr>
      </table></div>
 
    <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
      <p>A variable declaration updates the variable component of the
      static context by associating the given variable with a static
      type.</p>

      <p>If a variable declaration has an associated expression but
      does not have a type declaration, the static type of the
      variable is the static type of the expression.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>
                <b> |- </b>
                <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                <em>Variable</em>
              
	    </td></tr>
            <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(
                      <em>Variable</em> =&gt; <a href="#doc-fs-Type"><em>Type</em></a>) 
                
	      
            </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a>
                := <em>Expr</em>
                <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>If the variable declaration has an associated expression and
      has a type declaration, the static type of the variable is the
      specified type. The type of the expression must be a subtype of
      the declared type.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>
                <b> |- </b>
                <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                <em>Variable</em>
              
	    </td></tr>
            <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#doc-fs-Type"><em>Type</em></a> = <font size="6">[</font><em>SequenceType</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
  	     <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
  	       <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
  	       
  	     
	    </td></tr>
  	    <tr valign="middle" align="center"><td>
  	      
  		<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
  	      
  	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(
                      <em>Variable</em> =&gt; <a href="#doc-fs-Type"><em>Type</em></a>) 
                
	      
            </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a>
                as <em>SequenceType</em> := <em>Expr</em>
                <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>If the variable declaration is external and has a type
      declaration, the static type of the variable is the specified
      type.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>
                <b> |- </b>
                <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                <em>Variable</em>
              
	    </td></tr>
            <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#doc-fs-Type"><em>Type</em></a> = <font size="6">[</font><em>SequenceType</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(
                      <em>Variable</em> =&gt; <a href="#doc-fs-Type"><em>Type</em></a>) 
                
	      
            </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a>
                as <em>SequenceType</em> external
                <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">2</font></sub> 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

    <p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
      <p>To evaluate a variable declaration, its associated expression
      is evaluated, and the dynamic context is updated with the
      variable bound to the resulting value.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	   <tr valign="middle" align="center"><td>
	    <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b> <em>Expr</em>
	    <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a> 
	   </td></tr>
	   <tr valign="middle" align="center"><td>
            
              <a href="#xq_stat_env_def" class="env">statEnv</a>
              <b> |- </b>
              <a href="#prod-core-VarRef"><em>VarRef</em></a> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
              <em>Variable</em>
            
	   </td></tr>
	   <tr valign="middle" align="center"><td>
	     
               
                 <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> =
                   <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_val_env" class="env">varValue</a>(
                     <em>Variable</em> =&gt; <a href="#doc-fs-Value"><em>Value</em></a>) 
               
	     
           </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a>
                as <em>SequenceType</em> (:= <em>Expr</em> | external)
                <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>

      <p>Dynamic evaluation does not apply to externally defined
      variables.  The dynamic environment must provide the values of
      external variables in the initial dynamic context
      (<a href="#xq_default_dyn_env" class="env">dynEnvDefault</a>).</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                declare variable <a href="#prod-core-VarRef"><em>VarRef</em></a>
                as <em>SequenceType</em> external
                <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a> 
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	</table><br/>
      </div>
    </div><div class="div2">
<h3><a id="sec_FunctionDeclns" name="sec_FunctionDeclns"/>5.15 Function Declaration</h3><p><b>Introduction</b></p>

      <p>User-defined functions specify the name of the function, the
      names and types of the parameters, and the type of the
      result. The <b>function body</b> defines how the result of
      the function is computed from its parameters.</p>

      
<h5><a id="N1C240" name="N1C240"/>Function declarations</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-FunctionDecl" name="doc-xquery-FunctionDecl"/>[<small>26 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-FunctionDecl">FunctionDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "function"  QName  "("  <a href="#doc-xquery-ParamList">ParamList</a>?  ")"  ("as"  <a href="#doc-xquery-SequenceType">SequenceType</a>)?  (<a href="#doc-xquery-EnclosedExpr">EnclosedExpr</a>  |  "external")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-ParamList" name="doc-xquery-ParamList"/>[<small>27 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-ParamList">ParamList</a></code></td><td>   ::=   </td><td><code><a href="#doc-xquery-Param">Param</a>  (","  <a href="#doc-xquery-Param">Param</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-xquery-Param" name="doc-xquery-Param"/>[<small>28 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-Param">Param</a></code></td><td>   ::=   </td><td><code>"$"  QName  <a href="#doc-xquery-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody></table>
    <p><b>Core Grammar</b></p>
      <p>The core grammar productions for function declarations
      are:</p>

      
<h5><a id="N1C28E" name="N1C28E"/>Function declarations</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-FunctionDecl" name="doc-core-FunctionDecl"/>[<small>25 (Core)</small>]   </td><td><code><a href="#prod-core-FunctionDecl">FunctionDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "function"  <a href="#prod-core-QName">QName</a>  "("  <a href="#doc-core-ParamList">ParamList</a>?  ")"  ("as"  <a href="#doc-core-SequenceType">SequenceType</a>)?  (<a href="#doc-core-EnclosedExpr">EnclosedExpr</a>  |  "external")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-ParamList" name="doc-core-ParamList"/>[<small>26 (Core)</small>]   </td><td><code><a href="#prod-core-ParamList">ParamList</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-Param">Param</a>  (","  <a href="#doc-core-Param">Param</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-core-Param" name="doc-core-Param"/>[<small>27 (Core)</small>]   </td><td><code><a href="#prod-core-Param">Param</a></code></td><td>   ::=   </td><td><code>"$"  <a href="#prod-core-QName">QName</a>  <a href="#doc-core-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody></table>
    <p><b>Notation</b></p>
      <p id="jd_map_param">The following auxiliary mapping rule is
      used for the normalization of parameters in function
      declarations:
      <font size="6">[</font><font size="6">]</font><a href="#jd_map_param" class="judgment"><sub><font size="2">Param</font></sub></a>.</p>

      <p>Parameters without a declared typed are given the item*
      sequence type.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
           <font size="6">[</font><a href="#prod-core-VarRef"><em>VarRef</em></a><font size="6">]</font><a href="#jd_map_param" class="judgment"><sub><font size="2">Param</font></sub></a>
         
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
           <a href="#prod-core-VarRef"><em>VarRef</em></a> as item* 
         
       </td></tr>
      </table></div>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
           <font size="6">[</font><a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> <font size="6">]</font><a href="#jd_map_param" class="judgment"><sub><font size="2">Param</font></sub></a>
         
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
           <a href="#prod-core-VarRef"><em>VarRef</em></a> as <em>SequenceType</em> 
         
       </td></tr>
      </table></div>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>The parameter list and body of a user-defined function are
      all normalized into Core expressions.</p>
  
      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	 <font size="6">[</font>
  	   declare function <em>QName</em> ( <em>ParamList</em>? ) as
  	   <em>SequenceType</em> <em>EnclosedExpr</em>
  	 <font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
  	   declare function <em>QName</em> (
  	   <font size="6">[</font><em>ParamList</em>?<font size="6">]</font><a href="#jd_map_param" class="judgment"><sub><font size="2">Param</font></sub></a> )
  	   as <em>SequenceType</em>
  	   <font size="6">[</font><em>EnclosedExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
  	 
       </td></tr>
      </table></div>
 
      <p>If the return type of the function is not provided, it is
      given the <code>item*</code> sequence type.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
           <font size="6">[</font>declare function <em>QName</em> ( <em>ParamList</em>?  )
  	   <em>EnclosedExpr</em> <font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
         
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
  	   declare function <em>QName</em>(
  	   <font size="6">[</font><em>ParamList</em>?<font size="6">]</font><a href="#jd_map_param" class="judgment"><sub><font size="2">Param</font></sub></a> ) as item*
  	   <font size="6">[</font><em>EnclosedExpr</em><font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
  	 
       </td></tr>
      </table></div>

      <p>Externally defined functions are normalized similarly.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	 <font size="6">[</font>
  	   declare function <em>QName</em> ( <em>ParamList</em>? ) as
  	   <em>SequenceType</em> external<font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
  	   declare function <em>QName</em>(
  	   <font size="6">[</font><em>ParamList</em>?<font size="6">]</font><a href="#jd_map_param" class="judgment"><sub><font size="2">Param</font></sub></a> )
  	   as <em>SequenceType</em> external
  	 
       </td></tr>
      </table></div>
 
      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
           <font size="6">[</font>declare function <em>QName</em> ( <em>ParamList</em>?  )
  	   external <font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
         
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	 
  	   declare function <font size="6">[</font><em>QName</em><font size="6">]</font> (
  	   <font size="6">[</font><em>ParamList</em>?<font size="6">]</font><a href="#jd_map_param" class="judgment"><sub><font size="2">Param</font></sub></a> ) as item*
  	   external
  	 
       </td></tr>
      </table></div>

    <p><b><a class="processing" href="#processing_context">Static Context Processing</a></b></p>
      <p>Because functions are mutually referential, all function
      signatures must be defined in the static environment before
      static type analysis is applied to the function bodies.  This
      rule also updates the local functions component of the static
      context to indicate the function is declared within the given
      module.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <em>QName</em> <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
	      
                
                <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_functy_env" class="env">funcType</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a> =&gt; <em>FunctionDecl</em>) 
                
              
	    </td></tr>
	   <tr valign="middle" align="center"><td>
  	    <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub><b> |- </b>
  	      <em>FunctionDecl</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
  	      
  	    
	   </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	    
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <em>FunctionDecl</em> <a href="#jd_yields_context" class="judgment"><b>=&gt;</b><sub><font size="2">stat</font></sub></a> <a href="#xq_stat_env_def" class="env">statEnv</a><sub><font size="2">1</font></sub>
  	     
	    
	  </td></tr>
	</table><br/>
      </div>

      <p>Note that the static context processing is performing type
      checking of the function, as defined below. Note also that the
      type checking is done in the new environment in which the
      function declaration has been added which ensures that recursive
      calls are type-checked properly.</p>
    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The static typing rules for function bodies follows
      normalization and processing of the static context.  The typing
      rules below constructs a new environment in which each variable
      has the given expected type, then the static type of the
      function's body is computed under the new environment.  The
      function body's type must be a subtype of the expected return
      type.  If type checking fails, a static type error is raised.
      Otherwise, static typing of the function has no other effect, as
      function signatures are already inside the static
      environment.</p>
  
      <div align="center"> 
  	<table cellpadding="0" cellspacing="0" summary="">
  	   <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                ...
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">n</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <font size="6">[</font><em>SequenceType</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                        = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              </td></tr>
              <tr valign="middle" align="center"><td>
                ...
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <font size="6">[</font><em>SequenceType</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                        = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <font size="6">[</font><em>SequenceType</em><sub><font size="2">r</font></sub><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                        = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
              </td></tr>
  	    <tr valign="middle" align="center"><td>
  	      
  		
  		  <a href="#xq_stat_env_def" class="env">statEnv</a> + <a href="#xq_type_env" class="env">varType</a>(
  		      <em>Variable</em><sub><font size="2">1</font></sub> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
  		      ;...;
  		      <em>Variable</em><sub><font size="2">n</font></sub> =&gt; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
  		    ) 
  		<b> |- </b>
  		<em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
  	      
  	    </td></tr>
  	    <tr valign="middle" align="center"><td>
  	      
  		<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
  	      
  	    </td></tr>
  	   </table></td></tr></table></td></tr>
  	   <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
  	    <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
  	      declare function <em>QName</em>
  		(<a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as  <em>SequenceType</em><sub><font size="2">1</font></sub>, ···,
  	      <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub>  as <em>SequenceType</em><sub><font size="2">n</font></sub>)
  	      as <em>SequenceType</em><sub><font size="2">r</font></sub>
  	      { <em>Expr</em> } <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
  	      
  	    
  	  </td></tr>
  	</table><br/>
      </div>

      <p>The bodies of external functions are not available and
      therefore cannot by type checked.  To ensure type soundness, the
      implementation must guarantee that the value returned by the
      external function matches the expected return type. </p>

      <div align="center">
  	<table cellpadding="0" cellspacing="0" summary="">
  	   <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                ...
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">n</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <font size="6">[</font><em>SequenceType</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                        = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              </td></tr>
              <tr valign="middle" align="center"><td>
                ...
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <font size="6">[</font><em>SequenceType</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                        = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <font size="6">[</font><em>SequenceType</em><sub><font size="2">r</font></sub><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                        = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
              </td></tr>
  	   </table></td></tr></table></td></tr>
  	   <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
  	    <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
  	      declare function <em>QName</em>
  		( <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em><sub><font size="2">1</font></sub> , ···,
  	      <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> as <em>SequenceType</em><sub><font size="2">n</font></sub> )
  	      as <em>SequenceType</em><sub><font size="2">r</font></sub>
  	      external <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">r</font></sub>
  	      
  	    
  	  </td></tr>
  	</table><br/>
      </div>

     <p><b><a class="processing" href="#dyn_processing_context">Dynamic Context Processing</a></b></p>
       <p>A function declaration updates the dynamic context.  The
       function name with arity N is associated with the given
       function body.  The number of arguments is required, because
       XQuery permits overloading of function names as long as each
       function signature has a different number of arguments.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <em>QName</em> <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
	      
	    </td></tr>
	    <tr valign="middle" align="center"><td>
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">1</font></sub>
                    
                ···    
                
                  <a href="#xq_stat_env_def" class="env">statEnv</a>
                  <b> |- </b>
                  <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub> <a href="#jd_var_qname_expands_to" class="judgment"><b>of var expands to</b></a>
                  <em>Variable</em><sub><font size="2">n</font></sub>
                
            </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <font size="6">[</font><em>SequenceType</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                        = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              </td></tr>
              <tr valign="middle" align="center"><td>
                ...
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <font size="6">[</font><em>SequenceType</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                        = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>
              </td></tr>
            <tr valign="middle" align="center"><td>
	      
                
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub> =
                    <a href="#xq_dyn_env_def" class="env">dynEnv</a> + <a href="#xq_func_env" class="env">funcDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,...,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>) =&gt; (
                      <em>Expr</em> , <em>Variable</em><sub><font size="2">1</font></sub> , ···,
                      <em>Variable</em><sub><font size="2">n</font></sub>)) 
                
	      
	    </td></tr>
	  </table></td></tr></table></td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
  	    <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
  	      declare function <em>QName</em>
  		( <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">1</font></sub> as <em>SequenceType</em><sub><font size="2">1</font></sub>, ···,
  	      <a href="#prod-core-VarRef"><em>VarRef</em></a><sub><font size="2">n</font></sub>  as <em>SequenceType</em><sub><font size="2">n</font></sub> )
  	      as <em>SequenceType</em><sub><font size="2">r</font></sub>
  	      { <em>Expr</em> } <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a><sub><font size="2">1</font></sub>
  	      
  	    
	  </td></tr>
	</table><br/>
      </div>

       <p>An external function declaration does not affect the dynamic
       environment. The implementation must support the declared
       external functions.</p>

      <div align="center">
	<table cellpadding="0" cellspacing="0" summary="">
	  <tr valign="middle" align="center"><td>
	  </td></tr>
	  <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
  	    <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
  	      declare function <em>QName</em>
  		( <em>Variable</em><sub><font size="2">1</font></sub> as <em>SequenceType</em><sub><font size="2">1</font></sub>, ···,
  	      <em>Variable</em><sub><font size="2">n</font></sub> as <em>SequenceType</em><sub><font size="2">n</font></sub> )
  	      as <em>SequenceType</em><sub><font size="2">r</font></sub>
  	      external <a href="#jd_yields_dyn_context" class="judgment"><b>=&gt;</b><sub><font size="2">dyn</font></sub></a> <a href="#xq_dyn_env_def" class="env">dynEnv</a>
  	      
  	    
	  </td></tr>
	</table><br/>
      </div>
       <p>The dynamic semantics of a function body are applied when the
       function is called and is described in <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>

     </div><div class="div2">
<h3><a id="id-option-declaration" name="id-option-declaration"/>5.16 Option Declaration</h3>
<h5><a id="N1C85C" name="N1C85C"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-xquery-OptionDecl" name="doc-xquery-OptionDecl"/>[<small>13 (XQuery)</small>]   </td><td><code><a href="http://www.w3.org/TR/xquery/#prod-xquery-OptionDecl">OptionDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "option"  QName  <a href="#doc-xquery-StringLiteral">StringLiteral</a></code></td></tr></tbody></table><p><b>Core Grammar</b></p>
      <p>The core grammar production for option declarations is:</p>

      
<h5><a id="N1C876" name="N1C876"/></h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-core-OptionDecl" name="doc-core-OptionDecl"/>[<small>12 (Core)</small>]   </td><td><code><a href="#prod-core-OptionDecl">OptionDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "option"  <a href="#prod-core-QName">QName</a>  <a href="#doc-core-StringLiteral">StringLiteral</a></code></td></tr></tbody></table>
    <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>Option declarations are left unchanged through
      normalization.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
        
         <font size="6">[</font><em>OptionDecl</em><font size="6">]</font><a href="#jd_map_prolog" class="judgment"><sub><font size="2">PrologDecl</font></sub></a>
        
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
        
          <em>OptionDecl</em>
        
       </td></tr>
      </table></div>
    </div></div><div class="div1">
<h2><a id="id-xquery-conformance" name="id-xquery-conformance"/>6 Conformance</h2><p>The XQuery Formal Semantics is intended primarily as a component
  that can be used by <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a>, or a host language of
  <a href="#xpath20">[XML Path Language (XPath) 2.0]</a>. Therefore, the XQuery Formal Semantics
  relies on specifications that use it (such as [XPath 2.0], [XSLT
  2.0], and [XQuery]) to specify conformance criteria in their
  respective environments. Specifications that set conformance
  criteria for their use of the formal semantics must not relax the
  constraints expressed in this specification.</p><div class="div2">
<h3><a id="id-static-typing-feature" name="id-static-typing-feature"/>6.1 Static Typing Feature</h3><p>This specification normatively defines the static typing
    feature which can be used in <a href="#xquery">[XQuery 1.0: A Query Language for XML]</a> or a host
    language of <a href="#xpath20">[XML Path Language (XPath) 2.0]</a>. The static typing feature is
    specified using the static typing judgment introduced in <a href="#sec_static"><b>[3.2.3 Static typing judgment]</b></a>.</p><div class="div3">
<h4><a id="id-static-extensions" name="id-static-extensions"/>6.1.1 Static Typing Extensions</h4><p>In some cases, the static typing rules are not very precise
      (see, for example, the type inference rules for the ancestor
      axes—parent, ancestor, and ancestor-or-self—and for
      the function <code>fn:root</code>). If an implementation
      supports a static typing extension, it must always provide a
      more precise type than the one defined in this
      specification.</p><p id="jd_has_type_extension">This constraint is formally
      expressed as follows. A static typing extension <em>Expr</em>
      <a href="#jd_has_type_extension" class="judgment"><b>:</b><sub><font size="2">ext</font></sub></a> <a href="#doc-fs-Type"><em>Type</em></a> must be such that for every
      expression <em>Expr</em> the following holds.</p><div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
      	    <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
          
         </td></tr>
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a>' <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
          
         </td></tr>
        </table></td></tr></table></td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em> <a href="#jd_has_type_extension" class="judgment"><b>:</b><sub><font size="2">ext</font></sub></a> <a href="#doc-fs-Type"><em>Type</em></a>'
          
         </td></tr>
        </table></td></tr></table></td></tr>
       </table><br/>
      </div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not recommended for a static typing extension to
      change the static typing behavior of expressions that specify a
      type explicitly (<code>treat as</code>, <code>cast as</code>,
      <code>typeswitch</code>, function parameters, and type
      declarations in variable bindings), since the purpose of those
      expressions is to impose a specific type.</p></div></div></div></div><div class="div1">
<h2><a id="sec_special_functions" name="sec_special_functions"/>7 Additional Semantics of Functions</h2><p>This section defines the auxiliary functions required to define
  the formal semantics of [XPath/XQuery], and gives special normalization
  and static typing rules for some functions in <a href="#xpath-functions">[Functions and Operators]</a>.</p><p>Remember from <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a> that the
  following rules operate after namespace resolution for the function
  name, and directly over the input type of the parameters. In the
  rest of the section, we will use the following shortcuts notations
  for specific relevant URIs:</p><ul><li><p><code>FN-URI</code> for functions from the <a href="#xpath-functions">[Functions and Operators]</a>
    document.</p></li><li><p><code>OP-URI</code> for operators from the <a href="#xpath-functions">[Functions and Operators]</a>
    document.</p></li><li><p><code>FS-URI</code> for formal semantics functions.</p></li></ul><div class="div2">
<h3><a id="sec_special_fs_functions" name="sec_special_fs_functions"/>7.1 Formal Semantics Functions</h3><p><b>Introduction</b></p>
      <p>This section gives the definition and semantics of functions
      that are used in the formal semantics but are not in
      <a href="#xpath-functions">[Functions and Operators]</a>.  Their dynamic semantics are defined in the same
      informal style as in the <a href="#xpath-functions">[Functions and Operators]</a> document.  The static
      semantics of some formal-semantics functions require custom
      typing rules.</p>
    <div class="div3">
<h4><a id="sec_convert_operand" name="sec_convert_operand"/>7.1.1 <span>The <a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a> function</span></h4><div class="exampleInner"><div class="proto"><code class="function">fs:convert-operand</code>(<code class="arg">$actual</code><code class="as"> as </code><code class="type">item?</code>, <code class="arg">$expected</code><code class="as"> as </code><code class="type">xdt:anyAtomicType</code>)<code class="as"> as </code><code class="return-type">xdt:anyAtomicType ?</code></div></div><p>The formal-semantics function <a href="#sec_convert_operand"><em>fs:</em><code>convert-operand</code></a> converts
      the operands of arithmetic and comparison operators as
      follows:</p><ol class="enumar"><li><p>If <code>$actual</code> is the empty sequence, returns the
          empty sequence.</p></li><li><p>If <code>$actual</code> is of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>,
          then</p><ol class="enumla"><li><p>if <code>$expected</code> is of type
              <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, returns <code>$actual</code> cast to
              <code>xs:string</code>;</p></li><li><p>if <code>$expected</code> is of numeric type, returns
              <code>$actual</code> cast to <code>xs:double</code></p></li><li><p>otherwise returns <code>$actual</code> cast to the
              type of <code>$expected</code>.</p></li></ol></li><li><p>Otherwise, <code>$actual</code> is returned unchanged.</p></li></ol><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>No conversion is needed for numeric (or empty)
        operands.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                
                   <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                    <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (xs:decimal|xs:float|xs:double)?
                  
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,"<code>convert-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              
            </td></tr>
          </table><br/>
        </div>

        <p>Pairs of untyped atomic operands are converted to
        strings.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                  <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> ?
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> xdt:untypedAtomic
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,"<code>convert-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) :
                  <code>xs:string</code> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                
              
            </td></tr>
          </table><br/>
        </div>

        <p>When an untyped operand is paired with a numeric operand,
        it is converted to xs:double.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                  <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> ?
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <em>fs:</em><code>numeric</code>
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,"<code>convert-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) :
                  <code>xs:double</code> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                
              
            </td></tr>
          </table><br/>
        </div>

        <p>Finally, an untyped atomic operand not dealt with by the
        above rules is converted to the type of the other operand.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                  <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> ?
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                  <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                   <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                    <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (<a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>|<em>fs:</em><code>numeric</code>))
                  
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#sec_convert_operand">(<code>FS-URI</code>,"<code>convert-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) :
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                
              
            </td></tr>
          </table><br/>
        </div>

      </div><div class="div3">
<h4><a id="sec_convert_simple_operand" name="sec_convert_simple_operand"/>7.1.2 <span>The <a href="#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a> function</span></h4><div class="exampleInner"><div class="proto"><code class="function">fs:convert-simple-operand</code>(<code class="arg">$actual</code><code class="as"> as </code><code class="type">item *</code>, <code class="arg">$expected</code><code class="as"> as </code><code class="type">xdt:anyAtomicType</code>)<code class="as"> as </code><code class="return-type">xdt:anyAtomicTypeAtomic *</code></div></div><p>The formal-semantics function <a href="#sec_convert_simple_operand"><em>fs:</em><code>convert-simple-operand</code></a> is
      used to convert the value of the <code>$actual</code> argument
      such that it matches the type of the <code>$expected</code>
      argument (or matches a sequence of that type).</p><p>The dynamic semantics of this function are as follows:</p><ul><li><p>For each item in <code>$actual</code> argument that is of
          type xdt:untypedAtomic, that item is cast to the type of the
          <code>$expected</code> argument, and the resulting sequence
          is returned.</p></li></ul><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The following static semantics rules correspond to the
        dynamic semantics rules given above.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub> =
                  <a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>), <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
                
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#sec_convert_simple_operand">(<code>FS-URI</code>",<code>convert-simple-operand</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
                  <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                
              
            </td></tr>
          </table><br/>
        </div>
      </div><div class="div3">
<h4><a id="sec_distinct_docorder" name="sec_distinct_docorder"/>7.1.3 <span>The <a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a> function</span></h4><div class="exampleInner"><div class="proto"><code class="function">fs:distinct-doc-order</code>(<code class="arg">$nodes</code><code class="as"> as </code><code class="type">node *</code>)<code class="as"> as </code><code class="return-type">node *</code></div></div><p>The <a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a> function sorts its input sequence
      of nodes by document order
      and removes duplicates.</p><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The <a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a> function expects a sequence of
        nodes as input. The resulting type is computed using
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
       
	    <tr valign="middle" align="center"><td>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
			<a href="#sec_distinct_docorder">(<code>FS-URI</code>,"<code>distinct-doc-order</code>")</a> ( <a href="#doc-fs-Type"><em>Type</em></a>
			) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a>
			<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

</div><div class="div3">
<h4><a id="sec_distinct_docorder_or_atomic_sequence" name="sec_distinct_docorder_or_atomic_sequence"/>7.1.4 <span>The <a href="#sec_distinct_docorder_or_atomic_sequence"><em>fs:</em><code>distinct-doc-order-or-atomic-sequence</code></a> function</span></h4><div class="exampleInner"><div class="proto"><code class="function">fs:distinct-doc-order-or-atomic-sequence</code>(<code class="arg">$item</code><code class="as"> as </code><code class="type">node *</code>)<code class="as"> as </code><code class="return-type">item*</code></div></div><p>The <a href="#sec_distinct_docorder_or_atomic_sequence"><em>fs:</em><code>distinct-doc-order-or-atomic-sequence</code></a> function operates
      on either an homogeneous sequence of nodes or an homogeneous
      sequence of atomic values. If the input is a sequence of nodes,
      is sorts those nodes by document order and removes duplicates,
      using the fs:distinct-doc-order function. If it is a sequence of
      atomic values, it returns it unchanged.</p><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>

        <p>The <a href="#sec_distinct_docorder"><em>fs:</em><code>distinct-doc-order</code></a> function expects either a
        sequence of nodes as input or a sequence of atomic values. The
        resulting type is computed using <a href="#jd_prime" class="judgment">prime</a> and
        <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
       
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
                
                   <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                    <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> node*
                  
                
	      </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
			<a href="#sec_distinct_docorder_or_atomic_sequence">(<code>FS-URI</code>,"<code>distinct-doc-order-or-atomic-sequence</code>")</a> ( <a href="#doc-fs-Type"><em>Type</em></a>
			) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a>
			<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
       
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
                
                   <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                    <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>*
                  
                
	      </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		<a href="#sec_distinct_docorder_or_atomic_sequence">(<code>FS-URI</code>,"<code>distinct-doc-order-or-atomic-sequence</code>")</a> ( <a href="#doc-fs-Type"><em>Type</em></a>
			) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

</div><div class="div3">
<h4><a id="sec_items_to_nodes" name="sec_items_to_nodes"/>7.1.5 <span>The <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a> function</span></h4><div class="exampleInner"><div class="proto"><code class="function">fs:item-sequence-to-node-sequence</code>(<code class="arg">$items</code><code class="as"> as </code><code class="type">item *</code>)<code class="as"> as </code><code class="return-type">node *</code></div></div><p>The <a href="#sec_items_to_nodes"><em>fs:</em><code>item-sequence-to-node-sequence</code></a> function converts a sequence of
      item values to nodes by applying the normative rules in
      <a href="http://www.w3.org/TR/xquery#id-computedElements">Section 
3.7.3.1 Computed Element
   Constructors</a><sup><small>XQ</small></sup>.  </p><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
			<a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a>
			attribute*,
			(element|text|PI|comment|<code>xs:string</code>|<code>xs:float</code>|
			...|<code>xs:NOTATION</code>)*
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
			<a href="#sec_items_to_nodes">(<code>FS-URI</code>,"<code>item-sequence-to-node-sequence</code>")</a>
			(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> attribute*, (element|text|PI|comment)*
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

      </div><div class="div3">
<h4><a id="sec_item_seq_to_untypedAtomic" name="sec_item_seq_to_untypedAtomic"/>7.1.6 <span>The <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a> function</span></h4><p><b>Introduction</b></p> 
	<div class="exampleInner"><div class="proto"><code class="function">fs:item-sequence-to-untypedAtomic</code>(<code class="arg">$items</code><code class="as"> as </code><code class="type">item *</code>)<code class="as"> as </code><code class="return-type">xdt:untypedAtomic</code></div></div>

        <p>The <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a> function converts a
        sequence of item values to a string of type
        <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> by applying the normative rules in
        <a href="http://www.w3.org/TR/xquery#id-computedAttributes">Section 
3.7.3.2 Computed Attribute
   Constructors</a><sup><small>XQ</small></sup>.</p>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>If the input of the <a href="#sec_item_seq_to_untypedAtomic"><em>fs:</em><code>item-sequence-to-untypedAtomic</code></a> function
        is an empty sequence, it returns a zero-length
        string. Otherwise, each atomic value in the input sequence is
        cast into a string. The individual strings resulting from the
        previous step are merged into a single string by concatenating
        them with a single space character between each pair.</p>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>There are no special static typing rules for this
        function.</p>
      </div><div class="div3">
<h4><a id="sec_item_seq_to_untypedAtomic_PI" name="sec_item_seq_to_untypedAtomic_PI"/>7.1.7 <span>The <a href="#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a> function</span></h4><p><b>Introduction</b></p>

	<div class="exampleInner"><div class="proto"><code class="function">fs:item-sequence-to-untypedAtomic-PI</code>(<code class="arg">$items</code><code class="as"> as </code><code class="type">item *</code>)<code class="as"> as </code><code class="return-type">xdt:untypedAtomic</code></div></div>

        <p>The <a href="#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a> function converts a
        sequence of item values to a string of type
        <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> by applying the normative rules in
        <a href="http://www.w3.org/TR/xquery#id-computed-pis">Section 
3.7.3.5 Computed Processing Instruction Constructors</a><sup><small>XQ</small></sup>.</p>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>If the input is an empty sequence, the
        <a href="#sec_item_seq_to_untypedAtomic_PI"><em>fs:</em><code>item-sequence-to-untypedAtomic-PI</code></a> function returns a
        zero-length string. Otherwise, each atomic value in the input
        sequence is cast into a string. If any of the resulting
        strings contains the string "?&gt;", a dynamic error is
        raised. The individual strings resulting from the previous
        step are merged into a single string by concatenating them
        with a single space character between each pair. Leading
        whitespace is removed from the resulting string.</p>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
       <p>There are no special static typing rules for this
       function.</p>
     </div><div class="div3">
<h4><a id="sec_item_seq_to_untypedAtomic_text" name="sec_item_seq_to_untypedAtomic_text"/>7.1.8 <span>The <a href="#sec_item_seq_to_untypedAtomic_text"><em>fs:</em><code>item-sequence-to-untypedAtomic-text</code></a> function</span></h4><p><b>Introduction</b></p> 
	<div class="exampleInner"><div class="proto"><code class="function">fs:item-sequence-to-untypedAtomic-text</code>(<code class="arg">$items</code><code class="as"> as </code><code class="type">item *</code>)<code class="as"> as </code><code class="return-type">xdt:untypedAtomic?</code></div></div>

        <p>The <a href="#sec_item_seq_to_untypedAtomic_text"><em>fs:</em><code>item-sequence-to-untypedAtomic-text</code></a> function converts a
        sequence of item values to a string of type
        <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, or empty, by applying the rules in
        <a href="http://www.w3.org/TR/xquery#id-textConstructors">Section 
3.7.3.4 Text Node Constructors</a><sup><small>XQ</small></sup>.</p>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>If the input is the empty sequence, the
        <a href="#sec_item_seq_to_untypedAtomic_text"><em>fs:</em><code>item-sequence-to-untypedAtomic-text</code></a> function returns the empty
        sequence. Otherwise, each atomic value in the input sequence
        is cast into a string. The individual strings resulting from
        the previous step are merged into a single string by
        concatenating them with a single space character between each
        pair.</p>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>There are no special static typing rules for this
        function.</p>
      </div><div class="div3">
<h4><a id="sec_item_seq_to_untypedAtomic_comment" name="sec_item_seq_to_untypedAtomic_comment"/>7.1.9 <span>The <a href="#sec_item_seq_to_untypedAtomic_comment"><em>fs:</em><code>item-sequence-to-untypedAtomic-comment</code></a> function</span></h4><p><b>Introduction</b></p> 
	<div class="exampleInner"><div class="proto"><code class="function">fs:item-sequence-to-untypedAtomic-comment</code>(<code class="arg">$items</code><code class="as"> as </code><code class="type">item *</code>)<code class="as"> as </code><code class="return-type">xdt:untypedAtomic</code></div></div>

        <p>The <a href="#sec_item_seq_to_untypedAtomic_comment"><em>fs:</em><code>item-sequence-to-untypedAtomic-comment</code></a> function
        converts a sequence of item values to a string of type
        <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> by applying the normative rules in
        <a href="http://www.w3.org/TR/xquery#id-computed-comments">Section 
3.7.3.6 Computed Comment Constructors</a><sup><small>XQ</small></sup>.</p>
      <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p> 
        <p>If the input is the empty sequence, the
        <a href="#sec_item_seq_to_untypedAtomic_comment"><em>fs:</em><code>item-sequence-to-untypedAtomic-comment</code></a> function returns a
        zero-length string. Otherwise, each atomic value in the input
        sequence is cast into a string. The individual strings
        resulting from the previous step are merged into a single
        string by concatenating them with a single space character
        between each pair. It is a dynamic error if the result of the
        content expression of a computed comment constructor contains
        two adjacent hyphens or ends with a hyphen.</p>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>There are no special static typing rules for this
        function.</p>
      </div><div class="div3">
<h4><a id="sec_apply_ordering_mode" name="sec_apply_ordering_mode"/>7.1.10 <span>The <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>
      function</span></h4><div class="exampleInner"><div class="proto"><code class="function">fs:apply-ordering-mode</code>(<code class="arg">$items</code><code class="as"> as </code><code class="type">item()*</code>)<code class="as"> as </code><code class="return-type">item()*</code></div></div><p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>If the <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> is set to ordered, the
        <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a> function is the identity function,
        returning its input sequence in its original order.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>ordered</code>
	          
  	      <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
		      <em>Expr</em> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
              
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
  	      <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
		      <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<em>Expr</em>)
		      <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
              
	    </td></tr>
	  </table><br/>
	</div>

        <p>If the <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> is set to unordered, the
        <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a> is equivalent to the <code>fn:unordered</code>
        function, returning the items from its input sequence in
        arbitrary order.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>ordered</code>
	          
  	      <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
		      <code>fn:unordered</code>(<em>Expr</em>) <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
              
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
  	      <a href="#xq_dyn_env_def" class="env">dynEnv</a> <b> |- </b>
		      <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a>(<em>Expr</em>)
		      <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
              
	    </td></tr>
	  </table><br/>
	</div>

      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>If the ordering context is set to <code>ordered</code>, the
        static type of the input expression of the
        <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a> function is left unchanged.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>ordered</code>
	      
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
  	      <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
		      <a href="#sec_apply_ordering_mode">(<code>FS-URI</code>,"<code>apply-ordering-mode</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
		     <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
              
	    </td></tr>
	  </table><br/>
	</div>

        <p>If the ordering context is set to <code>unordered</code>,
        the static type of the input expression of the
        <a href="#sec_apply_ordering_mode"><em>fs:</em><code>apply-ordering-mode</code></a> function is computed using the
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a> judgments, as for the
        <code>fn:unordered</code> function.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	      <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ordering_mode_env" class="env">orderingMode</a> = <code>unordered</code>
	      
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
  	      <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
		      <a href="#sec_apply_ordering_mode">(<code>FS-URI</code>,"<code>apply-ordering-mode</code>")</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
		     <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a>
		     <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
              
	    </td></tr>
	  </table><br/>
	</div>
      </div><div class="div3">
<h4><a id="sec_fs_to" name="sec_fs_to"/>7.1.11 The <em>fs:</em><code>to</code> function</h4><div class="exampleInner"><div class="proto"><code class="function">fs:to</code>(<code class="arg">$firstval</code><code class="as"> as </code><code class="type">xs:integer?</code>, <code class="arg">$lastval</code><code class="as"> as </code><code class="type">xs:integer?</code>)<code class="as"> as </code><code class="return-type">xs:integer*</code></div></div><p>The formal semantics function <em>fs:</em><code>to</code> is a wrapper function
      for the <code>op:to</code> operator, taking the semantics of the range
      expression over empty sequences into account.</p><p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
        <p>If one of the input parameters for <em>fs:</em><code>to</code> is the empty
        sequence, the function returns the empty sequence, otherwise
        it returns the result of calling the <code>op:to</code> operator. This
        semantics is equivalent to the following function call.</p>

<div class="exampleInner"><pre>
declare function fs:to($firstval as xs:integer?, $lastval as xs:integer?) as xs:integer* {
  if (fn:empty($lastval) or fn:empty($lastval)
  then ()
  else op:to($firstval,$lastval)
};
</pre></div>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static type of <em>fs:</em><code>to</code> does not require any additional
        static typing rule, and is typed as a function call based on
        the above signature.</p>
      </div></div><div class="div2">
<h3><a id="function_rules" name="function_rules"/>7.2 Standard functions with specific typing rules</h3><p><b>Introduction</b></p>
      <p>This section gives special normalization and static typing
      rules for functions in <a href="#xpath-functions">[Functions and Operators]</a> for which the standard
      normalization or typing rules are not appropriate. All functions
      that are not mentioned behave as described in Section <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>. When given, the static typing rules
      in this section always give more precise type information than
      the generic rule based on the function's signature.</p>
    <div class="div3">
<h4><a id="sec_fn_last" name="sec_fn_last"/>7.2.1 The <code>fn:last</code> context function</h4><p>As explained in <a href="#eval_context"><b>[3.1.2 Dynamic Context]</b></a>, the
      <code>fn:last()</code> context function is modeled using the
      Formal Semantics variable <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>.</p><p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font><code>fn:last</code>()<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>
       </td></tr>
      </table></div>
      </div><div class="div3">
<h4><a id="sec_fn_position" name="sec_fn_position"/>7.2.2 The <code>fn:position</code> context function</h4><p>As explained in <a href="#eval_context"><b>[3.1.2 Dynamic Context]</b></a>, the
      <code>fn:position()</code> context function is modeled using the
      Formal Semantics variable <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>.</p><p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font><code>fn:position</code>()<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>
       </td></tr>
      </table></div>
      </div><div class="div3">
<h4><a id="sec_fn_abs_ceil_floor_round" name="sec_fn_abs_ceil_floor_round"/>7.2.3 <span>The <code>fn:abs</code>, <code>fn:ceiling</code>, <code>fn:floor</code>,
      <code>fn:round</code>, and <code>fn:round-half-to-even</code> functions</span></h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The typing rules for the <code>fn:abs</code>, <code>fn:ceiling</code>,
        <code>fn:floor</code>, <code>fn:round</code>, and <code>fn:round-half-to-even</code> functions promote
        their input type to the (least) base primitive numeric type
        from which the input type is derived. Parameters of type
        <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> are always promoted to <code>xs:double</code>.
        Instead of writing a separate judgment for each function, we
        write one rule with function variable <em>F</em>, which is
        one of the (<code>FN-URI</code>,"<code>abs</code>"), (<code>FN-URI</code>,"<code>ceiling</code>", (<code>FN-URI</code>,"<code>floor</code>"),
        (<code>FN-URI</code>,"<code>round</code>"), or (<code>FN-URI</code>,"<code>round-half-to-even</code>") functions.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a> ?
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> = <a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#doc-fs-Type"><em>Type</em></a>,  <code>xs:double</code>)
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_isin" class="judgment"><b>in</b></a> { <code>xs:integer</code>,
                  <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code> } 
                
              </td></tr>
            </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <em>F</em> (<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
 		
 	      
            </td></tr>
          </table><br/>
        </div>
      </div><div class="div3">
<h4><a id="sec_fn_boolean" name="sec_fn_boolean"/>7.2.4 <span>The <code>fn:boolean</code> function</span></h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The <code>fn:boolean</code> function as described in the
        <a href="#xpath-functions">[Functions and Operators]</a> document takes an empty sequence, a sequence of
        one or more nodes, or a singleton value of type <code>xs:string</code>,
        <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> or some numeric type.  All other values
        are illegal.</p>
        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (empty |
                <a href="#doc-fs-NodeType"><em>NodeType</em></a>+ | <code>xs:boolean</code> | <code>xs:string</code> |
                <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> | <em>fs:</em><code>numeric</code>)
              
              </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <code>fn:boolean</code>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:boolean</code>
              
            </td></tr>
          </table><br/>
        </div>
      </div><div class="div3">
<h4><a id="sec_fn_doc_collection" name="sec_fn_doc_collection"/>7.2.5 <span>The <code>fn:collection</code> and <code>fn:doc</code> functions</span></h4><p><b>Introduction</b></p>
        <p>The type inference rules for <code>fn:collection</code> and <code>fn:doc</code>
        depend on the syntactic form of their input expression. As a
        result, the corresponding type inference rules must be written
        directly over the input expression, unlike the other functions
        in this section.</p>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The <code>fn:collection</code> function as described in the
        <a href="#xpath-functions">[Functions and Operators]</a> document, takes a string-valued expression,
        which denotes a URI, and returns a value.</p>

        <p>If the <code>fn:collection</code> function has no parameter, the
        result type is given by the implementation for the default
        sequence if it exists.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>QName</em>
                  <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>collection</code>")
                
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                Implementation-defined default sequence
                has type <a href="#doc-fs-Type"><em>Type</em></a>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <em>QName</em>() <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
              
            </td></tr>
          </table><br/>
        </div>

        <p>If the argument to <code>fn:collection</code> is a <em>URILiteral</em>
        expression which is defined in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>, then
        the result type is the type corresponding to the
        <em>URILiteral</em> in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>. </p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>QName</em>
                  <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>collection</code>")
                
             </td></tr>
             <tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>(<em>URILiteral</em>) = <a href="#doc-fs-Type"><em>Type</em></a>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <em>QName</em>(<em>URILiteral</em>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
              
            </td></tr>
          </table><br/>
        </div>


        <p>Otherwise, if the argument is not a URI literal or is a
        string but not defined in <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>, then we
        don't know anything about the URI, and the static type is a
        collection of nodes:</p>

         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>QName</em>
                  <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>collection</code>")
                
             </td></tr>
             <tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_collection_type_env" class="env">collectionType</a>(<em>URILiteral</em>) undefined
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <em>QName</em>(<em>URILiteral</em>) <a href="#jd_has_type" class="judgment"><b>:</b></a>
                (element | attribute | processing-instruction | text |
                comment | document ) *
              
            </td></tr>
          </table><br/>
        </div>

         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>QName</em>
                  <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>collection</code>")
                
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <em>Expr</em> is not a <em>URILiteral</em>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <em>QName</em>(<em>Expr</em>) <a href="#jd_has_type" class="judgment"><b>:</b></a> (element | attribute | processing-instruction | text |
                comment | document ) *
              
            </td></tr>
          </table><br/>
        </div>

        <p>The static type of the <code>fn:doc</code> function has similar static
        rules, but, in addition, requires that the static type of the
        URI be any document:</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>QName</em>
                  <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>doc</code>")
                
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a>(<em>URILiteral</em>) = <a href="#doc-fs-Type"><em>Type</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> document 
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <em>QName</em>(<em>URILiteral</em>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
              
            </td></tr>
          </table><br/>
        </div>

        <p>Otherwise, if the argument is not a URI literal or is not
        defined in the domain of <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a>, then we don't know
        anything about the URI, and the static type is
        document:</p>

         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>QName</em>
                  <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>doc</code>")
                
             </td></tr>
             <tr valign="middle" align="center"><td>
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_doc_type_env" class="env">docType</a>(<em>URILiteral</em>) undefined
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
              <em>QName</em>(<em>URILiteral</em>) <a href="#jd_has_type" class="judgment"><b>:</b></a> document
              
            </td></tr>
          </table><br/>
        </div>

         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>QName</em>
                  <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>doc</code>")
                
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <a href="#jd_not" class="judgment"><b>not</b></a>(<em>Expr</em> = <em>URILiteral</em>)
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                <em>QName</em>(<em>Expr</em>) <a href="#jd_has_type" class="judgment"><b>:</b></a> document
              
            </td></tr>
          </table><br/>
        </div>

      </div><div class="div3">
<h4><a id="sec_fn_data" name="sec_fn_data"/>7.2.6 The <code>fn:data</code> function</h4><p><b>Introduction</b></p>
        <p>The <code>fn:data</code> function converts a sequence of items to a
        sequence of atomic values.</p>
      <p><b>Notation</b></p>
        <p id="jd_data">Inferring the type for the <code>fn:data</code> function
        is done by applying the <a href="#jd_data" class="judgment"><b>data on</b></a> auxiliary judgment, using
        the same approach as for the XPath steps.</p>

        <div align="center">
   	  
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
   	  
   	</div>

      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The general rule for <code>fn:data</code> is to apply the filter
        <a href="#jd_data" class="judgment"><b>data on</b></a> to the prime type of its argument type, then
        apply the quantifier to the result:</p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
 	      	<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  
                    <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                  
 	      	
              </td></tr>
 	    </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  (<code>FN-URI</code>,"<code>data</code>")(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to none, <a href="#jd_data" class="judgment"><b>data on</b></a> yields none.</p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <code>none</code> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>none</code>
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to empty, <a href="#jd_data" class="judgment"><b>data on</b></a> yields empty.</p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <code>empty</code> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>empty</code>
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to the union of two types, <a href="#jd_data" class="judgment"><b>data on</b></a> is
        applied to each of the two types. The resulting type is
        computed using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are
        defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>.  This rule is
        necessary because <a href="#jd_data" class="judgment"><b>data on</b></a> may return a sequence of atomic
        types.</p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
  	        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>'
 	        
              </td></tr>
              <tr valign="middle" align="center"><td>
  	        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>'
 	        
              </td></tr>
 	    </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) :
                  <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>'|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>')
                  <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>'|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>')
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to an atomic type, <a href="#jd_data" class="judgment"><b>data on</b></a> simply
        returns the atomic type:</p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
  	        
                   <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>
 	        
              </td></tr>
 	    </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to comment or processing instruction node types, <a href="#jd_data" class="judgment"><b>data on</b></a> returns
        <code>xs:string</code></p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
  	        
                   <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                    <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> comment | processing-instruction 
                  
 	        
              </td></tr>
 	    </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>xs:string</code>
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to text, and
        document node types,  <a href="#jd_data" class="judgment"><b>data on</b></a> returns
        <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a></p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
  	        
                   <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                    <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> text | document
                  
 	        
              </td></tr>
 	    </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to element node types with <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a>, the <a href="#jd_data" class="judgment"><b>data on</b></a> filter
        returns <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.</p>


      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
  	        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  
                    <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> of type <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a>
                  
 	        
              </td></tr>
 	    </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to an attribute node type, the <a href="#jd_data" class="judgment"><b>data on</b></a> filter returns the
        attribute's simple type.</p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
  	        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  
                    <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> of type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
                  
 	        
              </td></tr>
              <tr valign="middle" align="center"><td>
  	        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  
                    (of type <a href="#doc-fs-TypeName"><em>TypeName</em></a>) <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                  
 	        
              </td></tr>
 	    </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to an element type whose <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> denotes a simple type or a complex
        type of simple content, <a href="#jd_data" class="judgment"><b>data on</b></a> returns the element's simple
        type.</p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
  	        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  
                    <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
                  
 	        
              </td></tr>
              <tr valign="middle" align="center"><td>
  	        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  
                     <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                  
 	        
              </td></tr>
              <tr valign="middle" align="center"><td>
  	        
                   <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                     <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> (attribute *, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                  
 	            
  	        
                   <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                  
                     <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>*
                  
 	        
              </td></tr>
 	    </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>When applied to an element type whose <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> denotes a complex type of mixed
        content, the <a href="#jd_data" class="judgment"><b>data on</b></a> filter returns <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.</p>

      	<div align="center">
 	  <table cellpadding="0" cellspacing="0" summary="">
 	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
  	        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  
                    <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> of type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
                  
 	        
              </td></tr>
              <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
              
  	        
                  
                    <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) =
                    define type <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#doc-fs-Derivation"><em>Derivation</em></a> mixed { <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> }
                  
 	        
              </td></tr>
 	    </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <a href="#jd_data" class="judgment"><b>data on</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_has_type" class="judgment"><b>:</b></a> xdt:untypedAtomic
 		
 	      
 	    </td></tr>
 	  </table><br/>
      	</div>

        <p>The <a href="#jd_data" class="judgment"><b>data on</b></a> filter is not defined on any element type
        whose <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> denotes a
        complex type of complex content and therefore apply <a href="#jd_data" class="judgment"><b>data on</b></a>
        to such a node raises a static error.</p>
      <p><b>Example</b></p>
        <p>Consider the following variables and its corresponding
        static type.</p>
      
<div class="exampleInner"><pre>
    $x : (element price { attribute currency { xs:string }, xs:decimal }
         | element price_code { xs:integer })
</pre></div>

        <p>Applying the <code>fn:data</code> function on that variable results in
        the following type.</p>
      
<div class="exampleInner"><pre>
    fn:data($x) : (xs:decimal | xs:integer)
</pre></div>

        <p>Because the input type is a choice, applying the
        <a href="#jd_data" class="judgment"><b>data on</b></a> filter results in a choice of simple types for the
        output of the <code>fn:data</code> function.</p>
      </div><div class="div3">
<h4><a id="sec_fn_distinct_node_vals" name="sec_fn_distinct_node_vals"/>7.2.7 <span>The <code>fn:distinct-values</code> function</span></h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The <code>fn:distinct-values</code> function expects a sequence of atomic
        values as input and returns a sequence of prime types, which
        are defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>*
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>FN-URI</code>,"<code>distinct-values</code>")(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
		 
	    </td></tr>
	  </table><br/>
	</div>

      </div><div class="div3">
<h4><a id="sec_fn_unordered" name="sec_fn_unordered"/>7.2.8 <span>The <code>fn:unordered</code> function</span></h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static semantics for unordered is computed using
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>. The type of each argument is determined,
        and then <a href="#jd_prime" class="judgment">prime</a>(.) and <a href="#jd_quantifier" class="judgment">quantifier</a>(.)  are applied to
        the sequence type (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>).</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>FN-URI</code>,"<code>unordered</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
			 <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_quantifier" class="judgment">·</a>
			 <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
		 
	    </td></tr>
	  </table><br/>
	</div>
      </div><div class="div3">
<h4><a id="sec_fnerror" name="sec_fnerror"/>7.2.9 <span>The <code>fn:error</code> function</span></h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The fn:error function always has the <code>none</code> type.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>FN-URI</code>,"<code>error</code>")() <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>none</code>
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <code>xs:QName</code>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>FN-URI</code>,"<code>error</code>")(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>none</code>
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <code>xs:QName</code>?    
            <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <code>xs:string</code>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <code>fn:error</code>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>none</code>
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <code>xs:QName</code>?    
            <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <code>xs:string</code>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>FN-URI</code>,"<code>error</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <code>none</code>
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

      </div><div class="div3">
<h4><a id="sec_fn_aggregates" name="sec_fn_aggregates"/>7.2.10 <span>The <code>fn:min</code>, <code>fn:max</code>, <code>fn:avg</code>, and <code>fn:sum</code>
      functions</span></h4><p><b>Introduction</b></p>
       <p>The dynamic evaluation rules for aggregate functions convert
       any item of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> in the input sequence to
       <code>xs:double</code>, then attempt to promote all values in the input
       sequence to values that are comparable.  The static typing
       rules reflect the dynamic rules.</p>
     <p><b><a class="processing" href="#processing_normalization">Normalization</a></b></p>
      <p>The <code>fn:sum</code> function has two forms.  The first form takes
      two arguments: The first argument is the input sequence and the
      second argument is the value that should be returned if the
      input sequence is empty. In case there is no second argument,
      the value returned for an empty sequence is the <code>xs:integer</code>
      value 0.</p>

      <div align="center"><table cellpadding="0" cellspacing="0" summary="">
       <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font><code>fn:sum</code>(<em>Expr</em><sub><font size="2">1</font></sub>)<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
       <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
         <font size="6">[</font><code>fn:sum</code>(<em>Expr</em><sub><font size="2">1</font></sub>,0)<font size="6">]</font><a href="#jd_map_expr" class="judgment"><sub><font size="2">Expr</font></sub></a>
       </td></tr>
      </table></div>
      
     <p><b>Notation</b></p>
       <p id="jd_convert_untypedAtomic">The type function
       <a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a> takes a prime type and converts all
       occurrences of the type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> to a target type.
       It is defined recursively as follows.</p>
    
      <table summary="" class="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><col align="left" span="1"/><tbody><tr><td><a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>, <a href="#doc-fs-Type"><em>Type</em></a>)</td><td>  =  </td><td><a href="#doc-fs-Type"><em>Type</em></a></td></tr><tr><td><a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#doc-fs-FormalItemType"><em>FormalItemType</em></a>, <a href="#doc-fs-Type"><em>Type</em></a>)</td><td>  =  </td><td><a href="#doc-fs-FormalItemType"><em>FormalItemType</em></a> (<a href="#doc-fs-FormalItemType"><em>FormalItemType</em></a> is not <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>)</td></tr><tr><td><a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<code>empty</code>, <a href="#doc-fs-Type"><em>Type</em></a>)</td><td>  =  </td><td><code>empty</code></td></tr><tr><td><a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<code>none</code>, <a href="#doc-fs-Type"><em>Type</em></a>)</td><td>  =  </td><td><code>none</code></td></tr><tr><td><a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a>)</td><td>  =  </td><td><a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a>) | <a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a>)</td></tr></tbody></table>

     <p><b>Notation</b></p>

       <p id="jd_agg_quantifier">The function <a href="#jd_agg_quantifier" class="judgment"><b>aggregate_quantifier</b></a>
       converts the input type quantifier zero-or-more or zero-or-one
       to the result type quantifier zero-or-one, and converts the
       input type quantifier one or one-or-more, to the result type
       quantifier one.</p>

      <table summary="" class="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td><a href="#jd_agg_quantifier" class="judgment"><b>aggregate_quantifier</b></a>(<code>?</code>)</td><td>  =  </td><td><code>?</code></td></tr><tr><td><a href="#jd_agg_quantifier" class="judgment"><b>aggregate_quantifier</b></a>(<code>*</code>)</td><td>  =  </td><td><code>?</code></td></tr><tr><td><a href="#jd_agg_quantifier" class="judgment"><b>aggregate_quantifier</b></a>(<code>1</code>)</td><td>  =  </td><td><code>1</code></td></tr><tr><td><a href="#jd_agg_quantifier" class="judgment"><b>aggregate_quantifier</b></a>(<code>+</code>)</td><td>  =  </td><td><code>1</code></td></tr></tbody></table>
     <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
       <p>Now we can define the static typing rules for the aggregate
       functions.  First, the input type is converted to a prime type.
       Second, the type function <a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a> is applied
       to the prime type, yielding a new prime type, in which
       occurrences of <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> are converted to
       <code>xs:double</code>.  Third, the judgment <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> is
       applied to the new prime type and target type. The result type
       is combined with the aggregate quantifier of the input
       type.</p>

       <p>For a given aggregate function, instead of writing a
       separate judgment for each target type, we write one rule using
       a target type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>.</p>

       <p>For <code>fn:min</code> and <code>fn:max</code>, the target type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> is
       either <code>xs:string</code>, <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>,
       <code>xs:double</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
       <a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a>, or <a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      .</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <code>xs:double</code>)
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
               <a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">1</font></sub>, ...,<a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">n</font></sub> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              
            </td></tr>
       <tr valign="middle" align="center"><td>
        
         
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
          <a href="#jd_isin" class="judgment"><b>in</b></a>
          { <code>xs:string</code>, <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>,
       <code>xs:double</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
       <a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a>, <a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>       }
         
        
       </td></tr>
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">i</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                  
               1 &lt;= i &lt;= n
            </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              (<code>FN-URI</code>,"<code>min</code>")(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_agg_quantifier" class="judgment"><b>aggregate_quantifier</b></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>))
      	     
            
          </td></tr>
        </table><br/>
      </div>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <code>xs:double</code>)
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
               <a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">1</font></sub>, ...,<a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">n</font></sub> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              
            </td></tr>
       <tr valign="middle" align="center"><td>
        
         
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
          <a href="#jd_isin" class="judgment"><b>in</b></a>
          { <code>xs:string</code>, <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>,
       <code>xs:double</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>,
       <a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a>, <a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>       }
         
        
       </td></tr>
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">i</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                  
               1 &lt;= i &lt;= n
            </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              (<code>FN-URI</code>,"<code>max</code>")(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_agg_quantifier" class="judgment"><b>aggregate_quantifier</b></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>))
      	     
            
          </td></tr>
        </table><br/>
      </div>

      <p>For <code>fn:avg</code>, the target type <a href="#doc-fs-Type"><em>Type</em></a> is either
      <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, <a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a>,
      or <a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      .</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <code>xs:double</code>)
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
               <a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">1</font></sub>, ...,<a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">n</font></sub> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              
            </td></tr>
       <tr valign="middle" align="center"><td>
        
         
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
          <a href="#jd_isin" class="judgment"><b>in</b></a>
          { <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, <a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a>,
      <a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>       }
         
        
       </td></tr>
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">i</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                  
               1 &lt;= i &lt;= n
            </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              (<code>FN-URI</code>,"<code>avg</code>")(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_agg_quantifier" class="judgment"><b>aggregate_quantifier</b></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>))
      	     
            
          </td></tr>
        </table><br/>
      </div>

      <p>For <code>fn:sum</code>, the target type <a href="#doc-fs-Type"><em>Type</em></a> is either
      <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>,
      <a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a>, or <a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      . The second
      argument in <code>fn:sum</code> is the value that should be returned if the
      input sequence is empty. The result type is the union of the
      target type and the type of the second argument. Note that the
      rule checks that the type for the zero value is consistent with
      the type of the input sequence.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a> ?
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub> = <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub> =
           <a href="#jd_convert_untypedAtomic" class="judgment"><b>convert_untypedAtomic</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>, <code>xs:double</code>)
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
               <a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">1</font></sub>, ...,<a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">n</font></sub> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
              
            </td></tr>
       <tr valign="middle" align="center"><td>
        
         
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
          <a href="#jd_isin" class="judgment"><b>in</b></a>
          { <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>,
      <a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a> }
         
        
       </td></tr>
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-core-ItemType"><em>ItemType</em></a><sub><font size="2">i</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
                  
               1 &lt;= i &lt;= n
            </td></tr>
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
            </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              (<code>FN-URI</code>,"<code>sum</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
              <a href="#jd_quantifier" class="judgment">·</a>
              <a href="#jd_agg_quantifier" class="judgment"><b>aggregate_quantifier</b></a>(<a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>))
      	     
            
          </td></tr>
        </table><br/>
      </div>

    </div><div class="div3">
<h4><a id="sec_fn_remove" name="sec_fn_remove"/>7.2.11 <span>The <code>fn:remove</code> function</span></h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static type for the <code>fn:remove</code> function is computed
        using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in
        <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>. Since one item may be removed
        from the sequence, the resulting type is made optional.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> xs:integer
                
              </td></tr>
            </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  (<code>FN-URI</code>,"<code>remove</code>")(<a href="#doc-fs-Type"><em>Type</em></a>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)?
 		
 	      
            </td></tr>
          </table><br/>
        </div>
      </div><div class="div3">
<h4><a id="sec_fn_reverse" name="sec_fn_reverse"/>7.2.12 <span>The <code>fn:reverse</code> function</span></h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static type for the <code>fn:reverse</code> function is computed
        using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in
        <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
            </td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  (<code>FN-URI</code>,"<code>reverse</code>")(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
 		
 	      
            </td></tr>
          </table><br/>
        </div>
      </div><div class="div3">
<h4><a id="sec_fn_subsequence" name="sec_fn_subsequence"/>7.2.13 <span>The <code>fn:subsequence</code> function</span></h4><p><b>Introduction</b></p>
        <p>The <code>fn:subsequence</code> function has special typing rules when
        its second argument is the numeric literal value 1 or the
        built-in variable <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>.  These rules provide better
        typing for path expressions such as <em>Expr</em>[1] and
        <em>Expr</em>[<code>fn:last</code>()].</p>

        <p>The type inference rules for <code>fn:subsequence</code> depends on
        the syntactic form of their input expression. As a result, the
        corresponding type inference rules must be written directly
        over the input expression, unlike the other functions in this
        section.</p>
      <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>

        <p>If the type of the input expression has exactly one or
        one-or-more items, then the type inferred for <code>fn:subsequence</code>
        is the prime type of the input type.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   <em>QName</em>
                   <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")
                 
              </td></tr>
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		<em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a>
 		<a href="#doc-fs-Type"><em>Type</em></a>
                    
                <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_isin" class="judgment"><b>in</b></a>
                { <code>1</code>, <code>+</code> }
              </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <em>QName</em>(<em>Expr</em>,
			 1, 1) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

        <p>If the type of the input expression has zero or more items,
        <code>fn:subsequence</code> is applied on a numeric literal,
        <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>, or <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>, then the static type is
        zero-or-one of the prime type of the input type. Those static
        typing rules are intended to support more precise typing for
        the cases where <code>fn:subsequence</code> is the result of normalizing
        an XPath predicate of the form <em>Expr</em>[<em>NumericLiteral</em>]
        of <em>Expr</em>[last()], see <a href="#id-axis-steps"><b>[4.2.1 Steps]</b></a>.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   <em>QName</em>
                   <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")
                 
              </td></tr>
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		<em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a>
 		<a href="#doc-fs-Type"><em>Type</em></a>
                    
                <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_isin" class="judgment"><b>in</b></a>
                { <code>*</code> }
              </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <em>QName</em>(<em>Expr</em>,
			 <em>NumericLiteral</em>, 1) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <code>?</code>
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

        <p>The same rule applies when the last item in the input
        sequence is selected.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   <em>QName</em>
                   <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")
                 
              </td></tr>
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		<em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a>
 		<a href="#doc-fs-Type"><em>Type</em></a>
                    
                <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_isin" class="judgment"><b>in</b></a>
                { <code>*</code> }
              </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <em>QName</em>(<em>Expr</em>,
			 <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>last</code></a>, 1) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <code>?</code>
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

        <p>The same rule applies when an item is selected based on its
        position in the input sequence.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   <em>QName</em>
                   <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")
                 
              </td></tr>
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		<em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a>
 		<a href="#doc-fs-Type"><em>Type</em></a>
                    
                <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_isin" class="judgment"><b>in</b></a>
                { <code>*</code> }
              </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 <em>QName</em>(<em>Expr</em>,
			 <a href="#fs_builtin_vars"><code>$</code><em>fs:</em><code>position</code></a>, 1) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <code>?</code>
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

        <p>The last rule applies to all other applications of the
        <code>fn:subsequence</code> function. </p>
        <div align="center">

          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   <em>QName</em>
                   <a href="#jd_func_qname_expands_to" class="judgment"><b>of func expands to</b></a> (<code>FN-URI</code>,"<code>subsequence</code>")
                 
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> xs:double
                    
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <em>Expr</em><sub><font size="2">2</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> xs:double
                
              </td></tr>
            </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  <em>QName</em>(<em>Expr</em>, <em>Expr</em><sub><font size="2">1</font></sub>, <em>Expr</em><sub><font size="2">2</font></sub>)
                  <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
                  <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a> ?
 		
 	      
            </td></tr>
          </table><br/>
</div>

      </div><div class="div3">
<h4><a id="sec_op_union_intersect_except" name="sec_op_union_intersect_except"/>7.2.14 <span>The <code>op:union</code>, <code>op:intersect</code>, and
      <code>op:except</code> operators</span></h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static semantics for <code>op:union</code> is computed using
        <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>.  The type of each argument is determined,
        and then <a href="#jd_prime" class="judgment">prime</a>(.) and <a href="#jd_quantifier" class="judgment">quantifier</a>(.)  are applied to
        the sequence type (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>).</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>OP-URI</code>,"<code>union</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
			 <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> , <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
			 <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> , <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

        <p>The static semantics of <code>op:intersect</code> is analogous to that
        for <code>op:union</code>. Because an intersection may be empty, the
        result type is optional.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		<a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
		        (<code>OP-URI</code>,"<code>intersect</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,
		        <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) <a href="#jd_quantifier" class="judgment">·</a>
		        <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) <a href="#jd_quantifier" class="judgment">·</a> ?
		
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

        <p>The static semantics of <code>op:except</code> follows.  The type of
        the second argument is ignored as it does not contribute to
        the result type.  As with <code>op:intersect</code>, the result of
        <code>op:except</code> may be the empty sequence.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>OP-URI</code>,"<code>except</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <em>Expr</em><sub><font size="2">2</font></sub>)
			 <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_quantifier" class="judgment">·</a>
			 <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_quantifier" class="judgment">·</a>
			 ?
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>
      </div><div class="div3">
<h4><a id="sec_fn_insert_before" name="sec_fn_insert_before"/>7.2.15 <span>The <code>fn:insert-before</code> function</span></h4><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static type for the <code>fn:insert-before</code> function is
        computed using <a href="#jd_prime" class="judgment">prime</a> and <a href="#jd_quantifier" class="judgment">quantifier</a>, which are
        defined in <a href="#sec_factor"><b>[8.4 Judgments for FLWOR and other expressions on sequences]</b></a>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <code>xs:integer</code>
                
              </td></tr>
              <tr valign="middle" align="center"><td>
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub> = (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>)
                
              </td></tr>
            </table></td></tr></table></td></tr>
 	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
 	      <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
 		
                  (<code>FN-URI</code>,"<code>insert-before</code>")(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>) <a href="#jd_quantifier" class="judgment">·</a> <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>)
 		
 	      
            </td></tr>
          </table><br/>
        </div>
      </div><div class="div3">
<h4><a id="sec_fn_cardinality_funcs" name="sec_fn_cardinality_funcs"/>7.2.16 <span>The <code>fn:zero-or-one</code>, <code>fn:one-or-more</code>, and
      <code>fn:exactly-one</code> functions</span></h4><p>The functions <code>fn:zero-or-one</code>, <code>fn:one-or-more</code>, and
      <code>fn:exactly-one</code> check that the cardinality of a sequence is in
      the expected range.  They are useful to override the static type
      inferred for a given query. For example, in the following query,
      the user may know that all ISBN numbers are unique and therefore
      that the function always return at most one book
      element. However, the static typing feature cannot infer a
      precise enough type and will return a static type error at
      compile time.</p><div class="exampleInner"><pre>
  declare function book_with_isbn($isbn as xs:string) as schema-element(book)? {
    //book[@isbn=$isbn]
  }
</pre></div><p>In that query, the <code>fn:zero-or-one</code> function can be used to
      tell the type system that the cardinality is known to be zero or
      one.</p><div class="exampleInner"><pre>
  declare function book_with_isbn($isbn as xs:string) as schema-element(book)? {
    fn:zero-or-one(//book[@isbn=$isbn])
  }
</pre></div><p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
        <p>The static typing rules for those functions always infer a
        type with the cardinality indicated by that function.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>FN-URI</code>,"<code>zero-or-one</code>")(<a href="#doc-fs-Type"><em>Type</em></a>)
			 <a href="#jd_has_type" class="judgment"><b>:</b></a>
			 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)?
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>FN-URI</code>,"<code>one-or-more</code>")(<a href="#doc-fs-Type"><em>Type</em></a>)
			 <a href="#jd_has_type" class="judgment"><b>:</b></a>
			 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)+
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td>
	    </td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	      <tr valign="middle" align="center"><td>
		 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
			 (<code>FN-URI</code>,"<code>exactly-one</code>")(<a href="#doc-fs-Type"><em>Type</em></a>)
			 <a href="#jd_has_type" class="judgment"><b>:</b></a>
			 <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
		 
	      </td></tr>
	    </table></td></tr></table></td></tr>
	  </table><br/>
	</div>

      </div></div></div><div class="div1">
<h2><a id="sec_auxiliary_judgments" name="sec_auxiliary_judgments"/>8 Auxiliary Judgments</h2><p>This section defines auxiliary judgments used in 
  defining the formal semantics.  Many auxiliary judgments are used in both
  static and dynamic inference rules.  Those auxiliary judgments that
  are used in only the static or dynamic semantics are labeled as such.  </p><div class="div2">
<h3><a id="sec_accessing_types" name="sec_accessing_types"/>8.1 Judgments for accessing types</h3><p><b>Introduction</b></p>
      <p>This section defined several auxiliary judgments to access
      components of the [XPath/XQuery] type system. The first two
      judgments (<a href="#jd_derives_from" class="judgment"><b>derives from</b></a> and <a href="#jd_substitutes_for" class="judgment"><b>substitutes for</b></a>) are used
      to access the type and element name hierarchies in an XML
      Schema. The other judgments (<a href="#jd_lookup" class="judgment"><b>name lookup</b></a>, <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a>,
      <a href="#jd_extended_by" class="judgment"><b>extended by</b></a>, <a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a> and <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>) are used
      to lookup the meaning of element or attribute types from the
      schema. These judgments are used in many expressions, notably in
      the specification of type matching (See <a href="#sec_type_matching"><b>[8.3 Judgments for type matching]</b></a>), validation (See <a href="#sec_validate"><b>[E.1 Judgments for the validate expression]</b></a>), and the static semantics of step
      expressions (See <a href="#sec_auxiliary_xpath"><b>[8.2 Judgments for step expressions and filtering]</b></a>).</p>
    <div class="div3">
<h4><a id="jd_aux_derives_from" name="jd_aux_derives_from"/>8.1.1 Derives from</h4><p><b>Notation</b></p>
        <p id="jd_derives_from">The judgment</p>
    
        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">1</font></sub> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">2</font></sub>
          
        </div>
    
        <p>holds when <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">1</font></sub> derives from <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">2</font></sub>.
        This judgment formalizes the definition of the
        <code>derives-from</code> function in <a href="http://www.w3.org/TR/xquery#id-sequencetype-matching">Section 
2.5.4 SequenceType Matching</a><sup><small>XQ</small></sup>. </p>

      <p><b>Example</b></p>
        <p>For example, assuming the extended XML Schema given in
        section <a href="#sec_types_example"><b>[2.4.5 Example of a complete Schema]</b></a>, then the following
        judgments hold.</p>

<div class="exampleInner"><pre>
  USAddress            derives from  xs:anyType
  NYCAddress           derives from  USAddress
  NYCAddress           derives from  xs:anyType
  xsd:positiveInteger  derives from  xsd:integer
  xsd:integer          derives from  xs:anySimpleType
  fs:anon3             derives from  xsd:positiveInteger
  fs:anon3             derives from  xsd:integer
  fs:anon3             derives from  xs:anySimpleType
  fs:anon3             derives from  xs:anyType
</pre></div>

      <p><b>Note</b></p>
        <p>Derivation is a partial order. It is reflexive and
        transitive by the definition below.</p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>
    
        <p>Some rules have hypotheses that simply list a type,
        element, or attribute declaration.</p>
    
        <p>Every type name derives from itself.</p>
    
      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
         </td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a>
          
         </td></tr>
        </table><br/>
      </div>
    
      <p>Every type name derives from the type it is declared to
      derive from by restriction or extension.</p>
    
      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
         </td></tr>
         <tr valign="middle" align="center"><td>
          
           
             <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = define type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
             extends <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a> <a href="#doc-fs-OptMixed"><em>OptMixed</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
           
          
         </td></tr>
         </table></td></tr></table></td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a> <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
          
         </td></tr>
        </table><br/>
      </div>
    
      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
<tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
         </td></tr>
         <tr valign="middle" align="center"><td>

          
           
             <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = define type <a href="#doc-fs-TypeName"><em>TypeName</em></a>
             restricts <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a> <a href="#doc-fs-OptMixed"><em>OptMixed</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
           
          
</td></tr>
         </table></td></tr></table></td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a> <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
          
         </td></tr>
        </table><br/>
      </div>

<p>The above rules all require that the type names be defined in the
static context, but [XPath/XQuery] permits references to "unknown" type
names, i.e., 
type names that are not defined in the static context. 
An unknown type name might be encountered, if a module in which the
given type name occurs does not import the schema in which the given
type name is defined. In this case, an implementation is allowed (but
is not required) to provide an implementation-dependent mechanism for
determining whether the unknown type name is the same as or derived
by restriction from the expected type name.
The following rule formalizes this implementation dependent mechanism.
</p>    
      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
<tr valign="middle" align="center"><td>
          
           
             "The implementation is able to determine that
<a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">1</font></sub> is derived by
restriction from <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">2</font></sub>."
           
          
</td></tr>
         </table></td></tr></table></td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">1</font></sub> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">2</font></sub>
          
         </td></tr>
        </table><br/>
      </div>
    
      <p>The derivation relation is transitive.</p>
    
      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">1</font></sub> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">2</font></sub>
              
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">2</font></sub> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">3</font></sub>
          
         </td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">1</font></sub> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">3</font></sub>
          
         </td></tr>
        </table><br/>
      </div>
    
      </div><div class="div3">
<h4><a id="sec_substitutes" name="sec_substitutes"/>8.1.2 Substitutes for</h4><p>The substitutes judgment is used to know whether an element
      name is in the substitution group of another element name.</p><p><b>Notation</b></p>
        <p id="jd_substitutes_for">The judgment</p>
    
        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> <a href="#jd_substitutes_for" class="judgment"><b>substitutes for</b></a>
          <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub>
          
        </div>
    
        <p>holds when <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> substitutes for
        <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub>.</p>
      <p><b>Example</b></p>
        <p>For example, assuming the extended XML Schema given in
        section <a href="#sec_types_example"><b>[2.4.5 Example of a complete Schema]</b></a>, then the following
        judgments hold.</p>

<div class="exampleInner"><pre>
  usaddress  substitutes for  address
  nyaddress  substitutes for  usaddress
  nyaddress  substitutes for  address
</pre></div>
      <p><b>Note</b></p>
        <p>Substitution is a partial order.  It is reflexive and
        transitive by the definition below.  It is asymmetric because
        no cycles are allowed in substitution groups.</p>
      <p><b>Semantics</b></p>
        <p>The substitutes judgment for element names is specified by
        the following rules.</p>
    
        <p>Every element name substitutes for itself.</p>
    
        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_substitutes_for" class="judgment"><b>substitutes for</b></a> <a href="#doc-fs-ElementName"><em>ElementName</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>Every element name substitutes for the element it is
        declared to substitute for.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
         </td></tr>
         <tr valign="middle" align="center"><td>
            
             
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) =
                 define element <a href="#doc-fs-ElementName"><em>ElementName</em></a>
                   substitutes for <a href="#doc-fs-ElementName"><em>BaseElementName</em></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
             
            
         </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_substitutes_for" class="judgment"><b>substitutes for</b></a> <a href="#doc-fs-ElementName"><em>BaseElementName</em></a>
            
           </td></tr>
          </table><br/>
        </div>
    
        <p>Substitution is transitive.</p>
    
        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> <a href="#jd_substitutes_for" class="judgment"><b>substitutes for</b></a> <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub>
                
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> <a href="#jd_substitutes_for" class="judgment"><b>substitutes for</b></a> <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">3</font></sub>
            
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> <a href="#jd_substitutes_for" class="judgment"><b>substitutes for</b></a> <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">3</font></sub>
            
           </td></tr>
          </table><br/>
        </div>
      </div><div class="div3">
<h4><a id="sec_element_lookup" name="sec_element_lookup"/>8.1.3 Element and attribute name lookup (Dynamic)</h4><p>The <a href="#jd_lookup" class="judgment"><b>name lookup</b></a> judgment is used in the definition of the
      <a href="#jd_matches" class="judgment"><b>matches</b></a> judgment, which takes a value and a type and
      determines whether the value matches, or is an instance of, the
      given type.  Both <a href="#jd_lookup" class="judgment"><b>name lookup</b></a> and <a href="#jd_matches" class="judgment"><b>matches</b></a> are used in the
      dynamic semantics. </p><p>The <a href="#jd_lookup" class="judgment"><b>name lookup</b></a> judgment takes an element(attribute) name
      (derived from a node value) and an element(attribute) type and
      if the element(attribute) name matches the corresponding name in
      the element(attribute) type, the judgment yields the type's
      corresponding type reference and for elements, its nillable
      property.</p><p><b>Notation</b></p>
        <p id="jd_lookup">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup" class="judgment"><b>name lookup</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a>
          <a href="#jd_lookup" class="judgment"><b>yields</b></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>
          <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
          
        </div>

        <p>holds when the given element name matches the given element
        type and requires that the element be nillable as indicated
        and have the given type reference.</p>

      <p><b>Example</b></p>
        <p>For example, assuming the extended XML Schema given in
        section <a href="#sec_types_example"><b>[2.4.5 Example of a complete Schema]</b></a>, then the following
        judgments hold.</p>

<div class="exampleInner"><pre>
  comment    name lookup element comment                          yields of type xsd:string
  size       name lookup element size nillable of type xs:integer yields nillable of type xsd:string
  apt        name lookup element apt                              yields of type fs:anon3
  nycaddress name lookup element address                          yields of type NYCAddress
</pre></div>

        <p>Note that when the element name is in a substitution group,
        the name lookup returns the type name corresponding to the
        original element name (here the type <code>NYCAddress</code>
        for the element <code>nycaddress</code>, instead of
        <code>Address</code> for the element
        <code>address</code>).</p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>If the element type is a reference to a global element,
        then name lookup yields the type reference in the element
        declaration for the given element name.  The given element
        name must be in the substitution group of the global
        element.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> <a href="#jd_substitutes_for" class="judgment"><b>substitutes for</b></a> <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>
           
          
         </td></tr>
            <tr valign="middle" align="center"><td>
             
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>) =
                  define element <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub>
                    <em>OptSubstitution</em> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
              
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> <a href="#jd_lookup" class="judgment"><b>name lookup</b></a> element
             <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub> <a href="#jd_lookup" class="judgment"><b>yields</b></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the given element name matches the element name in the
        element type, and the element type contains a type reference,
        then name lookup yields that type reference.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup" class="judgment"><b>name lookup</b></a> element
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
             <a href="#jd_lookup" class="judgment"><b>yields</b></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the element type has no element name but contains a type
        reference, then name lookup yields the type reference.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup" class="judgment"><b>name lookup</b></a> element
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_lookup" class="judgment"><b>yields</b></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the element type has no element name and no type
        reference, then name lookup yields <code>xs:anyType</code>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup" class="judgment"><b>name lookup</b></a> element
             <a href="#jd_lookup" class="judgment"><b>yields</b></a> of type <code>xs:anyType</code>
            
           </td></tr>
          </table><br/>
        </div>

      <p><b>Notation</b></p>
        <p id="jd_attribute_lookup">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
          <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>yields</b></a>
          <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
          
        </div>

        <p>holds when matching an attribute with the given attribute
        name against the given attribute type matches the type
        reference.</p>
      <p><b>Example</b></p>
        <p>For example, assuming the extended XML Schema given in
        section <a href="#sec_types_example"><b>[2.4.5 Example of a complete Schema]</b></a>, then the following
        judgments hold.</p>

<div class="exampleInner"><pre>
  orderDate  name lookup  attribute orderDate of type xsd:date  yields  of type xsd:date?
  orderDate  name lookup  attribute of type xsd:date            yields  of type xsd:date?
</pre></div>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>If the attribute type is a reference to a global attribute,
        then name lookup yields the type reference in the attribute
        declaration for the given attribute name.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#doc-fs-AttributeName"><em>AttributeName</em></a>) =
                  define attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a>
                    <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
              
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
             attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>yields</b></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the given attribute name matches the attribute name in
        the attribute type, and the attribute type contains a type
        reference, then name lookup yields that type reference.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
             attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
             <a href="#jd_attribute_lookup" class="judgment"><b>yields</b></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the attribute type has no attribute name but contains a
        type reference, then name lookup yields the type
        reference.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
             attribute <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>yields</b></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the attribute type has no attribute name and no type
        reference, then name lookup yields <code>xs:anySimpleType</code>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
             attribute <a href="#jd_attribute_lookup" class="judgment"><b>yields</b></a> of type
             <code>xs:anySimpleType</code>
            
           </td></tr>
          </table><br/>
        </div>

      </div><div class="div3">
<h4><a id="jd_aux_static_lookup" name="jd_aux_static_lookup"/>8.1.4 Element and attribute type lookup (Static)</h4><p>The type lookup judgments are used to obtain the
      appropriate type reference for an attribute or element.</p><p><b>Notation</b></p>
        <p id="jd_static_lookup">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>
          <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
          
        </div>

        <p>holds when the element type is optionally nillable and has the given type
        reference.</p>

      <p><b>Semantics</b></p>     
        <p>The element type lookup judgments are specified by the
        following rules.</p>

        <p>A reference to a global element yields the type reference
        in the global element declaration with the given element
        name.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
         </td></tr>
            <tr valign="middle" align="center"><td>
             
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = define element
                  <a href="#doc-fs-ElementName"><em>ElementName</em></a> <em>OptSubstitution</em> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>
                  <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
              
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             element <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a>
             <a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>In the case of a local element type, type lookup yields the
        corresponding type reference.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             element <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the element type has no element name but contains a type
        reference, then type lookup yields that type reference.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             element <a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
             <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the element type has no element name and no type
        reference, then lookup yields <code>xs:anyType</code>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             element <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> of type
             <code>xs:anyType</code>
            
           </td></tr>
          </table><br/>
        </div>

      <p><b>Notation</b></p>
        <p id="jd_attribute_static_lookup">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href="#jd_attribute_static_lookup" class="judgment"><b>type lookup</b></a>
          <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
          
        </div>

        <p>holds when the attribute type has the  given type reference.</p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>A reference to a global attribute yields the type reference in
        the global attribute declaration with the given attribute name.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#doc-fs-AttributeName"><em>AttributeName</em></a>) =
                  define attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a>
                    <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
              
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> 
             <a href="#jd_attribute_static_lookup" class="judgment"><b>type lookup</b></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

       <p>If the attribute name is not defined, i.e., it is not declared
       in the in-scope schema definitions, then the attribute's
       default type is <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_attr_decl" class="env">attrDecl</a>(<a href="#doc-fs-AttributeName"><em>AttributeName</em></a>) undefined
              
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a>
             <a href="#jd_attribute_static_lookup" class="judgment"><b>type lookup</b></a>
             of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>
            
           </td></tr>
          </table><br/>
        </div>


        <p>In the case of a local attribute type, type lookup yields
        the corresponding type reference.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_attribute_static_lookup" class="judgment"><b>type lookup</b></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the attribute type has no attribute name but contains a
        type reference, then type lookup yields the type
        reference.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             attribute <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> 
             <a href="#jd_attribute_static_lookup" class="judgment"><b>type lookup</b></a>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the attribute type has no attribute name and no type
        reference, then type lookup yields <code>xs:anySimpleType</code>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             attribute <a href="#jd_attribute_static_lookup" class="judgment"><b>type lookup</b></a> of
             type <code>xs:anySimpleType</code>
            
           </td></tr>
          </table><br/>
        </div>

      </div><div class="div3">
<h4><a id="sec_extension" name="sec_extension"/>8.1.5 Extension</h4><p><b>Notation</b></p>

        <p id="jd_extended_by">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_extended_by" class="judgment"><b>extended by</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_extended_by" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
          
        </div>

        <p>holds when the result of extending <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> by <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
        is <a href="#doc-fs-Type"><em>Type</em></a>.  This judgment is used in the definition of
        type expansion <a href="#sec_type_expansion"><b>[8.1.9 Type expansion]</b></a>, which
        expands a type to include the union of all types derived from
        the given type,   </p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> = <em>AttributeAll</em><sub><font size="2">1</font></sub> , <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a><sub><font size="2">1</font></sub>
                
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> = <em>AttributeAll</em><sub><font size="2">2</font></sub> , <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_extended_by" class="judgment"><b>extended by</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_extended_by" class="judgment"><b>is</b></a>
                 (<em>AttributeAll</em><sub><font size="2">1</font></sub> &amp; <em>AttributeAll</em><sub><font size="2">2</font></sub>) , <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a><sub><font size="2">1</font></sub> , <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>
      </div><div class="div3">
<h4><a id="sec_mixed" name="sec_mixed"/>8.1.6 Mixed content</h4><p><b>Notation</b></p>
        <p id="jd_mixes_to">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_mixes_to" class="judgment"><b>mixes to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
          
        </div>

        <p>holds when the result of creating a mixed content from
        <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> is <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.</p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rule, which
        interleaves the element content with a sequence of text nodes
        and adds a union of <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a> values.  The
        <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a> sequence is required because it is
        possible to derive an element containing only atomic values
        from an element that is mixed.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Type"><em>Type</em></a> = <em>AttributeAll</em> , <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a>
            
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_mixes_to" class="judgment"><b>mixes to</b></a> <em>AttributeAll</em> , (
             <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a> &amp; text* | <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a> *)
            
           </td></tr>
          </table><br/>
        </div>

      </div><div class="div3">
<h4><a id="sec_adjustment" name="sec_adjustment"/>8.1.7 Type adjustment</h4><p>In the [XPath/XQuery] type system, a complex-type declaration
      does not include the implicit attributes and nodes that may be
      included in the type.  Type adjustment takes a complex type and
      adjusts it to include implicit attributes and nodes.  In
      particular, type adjustment:

      </p><ul><li><p>adds the four (optional) built-in attributes xsi:type,
        xsi:nil, xsi:schemaLocation, or
        xsi:noNamespaceSchemaLocation,</p></li><li><p>interleaves the type with a sequence of comments and
        processing-instructions, and </p></li><li><p>if the
        complex type is mixed, interleaves the type with a sequence of
        text nodes and <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>.</p></li></ul><p><b>Notation</b></p>
        <p id="jd_adjusts_to">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-OptMixed"><em>OptMixed</em></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
          
        </div>

        <p>holds when the second type is the same as the first after
        the first has been adjusted as described above.  </p>
      <p><b>Semantics</b></p>     
        <p>This judgment is specified by the following rules.</p>

        <p>If the type is flagged as mixed, then mix the type and
        extend it by the built-in attributes.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_mixes_to" class="judgment"><b>mixes to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_extended_by" class="judgment"><b>extended by</b></a> <a href="#sec_built_in_attributes"><em>BuiltInAttributes</em></a> <a href="#jd_extended_by" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub> &amp;
              <code>processing-instruction*</code> &amp;
              <code>comment*</code>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             mixed <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <p>Otherwise, just extend the type by the built-in
        attributes.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_extended_by" class="judgment"><b>extended by</b></a> <a href="#sec_built_in_attributes"><em>BuiltInAttributes</em></a> <a href="#jd_extended_by" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
            
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> &amp;
              <code>processing-instruction*</code> &amp;
              <code>comment*</code>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

      </div><div class="div3">
<h4><a id="sec_built_in_attributes" name="sec_built_in_attributes"/>8.1.8 Builtin attributes</h4><p>Schema defines four built-in attributes that can appear on
      any element in the document without being explicitly declared in
      the schema. Those four attributes need to be added inside
      content models when doing matching. The four built-in attributes
      of Schema are declared as follows.</p><div class="exampleInner"><pre>
  define attribute xsi:type of type xs:QName
  define attribute xsi:nil of type xs:boolean
  define attribute xsi:schemaLocation of type fs:anon
  define type fs:anon1 { xs:anyURI* }
  define attribute xsi:noNamespaceSchemaLocation of type xs:anyURI
</pre></div><p>For convenience, a type that is an all group of the four
       built-in XML Schema attributes is defined.</p><div class="exampleInner"><pre>
  BuiltInAttributes =
      attribute xsi:type ?
    &amp; attribute xsi:nil ?
    &amp; attribute xsi:schemaLocation ?
    &amp; attribute xsi:noNamespaceSchemaLocation ?
</pre></div></div><div class="div3">
<h4><a id="sec_type_expansion" name="sec_type_expansion"/>8.1.9 Type expansion</h4><p>The <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> judgment is one of the most important
      static judgments.  It is used in the static semantics of the
      child axis <a href="#sec_static_axis_judge"><b>[8.2.2.1 Static semantics of axes]</b></a>, which is used
      in the definition of many other rules that extract element types
      from an arbitrary content type.</p><p>The judgment takes a type name and computes the union of all
      types derived from the given type.  If the type is nillable, it
      also makes sure the content model allows the empty sequence.  If
      the type is mixed, it also adjusts the type to include the mixed
      content model.  The judgment depends on the
      <a href="#jd_union_interpretation" class="judgment"><b>extended with union interpretation of</b></a> judgment to recursively compute all
      derived types.</p><p><b>Notation</b></p>
        <p id="jd_expands_to">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
          <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
          
        </div>

        <p>holds when expanding the (nillable) type reference results
        in the given type.</p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>If the type is nillable, then its expansion is
        optional.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
             <a href="#doc-fs-Type"><em>Type</em></a>
            
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             nillable <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
             <a href="#doc-fs-Type"><em>Type</em></a>?
            
           </td></tr>
          </table><br/>
        </div>

        <p>The type definition for the type reference is contained in
        its expansion.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
            </td></tr>

            <tr valign="middle" align="center"><td>
            
             
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = define type
               <a href="#doc-fs-TypeName"><em>TypeName</em></a> extends <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a> <a href="#doc-fs-OptMixed"><em>OptMixed</em></a> {
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> }
             
            
            </td></tr>

            <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
            <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_union_interpretation" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_union_interpretation" class="judgment"><b>extended with union interpretation of</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a>
             
            </td></tr>

            <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-OptMixed"><em>OptMixed</em></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
            
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             of type <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <p>In case the type is <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a>, the type does not need
        to be adjusted as is required for other XML Schema types. See
        the corresponding definition in <a href="#id-predefined-types"><b>[3.5.1 Predefined Schema Types]</b></a>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

            <tr valign="middle" align="center"><td>
            
             
               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#dt-xdt_untyped"><code>xdt:untyped</code></a>) = define type
               <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a> extends <code>xs:anyType</code> {
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> }
             
            
            </td></tr>

           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             of type <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

      </div><div class="div3">
<h4><a id="sec_union_interpretation" name="sec_union_interpretation"/>8.1.10 Union interpretation of derived types</h4><p><b>Notation</b></p>
        <p id="jd_union_interpretation">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_union_interpretation" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
          <a href="#jd_union_interpretation" class="judgment"><b>extended with union interpretation of</b></a> 
          <a href="#doc-fs-TypeName"><em>TypeName</em></a>
          
        </div>

        <p>holds when the type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> is the expansion of the type
        name <a href="#doc-fs-TypeName"><em>TypeName</em></a> with definition <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> to include all
        types derived by extension and restriction from the given type
        name.  This rule is recursive, because each type name itself
        may have other type names that are derived from it.  The
        recursive rules traverse the entire derivation tree,
        identifying every type name derived from the original type
        name.</p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">

<tr valign="middle" align="center"><td>


               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">R,1</font></sub>) = define type
               <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">R,1</font></sub> restricts <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">0</font></sub> <a href="#doc-fs-OptMixed"><em>OptMixed</em></a><sub><font size="2">R,1</font></sub> {
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">R,1</font></sub> }


</td></tr>

<tr valign="middle" align="center"><td>

· · ·


</td></tr>

<tr valign="middle" align="center"><td>


               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">R,n</font></sub>) = define type
               <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">R,n</font></sub> restricts <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">0</font></sub> <a href="#doc-fs-OptMixed"><em>OptMixed</em></a><sub><font size="2">R,n</font></sub> {
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">R,n</font></sub> }


</td></tr>


<tr valign="middle" align="center"><td>

<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>

<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">R,1</font></sub>' <a href="#jd_union_interpretation" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">R,1</font></sub> <a href="#jd_union_interpretation" class="judgment"><b>extended with union interpretation of</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">R,1</font></sub> 


</td></tr>
<tr valign="middle" align="center"><td>

· · ·


</td></tr>
<tr valign="middle" align="center"><td>

<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>

<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">R,n</font></sub>' <a href="#jd_union_interpretation" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">R,n</font></sub> <a href="#jd_union_interpretation" class="judgment"><b>extended with union interpretation of</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">R,n</font></sub> 


</td></tr>


<tr valign="middle" align="center"><td>


               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">E,1</font></sub>) = define type
               <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">E,1</font></sub> extends <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">0</font></sub> <a href="#doc-fs-OptMixed"><em>OptMixed</em></a><sub><font size="2">E,1</font></sub> {
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">E,1</font></sub> }


</td></tr>

<tr valign="middle" align="center"><td>

· · ·


</td></tr>

<tr valign="middle" align="center"><td>


               <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">E,m</font></sub>) = define type
               <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">E,m</font></sub> extends <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">0</font></sub> <a href="#doc-fs-OptMixed"><em>OptMixed</em></a><sub><font size="2">E,m</font></sub> {
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">E,m</font></sub> }


</td></tr>


<tr valign="middle" align="center"><td>

<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>

<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">E,1</font></sub>' <a href="#jd_union_interpretation" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">E,1</font></sub> <a href="#jd_union_interpretation" class="judgment"><b>extended with union interpretation of</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">E,1</font></sub> 


</td></tr>
<tr valign="middle" align="center"><td>

· · ·


</td></tr>
<tr valign="middle" align="center"><td>

<a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>

<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">E,m</font></sub>' <a href="#jd_union_interpretation" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">E,m</font></sub> <a href="#jd_union_interpretation" class="judgment"><b>extended with union interpretation of</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">E,m</font></sub> 


</td></tr>


<tr valign="middle" align="center"><td>


<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">R,1</font></sub>' | · · · | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">R,n</font></sub>'
| <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub> | (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">E,1</font></sub>' ) | · · · | (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">E,m</font></sub>')


</td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_union_interpretation" class="judgment"><b>is</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">0</font></sub>
          <a href="#jd_union_interpretation" class="judgment"><b>extended with union interpretation of</b></a> 
          <a href="#doc-fs-TypeName"><em>TypeName</em></a><sub><font size="2">0</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

<p><b>Examples</b></p>

  <p>Note that this expansion does not enforce the <b>unique
  particular attribution</b> property specified by XML Schema in
  the resulting content models. Implementations may want to implement
  an equivalent alternative expansion that enforces that property.
  For example, expanding type <code>T1</code> below yields the
  following type that is not one-deterministic:</p>

<div class="exampleInner"><pre>
define type T1 { element a }
define type T2 extends T1 { element b }

(element a | element a, element b) is (element a) extended with union interpretation of T1
</pre></div>

<p>An implementation might want to infer the equivalent content model
that verifies the <b>unique particular attribution</b> property
of XML Schema:</p>

<div class="exampleInner"><pre>
(element a, (() | element b)) is (element a) extended with union interpretation of T1
</pre></div>


      </div></div><div class="div2">
<h3><a id="sec_auxiliary_xpath" name="sec_auxiliary_xpath"/>8.2 Judgments for step expressions and filtering</h3><p><b>Introduction</b></p>
      <p>Step expressions are one of the elementary operations in
      [XPath/XQuery]. Steps select nodes reachable from the root of an XML tree.
      Defining the semantics of step expressions requires a
      detailed analysis of all the possible cases of axis and node
      tests.</p>

      <p>This section introduces auxiliary judgments used to define
      the semantics of step expressions.  The <a href="#jd_principal" class="judgment"><b>principal</b></a> judgment
      (<a href="#sec_jd_principal"><b>[8.2.1 Principal Node Kind]</b></a>) captures the notion of
      <em>principal node kind</em> in XPath.  The Axis judgments
      (<a href="#sec_axis_judge"><b>[8.2.2 Auxiliary judgments for axes]</b></a>) define the static and dynamic
      semantics of all axes, and the Node Test judgments (<a href="#sec_test_judge"><b>[8.2.3 Auxiliary judgments for node tests]</b></a>) define the static and dynamic semantics
      of all node tests.  The <a href="#jd_filter" class="judgment"><b>filter</b></a> judgment accesses the value
      of an attribute and is used in the definition of validation
      (<a href="#sec_validation_judgments"><b>[E Auxiliary Judgments for Validation]</b></a>).</p>
    <div class="div3">
<h4><a id="sec_jd_principal" name="sec_jd_principal"/>8.2.1 Principal Node Kind</h4><p><b>Notation</b></p>
        <p>The following auxiliary grammar production describe
        principal node types (See <a href="#xpath20">[XML Path Language (XPath) 2.0]</a>).</p>
      
        
<h5><a id="N1FBF1" name="N1FBF1"/>PrincipalNodeKind</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-PrincipalNodeKind" name="doc-fs-PrincipalNodeKind"/>[<small>72 (Formal)</small>]   </td><td><code>PrincipalNodeKind</code></td><td>   ::=   </td><td><code>"element"  |  "attribute"  |  "namespace"</code></td></tr></tbody></table>

      <p><b>Notation</b></p>
        <p id="jd_principal">The judgment</p>
      
       <div align="center">
        
         <em>Axis</em> <a href="#jd_principal" class="judgment"><b>principal</b></a>
         <em>PrincipalNodeKind</em>
        
       </div>
      
        <p>holds when <em>PrincipalNodeKind</em> is the principal node
        kind for <em>Axis</em>.</p>

      <p><b>Example</b></p>
        <p>For example, the following judgments hold.</p>

<div class="exampleInner"><pre>
  child::       principal  element
  descendant::  principal  element
  preceding::   principal  element
  attribute::   principal  attribute
  namespace::   principal  namespace
</pre></div>

      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>The principal node type for the attribute axis is
        attribute.</p>

        <div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <code>attribute::</code> <a href="#jd_principal" class="judgment"><b>principal</b></a> attribute
           
          </td></tr>
         </table><br/>
        </div>

        <p>The principal node type for the namespace axis is
        namespace.</p>

        <div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <code>namespace::</code> <a href="#jd_principal" class="judgment"><b>principal</b></a> namespace
           
          </td></tr>
         </table><br/>
        </div>

        <p>The principal node type for all other axis is element.</p>

        <div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td>
           <em>Axis</em> != <code>attribute::</code>    
           <em>Axis</em> != <code>namespace::</code>
          </td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <em>Axis</em> <a href="#jd_principal" class="judgment"><b>principal</b></a> element
           
          </td></tr>
         </table><br/>
        </div>

      </div><div class="div3">
<h4><a id="sec_axis_judge" name="sec_axis_judge"/>8.2.2 Auxiliary judgments for axes</h4><div class="div4">
<h5><a id="sec_static_axis_judge" name="sec_static_axis_judge"/>8.2.2.1 Static semantics of axes</h5><p><b>Notation</b></p>
          <p id="jd_axis_type">The following judgment</p>

          <div align="center">
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
             <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
            
           
          </div>

          <p>holds when applying the axis <em>Axis</em> on type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
          yields the type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.</p>

          <p id="jd_has_element_content">The following two judgments are used
          in the definition of <a href="#jd_axis_type" class="judgment"><b>axis</b></a>.  The judgment</p>

          <div align="center">
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_has_element_content" class="judgment"><b>has-node-content</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
            
           
          </div>

          <p>only applies to a type that is a valid element content
          type and holds when <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> has the content type
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.  The judgment separates the attribute types from
          the other node or atomic-valued types of the element content type
          and yields the non-attribute types.</p>

          <p id="jd_has_attribute_content">The judgment</p>

          <div align="center">
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_has_attribute_content" class="judgment"><b>has-attribute-content</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
            
           
          </div>

          <p>only applies to a type that is a valid element content
          type and holds when <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> has attribute types
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.  The judgment yields the attribute types of
          the element content type.</p>
        <p><b>Example</b></p>
          <p>For example, the following judgments hold.</p>

<div class="exampleInner"><pre>
  axis child::      of  element of type xs:string   :  text
  axis child::      of  element items of type Items :  element item of type fs:anon1*

  axis child::      of  element purchaseOrder       : 
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items

  axis attribute::  of  element of type xs:string   :  empty

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-node-content
    element item of type fs:anon1*

    attribute partNum of type SKU,
    element item of type fs:anon1*
  has-attribute-content
    attribute partNum of type SKU

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-node-content
    (element item of type fs:anon1*) |
    (element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)

    (attribute partNum of type SKU,
     element item of type fs:anon1*) |
    (attribute orderDate of type xs:date?,
     element shipTo of type USAddress,
     element billTo of type USAddress,
     element comment?,
     element items of type Items)
  has-attribute-content
    (attribute partNum of type SKU) |
    (attribute orderDate of type xs:date?)
</pre></div>
        <div class="div5">
<h6><a id="sec_inference_axis" name="sec_inference_axis"/>8.2.2.1.1 Inference rules for all axis</h6><p><b>Semantics</b></p>
          <p>This judgment is specified by the following rules.</p>

          <p>The following rules compute the type of the axis
          expression when applied to each item type in the content model.</p>

         <div align="center"> 
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <em>Occurrence</em>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <em>Occurrence</em>
             
            
           </td></tr>
          </table><br/>
         </div>
     
         <div align="center"> 
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b> 
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>&amp;<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>&amp;<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
             
            
           </td></tr>
          </table><br/>
         </div>
     
         <div align="center"> 
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b> 
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
             
            
           </td></tr>
          </table><br/>
         </div>
     
         <div align="center"> 
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b> 
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
             
            
           </td></tr>
          </table><br/>
         </div>
     
         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
               
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> none <a href="#jd_axis_type" class="judgment"><b>:</b></a> none
             
            
           </td></tr>
          </table><br/>
         </div>
     
         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
               
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis_type" class="judgment"><b>of</b></a> <code>empty</code> <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
             
            
           </td></tr>
          </table><br/>
         </div>

         <p>The following rules specifies how to compute the type of
         each axis applied to an item type.</p>

      </div><div class="div5">
<h6><a id="sec_inference_self" name="sec_inference_self"/>8.2.2.1.2 Inference rules for the <code>self</code> axis</h6><p><b>Semantics</b></p>

         <p>Applying the self axis to a node type results in the same
         node type.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	           <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>self::</code> <a href="#jd_axis_type" class="judgment"><b>of</b></a>
	           <a href="#doc-fs-NodeType"><em>NodeType</em></a> <a href="#jd_axis_type" class="judgment"><b>:</b></a>
	           <a href="#doc-fs-NodeType"><em>NodeType</em></a>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

      </div><div class="div5">
<h6><a id="sec_inference_child" name="sec_inference_child"/>8.2.2.1.3 Inference rules for the <code>child</code> axis</h6><p><b>Semantics</b></p>

         <p>In the case of an element type, the static type of the
         child axis is obtained by type lookup and expansion of the
         resulting type.  Note that the <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> judgment
         yields the type that corresponds to a given type name.
         Because the meaning of a type name includes the definitions
         of <em>all</em> type names derived by extension and
         restriction from the given type name, <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> yields
         the <em>union</em> of all the type definitions of all
         type names derived from the input type name.  Each type in
         the union contains the complete definition of the type name,
         i.e., it includes built-in attributes and, if necessary,
         processing-instruction, comment, and text types.</p>

         <p>After type expansion, the judgment
         <a href="#jd_has_element_content" class="judgment"><b>has-node-content</b></a> is applied to each type in the
         union.  The resulting type is the union of all non-attribute
         types in the expanded type.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-ElementType"><em>ElementType</em></a>
                <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>
                <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
                  <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> | · ·
                  · | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> 
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_has_element_content" class="judgment"><b>has-node-content</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>' 
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                
· · · 
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> <a href="#jd_has_element_content" class="judgment"><b>has-node-content</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>' 
                
               
              </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a>
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>' | ... | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>'
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>If the type is a sequence of attributes, then the content
         type is <code>empty</code>.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> attribute*
               
              </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_element_content" class="judgment"><b>has-node-content</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>If the type is attributes followed by a simple type, the
         content type is zero-or-one text.  The resulting
         type is optional since an expression returning the empty
         sequence results in no text node being constructed.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#doc-fs-Type"><em>Type</em></a> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                attribute*
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>*
                
               
              </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
                   <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_element_content" class="judgment"><b>has-node-content</b></a> text? 
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In the case of an element type with complex content type,
         the content type is simply the non-attribute part of the
         complex content type.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#doc-fs-Type"><em>Type</em></a> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                attribute*
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a>*
               
              </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_element_content" class="judgment"><b>has-node-content</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In the case of an attribute type, the static type of the
         child axis is empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>child::</code> <a href="#jd_axis_type" class="judgment"><b>of</b></a>
	               <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In the case of a text node type, the static type of the child
         axis is empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>child::</code> <a href="#jd_axis_type" class="judgment"><b>of</b></a> text
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In the case of a comment node type, the static type of the child
         axis is empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> comment
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In the case of a processing-instruction node type, the
         static type of the child axis is empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> processing-instruction
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In case of a document node type, the static type of the
         child axis is the type of the document node content,
         interleaved with a sequence of comments and
         processing-instructions.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>child::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> document { <a href="#doc-fs-Type"><em>Type</em></a> }
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a> &amp;
	               processing-instruction* &amp; comment*
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

      </div><div class="div5">
<h6><a id="sec_inference_attribute" name="sec_inference_attribute"/>8.2.2.1.4 Inference rules for the <code>attribute</code> axis</h6><p><b>Semantics</b></p>

         <p>The static type for the attribute axis is computed in a
         similar way as the static type for the child axis.  As above,
         the <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> judgment may yield a union type.  After
         type expansion, the judgment <a href="#jd_has_attribute_content" class="judgment"><b>has-attribute-content</b></a> is
         applied to each type in the union.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-ElementType"><em>ElementType</em></a> 
                <a href="#jd_static_lookup" class="judgment"><b>type lookup</b></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a>
                <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#doc-fs-OptNillable"><em>OptNillable</em></a> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
                  <a href="#jd_expands_to" class="judgment"><b>expands to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> | · ·
                  · | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> 
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_has_attribute_content" class="judgment"><b>has-attribute-content</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>'
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                
· · · 
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> <a href="#jd_has_attribute_content" class="judgment"><b>has-attribute-content</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>'
                
               
              </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a>
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>' | ... | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>'
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>When applied to an element type,
         <a href="#jd_has_attribute_content" class="judgment"><b>has-attribute-content</b></a> yields the type of the element's
         content that are attributes.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                
                  <a href="#doc-fs-Type"><em>Type</em></a> = (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
                attribute*
                
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a>* | <a href="#dt-xdt_anyAtomicType"><code>xdt:anyAtomicType</code></a>*
               
              </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_has_attribute_content" class="judgment"><b>has-attribute-content</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In case of an attribute type, the static type of the
         attribute axis is empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>attribute::</code> <a href="#jd_axis_type" class="judgment"><b>of</b></a>
	               <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In case of a text node type, the static type of the
         attribute axis is empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> text <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In case of a comment node type, the static type of the
         attribute axis is empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> comment <a href="#jd_axis_type" class="judgment"><b>:</b></a>
	               <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In case of a processing-instruction node type, the static type of the
         attribute axis is empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> processing-instruction
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>In case of a document node type, the static type of the
         attribute axis is the empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>attribute::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> document { <a href="#doc-fs-Type"><em>Type</em></a> }
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

      </div><div class="div5">
<h6><a id="sec_inference_parent" name="sec_inference_parent"/>8.2.2.1.5 Inference rules for the <code>parent</code> axis</h6><p><b>Semantics</b></p>

         <p>The type for the parent of an element type, a text node
         type, a PI node type, or a comment node type is either an
         element, a document, or empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> element <a href="#jd_axis_type" class="judgment"><b>:</b></a>
	               (element | document)?
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> text <a href="#jd_axis_type" class="judgment"><b>:</b></a>
	               (element | document)?
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> processing-instruction
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> (element | document)?
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> comment <a href="#jd_axis_type" class="judgment"><b>:</b></a>
	               (element | document)?
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>The type for the parent of an attribute node is an
         element or empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> element?
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>The type for the parent of a document node type is always
         empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>parent::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

      </div><div class="div5">
<h6><a id="sec_inference_namespace" name="sec_inference_namespace"/>8.2.2.1.6 Inference rules for the <code>namespace</code> axis</h6><p><b>Semantics</b></p>

         <p>The type for the namespace axis is always empty.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td>
	     </td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>namespace::</code>
	               <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeType"><em>NodeType</em></a>
	               <a href="#jd_axis_type" class="judgment"><b>:</b></a> <code>empty</code>
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

      </div><div class="div5">
<h6><a id="sec_inference_descendant" name="sec_inference_descendant"/>8.2.2.1.7 Inference rules for the <code>descendant</code> axis</h6><p><b>Semantics</b></p>

         <p>The types for the descendant axis is obtained as the
         closure of the type of the child axis. This is expressed by
         the following inference rule.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>child::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
	         
	       </td></tr>
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>child::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
	         
	       </td></tr>
	       <tr valign="middle" align="center"><td>
	         
                   ...
	         
	       </td></tr>
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>child::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n+1</font></sub> 
	         
	       </td></tr>
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                     <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n+1</font></sub>) <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | ... | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>) 
	         
	       </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>descendant::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a>
                   (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | ... |
                   <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>))*
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p><b>Note</b></p>
           <p>Note that the last premise in the above rule 
           terminates the recursion. The rule computes the n-th
           type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> such that applying the child axis one more
           time does not add any new item type to the union. This
           condition is guaranteed to hold at some point, because the
           number of item types is bounded by all of the item types
           defined in the in-scope schema definitions.</p>
         

      </div><div class="div5">
<h6><a id="sec_inference_descendant_of_self" name="sec_inference_descendant_of_self"/>8.2.2.1.8 Inference rules for the <code>descendant-or-self</code> axis</h6><p><b>Semantics</b></p>

         <p>The type for the descendant-or-self axis is the union of
         the type for the self axis and for the descendant axis.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>descendant::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
	         
	       </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>descendant-or-self::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>))*
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

      </div><div class="div5">
<h6><a id="sec_inference_ancestor" name="sec_inference_ancestor"/>8.2.2.1.9 Inference rules for the <code>ancestor</code> axis</h6><p><b>Semantics</b></p>

         <p>The type for the ancestor axis is computed similarly as
         for the descendant axis.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
	               <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>ancestor::</code> <a href="#jd_axis_type" class="judgment"><b>of</b></a>
	               <a href="#doc-fs-NodeType"><em>NodeType</em></a> <a href="#jd_axis_type" class="judgment"><b>:</b></a>
	               (element | document)*
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

         <p>Note that this rule will always result in the type
         <code>(element | document)*</code> type, but this formulation
         is preferred for consistency, and in case the static typing
         for the parent axis gets improved in a future version.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>parent::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
	         
	       </td></tr>
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>parent::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
	         
	       </td></tr>
	       <tr valign="middle" align="center"><td>
	         
                   ...
	         
	       </td></tr>
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>parent::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n+1</font></sub> 
	         
	       </td></tr>
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                     <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n+1</font></sub>) <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | ... | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>) 
	         
	       </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>ancestor::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a>
                   (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | ... |
                   <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>))*
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>

      </div><div class="div5">
<h6><a id="sec_inference_ancestor_of_self" name="sec_inference_ancestor_of_self"/>8.2.2.1.10 Inference rules for the <code>ancestor-or-self</code> axis</h6><p><b>Semantics</b></p>

         <p>The type for the ancestor-or-self axis is the union of the
         type for the self axis and for the ancestor axis.</p>

	 <div align="center">
	   <table cellpadding="0" cellspacing="0" summary="">
	     <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
	       <tr valign="middle" align="center"><td>
	         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                   
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>ancestor::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
	         
	       </td></tr>
	     </table></td></tr></table></td></tr>
	     <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
	         
                   <a href="#jd_axis_type" class="judgment"><b>axis</b></a> <code>ancestor-or-self::</code>
                   <a href="#jd_axis_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
                   <a href="#jd_axis_type" class="judgment"><b>:</b></a> (<a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>))*
	         
	       
	     </td></tr>
	   </table><br/>
	 </div>
        </div></div><div class="div4">
<h5><a id="sec_dyn_axes" name="sec_dyn_axes"/>8.2.2.2 Dynamic semantics of axes</h5><p><b>Notation</b></p>
          <p id="jd_axis">The following judgment</p>
          <div align="center">
           
            <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            
             <a href="#jd_axis" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
            
           
          </div>
     
          <p>holds when applying the axis <em>Axis</em> on <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
          yields <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>:</p>
    
        <p><b>Example</b></p>
          <p>For example, the following judgments hold.</p>

<div class="exampleInner"><pre>
  axis child::      of    element sizes { text { "1 2 3" } }  =&gt;  text { "1 2 3" }

  axis attribute::  of
     element weight of type xs:integer {
       attribute xsi:type of type xs:QName {
         "xs:integer" of type xs:QName
       },
       42 of type xs:integer
     }
  =&gt; attribute xsi:type of type xs:QName {
       "xs:integer" of type xs:QName
     }

  
</pre></div>
        <p><b>Semantics</b></p>
          <p>This judgment is specified by the following rules.</p>

          <p>The first set of rules are used to process the axis
          judgment on each individual item in the input sequence.</p>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class="judgment"><b>of</b></a> () <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> ()
              
             
            </td></tr>
           </table><br/>
          </div>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
               
                <a href="#jd_axis" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
                <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
               
                <a href="#jd_axis" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
                <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">4</font></sub>
               
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class="judgment"><b>of</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">4</font></sub>
              
             
            </td></tr>
           </table><br/>
          </div>

          <p>The following rules specifies how the value filter
          judgment is applied on each Axis.</p>

          <p>The self axis just returns the context node.</p>

          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
              </td></tr>
              <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
                <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
                  
                    <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>self::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
                    <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
                  
                
              </td></tr>
            </table><br/>
          </div>

          <p>The child, parent, attribute and namespace axis are
          specified as follows.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
            </td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code> child::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> element
               <a href="#doc-fs-ElementName"><em>ElementName</em></a> { <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a>,<a href="#doc-fs-ElementValue"><em>ElementValue</em></a> } <a href="#jd_axis" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-ElementValue"><em>ElementValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
            </td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>attribute::</code> <a href="#jd_axis" class="judgment"><b>of</b></a>
               <a href="#doc-fs-ElementName"><em>ElementName</em></a> {
               <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a>,<a href="#doc-fs-ElementValue"><em>ElementValue</em></a> }
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
            </td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>parent::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <em>dm:</em>parent(<a href="#doc-fs-NodeValue"><em>NodeValue</em></a>)
              
             
            </td></tr>
           </table><br/>
          </div>

          <table border="1" summary="Editorial note"><tr><td width="50%" valign="top" align="left"><b>Editorial note</b></td><td width="50%" valign="top" align="right"> </td></tr><tr><td valign="top" align="left" colspan="2">The use of the <code>dm:</code> should be
            removed. This can be removed when adding the notion of
            store in the dynamic rules.</td></tr></table>
          
          <p>The descendant, descendant-or-self, ancestor, and
          ancestor-or-self axis are implemented through recursive
          application of the children and parent filters.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b> 
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>child::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>descendant::</code> <a href="#jd_axis" class="judgment"><b>of</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_axis" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>descendant::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b> 
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>self::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b> 
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>descendant::</code> <a href="#jd_axis" class="judgment"><b>of</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_axis" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>descendant-or-self::</code> <a href="#jd_axis" class="judgment"><b>of</b></a>
               <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b> 
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>parent::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b> 
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>ancestor::</code> <a href="#jd_axis" class="judgment"><b>of</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_axis" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>ancestor::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b> 
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>self::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code> ancestor::</code> <a href="#jd_axis" class="judgment"><b>of</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_axis" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_axis" class="judgment"><b>axis</b></a> <code>ancestor-or-self::</code> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
               <a href="#jd_axis" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
              
             
            </td></tr>
           </table><br/>
          </div>



          <p>In all the other cases, the axis application results in
          an empty sequence.</p>

          <div align="center">
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            
             <a href="#jd_axis" class="judgment"><b>axis</b></a> <em>Axis</em> <a href="#jd_axis" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
             <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> ()
            
            otherwise.
          </div>

         </div></div><div class="div3">
<h4><a id="sec_test_judge" name="sec_test_judge"/>8.2.3 Auxiliary judgments for node tests</h4><p>A node test may be a name test or a kind test.  In the static
      and dynamic semantics, we begin with name tests, followed by
      kind tests. </p><div class="div4">
<h5><a id="sec_sem_node_tests" name="sec_sem_node_tests"/>8.2.3.1 Static semantics of node tests</h5><p><b>Notation</b></p>
          <p id="jd_test_type">The following judgment</p>

          <div align="center">
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
             <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
            
           
          </div>

          <p>holds when applying the node test <em>NodeTest</em> on the
          type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> in the context of the given principal node
          kind, yields the type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.</p>

        <p><b>Example</b></p>
          <p>For example, assuming the extended XML Schema given in
          section <a href="#sec_types_example"><b>[2.4.5 Example of a complete Schema]</b></a>, then the
          following judgments hold.</p>

<div class="exampleInner"><pre>
  test shipTo with element of
    element shipTo of type USAddress,
    element billTo of type USAddress,
    element ipo:comment?,
    element items of type Items
  : element shipTo of type USAddress
</pre></div>
        <p><b>Semantics</b></p>
          <p>This judgment is specified by the following rules.</p>

          <p>The first set of rules is similar to that for axes, and
          are used to process the content each individual item type in
          the input content model.</p>
     
         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <em>Occurrence</em>
              <a href="#jd_test_type" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <em>Occurrence</em>
             
            
           </td></tr>
          </table><br/>
         </div>


         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
<tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
<tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
             

</td></tr>
<tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
             

</td></tr>
</table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              &amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub> &amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub> 
             
            
           </td></tr>
          </table><br/>
         </div>


         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
<tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
<tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
             

</td></tr>
<tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
             

</td></tr>
</table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> , <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub> , <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub> 
             
            
           </td></tr>
          </table><br/>
         </div>


         <div align="center"> 
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
             
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b> 
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
              
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">4</font></sub>
             
            
           </td></tr>
          </table><br/>
         </div>

         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
               
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> none
              <a href="#jd_test_type" class="judgment"><b>:</b></a> none
             
            
           </td></tr>
          </table><br/>
         </div>
     
         <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
               
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             
              <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test_type" class="judgment"><b>with</b></a>
              <em>PrincipalNodeKind</em> <a href="#jd_test_type" class="judgment"><b>of</b></a> empty
              <a href="#jd_test_type" class="judgment"><b>:</b></a> empty
             
            
           </td></tr>
          </table><br/>
         </div>
        <p>The following rules specify how the test judgment apply to
      node tests in the context of a principal node kind.  We start
      with name tests followed by kind tests.</p><div class="div5">
<h6><a id="sec_sem_name_tests" name="sec_sem_name_tests"/>8.2.3.1.1 Name Tests</h6><p>Name tests on elements and attributes always compute the most
      specific type possible. For example, if <code>$v</code> is bound
      to an element with a computed name, the type of <code>$v</code>
      is <code>element</code>. The static type computed for the
      expression <code>$v/self::foo</code> is <code>element foo of
      type xs:anyType</code>, which makes use of <code>foo</code> in
      the name test to compute a more specific type.  Also note that
      each case of name matching restricts the principal node kind
      appropriately.</p><div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">2</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>QName</em><sub><font size="2">2</font></sub>
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href="#jd_test_type" class="judgment"><b>:</b></a>
             element <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> 
            
           </td></tr>
          </table><br/>
        </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">2</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>
           
             
            </td></tr>
           <tr valign="middle" align="center"><td>
            <code>fn:local-name-from-QName</code>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>) = <em>LocalPart</em><sub><font size="2">1</font></sub>
           </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>QName</em><sub><font size="2">2</font></sub> <a href="#jd_test_type" class="judgment"><b>with</b></a>
             element <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <code>*:</code><em>LocalPart</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> element <em>QName</em><sub><font size="2">2</font></sub>
             <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">2</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>
           
             
            </td></tr>
           <tr valign="middle" align="center"><td>
            <code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>) = <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em><sub><font size="2">1</font></sub>)
           </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>QName</em><sub><font size="2">2</font></sub> <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <em>Prefix</em><sub><font size="2">1</font></sub><code>:*</code> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> element
             <em>Prefix</em><sub><font size="2">1</font></sub><code>:</code><em>LocalPart</em><sub><font size="2">2</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             
           
          </td></tr>
         </table><br/>
     </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>QName</em><sub><font size="2">2</font></sub> <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href="#jd_test_type" class="judgment"><b>:</b></a>
             element <em>QName</em><sub><font size="2">2</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>
           
             
            </td></tr>
            <tr valign="middle" align="center"><td>
           <code>fn:namespace-uri-from-QName</code>( <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub> ) = <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em><sub><font size="2">1</font></sub>)
            </td></tr>
            <tr valign="middle" align="center"><td>
           <em>LocalPart</em><sub><font size="2">2</font></sub> = <code>fn:local-name-from-QName</code>( <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub> )
            </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> element
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><div align="center">
     <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td>
           <em>LocalPart</em><sub><font size="2">1</font></sub> = <em>LocalPart</em><sub><font size="2">2</font></sub>
          </td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <code>*:</code><em>LocalPart</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> element
             <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary=""> 
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <em>Prefix</em><sub><font size="2">1</font></sub><code>:*</code> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> element
             <em>Prefix</em><sub><font size="2">1</font></sub><code>:</code><em>LocalPart</em><sub><font size="2">2</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> element
             <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>

         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>
           
             
            </td></tr>
            <tr valign="middle" align="center"><td>
           <code>fn:namespace-uri-from-QName</code>( <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>) = <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em><sub><font size="2">2</font></sub>)
            </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size="2">2</font></sub>:*
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> element
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size="2">2</font></sub><code>:*</code>
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <code>*:</code><em>LocalPart</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> element
             <em>Prefix</em><sub><font size="2">2</font></sub><code>:</code><em>LocalPart</em><sub><font size="2">1</font></sub>
             <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td>
           <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em><sub><font size="2">1</font></sub>) = <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em><sub><font size="2">2</font></sub>)
          </td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size="2">2</font></sub><code>:*</code>
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <em>Prefix</em><sub><font size="2">1</font></sub><code>:*</code> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
             <a href="#jd_test_type" class="judgment"><b>:</b></a> element
             <em>Prefix</em><sub><font size="2">1</font></sub><code>:*</code> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size="2">2</font></sub><code>:*</code>
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href="#jd_test_type" class="judgment"><b>:</b></a>
             element <em>Prefix</em><sub><font size="2">2</font></sub><code>:*</code> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><div align="center">
         <table cellpadding="0" cellspacing="0" summary="">
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
           
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            
             <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*</code>
             <a href="#jd_test_type" class="judgment"><b>with</b></a> element
             <a href="#jd_test_type" class="judgment"><b>of</b></a> element
             <em>QName</em> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a> <a href="#jd_test_type" class="judgment"><b>:</b></a>
             element <em>QName</em> <a href="#doc-fs-OptTypeSpecifier"><em>OptTypeSpecifier</em></a>
            
           
          </td></tr>
         </table><br/>
     </div><p>Similar typing rules apply to the attribute name tests:</p><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
         
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
         
        </td></tr>
        <tr valign="middle" align="center"><td>
         
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">2</font></sub> <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
         
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>QName</em><sub><font size="2">2</font></sub>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
          <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
         
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">2</font></sub> <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>
           
         
        </td></tr>
        <tr valign="middle" align="center"><td>
         <code>fn:local-name-from-QName</code>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>) = <em>LocalPart</em><sub><font size="2">1</font></sub>
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>QName</em><sub><font size="2">2</font></sub>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
          <code>*:</code><em>LocalPart</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>QName</em><sub><font size="2">2</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
         
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">2</font></sub> <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>
           
         
        </td></tr>
        <tr valign="middle" align="center"><td>
         <code>fn:namespace-uri-from-QName</code>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">2</font></sub>) = <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em><sub><font size="2">1</font></sub>)
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>QName</em><sub><font size="2">2</font></sub>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
          <em>Prefix</em><sub><font size="2">1</font></sub><code>:*</code> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>Prefix</em><sub><font size="2">1</font></sub><code>:</code><em>LocalPart</em><sub><font size="2">2</font></sub><a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>QName</em><sub><font size="2">2</font></sub>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>QName</em><sub><font size="2">2</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
         
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <em>QName</em><sub><font size="2">1</font></sub> <a href="#jd_attr_qname_expands_to" class="judgment"><b>of attr expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>
           
         
        </td></tr>
        <tr valign="middle" align="center"><td>
        <code>fn:local-name-from-QName</code>( <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub> ) = <em>LocalPart</em><sub><font size="2">2</font></sub>
        </td></tr>
       </table></td></tr></table></td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
          <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        <em>LocalPart</em><sub><font size="2">1</font></sub> = <em>LocalPart</em><sub><font size="2">2</font></sub>
       </td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
          <code>*:</code><em>LocalPart</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary=""> 
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
          <em>Prefix</em><sub><font size="2">1</font></sub>:* <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>Prefix</em><sub><font size="2">1</font></sub>:<em>LocalPart</em><sub><font size="2">2</font></sub><a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <code>*:</code><em>LocalPart</em><sub><font size="2">2</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        <code>fn:namespace-uri-from-QName</code>( <em>QName</em><sub><font size="2">1</font></sub>) = <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em><sub><font size="2">2</font></sub>)
       </td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size="2">2</font></sub><code>:*</code>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
          <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>QName</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size="2">2</font></sub><code>:*</code>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
          <code>*:</code><em>LocalPart</em><sub><font size="2">1</font></sub> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>Prefix</em><sub><font size="2">2</font></sub><code>:</code><em>LocalPart</em><sub><font size="2">1</font></sub>
          <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em><sub><font size="2">1</font></sub>) = <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em><sub><font size="2">2</font></sub>)
       </td></tr>
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size="2">2</font></sub><code>:*</code>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute
          <em>Prefix</em><sub><font size="2">1</font></sub><code>:*</code> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>Prefix</em><sub><font size="2">1</font></sub><code>:*</code> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>Prefix</em><sub><font size="2">2</font></sub><code>:*</code>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute
          <em>Prefix</em><sub><font size="2">2</font></sub><code>:*</code> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>*</code> <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
          <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute <em>QName</em> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
          <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute <em>QName</em> <a href="#doc-fs-OptTypeReference"><em>OptTypeReference</em></a>
         
        
       </td></tr>
      </table><br/>
     </div><p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p><div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>NameTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
               <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub>)
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub>
               <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub>)
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
               
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>NameTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub>
               <a href="#jd_test_type" class="judgment"><b>:</b></a> empty
              
             
            </td></tr>
           </table><br/>
          </div></div><div class="div5">
<h6><a id="sec_sem_kind_tests" name="sec_sem_kind_tests"/>8.2.3.1.2 Kind Tests</h6><p>All the rules for typing the document, element, and attribute
    kind tests are similar.  First, the document, element, or
    attribute test is normalized to the equivalent document, element,
    or attribute type by applying the <font size="6">[</font><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
    normalization rule to the kind test.</p><p>After normalization of the kind test as an XQuery type, that
    type is compared to the expression's inferred type. If the latter
    is a subtype of the former other, then the kind test yields the
    smaller type.</p><p>Document kind test</p><p><b>Semantics</b></p>
      <p>If the type of the expression is a subtype of the document
      kind test, then we are guaranteed that during evaluation, the
      expression's value will always match the document kind test, and
      therefore the type of the entire expression is the type of the
      input expression.</p>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <font size="6">[</font><em>DocumentTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
            = <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>
          
         </td></tr>
         <tr valign="middle" align="center"><td>
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>
          
         </td></tr>
        </table></td></tr></table></td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          
           <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>DocumentTest</em>
           <a href="#jd_test_type" class="judgment"><b>with</b></a> element
           <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
           <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
          
         
        </td></tr>
       </table><br/>
      </div>

      <p>Conversely, if the type of the document kind test is a
      subtype of the expression, then during evaluation, the
      expression's value may or may not match the document kind test,
      and therefore the type of the entire expression is zero-or-one
      of the type of the document kind test. </p>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <font size="6">[</font><em>DocumentTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
            = <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>
          
         </td></tr>
         <tr valign="middle" align="center"><td>
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <a href="#doc-fs-DocumentType"><em>DocumentType</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
          
         </td></tr>
        </table></td></tr></table></td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
         <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          
           <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>DocumentTest</em>
           <a href="#jd_test_type" class="judgment"><b>with</b></a> element
           <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
           <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>?
          
         
        </td></tr>
       </table><br/>
      </div>

      <p>If the types of the expression and document kind test are
      unrelated, then we apply the kind test rule recursively on the
      element types, which may yield a non-empty type.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font>document-node (<em>ElementTest</em>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-DocumentType"><em>DocumentType</em></a> <b>or</b> <a href="#doc-fs-DocumentType"><em>DocumentType</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
              
             </td></tr>

             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>ElementTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test" class="judgment"><b>of</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
               <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
               
                  
              
               
                <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> empty)
               
              
             </td></tr>

            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> document-node (<em>ElementTest</em>)
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test" class="judgment"><b>of</b></a> document { <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> }
               <a href="#jd_test_type" class="judgment"><b>:</b></a> document { <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> }
              
             
            </td></tr>
           </table><br/>
          </div>

          <p>If there is no non-empty type, then the kind test yields
          the empty type.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font>document-node (<em>ElementTest</em>)<font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-DocumentType"><em>DocumentType</em></a> or <a href="#doc-fs-DocumentType"><em>DocumentType</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
              
             </td></tr>

             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>ElementTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test" class="judgment"><b>of</b></a>  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
               <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
               
                  
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> empty
             </td></tr>

            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> document-node (<em>ElementTest</em>)
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test" class="judgment"><b>of</b></a> document { <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> }
               <a href="#jd_test_type" class="judgment"><b>:</b></a> empty
              
             
            </td></tr>
           </table><br/>
          </div>
        <p>Element kind test</p><p><b>Semantics</b></p>
     <p>The rules for the element kind test are similar to those for
     the document kind test.</p> <p>If the type of the expression is a
     subtype of the element kind test, then we are guaranteed that
     during evaluation, the expression's element value will always
     match the element kind test, and therefore the type of the entire
     expression is the type of the input expression.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>ElementTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-ElementType"><em>ElementType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>ElementTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
               <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
              
             
            </td></tr>
           </table><br/>
          </div>

<p>Conversely, if the type of the element kind test is a subtype of
the expression, then during evaluation, the expression's element value
may or may not match the element kind test, and therefore the type of
the entire expression is zero-or-one of the type of the element kind
test. </p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>ElementTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-ElementType"><em>ElementType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>ElementTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
               <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a>?
              
             
            </td></tr>
           </table><br/>
          </div>

          <p>If the types of the expression and element kind test are
          unrelated (i.e., neither type is a subtype of the other),
          then we must compare the structure of the type of the
          element test with the type of the element expression, as an
          element type or test may contain wildcards.</p>

          <p>In the first case, the element kind test contains an
          element name and a type name and the input expression's type
          contains only a type name.  If the input expression's
          content type is a subtype of the element kind test's content
          type, then the type of the entire expression is zero-or-one
          of an element with the given name and the input expression's
          content type.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>ElementTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = element <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub>
                  
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>ElementTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test_type" class="judgment"><b>of</b></a> element <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub>
               <a href="#jd_test_type" class="judgment"><b>:</b></a> element <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub>
               <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub>? 
              
             
            </td></tr>
           </table><br/>
          </div>

<p>In the second case, the structure of the input types is reversed: 
The input expression's type contains an element name
and a type name and the element kind test's type contains only a type
name.  If the element kind test's content type is a subtype of the
input expression's content type, then the type of the entire
expression is zero-or-one of an element with the given name and the
element kind test's content type.</p>
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>ElementTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = element <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub>
                  
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>ElementTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test_type" class="judgment"><b>of</b></a> element <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub>
               <a href="#jd_test_type" class="judgment"><b>:</b></a> element <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">2</font></sub>
               <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub>? 
              
             
            </td></tr>
           </table><br/>
          </div>

          <p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>ElementTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub>
               <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub>)

              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub>
               <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">1</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub>)

              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">1</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)

              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)

              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>ElementTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> element
               <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a><sub><font size="2">2</font></sub> <a href="#doc-fs-TypeSpecifier"><em>TypeSpecifier</em></a><sub><font size="2">2</font></sub>
               <a href="#jd_test_type" class="judgment"><b>:</b></a> empty
              
             
            </td></tr>
           </table><br/>
          </div>
        <p>Attribute kind test</p><p><b>Semantics</b></p>
     <p>The rules for the attribute kind test are isomorphic to those
     for element kind test.</p> <p>If the type of the expression is a
     subtype of the attribute kind test, then we are guaranteed that
     during evaluation, the expression's attribute value will always
     match the attribute kind test, and therefore the type of the
     entire expression is the type of the input expression.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>AttributeTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>AttributeTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
               <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
               <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
              
             
            </td></tr>
           </table><br/>
          </div>

<p>Conversely, if the type of the attribute kind test is a subtype of the expression, then
during evaluation, the expression's attribute value may or may not 
match the attribute kind test, and therefore the type of the entire expression
is zero-or-one of the type of the attribute kind test. </p>
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>AttributeTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>AttributeTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
               <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
               <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>?
              
             
            </td></tr>
           </table><br/>
          </div>

          <p>If the types of the expression and attribute kind test
          are unrelated (i.e., neither type is a subtype of the
          other), then we must compare the structure of the type of
          the attribute test with the type of the attribute
          expression, as an attribute type or test may contain
          wildcards.</p>

          <p>In the first case, the attribute kind test contains an
          attribute name and a type name and the input expression's
          type contains only a type name.  If the input expression's
          content type is a subtype of the attribute kind test's
          content type, then the type of the entire expression is
          zero-or-one of an attribute with the given name and the
          input expression's content type.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>AttributeTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a><sub><font size="2">1</font></sub> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">1</font></sub>
                  
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">1</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">2</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>AttributeTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
               <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">2</font></sub>
               <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a><sub><font size="2">1</font></sub>
               <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">2</font></sub>? 
              
             
            </td></tr>
           </table><br/>
          </div>

<p>In the second case, the structure of the input types is reversed: 
The input expression's type contains an attribute name
and a type name and the attribute kind test's type contains only a type
name.  If the attribute kind test's content type is a subtype of the
input expression's content type, then the type of the entire
expression is zero-or-one of an attribute with the given name and the
attribute kind test's content type.</p>
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>AttributeTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = attribute <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">1</font></sub>
                  
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">1</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">2</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>AttributeTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
               <a href="#jd_test_type" class="judgment"><b>of</b></a> attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a><sub><font size="2">2</font></sub> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">2</font></sub>
               <a href="#jd_test_type" class="judgment"><b>:</b></a> attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a><sub><font size="2">2</font></sub>
               <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">1</font></sub>? 
              
             
            </td></tr>
           </table><br/>
          </div>

          <p>Lastly, if none of the above rules holds, then the type
          of the input expression is empty.</p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>AttributeTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">1</font></sub> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">1</font></sub>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">1</font></sub>
               <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">2</font></sub> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">2</font></sub>)
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">2</font></sub>
               <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">1</font></sub> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">1</font></sub>)
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">1</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">2</font></sub> <a href="#jd_expands_to" class="judgment"><b>expands to</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> 
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
               <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>)
               
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
               <a href="#jd_test_type" class="judgment"><b>test</b></a> <em>AttributeTest</em>
               <a href="#jd_test_type" class="judgment"><b>with</b></a> attribute
               <a href="#jd_test_type" class="judgment"><b>of</b></a> <a href="#doc-fs-AttributeNameOrWildcard"><em>AttributeName</em></a><sub><font size="2">2</font></sub> <a href="#doc-fs-TypeReference"><em>TypeReference</em></a><sub><font size="2">2</font></sub>
               <a href="#jd_test_type" class="judgment"><b>:</b></a> empty
              
             
            </td></tr>
           </table><br/>
          </div>
        <p>Processing instruction, comment, and text kind tests.</p><p><b>Semantics</b></p>
     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> 
          <code>processing-instruction()</code>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
          <a href="#jd_test_type" class="judgment"><b>of</b></a> processing-instruction
          <a href="#jd_test_type" class="judgment"><b>:</b></a> processing-instruction
         
        
       </td></tr>
      </table><br/>
     </div>

     <p>A processing-instruction node test with a string
     literal or NCName matches a processing instruction whose target
     has the given name.  Since target matching cannot be checked
     statically, the static type of the node test is zero-or-one
     processing instruction.</p>
     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a>
          <code>processing-instruction(</code><em>StringLiteral</em> | <em>NCName</em><code>)</code>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
          <a href="#jd_test_type" class="judgment"><b>of</b></a> processing-instruction
          <a href="#jd_test_type" class="judgment"><b>:</b></a> processing-instruction?
         
        
       </td></tr>
      </table><br/>
     </div>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>comment()</code>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
          <a href="#jd_test_type" class="judgment"><b>of</b></a> comment <a href="#jd_test_type" class="judgment"><b>:</b></a>
          comment
         
        
       </td></tr>
      </table><br/>
     </div>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>text()</code>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
          <a href="#jd_test_type" class="judgment"><b>of</b></a> text <a href="#jd_test_type" class="judgment"><b>:</b></a> text
         
        
       </td></tr>
      </table><br/>
     </div>

     <div align="center">
      <table cellpadding="0" cellspacing="0" summary="">
       <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
          <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>node()</code>
          <a href="#jd_test_type" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
          <a href="#jd_test_type" class="judgment"><b>of</b></a>
          <a href="#doc-fs-NodeType"><em>NodeType</em></a> <a href="#jd_test_type" class="judgment"><b>:</b></a> <a href="#doc-fs-NodeType"><em>NodeType</em></a>
         
        
       </td></tr>
      </table><br/>
     </div>

     <p>If none of the above rules apply, then the node test returns
     the empty sequence and the following rule applies:</p>
     
     <div align="center">
       <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
         
       <a href="#jd_test_type" class="judgment"><b>test</b></a> <code>node()</code>
       <a href="#jd_test_type" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
       <a href="#jd_test_type" class="judgment"><b>of</b></a>
       <a href="#doc-fs-NodeType"><em>NodeType</em></a> <a href="#jd_test_type" class="judgment"><b>:</b></a> <code>empty</code>
         
       
     </div>
     </div></div><div class="div4">
<h5><a id="sec_dyn_node_tests" name="sec_dyn_node_tests"/>8.2.3.2 Dynamic semantics of node tests</h5><p><b>Notation</b></p>
        <p id="jd_test">The following judgment</p>
        <div align="center">
         
          <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
          
           <a href="#jd_test" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test" class="judgment"><b>with</b></a>
           <em>PrincipalNodeKind</em> <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
          
         
        </div>
     
        <p>holds when applying the node test <em>NodeTest</em> on
        <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> in the context of the <em>PrincipalNodeKind</em>
        yields <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>:</p>
      <p><b>Example</b></p>
        <p>For example, the following judgments hold.</p>

<div class="exampleInner"><pre>
  test node()  with element  of    text { "1 2 3" }  =&gt; text { "1 2 3" }
  test size    with element  of    text { "1 2 3" }  =&gt; ()

  test foo:*   with element  of
     (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      element bar:b of type xs:int { 3 },
      element bar:c of type xs:int { 4 },
      element foo:d of type xs:int { 5 })
  =&gt; (element foo:a of type xs:int { 1 },
      element foo:a of type xs:int { 2 },
      (),
      (),
      element foo:d of type xs:int { 5 })
</pre></div>
      <p><b>Note</b></p>
        <p>The last example illustrates how a test judgment operates
        on a sequence of nodes, applying the test on each node in the
        sequence individually, while preserving the structure of the
        sequence.</p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>The first set of rules are similar to those for axes, and
        are used to process the test judgment on each individual item
        in the input sequence.</p>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test" class="judgment"><b>with</b></a>
             <em>PrincipalNodeKind</em> <a href="#jd_test" class="judgment"><b>of</b></a> () <a href="#jd_test" class="judgment"><b>=&gt;</b></a> ()
              
             
            </td></tr>
           </table><br/>
          </div>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
               
                <a href="#jd_test" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test" class="judgment"><b>with</b></a>
             <em>PrincipalNodeKind</em> <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
               
                <a href="#jd_test" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test" class="judgment"><b>with</b></a>
             <em>PrincipalNodeKind</em> <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">4</font></sub>
               
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
             <a href="#jd_test" class="judgment"><b>test</b></a> <em>NodeTest</em> <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
             <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_test" class="judgment"><b>=&gt;</b></a>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">4</font></sub>
              
             
            </td></tr>
           </table><br/>
          </div>
        <div class="div5">
<h6><a id="sec_dyn_sem_name_tests" name="sec_dyn_sem_name_tests"/>8.2.3.2.1 Name Tests</h6><p>The following rules specify how the value filter
          judgment is applied on a name test in the context of a
          principal node kind.</p><p><b>Semantics</b></p>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <em>dm:</em><code>node-kind</code>( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <em>PrincipalNodeKind</em>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               <code>fn:node-name</code>( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               
                <code>fn:namespace-uri-from-QName</code>( <a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em>)
               
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               <code>fn:local-name-from-QName</code>( <a href="#id-expanded-qnames"><em>expanded-QName</em></a> ) = <em>LocalPart</em>
               
              
             </td></tr>

            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <em>Prefix</em>:<em>LocalPart</em>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <em>dm:</em><code>node-kind</code>( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <em>PrincipalNodeKind</em>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>*</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
               <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <em>dm:</em><code>node-kind</code>( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <em>PrincipalNodeKind</em>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               <code>fn:node-name</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               <code>fn:namespace-uri-from-QName</code> ( <em>QName</em> ) = <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_ns_env" class="env">namespace</a>(<em>Prefix</em>) 
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <em>Prefix</em><code>:*</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <em>dm:</em><code>node-kind</code>( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <em>PrincipalNodeKind</em>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               <code>fn:node-name</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               <code>fn:local-name-from-QName</code> ( <a href="#id-expanded-qnames"><em>expanded-QName</em></a> ) = local 
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>*:</code><em>LocalPart</em>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>
        </div><div class="div5">
<h6><a id="sec_dyn_kind_tests" name="sec_dyn_kind_tests"/>8.2.3.2.2 Kind Tests</h6><p>All the rules for evaluating the document, element, and attribute kind
tests are similar.  First, the document, element, or attribute test is
normalized to the equivalent document, element, or attribute type by
applying the <font size="6">[</font><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a> normalization rule.
As explained in <a href="#id-sequencetype"><b>[3.5.3 SequenceType Syntax]</b></a>,
SequenceTypes are normalized to XQuery types whenever a dynamic or static rule
requires the corresponding type. The reason for this deviation from the
processing model is that the result of SequenceType
normalization is not part of the [XPath/XQuery] core syntax.  
</p><p>
After normalization of the SequenceType to an XQuery type, the
document, element, or attribute value is simply matched against the
XQuery type.   If the value matches the type, then the judgment yields
the value, otherwise the judgment yields the empty sequence.
</p><p>Document kind test</p><p><b>Semantics</b></p>
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>DocumentTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#doc-fs-DocumentValue"><em>DocumentValue</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <em>DocumentTest</em>
               <a href="#jd_test" class="judgment"><b>with</b></a> element
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-DocumentValue"><em>DocumentValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-DocumentValue"><em>DocumentValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>DocumentTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-DocumentValue"><em>DocumentValue</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-DocumentType"><em>DocumentType</em></a>)
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <em>DocumentTest</em>
               <a href="#jd_test" class="judgment"><b>with</b></a> element
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-DocumentValue"><em>DocumentValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> ()
              
             
            </td></tr>
           </table><br/>
          </div>
        <p>Element kind test</p><p><b>Semantics</b></p>
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>ElementTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-ElementType"><em>ElementType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#doc-fs-ElementValue"><em>ElementValue</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <em>ElementTest</em>
               <a href="#jd_test" class="judgment"><b>with</b></a> element
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-ElementValue"><em>ElementValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-ElementValue"><em>ElementValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>ElementTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-ElementType"><em>ElementType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-ElementValue"><em>ElementValue</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a>)
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <em>ElementTest</em>
               <a href="#jd_test" class="judgment"><b>with</b></a> element
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-ElementValue"><em>ElementValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> ()
              
             
            </td></tr>
           </table><br/>
          </div>
        <p>Attribute kind test</p><p><b>Semantics</b></p>
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>AttributeTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <em>AttributeTest</em>
               <a href="#jd_test" class="judgment"><b>with</b></a> attribute
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <font size="6">[</font><em>AttributeTest</em><font size="6">]</font><a href="#jd_map_sequencetype" class="judgment"><sub><font size="2">sequencetype</font></sub></a>
                = <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_not" class="judgment"><b>not</b></a>(<a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>)
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <em>AttributeTest</em>
               <a href="#jd_test" class="judgment"><b>with</b></a> attribute
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-AttributeValue"><em>AttributeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> ()
              
             
            </td></tr>
           </table><br/>
          </div>
        <p>Processing instruction, comment, and text kind tests.</p><p><b>Semantics</b></p>
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <em>dm:</em><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "processing-instruction"
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>processing-instruction()</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <em>dm:</em><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "processing-instruction"
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               <code>fn:node-name</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
              
             </td></tr>
             <tr valign="middle" align="center"><td>
              
               <code>fn:local-name-from-QName</code> ( <a href="#id-expanded-qnames"><em>expanded-QName</em></a> ) = <em>String</em>
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>processing-instruction(</code> <em>StringLiteral</em> <code>)</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>

          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <a href="#jd_not" class="judgment"><b>not</b></a>(<em>dm:</em><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "processing-instruction")
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>processing-instruction()</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> ()
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <em>dm:</em><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "comment"
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>comment()</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <a href="#jd_not" class="judgment"><b>not</b></a>(<em>dm:</em><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "comment")
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>comment()</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> ()
              
             
            </td></tr>
           </table><br/>
          </div>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <em>dm:</em><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "text"
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>text()</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
              
               <a href="#jd_not" class="judgment"><b>not</b></a>(<em>dm:</em><code>node-kind</code> ( <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> ) = "text")
              
             </td></tr>
            </table></td></tr></table></td></tr>
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>text()</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> ()
              
             
            </td></tr>
           </table><br/>
          </div>

          <p>The <code>node()</code> node test is true for all
          nodes. Therefore, the following rule does not have any
          precondition (remember that an empty upper part in the rule
          indicates that the rule is always true).</p>
     
          <div align="center">
           <table cellpadding="0" cellspacing="0" summary="">
            <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
             <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              
               <a href="#jd_test" class="judgment"><b>test</b></a> <code>node()</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
               <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a>
              
             
            </td></tr>
           </table><br/>
          </div>

          <p>If none of the above rules applies then the node test
          returns the empty sequence, and the following dynamic rule
          is applied:</p>
          
          <div align="center">
           <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
            
             <a href="#jd_test" class="judgment"><b>test</b></a> <code>node()</code>
               <a href="#jd_test" class="judgment"><b>with</b></a> <em>PrincipalNodeKind</em>
             <a href="#jd_test" class="judgment"><b>of</b></a> <a href="#doc-fs-NodeValue"><em>NodeValue</em></a> <a href="#jd_test" class="judgment"><b>=&gt;</b></a> ()
            
           
          </div>
        </div></div></div></div><div class="div2">
<h3><a id="sec_type_matching" name="sec_type_matching"/>8.3 Judgments for type matching</h3><p><b>Introduction</b></p>
      <p>XQuery supports type declarations on variable bindings, and
      several operations on types (<code>typeswitch</code>,
      <code>instance of</code>, etc). This section describes judgments
      used for the specification of the semantics of those
      operations.</p>

      <ul><li><p>The "match" judgment specifies formally type
          matching. It takes as input a value and a type and either
          succeeds or fails. It is used in matching parameters against
          function signatures, type declarations, and matching values
          against cases in "typeswitch". An informal
          description of type matching is given in <a href="http://www.w3.org/TR/xquery#id-sequencetype-matching">Section 
2.5.4 SequenceType Matching</a><sup><small>XQ</small></sup>.</p></li><li><p>The "subtyping" judgment takes two types and
          succeeds if all values matching the first type also match
          the second. It is used to define the static semantics of
          operations using type matching.</p></li></ul>
  
    <div class="div3">
<h4><a id="sec_matches" name="sec_matches"/>8.3.1 Matches</h4><p><b>Notation</b></p>
        <p id="jd_matches">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
          
        </div>

        <p>holds when the given value matches the given type.</p>
      <p><b>Example</b></p>
        <p>For example, assuming the extended XML Schema given in
        section <a href="#sec_types_example"><b>[2.4.5 Example of a complete Schema]</b></a>, then the following
        judgments hold.</p>

<div class="exampleInner"><pre>
  element comment of type xsd:string { "This is not important" }
    matches
  element comment of type xsd:string

  (element apt of type fs:anon3 { 2510 },
   element apt of type fs:anon3 { 2511 })
    matches
  element apt+

  ()
    matches
  element usaddress?

  element usaddress of type USAddress {
    element name of type xsd:string { "The Archive" },
    element street of type xsd:string { "Christopher Street" },
    element city of type xsd:string { "New York" },
    element state of type xsd:string { "NY" },
    element zip of type xsd:decimal { 10210 }
  }
    matches
  element usaddress?
</pre></div>
      <p><b>Semantics</b></p>

       <p>We start by giving the inference rules for matching an
        item value with an item type.</p>

        <p>An atomic value matches an atomic type if its <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup> derives from the atomic
        type.  The value itself is ignored -- this is checked as part
        of validation.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a>
              <a href="#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub>
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a> of type <a href="#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <p>A text node matches text.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             text { <em>String</em> } <a href="#jd_matches" class="judgment"><b>matches</b></a> text
            
           </td></tr>
          </table><br/>
        </div>

        <p>A comment node matches comment.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             comment { <em>String</em> } <a href="#jd_matches" class="judgment"><b>matches</b></a> comment
            
           </td></tr>
          </table><br/>
        </div>

        <p>A processing-instruction node matches processing-instruction.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             processing-instruction <em>QName</em> { <em>String</em> } <a href="#jd_matches" class="judgment"><b>matches</b></a> processing-instruction
            
           </td></tr>
          </table><br/>
        </div>

        <p>A document node matches a document type if the node's content matches the document
        type's corresponding content type.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
             
            
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             document { <a href="#doc-fs-Value"><em>Value</em></a> } <a href="#jd_matches" class="judgment"><b>matches</b></a> document { <a href="#doc-fs-Type"><em>Type</em></a> }
            
           </td></tr>
          </table><br/>
        </div>

        <p>The rules for matching an element value with an element
        type are more complicated.  When an element value is not
        nilled, the element matches an element type if the element
        name and the element type resolve to some type name, and the
        element value's <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup>
        is derived from the resolved type name.  Note that there is no
        need to check structural constraints on the value since those
        have been checked during XML Schema validation and the value
        is assumed to be consistent with its <a href="http://www.w3.org/TR/xquery#dt-type-annotation">type annotation</a><sup><small>XQ</small></sup>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup" class="judgment"><b>name lookup</b></a>
              <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup" class="judgment"><b>yields</b></a> <a href="#doc-fs-OptNillable"><em>OptNillable</em></a> of
              type <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a>
              <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter" class="judgment"><b>filter</b></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> () <a href="#jd_filter" class="judgment"><b>or</b></a> false
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             element <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Value"><em>Value</em></a> } <a href="#jd_matches" class="judgment"><b>matches</b></a>
             <a href="#doc-fs-ElementType"><em>ElementType</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p><b>Note</b></p>
          <p>Type matching uses the name lookup judgment defined in
          <a href="#sec_element_lookup"><b>[8.1.3 Element and attribute name lookup (Dynamic)]</b></a>.</p>
        

        <p>In the case the element has been nilled, that is there
exists and xsi:nil attribute set to true in the element value, the
following rule checks that the type is nillable. </p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup" class="judgment"><b>name lookup</b></a>
              <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup" class="judgment"><b>yields</b></a> nillable of type
              <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a>
              <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter" class="judgment"><b>filter</b></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> true
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             element <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Value"><em>Value</em></a> } <a href="#jd_matches" class="judgment"><b>matches</b></a>
             <a href="#doc-fs-ElementType"><em>ElementType</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>The rule for attributes is similar, but does not require
        the check for the xsi:nil attribute.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
              <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>yields</b></a> of type
              <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_derives_from" class="judgment"><b>derives from</b></a>
              <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> of type
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Value"><em>Value</em></a> } <a href="#jd_matches" class="judgment"><b>matches</b></a>
             <a href="#doc-fs-AttributeType"><em>AttributeType</em></a>
            
           </td></tr>
          </table><br/>
        </div>

        <p>A type can also be a sequence of items, in that case the
        matching rules also need to check whether the constraints
        described by the type as a regular expression hold. This is
        specified by the following rules.</p>

        <p>The empty sequence matches the empty sequence type.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             () <a href="#jd_matches" class="judgment"><b>matches</b></a> <code>empty</code>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If two values match two types, then their sequence matches
        the corresponding sequence type.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If a value matches a type, then it also matches a choice
        type where that type is one of the choices.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If two values match two types, then their interleaving
        matches the corresponding all group.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a>
              <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_interleave" class="judgment"><b>interleave</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_interleave" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> &amp;
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <p>An optional type matches a value of that type or the empty
        sequence.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a>
              (<a href="#doc-fs-Type"><em>Type</em></a> | empty)
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>?
            
           </td></tr>
          </table><br/>
        </div>

        <p>The following rules are used to match a value against a
        sequence of zero (or one) or more types.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             () <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>*
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                 
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>*
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>*
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
                 
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>*
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>, <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>+
            
           </td></tr>
          </table><br/>
        </div>

      <p><b>Note</b></p>
        <p>The above definition of type matching, although complete
        and precise, does not give a simple means to
        <em>compute</em> type matching. Notably, some of the above
        rules can be non-deterministic (e.g., the rule for matching of
        choice or repetition).</p>

        <p>The structural component of the [XPath/XQuery] type system can
        be modeled by regular expressions. Regular expressions can be
        implemented by means of finite state automata. Computing type
        matching then is equivalent to check if a given sequence of
        items is <em>recognized</em> by its corresponding finite
        state automata. Finite state automata and their relationships
        to regular expressions have been extensively studied and
        documented in computer-science literature. The interested reader can
        consult the relevant literature, for instance <a href="#Languages">[Languages]</a>, or <a href="#TATA">[TATA]</a>.</p>
      </div><div class="div3">
<h4><a id="sec_subtyping" name="sec_subtyping"/>8.3.2 Subtype and Type equality</h4><p><b>Introduction</b></p>
        <p>This section defines the semantics of subtyping in
        [XPath/XQuery]. Subtyping is used during the static type analysis,
        in typeswitch expressions, treat and assert expressions, and
        to check the correctness of function applications.</p>

        <p>Note that intuitive relationships between types. For
        instance, that (<a href="#doc-fs-Type"><em>Type</em></a>,()) is equivalent to <a href="#doc-fs-Type"><em>Type</em></a> can
        be deduced using the subtyping judgment (and algorithm)
        described here.</p>
      <p><b>Notation</b></p>
        <p id="jd_subtype_of">The judgment</p>
      
        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
          
        </div>
      
        <p>holds if the first type is a subtype of the second.</p>
      <p><b>Semantics</b></p>
        <p>This judgment is true if and only if, for every value
        <a href="#doc-fs-Value"><em>Value</em></a>, if <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> holds, then
        <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> also holds.</p>
      <p><b>Note</b></p>
        <p>It is easy to see that the subtype relation <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a>
        is a partial order, i.e. it is <b>reflexive</b>:</p>
  
        
           <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          
            <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
          
            
  
        <p>and it is <b>transitive</b>: if,</p>
  
         <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          
            <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
          
            
  
        <p>and,</p>
  
         <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          
            <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
          
            
  
        <p>then,</p>
  
         <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          
            <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
          
            

        <p>Finally, two types are equal if each is a subtype of the
        other, that is: </p>
         <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          
            <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
          
            
  
        <p>and,</p>
  
         <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          
            <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
          
            
  
        <p>then,</p>
  
         <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
          
            <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> = <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
          
        

      <p><b>Note</b></p>
        <p>The above definition although complete and precise, does
        not give a simple means to <em>compute</em>
        subtyping. Notably the definition above refers to values which
        are not available at static type checking time.</p>

        <p>The structural component of the [XPath/XQuery] type system can
        be modeled by regular expressions. Regular expressions can be
        implemented by means of finite state automata. Computing
        subtyping between two types can then be done by computing if
        <em>inclusion</em> holds between their corresponding
        finite states automata.</p>
    
        <p>Finite state automata and how to compute operations on
        those automata, such as inclusion, emptiness or intersection
        have been extensively studied and documented in the
        literature. The interested reader can consult the relevant
        literature on tree grammars, for instance <a href="#Languages">[Languages]</a>, or <a href="#TATA">[TATA]</a>.</p>
      </div></div><div class="div2">
<h3><a id="sec_factor" name="sec_factor"/>8.4 Judgments for FLWOR and other expressions on sequences</h3><p><b>Introduction</b></p>
      <p>Some [XPath/XQuery] operations work on sequences of items. For
      instance, [For/FLWOR] expressions iterate over a sequence of
      items and the <code>fn:unordered</code> function can return all items in a
      sequence in any order, etc.</p>

      <p>Static typing for those operations need to infer a type
      acceptable for <em>all</em> the items in the sequence. This
      sometimes require to approximate the type known for each item
      individually.</p>

    <p><b>Example</b></p>

      <p>Assume the variable <code>$shipTo</code> is bound to the
      shipTo element</p>

<div class="exampleInner"><pre>
    &lt;shipTo country="US"&gt;
        &lt;name&gt;Alice Smith&lt;/name&gt;
        &lt;street&gt;123 Maple Street&lt;/street&gt;
        &lt;city&gt;Mill Valley&lt;/city&gt;
        &lt;state&gt;CA&lt;/state&gt;
        &lt;zip&gt;90952&lt;/zip&gt;
    &lt;/shipTo&gt;
</pre></div>

      <p>and has type</p>

<div class="exampleInner"><pre>
   element shipTo of type USAddress
</pre></div>

      <p>The following query orders all children of the shipTo element
      by alphabetical order of their content.</p>

<div class="exampleInner"><pre>
   for $x in $shipTo/*
   order by $x/text()
   return $x
</pre></div>

      <p>resulting in the sequence</p>

<div class="exampleInner"><pre>
    (&lt;street&gt;123 Maple Street&lt;/street&gt;,
     &lt;zip&gt;90952&lt;/zip&gt;,
     &lt;name&gt;Alice Smith&lt;/name&gt;,
     &lt;state&gt;CA&lt;/state&gt;,
     &lt;city&gt;Mill Valley&lt;/city&gt;)
</pre></div>

      <p>This operation iterates over the elements in the input
      sequence returned by the expression <code>$shipTo/*</code>,
      whose type is the content of a type USAddress.</p>

<div class="exampleInner"><pre>
    (element name of type xsd:string,
     element street of type xsd:string,
     element city of type xsd:string,
     element state of type xsd:string,
     element zip of type xsd:decimal)
</pre></div>

      <p>During static typing, one must give a type to the variable
      <code>$x</code> which corresponds to the type of each element in
      the sequence. Since each item as a of a different type, one must
      find an item type which is valid for all cases in the
      sequence. This can be done by using a choice for the variable
      <code>$x</code>, as follows</p>

<div class="exampleInner"><pre>
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)
</pre></div>

      <p>This type indicates that the type of the variable can be of
      any of the item types in the input sequence.</p>

      <p>The static inference also needs to approximate the number of
      occurrence of items in the sequence. In this example, there is
      at least one item and more than one, so the closest occurrence
      indicator is <code>+</code> for one or more items.</p>

      <p>The static inference for this example finally results in the
      following type.</p>

<div class="exampleInner"><pre>
    (element name of type xsd:string |
     element street of type xsd:string |
     element city of type xsd:string |
     element state of type xsd:string |
     element zip of type xsd:decimal)+
</pre></div>

      <p>This section defines a <em>prime type</em>, which is a
      choice of item types. It defines two functions on types that
      compute the prime type of an arbitrary type, and approximate the
      occurrence of items in an arbitrary type.  Those judgments are
      used the static semantics of many expressions, including
      "for", "some", and
      "every" expressions, many functions, including
      "fn:unordered" and "fn:distinct"
      functions.</p>

    <p><b>Notation</b></p>
      <p>A choice of item types is called a <em>prime type</em>,
      as described by the following grammar production.</p>
      
      
<h5><a id="N23D16" name="N23D16"/>Prime Types</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-PrimeType" name="doc-fs-PrimeType"/>[<small>47 (Formal)</small>]   </td><td><code>PrimeType</code></td><td>   ::=   </td><td><code><a href="#doc-fs-FormalItemType">FormalItemType</a><br/>|  (<a href="#doc-fs-PrimeType">PrimeType</a>  "|"  <a href="#doc-fs-PrimeType">PrimeType</a>)</code></td></tr></tbody></table>
  
    <p><b>Notation</b></p>
      <p id="jd_prime">The type function <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
      extracts all item types from the type <a href="#doc-fs-Type"><em>Type</em></a>, and combines
      them into a choice.</p>

      <p id="jd_quantifier">The function <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>)
      approximates the possible number of items in <a href="#doc-fs-Type"><em>Type</em></a> with the
      occurrence indicators supported by the [XPath/XQuery] type system
      (<code>?, +, *</code>).</p>

      <p>For interim results, the auxiliary occurrence
      indicator <code>1</code> denotes  exactly one occurrence.</p>
    <p><b>Semantics</b></p>
      <p>The <a href="#jd_prime" class="judgment">prime</a> function is defined by induction as
      follows.</p>
    
      <table summary="" class="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-FormalItemType"><em>FormalItemType</em></a>)</td><td>  =  </td><td><a href="#doc-fs-FormalItemType"><em>FormalItemType</em></a></td></tr><tr><td><a href="#jd_prime" class="judgment">prime</a>(<code>empty</code>)</td><td>  =  </td><td><code>none</code></td></tr><tr><td><a href="#jd_prime" class="judgment">prime</a>(<code>none</code>)</td><td>  =  </td><td><code>none</code></td></tr><tr><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> , <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td><td>  =  </td><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td></tr><tr><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> &amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td><td>  =  </td><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td></tr><tr><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td><td>  =  </td><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td></tr><tr><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>?)</td><td>  =  </td><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td></tr><tr><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>*)</td><td>  =  </td><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td></tr><tr><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>+)</td><td>  =  </td><td><a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>)</td></tr></tbody></table>

    <p><b>Semantics</b></p>
      <p>The <a href="#jd_quantifier" class="judgment">quantifier</a> function is defined by induction as
      follows.</p>
      
      <table summary="" class="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-FormalItemType"><em>FormalItemType</em></a>)</td><td>  =  </td><td>1</td></tr><tr><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<code>empty</code>)</td><td>  =  </td><td>?</td></tr><tr><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<code>none</code>)</td><td>  =  </td><td>1</td></tr><tr><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> , <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td><td>  =  </td><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) , <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td></tr><tr><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> &amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td><td>  =  </td><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) , <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td></tr><tr><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td><td>  =  </td><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) | <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)</td></tr><tr><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>?)</td><td>  =  </td><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a> ?</td></tr><tr><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>*)</td><td>  =  </td><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a> *</td></tr><tr><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>+)</td><td>  =  </td><td><a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_quantifier" class="judgment">·</a> +</td></tr></tbody></table>
      
      <p>This definition uses the sum (<em>Occurrence</em><sub><font size="2">1</font></sub> ,
      <em>Occurrence</em><sub><font size="2">2</font></sub>), the choice (<em>Occurrence</em><sub><font size="2">1</font></sub> |
      <em>Occurrence</em><sub><font size="2">2</font></sub>), and the product (<em>Occurrence</em><sub><font size="2">1</font></sub> <a href="#jd_quantifier" class="judgment">·</a>
      <em>Occurrence</em><sub><font size="2">2</font></sub>) of two occurrence indicators <em>Occurrence</em><sub><font size="2">1</font></sub>,
      <em>Occurrence</em><sub><font size="2">2</font></sub>, which are defined by the following tables.</p>
      
      <table summary="" class="figure"><tbody><tr><td>
        <table summary="" border="1"><tbody><tr><td> , </td><td> 1 </td><td> ? </td><td> + </td><td> * </td></tr><tr><td> 1 </td><td> + </td><td> + </td><td> + </td><td> + </td></tr><tr><td> ? </td><td> + </td><td> * </td><td> + </td><td> * </td></tr><tr><td> + </td><td> + </td><td> + </td><td> + </td><td> + </td></tr><tr><td> * </td><td> + </td><td> * </td><td> + </td><td> * </td></tr></tbody></table>
        </td><td>    </td><td>
        <table summary="" border="1"><tbody><tr><td> | </td><td> 1 </td><td> ? </td><td> + </td><td> * </td></tr><tr><td> 1 </td><td> 1 </td><td> ? </td><td> + </td><td> * </td></tr><tr><td> ? </td><td> ? </td><td> ? </td><td> * </td><td> * </td></tr><tr><td> + </td><td> + </td><td> * </td><td> + </td><td> * </td></tr><tr><td> * </td><td> * </td><td> * </td><td> * </td><td> * </td></tr></tbody></table>
        </td><td>    </td><td>
        <table summary="" border="1"><tbody><tr><td> · </td><td> 1 </td><td> ? </td><td> + </td><td> * </td></tr><tr><td> 1 </td><td> 1 </td><td> ? </td><td> + </td><td> * </td></tr><tr><td> ? </td><td> ? </td><td> ? </td><td> * </td><td> * </td></tr><tr><td> + </td><td> + </td><td> * </td><td> + </td><td> * </td></tr><tr><td> * </td><td> * </td><td> * </td><td> * </td><td> * </td></tr></tbody></table>
        </td></tr></tbody></table>
      
    <p><b>Examples</b></p>
      <p>For example, here are the result of applying <a href="#jd_prime" class="judgment">prime</a> and
      <a href="#jd_quantifier" class="judgment">quantifier</a> on a few simple types.</p>

<div class="exampleInner"><pre>
  prime(element a+)                         = element a
  prime(element a | empty)                  = element a
  prime(element a?,element b?)              = element a | element b
  prime(element a | element b+, element c*) = element a | element b | element c

  quantifier(element a+)                         = +
  quantifier(element a | empty)                  = ?
  quantifier(element a?,element b?)              = *
  quantifier(element a | element b+, element d*) = +
</pre></div>

      <p>Note that the last occurrence indicator should be '+', since
      the regular expression is such that there must be at least one
      element in the sequence (this element being an 'a' element or a
      'b' element).</p>
    <p><b>Note</b></p>
      <p>Note that <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) ·
      <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) is always a super type of the
      original type <a href="#doc-fs-Type"><em>Type</em></a> I.e., <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a>) ·
      <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a>) <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a> always
      holds. Therefore, it is appropriate to used it as an
      approximation for the type of an expression. This property is
      required for the soundness of the static type analysis.</p>

    <p><b>Semantics</b></p>
      <p>Finally, a type <a href="#doc-fs-Type"><em>Type</em></a> and an occurrence indicator can be
      combined back together to yield a new type with the ·
      operation, as follows.</p>
    
      <table summary="" class="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td><a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_quantifier" class="judgment">·</a> 1</td><td>  =  </td><td><a href="#doc-fs-Type"><em>Type</em></a></td></tr><tr><td><a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_quantifier" class="judgment">·</a> ?</td><td>  =  </td><td><a href="#doc-fs-Type"><em>Type</em></a>?</td></tr><tr><td><a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_quantifier" class="judgment">·</a> +</td><td>  =  </td><td><a href="#doc-fs-Type"><em>Type</em></a>+</td></tr><tr><td><a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_quantifier" class="judgment">·</a> *</td><td>  =  </td><td><a href="#doc-fs-Type"><em>Type</em></a>*</td></tr></tbody></table>
    
    </div><div class="div2">
<h3><a id="sec_promotion_judgments" name="sec_promotion_judgments"/>8.5 Judgments for function calls</h3><p><b>Introduction</b></p>
      <p>Function calls can perform type promotion between atomic
      types. This section introduces judgments which describe type
      promotion for the purpose of the dynamic and static semantics.
      These promotion rules include promoting <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> to any
      other type.
      </p>
    <div class="div3">
<h4><a id="sec_promotion" name="sec_promotion"/>8.5.1 Type promotion</h4><p><b>Notation</b></p>
      <p id="jd_can_be_promoted_to">The judgment</p>

      <div align="center">
          
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
          
      </div>
    
      <p>holds if type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> can be promoted to type
      <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.</p>
    
    <p><b>Example</b></p>
      <p>For example, the following judgments hold:</p>

<div class="exampleInner"><pre>
  xs:integer  can be promoted to  xs:integer
  xs:decimal  can be promoted to  xs:float
  xs:integer  can be promoted to  xs:float
  xs:float    can be promoted to  xs:double
  xdt:untypedAtomic     can be promoted to  xs:double
</pre></div>
    <p><b>Semantics</b></p>
      <p>This judgment is specified by the following rules.</p>

      <p><code>xs:decimal</code> can be promoted to <code>xs:float</code>:</p>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
        </td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <code>xs:decimal</code> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <code>xs:float</code>
           
          
         </td></tr>
        </table></td></tr></table></td></tr>
       </table><br/>
      </div>

      <p><code>xs:float</code> can be promoted to <code>xs:double</code>:</p>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
        </td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <code>xs:float</code> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <code>xs:double</code>
           
          
         </td></tr>
        </table></td></tr></table></td></tr>
       </table><br/>
      </div>

      <p><a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> can be promoted to any type:</p>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
        </td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a>  <a href="#doc-fs-Type"><em>Type</em></a>
           
          
         </td></tr>
        </table></td></tr></table></td></tr>
       </table><br/>
      </div>

      <p>A type can be promoted to itself or to any type of which it
      is a subtype:</p>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
        </td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
           
          
         </td></tr>
        </table></td></tr></table></td></tr>
       </table><br/>
      </div>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
         
            <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
           
             <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_subtype_of" class="judgment"><b>&lt;:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
           
         
        </td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
           
          
         </td></tr>
        </table></td></tr></table></td></tr>
       </table><br/>
      </div>

      <p>Type promotion is transitive:</p>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
           
              
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
           
          
        </td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">3</font></sub>
           
          
         </td></tr>
        </table></td></tr></table></td></tr>
       </table><br/>
      </div>

      <p>Finally, type promotion distributes over occurrence and union
        constructors.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
              
                
            
              
                <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) &lt;= <a href="#jd_quantifier" class="judgment">quantifier</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>)
              
            
          </td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
                
              
            </td></tr>
          </table></td></tr></table></td></tr>
        </table><br/>

        <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td>
            <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>) <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>')
              
                
            
              
                <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#jd_prime" class="judgment">prime</a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>')
              
            
          </td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                
                  (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>) <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> (<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>' | <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>')
                
              
            </td></tr>
          </table></td></tr></table></td></tr>
        </table><br/>
      </div>
    <p>where the "&lt;=" operator for occurrence
      indicators denotes set inclusion of the subsets of the allowed
      occurrences.</p><p><b>Notation</b></p>
      <p id="jd_promotes_to">The judgment</p>

      <div align="center">
          
        <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
        <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_promotes_to" class="judgment"><b>against</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
        <a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
          
      </div>
    
      <p>holds if value <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> can be promoted to the value
      <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> against the type <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>.</p>

    <p><b>Example</b></p>
      <p>For example, the following judgments hold</p>

<div class="exampleInner"><pre>
  1     of type xs:integer  against  xs:integer  is promoted to  1     of type xs:integer
  1     of type xs:integer  against  xs:decimal  is promoted to  1     of type xs:integer
  1     of type xs:integer  against  xs:float    is promoted to  1.0e0 of type xs:float
  1.0e0 of type xs:float    against  xs:double   is promoted to  1.0e0 of type xs:double
</pre></div>

       <p>Note that type promotion changes the value, and only occurs
       if the input value does not matches the target type.</p>
    <p><b>Semantics</b></p>
      <p>This judgment is specified by the following rules.</p>

      <p>If the value matches the target type, then it is promoted to
      itself</p>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
          
         </td></tr>
        </table></td></tr></table></td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
            <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_promotes_to" class="judgment"><b>against</b></a> <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
           
          
         </td></tr>
        </table></td></tr></table></td></tr>
       </table><br/>
      </div>

      <p>If the value does not match the target type, but matches a
      type which can be promoted to the target type, then the value is
      cast to the target type.</p>

      <div align="center">
       <table cellpadding="0" cellspacing="0" summary="">
        <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_matches" class="judgment"><b>matches</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
           
          
         </td></tr>
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
           
          
         </td></tr>
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> != <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
           
          
         </td></tr>
         <tr valign="middle" align="center"><td>
          
           <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> cast as <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_yields" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
          
         </td></tr>
        </table></td></tr></table></td></tr>
        <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_promotes_to" class="judgment"><b>against</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> <a href="#jd_promotes_to" class="judgment"><b>promotes to</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
           
          
         </td></tr>
        </table></td></tr></table></td></tr>
       </table><br/>
      </div>

    </div></div><div class="div2">
<h3><a id="sec_validation_mode" name="sec_validation_mode"/>8.6 Judgments for validation modes and contexts</h3><div class="div3">
<h4><a id="jd_aux_context_is" name="jd_aux_context_is"/>8.6.1 Elements in validation mode</h4><p><b>Notation</b></p>

      <p>A validation mode may occur explicitly in a validate
      expression <a href="#sec_validate_expr"><b>[4.13 Validate Expressions]</b></a>. The following
      <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a> judgment resolves an element name within a given
      validation mode to the type that the element name denotes. The
      judgment is used in the semantics of the validate expression and
      in sequence type.</p>

      <p id="jd_in_validation_context">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-xquery-ElementNameOrWildcard"><em>ElementNameOrWildcard</em></a> <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a> <em>ValidationMode</em> <a href="#jd_in_validation_context" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
          
        </div>
        <p>holds when the possibly optional element name resolves to
        the given type in the given validation mode.</p>
    <p><b>Semantics</b></p>
      <p>We start with the rules for the global validation
      context.</p>

      <p>If no element name is present, the global validation context
      resolves to the union of all element types that are globally
      declared.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">1</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>
           
          
         </td></tr>
<tr valign="middle" align="center"><td>...</td></tr>
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-ElementName"><em>ElementName</em></a><sub><font size="2">n</font></sub> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">n</font></sub>
           
          
         </td></tr>

<tr valign="middle" align="center"><td>


<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">1</font></sub>) = define <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">1</font></sub> 

</td></tr>
<tr valign="middle" align="center"><td>...</td></tr>
<tr valign="middle" align="center"><td>


<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a><sub><font size="2">n</font></sub>) = define <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">n</font></sub> 

</td></tr>
         </table></td></tr></table></td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a> <em>ValidationMode</em> <a href="#jd_in_validation_context" class="judgment"><b>resolves to</b></a> (<a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">1</font></sub> | ... | <a href="#doc-fs-ElementType"><em>ElementType</em></a><sub><font size="2">n</font></sub>)
          
         </td></tr>
        </table><br/>
      </div>

      <p>If the element name is globally declared in the schema, it
      resolves to the element type of the corresponding global element
      declaration, independently of the validation mode.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
         </td></tr>
<tr valign="middle" align="center"><td>


<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) = define <a href="#doc-fs-ElementType"><em>ElementType</em></a> 
          
          </td></tr>
         </table></td></tr></table></td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a> <em>ValidationMode</em> <a href="#jd_in_validation_context" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a>
          
         </td></tr>
        </table><br/>
      </div>

      <p>If an element name is not globally defined and the validation
      mode is lax, then the element name resolves to the element type
      with the given element name with any content type.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
         <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
         </td></tr>
<tr valign="middle" align="center"><td>


<a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_elem_decl" class="env">elemDecl</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) undefined 
          
          </td></tr>
         </table></td></tr></table></td></tr>
         <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_in_validation_context" class="judgment"><b>with mode</b></a> lax
          <a href="#jd_in_validation_context" class="judgment"><b>resolves to</b></a> element <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type <code>xs:anyType</code>
          
         </td></tr>
        </table><br/>
      </div>

     </div></div></div></div><div class="back"><div class="div1">
<h2><a id="sec_core" name="sec_core"/>A Normalized core grammar</h2><p>This section contains the grammar of [XPath/XQuery] after it has been
  normalized, sometimes referred to as the "core"
  syntax.</p><div class="div2">
<h3><a id="sec_core_grammar" name="sec_core_grammar"/>A.1 Core BNF</h3><p>The following grammar uses the same Basic EBNF notation as
     <a href="#REC-xml">[XML]</a>, except that grammar symbols always have
     initial capital letters. The EBNF contains the lexemes embedded
     in the productions.</p>
<h5><a id="N248CE" name="N248CE"/>Named Terminals</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="prod-core-IntegerLiteral" name="prod-core-IntegerLiteral"/>[<small>105 (Core)</small>]   </td><td><code><a href="#doc-core-IntegerLiteral">IntegerLiteral</a></code></td><td>   ::=   </td><td><code><a href="#doc-core-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-DecimalLiteral" name="prod-core-DecimalLiteral"/>[<small>106 (Core)</small>]   </td><td><code><a href="#doc-core-DecimalLiteral">DecimalLiteral</a></code></td><td>   ::=   </td><td><code>("."  <a href="#doc-core-Digits">Digits</a>)  |  (<a href="#doc-core-Digits">Digits</a>  "."  [0-9]*)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-DoubleLiteral" name="prod-core-DoubleLiteral"/>[<small>107 (Core)</small>]   </td><td><code><a href="#doc-core-DoubleLiteral">DoubleLiteral</a></code></td><td>   ::=   </td><td><code>(("."  <a href="#doc-core-Digits">Digits</a>)  |  (<a href="#doc-core-Digits">Digits</a>  ("."  [0-9]*)?))  [eE]  [+-]?  <a href="#doc-core-Digits">Digits</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-StringLiteral" name="prod-core-StringLiteral"/>[<small>108 (Core)</small>]   </td><td><code><a href="#doc-core-StringLiteral">StringLiteral</a></code></td><td>   ::=   </td><td><code>('"'  (<a href="#prod-core-EscapeQuot">EscapeQuot</a>  |  [^"])*  '"')  |  ("'"  (<a href="#prod-core-EscapeApos">EscapeApos</a>  |  [^'])*  "'")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-EscapeQuot" name="prod-core-EscapeQuot"/>[<small>109 (Core)</small>]   </td><td><code>EscapeQuot</code></td><td>   ::=   </td><td><code>'""'</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-EscapeApos" name="prod-core-EscapeApos"/>[<small>110 (Core)</small>]   </td><td><code>EscapeApos</code></td><td>   ::=   </td><td><code>"''"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ElementContentChar" name="prod-core-ElementContentChar"/>[<small>111 (Core)</small>]   </td><td><code>ElementContentChar</code></td><td>   ::=   </td><td><code><a href="#prod-core-Char">Char</a> - [{}&lt;&amp;]</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-QuotAttrContentChar" name="prod-core-QuotAttrContentChar"/>[<small>112 (Core)</small>]   </td><td><code>QuotAttrContentChar</code></td><td>   ::=   </td><td><code><a href="#prod-core-Char">Char</a> - ["{}&lt;&amp;]</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-AposAttrContentChar" name="prod-core-AposAttrContentChar"/>[<small>113 (Core)</small>]   </td><td><code>AposAttrContentChar</code></td><td>   ::=   </td><td><code><a href="#prod-core-Char">Char</a> - ['{}&lt;&amp;]</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-PITarget" name="prod-core-PITarget"/>[<small>114 (Core)</small>]   </td><td><code>PITarget</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</a><sup><small>XML</small></sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-QName" name="prod-core-QName"/>[<small>115 (Core)</small>]   </td><td><code>QName</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-NCName" name="prod-core-NCName"/>[<small>116 (Core)</small>]   </td><td><code>NCName</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-S" name="prod-core-S"/>[<small>117 (Core)</small>]   </td><td><code>S</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</a><sup><small>XML</small></sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Char" name="prod-core-Char"/>[<small>118 (Core)</small>]   </td><td><code>Char</code></td><td>   ::=   </td><td><code><a href="http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td></tr></tbody></table>
<h5><a id="BNF-Grammar" name="BNF-Grammar"/>Non-Terminals</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="prod-core-Module" name="prod-core-Module"/>[<small>1 (Core)</small>]   </td><td><code><a href="#doc-core-Module">Module</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-VersionDecl">VersionDecl</a>?<sup>L2</sup>  (<a href="#prod-core-LibraryModule">LibraryModule</a><sup>L2</sup>  |  <a href="#prod-core-MainModule">MainModule</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-VersionDecl" name="prod-core-VersionDecl"/>[<small>2 (Core)</small>]   </td><td><code><a href="#doc-core-VersionDecl">VersionDecl</a></code></td><td>   ::=   </td><td><code>"xquery"  "version"  <a href="#prod-core-StringLiteral">StringLiteral</a>  ("encoding"  <a href="#prod-core-StringLiteral">StringLiteral</a>)?  <a href="#prod-core-Separator">Separator</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-MainModule" name="prod-core-MainModule"/>[<small>3 (Core)</small>]   </td><td><code><a href="#doc-core-MainModule">MainModule</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-Prolog">Prolog</a>  <a href="#prod-core-QueryBody">QueryBody</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-LibraryModule" name="prod-core-LibraryModule"/>[<small>4 (Core)</small>]   </td><td><code><a href="#doc-core-LibraryModule">LibraryModule</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ModuleDecl">ModuleDecl</a>  <a href="#prod-core-Prolog">Prolog</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ModuleDecl" name="prod-core-ModuleDecl"/>[<small>5 (Core)</small>]   </td><td><code><a href="#doc-core-ModuleDecl">ModuleDecl</a></code></td><td>   ::=   </td><td><code>"module"  "namespace"  <a href="#prod-core-NCName">NCName</a>  "="  <a href="#prod-core-URILiteral">URILiteral</a>  <a href="#prod-core-Separator">Separator</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Prolog" name="prod-core-Prolog"/>[<small>6 (Core)</small>]   </td><td><code><a href="#doc-core-Prolog">Prolog</a></code></td><td>   ::=   </td><td><code>((<a href="#prod-core-DefaultNamespaceDecl">DefaultNamespaceDecl</a><sup>L3</sup>  |  <a href="#prod-core-Setter">Setter</a><sup>L3</sup>  |  <a href="#prod-core-NamespaceDecl">NamespaceDecl</a><sup>L2</sup>  |  <a href="#prod-core-Import">Import</a>)  <a href="#prod-core-Separator">Separator</a>)*<sup>L2</sup>  ((<a href="#prod-core-VarDecl">VarDecl</a><sup>L2</sup>  |  <a href="#prod-core-FunctionDecl">FunctionDecl</a><sup>L2</sup>  |  <a href="#prod-core-OptionDecl">OptionDecl</a>)  <a href="#prod-core-Separator">Separator</a>)*<sup>L2</sup></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Setter" name="prod-core-Setter"/>[<small>7 (Core)</small>]   </td><td><code><a href="#doc-core-Setter">Setter</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-DefaultCollationDecl">DefaultCollationDecl</a><sup>L3</sup>  |  <a href="#prod-core-BaseURIDecl">BaseURIDecl</a><sup>L2</sup>  |  <a href="#prod-core-ConstructionDecl">ConstructionDecl</a><sup>L2</sup>  |  <a href="#prod-core-OrderingModeDecl">OrderingModeDecl</a><sup>L2</sup>  |  <a href="#prod-core-EmptyOrderDecl">EmptyOrderDecl</a><sup>L3</sup>  |  <a href="#prod-core-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Import" name="prod-core-Import"/>[<small>8 (Core)</small>]   </td><td><code><a href="#doc-core-Import">Import</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-SchemaImport">SchemaImport</a><sup>L2</sup>  |  <a href="#prod-core-ModuleImport">ModuleImport</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Separator" name="prod-core-Separator"/>[<small>9 (Core)</small>]   </td><td><code><a href="#doc-core-Separator">Separator</a></code></td><td>   ::=   </td><td><code>";"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-NamespaceDecl" name="prod-core-NamespaceDecl"/>[<small>10 (Core)</small>]   </td><td><code><a href="#doc-core-NamespaceDecl">NamespaceDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "namespace"  <a href="#prod-core-NCName">NCName</a>  "="  <a href="#prod-core-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-DefaultNamespaceDecl" name="prod-core-DefaultNamespaceDecl"/>[<small>11 (Core)</small>]   </td><td><code><a href="#doc-core-DefaultNamespaceDecl">DefaultNamespaceDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "default"  ("element"  |  "function")  "namespace"  <a href="#prod-core-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-OptionDecl" name="prod-core-OptionDecl"/>[<small>12 (Core)</small>]   </td><td><code><a href="#doc-core-OptionDecl">OptionDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "option"  <a href="#prod-core-QName">QName</a>  <a href="#prod-core-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-OrderingModeDecl" name="prod-core-OrderingModeDecl"/>[<small>13 (Core)</small>]   </td><td><code><a href="#doc-core-OrderingModeDecl">OrderingModeDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "ordering"  ("ordered"  |  "unordered")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-EmptyOrderDecl" name="prod-core-EmptyOrderDecl"/>[<small>14 (Core)</small>]   </td><td><code><a href="#doc-core-EmptyOrderDecl">EmptyOrderDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "default"  "order"  "empty"  ("greatest"  |  "least")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CopyNamespacesDecl" name="prod-core-CopyNamespacesDecl"/>[<small>15 (Core)</small>]   </td><td><code><a href="#doc-core-CopyNamespacesDecl">CopyNamespacesDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "copy-namespaces"  <a href="#prod-core-PreserveMode">PreserveMode</a>  ","  <a href="#prod-core-InheritMode">InheritMode</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-PreserveMode" name="prod-core-PreserveMode"/>[<small>16 (Core)</small>]   </td><td><code><a href="#doc-core-PreserveMode">PreserveMode</a></code></td><td>   ::=   </td><td><code>"preserve"  |  "no-preserve"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-InheritMode" name="prod-core-InheritMode"/>[<small>17 (Core)</small>]   </td><td><code><a href="#doc-core-InheritMode">InheritMode</a></code></td><td>   ::=   </td><td><code>"inherit"  |  "no-inherit"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-DefaultCollationDecl" name="prod-core-DefaultCollationDecl"/>[<small>18 (Core)</small>]   </td><td><code><a href="#doc-core-DefaultCollationDecl">DefaultCollationDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "default"  "collation"  <a href="#prod-core-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-BaseURIDecl" name="prod-core-BaseURIDecl"/>[<small>19 (Core)</small>]   </td><td><code><a href="#doc-core-BaseURIDecl">BaseURIDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "base-uri"  <a href="#prod-core-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-SchemaImport" name="prod-core-SchemaImport"/>[<small>20 (Core)</small>]   </td><td><code><a href="#doc-core-SchemaImport">SchemaImport</a></code></td><td>   ::=   </td><td><code>"import"  "schema"  <a href="#prod-core-SchemaPrefix">SchemaPrefix</a>?  <a href="#prod-core-URILiteral">URILiteral</a>  ("at"  <a href="#prod-core-URILiteral">URILiteral</a>  (","  <a href="#prod-core-URILiteral">URILiteral</a>)*)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-SchemaPrefix" name="prod-core-SchemaPrefix"/>[<small>21 (Core)</small>]   </td><td><code><a href="#doc-core-SchemaPrefix">SchemaPrefix</a></code></td><td>   ::=   </td><td><code>("namespace"  <a href="#prod-core-NCName">NCName</a>  "=")  |  ("default"  "element"  "namespace")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ModuleImport" name="prod-core-ModuleImport"/>[<small>22 (Core)</small>]   </td><td><code><a href="#doc-core-ModuleImport">ModuleImport</a></code></td><td>   ::=   </td><td><code>"import"  "module"  ("namespace"  <a href="#prod-core-NCName">NCName</a>  "=")?  <a href="#prod-core-URILiteral">URILiteral</a>  ("at"  <a href="#prod-core-URILiteral">URILiteral</a>  (","  <a href="#prod-core-URILiteral">URILiteral</a>)*)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-VarDecl" name="prod-core-VarDecl"/>[<small>23 (Core)</small>]   </td><td><code><a href="#doc-core-VarDecl">VarDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "variable"  "$"  <a href="#prod-core-QName">QName</a>  <a href="#prod-core-TypeDeclaration">TypeDeclaration</a>?  ((":="  <a href="#prod-core-ExprSingle">ExprSingle</a>)  |  "external")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ConstructionDecl" name="prod-core-ConstructionDecl"/>[<small>24 (Core)</small>]   </td><td><code><a href="#doc-core-ConstructionDecl">ConstructionDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "construction"  ("strip"  |  "preserve")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-FunctionDecl" name="prod-core-FunctionDecl"/>[<small>25 (Core)</small>]   </td><td><code><a href="#doc-core-FunctionDecl">FunctionDecl</a></code></td><td>   ::=   </td><td><code>"declare"  "function"  <a href="#prod-core-QName">QName</a>  "("  <a href="#prod-core-ParamList">ParamList</a>?  ")"  ("as"  <a href="#prod-core-SequenceType">SequenceType</a>)?  (<a href="#prod-core-EnclosedExpr">EnclosedExpr</a>  |  "external")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ParamList" name="prod-core-ParamList"/>[<small>26 (Core)</small>]   </td><td><code><a href="#doc-core-ParamList">ParamList</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-Param">Param</a>  (","  <a href="#prod-core-Param">Param</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Param" name="prod-core-Param"/>[<small>27 (Core)</small>]   </td><td><code><a href="#doc-core-Param">Param</a></code></td><td>   ::=   </td><td><code>"$"  <a href="#prod-core-QName">QName</a>  <a href="#prod-core-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-EnclosedExpr" name="prod-core-EnclosedExpr"/>[<small>28 (Core)</small>]   </td><td><code><a href="#doc-core-EnclosedExpr">EnclosedExpr</a></code></td><td>   ::=   </td><td><code>"{"  <a href="#prod-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-QueryBody" name="prod-core-QueryBody"/>[<small>29 (Core)</small>]   </td><td><code><a href="#doc-core-QueryBody">QueryBody</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-Expr">Expr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Expr" name="prod-core-Expr"/>[<small>30 (Core)</small>]   </td><td><code><a href="#doc-core-Expr">Expr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ExprSingle">ExprSingle</a>  (","  <a href="#prod-core-ExprSingle">ExprSingle</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ExprSingle" name="prod-core-ExprSingle"/>[<small>31 (Core)</small>]   </td><td><code><a href="#doc-core-ExprSingle">ExprSingle</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-FLWORExpr">FLWORExpr</a><sup>L2</sup><br/>|  <a href="#prod-core-TypeswitchExpr">TypeswitchExpr</a><sup>L2</sup><br/>|  <a href="#prod-core-IfExpr">IfExpr</a><sup>L2</sup><br/>|  <a href="#prod-core-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-FLWORExpr" name="prod-core-FLWORExpr"/>[<small>32 (Core)</small>]   </td><td><code><a href="#doc-core-FLWORExpr">FLWORExpr</a></code></td><td>   ::=   </td><td><code>(<a href="#prod-core-ForClause">ForClause</a>  |  <a href="#prod-core-LetClause">LetClause</a>)  "return"  <a href="#prod-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ForClause" name="prod-core-ForClause"/>[<small>33 (Core)</small>]   </td><td><code><a href="#doc-core-ForClause">ForClause</a></code></td><td>   ::=   </td><td><code>"for"  "$"  <a href="#prod-core-VarName">VarName</a>  <a href="#prod-core-TypeDeclaration">TypeDeclaration</a>?  <a href="#prod-core-PositionalVar">PositionalVar</a>?  "in"  <a href="#prod-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-PositionalVar" name="prod-core-PositionalVar"/>[<small>34 (Core)</small>]   </td><td><code><a href="#doc-core-PositionalVar">PositionalVar</a></code></td><td>   ::=   </td><td><code>"at"  "$"  <a href="#prod-core-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-LetClause" name="prod-core-LetClause"/>[<small>35 (Core)</small>]   </td><td><code><a href="#doc-core-LetClause">LetClause</a></code></td><td>   ::=   </td><td><code>"let"  "$"  <a href="#prod-core-VarName">VarName</a>  <a href="#prod-core-TypeDeclaration">TypeDeclaration</a>?  ":="  <a href="#prod-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-OrderByClause" name="prod-core-OrderByClause"/>[<small>36 (Core)</small>]   </td><td><code><a href="#doc-core-OrderByClause">OrderByClause</a></code></td><td>   ::=   </td><td><code>(("order"  "by")  |  ("stable"  "order"  "by"))  <a href="#prod-core-OrderSpecList">OrderSpecList</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-OrderSpecList" name="prod-core-OrderSpecList"/>[<small>37 (Core)</small>]   </td><td><code><a href="#doc-core-OrderSpecList">OrderSpecList</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-OrderSpec">OrderSpec</a>  (","  <a href="#prod-core-OrderSpec">OrderSpec</a>)*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-OrderSpec" name="prod-core-OrderSpec"/>[<small>38 (Core)</small>]   </td><td><code><a href="#doc-core-OrderSpec">OrderSpec</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ExprSingle">ExprSingle</a>  <a href="#prod-core-OrderModifier">OrderModifier</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-OrderModifier" name="prod-core-OrderModifier"/>[<small>39 (Core)</small>]   </td><td><code><a href="#doc-core-OrderModifier">OrderModifier</a></code></td><td>   ::=   </td><td><code>("ascending"  |  "descending")?  ("empty"  ("greatest"  |  "least"))?  ("collation"  <a href="#prod-core-URILiteral">URILiteral</a>)?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-QuantifiedExpr" name="prod-core-QuantifiedExpr"/>[<small>40 (Core)</small>]   </td><td><code><a href="#doc-core-QuantifiedExpr">QuantifiedExpr</a></code></td><td>   ::=   </td><td><code>("some"  |  "every")  "$"  <a href="#prod-core-VarName">VarName</a>  <a href="#prod-core-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#prod-core-ExprSingle">ExprSingle</a>  (","  "$"  <a href="#prod-core-VarName">VarName</a>  <a href="#prod-core-TypeDeclaration">TypeDeclaration</a>?  "in"  <a href="#prod-core-ExprSingle">ExprSingle</a>)*  "satisfies"  <a href="#prod-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-TypeswitchExpr" name="prod-core-TypeswitchExpr"/>[<small>41 (Core)</small>]   </td><td><code><a href="#doc-core-TypeswitchExpr">TypeswitchExpr</a></code></td><td>   ::=   </td><td><code>"typeswitch"  "("  <a href="#prod-core-Expr">Expr</a>  ")"  <a href="#prod-core-CaseClause">CaseClause</a>+  "default"  ("$"  <a href="#prod-core-VarName">VarName</a>)?  "return"  <a href="#prod-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CaseClause" name="prod-core-CaseClause"/>[<small>42 (Core)</small>]   </td><td><code><a href="#doc-core-CaseClause">CaseClause</a></code></td><td>   ::=   </td><td><code>"case"  ("$"  <a href="#prod-core-VarName">VarName</a>  "as")?  <a href="#prod-core-SequenceType">SequenceType</a>  "return"  <a href="#prod-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-IfExpr" name="prod-core-IfExpr"/>[<small>43 (Core)</small>]   </td><td><code><a href="#doc-core-IfExpr">IfExpr</a></code></td><td>   ::=   </td><td><code>"if"  "("  <a href="#prod-core-Expr">Expr</a>  ")"  "then"  <a href="#prod-core-ExprSingle">ExprSingle</a>  "else"  <a href="#prod-core-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-OrExpr" name="prod-core-OrExpr"/>[<small>44 (Core)</small>]   </td><td><code><a href="#doc-core-OrExpr">OrExpr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-AndExpr">AndExpr</a> ( "or"  <a href="#prod-core-AndExpr">AndExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-AndExpr" name="prod-core-AndExpr"/>[<small>45 (Core)</small>]   </td><td><code><a href="#doc-core-AndExpr">AndExpr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-CastableExpr">CastableExpr</a> ( "and"  <a href="#prod-core-CastableExpr">CastableExpr</a> )*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CastableExpr" name="prod-core-CastableExpr"/>[<small>46 (Core)</small>]   </td><td><code><a href="#doc-core-CastableExpr">CastableExpr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-CastExpr">CastExpr</a> ( "castable"  "as"  <a href="#prod-core-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CastExpr" name="prod-core-CastExpr"/>[<small>47 (Core)</small>]   </td><td><code><a href="#doc-core-CastExpr">CastExpr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ValueExpr">ValueExpr</a> ( "cast"  "as"  <a href="#prod-core-SingleType">SingleType</a> )?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ValueExpr" name="prod-core-ValueExpr"/>[<small>48 (Core)</small>]   </td><td><code><a href="#doc-core-ValueExpr">ValueExpr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ValidateExpr">ValidateExpr</a><sup>L2</sup>  |  <a href="#prod-core-StepExpr">StepExpr</a>  |  <a href="#prod-core-ExtensionExpr">ExtensionExpr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ValidateExpr" name="prod-core-ValidateExpr"/>[<small>49 (Core)</small>]   </td><td><code><a href="#doc-core-ValidateExpr">ValidateExpr</a></code></td><td>   ::=   </td><td><code>"validate"  <a href="#prod-core-ValidationMode">ValidationMode</a>?  "{"  <a href="#prod-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ValidationMode" name="prod-core-ValidationMode"/>[<small>50 (Core)</small>]   </td><td><code><a href="#doc-core-ValidationMode">ValidationMode</a></code></td><td>   ::=   </td><td><code>"lax"  |  "strict"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ExtensionExpr" name="prod-core-ExtensionExpr"/>[<small>51 (Core)</small>]   </td><td><code><a href="#doc-core-ExtensionExpr">ExtensionExpr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-Pragma">Pragma</a>+  "{"  <a href="#prod-core-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Pragma" name="prod-core-Pragma"/>[<small>52 (Core)</small>]   </td><td><code><a href="#doc-core-Pragma">Pragma</a></code></td><td>   ::=   </td><td><code>"(#"  <a href="#prod-core-S">S</a>?  <a href="#prod-core-QName">QName</a>  <a href="#prod-core-PragmaContents">PragmaContents</a>  "#)"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-PragmaContents" name="prod-core-PragmaContents"/>[<small>53 (Core)</small>]   </td><td><code><a href="#doc-core-PragmaContents">PragmaContents</a></code></td><td>   ::=   </td><td><code>(<a href="#prod-core-Char">Char</a>* - (Char* '#)' Char*))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-StepExpr" name="prod-core-StepExpr"/>[<small>54 (Core)</small>]   </td><td><code><a href="#doc-core-StepExpr">StepExpr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-PrimaryExpr">PrimaryExpr</a><sup>L3</sup>  |  <a href="#prod-core-AxisStep">AxisStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-AxisStep" name="prod-core-AxisStep"/>[<small>55 (Core)</small>]   </td><td><code><a href="#doc-core-AxisStep">AxisStep</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ReverseStep">ReverseStep</a><sup>L2</sup>  |  <a href="#prod-core-ForwardStep">ForwardStep</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ForwardStep" name="prod-core-ForwardStep"/>[<small>56 (Core)</small>]   </td><td><code><a href="#doc-core-ForwardStep">ForwardStep</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ForwardAxis">ForwardAxis</a>  <a href="#prod-core-NodeTest">NodeTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ForwardAxis" name="prod-core-ForwardAxis"/>[<small>57 (Core)</small>]   </td><td><code><a href="#doc-core-ForwardAxis">ForwardAxis</a></code></td><td>   ::=   </td><td><code>("child"  "::")<br/>|  ("descendant"  "::")<br/>|  ("attribute"  "::")<br/>|  ("self"  "::")<br/>|  ("descendant-or-self"  "::")<br/>|  ("namespace"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ReverseStep" name="prod-core-ReverseStep"/>[<small>58 (Core)</small>]   </td><td><code><a href="#doc-core-ReverseStep">ReverseStep</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ReverseAxis">ReverseAxis</a>  <a href="#prod-core-NodeTest">NodeTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ReverseAxis" name="prod-core-ReverseAxis"/>[<small>59 (Core)</small>]   </td><td><code><a href="#doc-core-ReverseAxis">ReverseAxis</a></code></td><td>   ::=   </td><td><code>("parent"  "::")<br/>|  ("ancestor"  "::")<br/>|  ("ancestor-or-self"  "::")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-NodeTest" name="prod-core-NodeTest"/>[<small>60 (Core)</small>]   </td><td><code><a href="#doc-core-NodeTest">NodeTest</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-KindTest">KindTest</a><sup>L2</sup>  |  <a href="#prod-core-NameTest">NameTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-NameTest" name="prod-core-NameTest"/>[<small>61 (Core)</small>]   </td><td><code><a href="#doc-core-NameTest">NameTest</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a>  |  <a href="#prod-core-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Wildcard" name="prod-core-Wildcard"/>[<small>62 (Core)</small>]   </td><td><code><a href="#doc-core-Wildcard">Wildcard</a></code></td><td>   ::=   </td><td><code>"*"<br/>|  (<a href="#prod-core-NCName">NCName</a>  ":"  "*")<br/>|  ("*"  ":"  <a href="#prod-core-NCName">NCName</a>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-PrimaryExpr" name="prod-core-PrimaryExpr"/>[<small>63 (Core)</small>]   </td><td><code><a href="#doc-core-PrimaryExpr">PrimaryExpr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-Literal">Literal</a>  |  <a href="#prod-core-VarRef">VarRef</a>  |  <a href="#prod-core-ParenthesizedExpr">ParenthesizedExpr</a>  |  <a href="#prod-core-FunctionCall">FunctionCall</a><sup>L2</sup>  |  <a href="#prod-core-Constructor">Constructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Literal" name="prod-core-Literal"/>[<small>64 (Core)</small>]   </td><td><code><a href="#doc-core-Literal">Literal</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-NumericLiteral">NumericLiteral</a>  |  <a href="#prod-core-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-NumericLiteral" name="prod-core-NumericLiteral"/>[<small>65 (Core)</small>]   </td><td><code><a href="#doc-core-NumericLiteral">NumericLiteral</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-IntegerLiteral">IntegerLiteral</a>  |  <a href="#prod-core-DecimalLiteral">DecimalLiteral</a>  |  <a href="#prod-core-DoubleLiteral">DoubleLiteral</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-VarRef" name="prod-core-VarRef"/>[<small>66 (Core)</small>]   </td><td><code><a href="#doc-core-VarRef">VarRef</a></code></td><td>   ::=   </td><td><code>"$"  <a href="#prod-core-VarName">VarName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-VarName" name="prod-core-VarName"/>[<small>67 (Core)</small>]   </td><td><code><a href="#doc-core-VarName">VarName</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ParenthesizedExpr" name="prod-core-ParenthesizedExpr"/>[<small>68 (Core)</small>]   </td><td><code><a href="#doc-core-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>   ::=   </td><td><code>"("  <a href="#prod-core-Expr">Expr</a>?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-OrderedExpr" name="prod-core-OrderedExpr"/>[<small>69 (Core)</small>]   </td><td><code><a href="#doc-core-OrderedExpr">OrderedExpr</a></code></td><td>   ::=   </td><td><code>"ordered"  "{"  <a href="#prod-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-UnorderedExpr" name="prod-core-UnorderedExpr"/>[<small>70 (Core)</small>]   </td><td><code><a href="#doc-core-UnorderedExpr">UnorderedExpr</a></code></td><td>   ::=   </td><td><code>"unordered"  "{"  <a href="#prod-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-FunctionCall" name="prod-core-FunctionCall"/>[<small>71 (Core)</small>]   </td><td><code><a href="#doc-core-FunctionCall">FunctionCall</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a>  "("  (<a href="#prod-core-ExprSingle">ExprSingle</a>  (","  <a href="#prod-core-ExprSingle">ExprSingle</a>)*)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-Constructor" name="prod-core-Constructor"/>[<small>72 (Core)</small>]   </td><td><code><a href="#doc-core-Constructor">Constructor</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ComputedConstructor">ComputedConstructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ComputedConstructor" name="prod-core-ComputedConstructor"/>[<small>73 (Core)</small>]   </td><td><code><a href="#doc-core-ComputedConstructor">ComputedConstructor</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-CompDocConstructor">CompDocConstructor</a><br/>|  <a href="#prod-core-CompElemConstructor">CompElemConstructor</a><br/>|  <a href="#prod-core-CompAttrConstructor">CompAttrConstructor</a><br/>|  <a href="#prod-core-CompTextConstructor">CompTextConstructor</a><br/>|  <a href="#prod-core-CompCommentConstructor">CompCommentConstructor</a><br/>|  <a href="#prod-core-CompPIConstructor">CompPIConstructor</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CompDocConstructor" name="prod-core-CompDocConstructor"/>[<small>74 (Core)</small>]   </td><td><code><a href="#doc-core-CompDocConstructor">CompDocConstructor</a></code></td><td>   ::=   </td><td><code>"document"  "{"  <a href="#prod-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CompElemConstructor" name="prod-core-CompElemConstructor"/>[<small>75 (Core)</small>]   </td><td><code><a href="#doc-core-CompElemConstructor">CompElemConstructor</a></code></td><td>   ::=   </td><td><code>"element"  (<a href="#prod-core-QName">QName</a>  |  ("{"  <a href="#prod-core-Expr">Expr</a>  "}"))  "{"  <a href="#prod-core-ContentExpr">ContentExpr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ContentExpr" name="prod-core-ContentExpr"/>[<small>76 (Core)</small>]   </td><td><code><a href="#doc-core-ContentExpr">ContentExpr</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-Expr">Expr</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CompAttrConstructor" name="prod-core-CompAttrConstructor"/>[<small>77 (Core)</small>]   </td><td><code><a href="#doc-core-CompAttrConstructor">CompAttrConstructor</a></code></td><td>   ::=   </td><td><code>"attribute"  (<a href="#prod-core-QName">QName</a>  |  ("{"  <a href="#prod-core-Expr">Expr</a>  "}"))  "{"  <a href="#prod-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CompTextConstructor" name="prod-core-CompTextConstructor"/>[<small>78 (Core)</small>]   </td><td><code><a href="#doc-core-CompTextConstructor">CompTextConstructor</a></code></td><td>   ::=   </td><td><code>"text"  "{"  <a href="#prod-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CompCommentConstructor" name="prod-core-CompCommentConstructor"/>[<small>79 (Core)</small>]   </td><td><code><a href="#doc-core-CompCommentConstructor">CompCommentConstructor</a></code></td><td>   ::=   </td><td><code>"comment"  "{"  <a href="#prod-core-Expr">Expr</a>  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CompPIConstructor" name="prod-core-CompPIConstructor"/>[<small>80 (Core)</small>]   </td><td><code><a href="#doc-core-CompPIConstructor">CompPIConstructor</a></code></td><td>   ::=   </td><td><code>"processing-instruction"  (<a href="#prod-core-NCName">NCName</a>  |  ("{"  <a href="#prod-core-Expr">Expr</a>  "}"))  "{"  <a href="#prod-core-Expr">Expr</a>?  "}"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-SingleType" name="prod-core-SingleType"/>[<small>81 (Core)</small>]   </td><td><code><a href="#doc-core-SingleType">SingleType</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-AtomicType">AtomicType</a>  "?"?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-TypeDeclaration" name="prod-core-TypeDeclaration"/>[<small>82 (Core)</small>]   </td><td><code><a href="#doc-core-TypeDeclaration">TypeDeclaration</a></code></td><td>   ::=   </td><td><code>"as"  <a href="#prod-core-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-SequenceType" name="prod-core-SequenceType"/>[<small>83 (Core)</small>]   </td><td><code><a href="#doc-core-SequenceType">SequenceType</a></code></td><td>   ::=   </td><td><code>("empty-sequence"  "("  ")")<sup>L2</sup><br/>|  (<a href="#prod-core-ItemType">ItemType</a>  <a href="#prod-core-OccurrenceIndicator">OccurrenceIndicator</a>?<sup>CC</sup>)</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-OccurrenceIndicator" name="prod-core-OccurrenceIndicator"/>[<small>84 (Core)</small>]   </td><td><code><a href="#doc-core-OccurrenceIndicator">OccurrenceIndicator</a></code></td><td>   ::=   </td><td><code>"?"  |  "*"  |  "+"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ItemType" name="prod-core-ItemType"/>[<small>85 (Core)</small>]   </td><td><code><a href="#doc-core-ItemType">ItemType</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-KindTest">KindTest</a><sup>L2</sup>  |  ("item"  "("  ")")<sup>L2</sup>  |  <a href="#prod-core-AtomicType">AtomicType</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-AtomicType" name="prod-core-AtomicType"/>[<small>86 (Core)</small>]   </td><td><code><a href="#doc-core-AtomicType">AtomicType</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-KindTest" name="prod-core-KindTest"/>[<small>87 (Core)</small>]   </td><td><code><a href="#doc-core-KindTest">KindTest</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-DocumentTest">DocumentTest</a><br/>|  <a href="#prod-core-ElementTest">ElementTest</a><br/>|  <a href="#prod-core-AttributeTest">AttributeTest</a><br/>|  <a href="#prod-core-SchemaElementTest">SchemaElementTest</a><br/>|  <a href="#prod-core-SchemaAttributeTest">SchemaAttributeTest</a><br/>|  <a href="#prod-core-PITest">PITest</a><br/>|  <a href="#prod-core-CommentTest">CommentTest</a><br/>|  <a href="#prod-core-TextTest">TextTest</a><br/>|  <a href="#prod-core-AnyKindTest">AnyKindTest</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-AnyKindTest" name="prod-core-AnyKindTest"/>[<small>88 (Core)</small>]   </td><td><code><a href="#doc-core-AnyKindTest">AnyKindTest</a></code></td><td>   ::=   </td><td><code>"node"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-DocumentTest" name="prod-core-DocumentTest"/>[<small>89 (Core)</small>]   </td><td><code><a href="#doc-core-DocumentTest">DocumentTest</a></code></td><td>   ::=   </td><td><code>"document-node"  "("  (<a href="#prod-core-ElementTest">ElementTest</a>  |  <a href="#prod-core-SchemaElementTest">SchemaElementTest</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-TextTest" name="prod-core-TextTest"/>[<small>90 (Core)</small>]   </td><td><code><a href="#doc-core-TextTest">TextTest</a></code></td><td>   ::=   </td><td><code>"text"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-CommentTest" name="prod-core-CommentTest"/>[<small>91 (Core)</small>]   </td><td><code><a href="#doc-core-CommentTest">CommentTest</a></code></td><td>   ::=   </td><td><code>"comment"  "("  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-PITest" name="prod-core-PITest"/>[<small>92 (Core)</small>]   </td><td><code><a href="#doc-core-PITest">PITest</a></code></td><td>   ::=   </td><td><code>"processing-instruction"  "("  (<a href="#prod-core-NCName">NCName</a>  |  <a href="#prod-core-StringLiteral">StringLiteral</a>)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-AttributeTest" name="prod-core-AttributeTest"/>[<small>93 (Core)</small>]   </td><td><code><a href="#doc-core-AttributeTest">AttributeTest</a></code></td><td>   ::=   </td><td><code>"attribute"  "("  (<a href="#prod-core-AttribNameOrWildcard">AttribNameOrWildcard</a>  (","  <a href="#prod-core-TypeName">TypeName</a>)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-AttribNameOrWildcard" name="prod-core-AttribNameOrWildcard"/>[<small>94 (Core)</small>]   </td><td><code><a href="#doc-core-AttribNameOrWildcard">AttribNameOrWildcard</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-AttributeName">AttributeName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-SchemaAttributeTest" name="prod-core-SchemaAttributeTest"/>[<small>95 (Core)</small>]   </td><td><code><a href="#doc-core-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>   ::=   </td><td><code>"schema-attribute"  "("  <a href="#prod-core-AttributeDeclaration">AttributeDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-AttributeDeclaration" name="prod-core-AttributeDeclaration"/>[<small>96 (Core)</small>]   </td><td><code><a href="#doc-core-AttributeDeclaration">AttributeDeclaration</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-AttributeName">AttributeName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ElementTest" name="prod-core-ElementTest"/>[<small>97 (Core)</small>]   </td><td><code><a href="#doc-core-ElementTest">ElementTest</a></code></td><td>   ::=   </td><td><code>"element"  "("  (<a href="#prod-core-ElementNameOrWildcard">ElementNameOrWildcard</a>  (","  <a href="#prod-core-TypeName">TypeName</a>  "?"?)?)?  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ElementNameOrWildcard" name="prod-core-ElementNameOrWildcard"/>[<small>98 (Core)</small>]   </td><td><code><a href="#doc-core-ElementNameOrWildcard">ElementNameOrWildcard</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ElementName">ElementName</a>  |  "*"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-SchemaElementTest" name="prod-core-SchemaElementTest"/>[<small>99 (Core)</small>]   </td><td><code><a href="#doc-core-SchemaElementTest">SchemaElementTest</a></code></td><td>   ::=   </td><td><code>"schema-element"  "("  <a href="#prod-core-ElementDeclaration">ElementDeclaration</a>  ")"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ElementDeclaration" name="prod-core-ElementDeclaration"/>[<small>100 (Core)</small>]   </td><td><code><a href="#doc-core-ElementDeclaration">ElementDeclaration</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-ElementName">ElementName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-AttributeName" name="prod-core-AttributeName"/>[<small>101 (Core)</small>]   </td><td><code><a href="#doc-core-AttributeName">AttributeName</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-ElementName" name="prod-core-ElementName"/>[<small>102 (Core)</small>]   </td><td><code><a href="#doc-core-ElementName">ElementName</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-TypeName" name="prod-core-TypeName"/>[<small>103 (Core)</small>]   </td><td><code><a href="#doc-core-TypeName">TypeName</a></code></td><td>   ::=   </td><td><code><a href="#prod-core-QName">QName</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="prod-core-URILiteral" name="prod-core-URILiteral"/>[<small>104 (Core)</small>]   </td><td><code>URILiteral</code></td><td>   ::=   </td><td><code><a href="#prod-core-StringLiteral">StringLiteral</a></code></td></tr></tbody></table></div></div><div class="div1">
<h2><a id="sec_functions_and_operators" name="sec_functions_and_operators"/>B Functions and Operators</h2><div class="div2">
<h3><a id="sec_used_functions" name="sec_used_functions"/>B.1 Functions and Operators used in the Formal Semantics</h3><p>Here is the list of functions from the <a href="#xpath-functions">[Functions and Operators]</a> document
    that are used in the [XPath/XQuery] Formal Semantics:</p><ul><li><p id="func-add-dayTimeDurations"><a href="http://www.w3.org/TR/xpath-functions/#func-add-dayTimeDurations">Section 
10.6.6 op:add-dayTimeDurations</a><sup><small>FO</small></sup></p></li><li><p id="func-add-dayTimeDuration-to-dateTime"><a href="http://www.w3.org/TR/xpath-functions/#func-add-dayTimeDuration-to-dateTime">Section 
10.8.5 op:add-dayTimeDuration-to-dateTime</a><sup><small>FO</small></sup></p></li><li><p id="func-add-dayTimeDuration-to-date"><a href="http://www.w3.org/TR/xpath-functions/#func-add-dayTimeDuration-to-date">Section 
10.8.9 op:add-dayTimeDuration-to-date</a><sup><small>FO</small></sup></p></li><li><p id="func-add-dayTimeDuration-to-time"><a href="http://www.w3.org/TR/xpath-functions/#func-add-dayTimeDuration-to-time">Section 
10.8.12 op:add-dayTimeDuration-to-time</a><sup><small>FO</small></sup></p></li><li><p id="func-add-yearMonthDurations"><a href="http://www.w3.org/TR/xpath-functions/#func-add-yearMonthDurations">Section 
10.6.1 op:add-yearMonthDurations</a><sup><small>FO</small></sup></p></li><li><p id="func-add-yearMonthDuration-to-dateTime"><a href="http://www.w3.org/TR/xpath-functions/#func-add-yearMonthDuration-to-dateTime">Section 
10.8.4 op:add-yearMonthDuration-to-dateTime</a><sup><small>FO</small></sup></p></li><li><p id="func-add-yearMonthDuration-to-date"><a href="http://www.w3.org/TR/xpath-functions/#func-add-yearMonthDuration-to-date">Section 
10.8.8 op:add-yearMonthDuration-to-date</a><sup><small>FO</small></sup></p></li><li><p id="func-boolean-equal"><a href="http://www.w3.org/TR/xpath-functions/#func-boolean-equal">Section 
9.2.1 op:boolean-equal</a><sup><small>FO</small></sup></p></li><li><p id="func-boolean-greater-than"><a href="http://www.w3.org/TR/xpath-functions/#func-boolean-greater-than">Section 
9.2.3 op:boolean-greater-than</a><sup><small>FO</small></sup></p></li><li><p id="func-boolean-less-than"><a href="http://www.w3.org/TR/xpath-functions/#func-boolean-less-than">Section 
9.2.2 op:boolean-less-than</a><sup><small>FO</small></sup></p></li><li><p id="func-boolean"><a href="http://www.w3.org/TR/xpath-functions/#func-boolean">Section 
15.1.1 fn:boolean</a><sup><small>FO</small></sup></p></li><li><p id="func-compare"><a href="http://www.w3.org/TR/xpath-functions/#func-compare">Section 
7.3.2 fn:compare</a><sup><small>FO</small></sup></p></li><li><p id="func-concatenate"><a href="http://www.w3.org/TR/xpath-functions/#func-concatenate">Section 
15.1.2 op:concatenate</a><sup><small>FO</small></sup></p></li><li><p id="func-count"><a href="http://www.w3.org/TR/xpath-functions/#func-count">Section 
15.4.1 fn:count</a><sup><small>FO</small></sup></p></li><li><p id="func-dateTime-equal"><a href="http://www.w3.org/TR/xpath-functions/#func-dateTime-equal">Section 
10.4.8 op:dateTime-equal</a><sup><small>FO</small></sup></p></li><li><p id="func-dateTime-greater-than"><a href="http://www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">Section 
10.4.10 op:dateTime-greater-than</a><sup><small>FO</small></sup></p></li><li><p id="func-dateTime-less-than"><a href="http://www.w3.org/TR/xpath-functions/#func-dateTime-less-than">Section 
10.4.9 op:dateTime-less-than</a><sup><small>FO</small></sup></p></li><li><p id="func-dayTimeDuration-equal"><a href="http://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-equal">Section 
10.4.4 op:dayTimeDuration-equal</a><sup><small>FO</small></sup></p></li><li><p id="func-dayTimeDuration-greater-than"><a href="http://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-greater-than">Section 
10.4.6 op:dayTimeDuration-greater-than</a><sup><small>FO</small></sup></p></li><li><p id="func-dayTimeDuration-less-than"><a href="http://www.w3.org/TR/xpath-functions/#func-dayTimeDuration-less-than">Section 
10.4.5 op:dayTimeDuration-less-than</a><sup><small>FO</small></sup></p></li><li><p id="func-divide-dayTimeDuration"><a href="http://www.w3.org/TR/xpath-functions/#func-divide-dayTimeDuration">Section 
10.6.9 op:divide-dayTimeDuration</a><sup><small>FO</small></sup></p></li><li><p id="func-divide-yearMonthDuration"><a href="http://www.w3.org/TR/xpath-functions/#func-divide-yearMonthDuration">Section 
10.6.4 op:divide-yearMonthDuration</a><sup><small>FO</small></sup></p></li><li><p id="func-data"><a href="http://www.w3.org/TR/xpath-functions/#func-data">Section 
2.4 fn:data</a><sup><small>FO</small></sup></p></li><li><p id="func-empty"><a href="http://www.w3.org/TR/xpath-functions/#func-empty">Section 
15.1.4 fn:empty</a><sup><small>FO</small></sup></p></li><li><p id="func-error"><a href="http://www.w3.org/TR/xpath-functions/#func-error">Section 
3 The Error Function</a><sup><small>FO</small></sup></p></li><li><p id="func-except"><a href="http://www.w3.org/TR/xpath-functions/#func-except">Section 
15.3.4 op:except</a><sup><small>FO</small></sup></p></li><li><p id="func-false"><a href="http://www.w3.org/TR/xpath-functions/#func-false">Section 
9.1.2 fn:false</a><sup><small>FO</small></sup></p></li><li><p id="func-intersect"><a href="http://www.w3.org/TR/xpath-functions/#func-intersect">Section 
15.3.3 op:intersect</a><sup><small>FO</small></sup></p></li><li><p id="func-is-same-node"><a href="http://www.w3.org/TR/xpath-functions/#func-is-same-node">Section 
14.6 op:is-same-node</a><sup><small>FO</small></sup></p></li><li><p id="func-last"><a href="http://www.w3.org/TR/xpath-functions/#func-last">Section 
16.2 fn:last</a><sup><small>FO</small></sup></p></li><li><p id="func-multiply-dayTimeDuration"><a href="http://www.w3.org/TR/xpath-functions/#func-multiply-dayTimeDuration">Section 
10.6.8 op:multiply-dayTimeDuration</a><sup><small>FO</small></sup></p></li><li><p id="func-multiply-yearMonthDuration"><a href="http://www.w3.org/TR/xpath-functions/#func-multiply-yearMonthDuration">Section 
10.6.3 op:multiply-yearMonthDuration</a><sup><small>FO</small></sup></p></li><li><p id="func-node-after"><a href="http://www.w3.org/TR/xpath-functions/#func-node-after">Section 
14.8 op:node-after</a><sup><small>FO</small></sup></p></li><li><p id="func-node-before"><a href="http://www.w3.org/TR/xpath-functions/#func-node-before">Section 
14.7 op:node-before</a><sup><small>FO</small></sup></p></li><li><p id="func-NOTATION-equal"><a href="http://www.w3.org/TR/xpath-functions/#func-NOTATION-equal">Section 
13.1.1 op:NOTATION-equal</a><sup><small>FO</small></sup></p></li><li><p id="func-not"><a href="http://www.w3.org/TR/xpath-functions/#func-not">Section 
9.3.1 fn:not</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-add"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-add">Section 
6.2.1 op:numeric-add</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-divide"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-divide">Section 
6.2.4 op:numeric-divide</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-equal"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">Section 
6.3.1 op:numeric-equal</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-greater-than"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-greater-than">Section 
6.3.3 op:numeric-greater-than</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-less-than"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-less-than">Section 
6.3.2 op:numeric-less-than</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-mod"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-mod">Section 
6.2.6 op:numeric-mod</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-multiply"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-multiply">Section 
6.2.3 op:numeric-multiply</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-subtract"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-subtract">Section 
6.2.2 op:numeric-subtract</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-unary-minus"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-unary-minus">Section 
6.2.8 op:numeric-unary-minus</a><sup><small>FO</small></sup></p></li><li><p id="func-numeric-unary-plus"><a href="http://www.w3.org/TR/xpath-functions/#func-numeric-unary-plus">Section 
6.2.7 op:numeric-unary-plus</a><sup><small>FO</small></sup></p></li><li><p id="func-position"><a href="http://www.w3.org/TR/xpath-functions/#func-position">Section 
16.1 fn:position</a><sup><small>FO</small></sup></p></li><li><p id="func-QName-equal"><a href="http://www.w3.org/TR/xpath-functions/#func-QName-equal">Section 
11.2.1 op:QName-equal</a><sup><small>FO</small></sup></p></li><li><p id="func-root"><a href="http://www.w3.org/TR/xpath-functions/#func-root">Section 
14.9 fn:root</a><sup><small>FO</small></sup></p></li><li><p id="func-round"><a href="http://www.w3.org/TR/xpath-functions/#func-round">Section 
6.4.4 fn:round</a><sup><small>FO</small></sup></p></li><li><p id="func-subsequence"><a href="http://www.w3.org/TR/xpath-functions/#func-subsequence">Section 
15.1.10 fn:subsequence</a><sup><small>FO</small></sup></p></li><li><p id="func-subtract-dayTimeDuration-from-dateTime"><a href="http://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDuration-from-dateTime">Section 
10.8.7 op:subtract-dayTimeDuration-from-dateTime</a><sup><small>FO</small></sup></p></li><li><p id="func-subtract-dayTimeDuration-from-date"><a href="http://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDuration-from-date">Section 
10.8.11 op:subtract-dayTimeDuration-from-date</a><sup><small>FO</small></sup></p></li><li><p id="func-subtract-dayTimeDuration-from-time"><a href="http://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDuration-from-time">Section 
10.8.13 op:subtract-dayTimeDuration-from-time</a><sup><small>FO</small></sup></p></li><li><p id="func-subtract-dayTimeDurations"><a href="http://www.w3.org/TR/xpath-functions/#func-subtract-dayTimeDurations">Section 
10.6.7 op:subtract-dayTimeDurations</a><sup><small>FO</small></sup></p></li><li><p id="func-subtract-yearMonthDuration-from-dateTime"><a href="http://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDuration-from-dateTime">Section 
10.8.6 op:subtract-yearMonthDuration-from-dateTime</a><sup><small>FO</small></sup></p></li><li><p id="func-subtract-yearMonthDuration-from-date"><a href="http://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDuration-from-date">Section 
10.8.10 op:subtract-yearMonthDuration-from-date</a><sup><small>FO</small></sup></p></li><li><p id="func-subtract-yearMonthDurations"><a href="http://www.w3.org/TR/xpath-functions/#func-subtract-yearMonthDurations">Section 
10.6.2 op:subtract-yearMonthDurations</a><sup><small>FO</small></sup></p></li><li><p id="func-to"><a href="http://www.w3.org/TR/xpath-functions/#func-to">Section 
15.5.1 op:to</a><sup><small>FO</small></sup></p></li><li><p id="func-true"><a href="http://www.w3.org/TR/xpath-functions/#func-true">Section 
9.1.1 fn:true</a><sup><small>FO</small></sup></p></li><li><p id="func-union"><a href="http://www.w3.org/TR/xpath-functions/#func-union">Section 
15.3.2 op:union</a><sup><small>FO</small></sup></p></li><li><p id="func-yearMonthDuration-equal"><a href="http://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-equal">Section 
10.4.1 op:yearMonthDuration-equal</a><sup><small>FO</small></sup></p></li><li><p id="func-yearMonthDuration-greater-than"><a href="http://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-greater-than">Section 
10.4.3 op:yearMonthDuration-greater-than</a><sup><small>FO</small></sup></p></li><li><p id="func-yearMonthDuration-less-than"><a href="http://www.w3.org/TR/xpath-functions/#func-yearMonthDuration-less-than">Section 
10.4.2 op:yearMonthDuration-less-than</a><sup><small>FO</small></sup></p></li></ul></div><div class="div2">
<h3><a id="sec_operators" name="sec_operators"/>B.2 Mapping of Overloaded Internal Functions</h3><p>This section gives the semantics specific to overloaded
    internal functions (with prefix <em>fs:</em>) that are used to
    define overloaded XQuery operators (with prefix <em>op:</em>),
    such as comparison expressions or arithmetic expressions. Static
    typing for those functions are defined over unions of (possibly
    optional) atomic types. The semantics is obtained in three
    steps. First, a rule is applied to deal with the union of those
    (possibly optional) atomic types. A second set of rules treat the
    cases where one of the operands of those functions is the empty
    type (resp. empty sequence) or optional. Finally, a final rule
    deals with type promotion and access to an operators mapping table
    which maps the overloaded internal functions to the appropriate
    operator functions defined in <a href="#xpath-functions">[Functions and Operators]</a> and give the
    corresponding type.</p><p><b>Notation</b></p>
      <p>The following auxiliary grammar production describe optional
      atomic types.</p>

      
<h5><a id="N25349" name="N25349"/>OptAtomicType</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-OptAtomicType" name="doc-fs-OptAtomicType"/>[<small>81 (Formal)</small>]   </td><td><code>OptAtomicType</code></td><td>   ::=   </td><td><code><a href="#doc-fs-AtomicTypeName">AtomicTypeName</a>  |  (<a href="#doc-fs-AtomicTypeName">AtomicTypeName</a>  "?")  |  "empty"</code></td></tr></tbody></table>

    <p><b><a class="processing" href="#processing_static">Static Type Analysis</a></b></p>
      <p>The following static typing rules apply generically to all
      the <em>fs:</em> special functions. They do not apply to any
      other function calls, which are treated in <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p>

      <p>First, if the static type of one of the expressions passed as
      argument is a union of atomic types, the function call is type
      checked once separately for each atomic type in that union. The
      static type of the entire function call expression is then the
      union of the types computed in each case.</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> = (<a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">1</font></sub><sub><font size="2">,1</font></sub>|...|<a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">m</font></sub><sub><font size="2">,1</font></sub>)
                
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
                
                  ...
                
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              
                
                  <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub> = (<a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">1</font></sub><sub><font size="2">,n</font></sub>|...|<a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">m</font></sub><sub><font size="2">,n</font></sub>)
                
              
            </td></tr>
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                  <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">1</font></sub><sub><font size="2">,1</font></sub>,..., <a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">1</font></sub><sub><font size="2">,n</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">1</font></sub>'
                
              
            </td></tr>
            <tr valign="middle" align="center"><td>...</td></tr>
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                  <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">m</font></sub><sub><font size="2">,1</font></sub>,..., <a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">m</font></sub><sub><font size="2">,n</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">r</font></sub>'
                
              
            </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                  <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>, ..., <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">n</font></sub>)
                  <a href="#jd_has_type" class="judgment"><b>:</b></a>
                  (<a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">1</font></sub>'|...|<a href="#doc-fs-OptAtomicType"><em>OptAtomicType</em></a><sub><font size="2">r</font></sub>')
                
              
            </td></tr>
          </table></td></tr></table></td></tr>
        </table><br/>
      </div>

      <p><b>Note</b></p>
        <p>Note that this approach can be used since the type declared
        for a function parameter is never itself be a union.</p>
      

      <p>The following rules deal with optional arguments. In the case
      of binary operators, if either one of the types of the operands
      is empty, the resulting type is empty.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> empty
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em><a href="#id-expanded-qnames"><em>expanded-QName</em></a></em>(<em>Expr</em><sub><font size="2">1</font></sub>,<em>Expr</em><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> empty
		
	      
	    </td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> empty
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em><a href="#id-expanded-qnames"><em>expanded-QName</em></a></em>(<em>Expr</em><sub><font size="2">1</font></sub>,<em>Expr</em><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> empty
		
	      
	    </td></tr>
	  </table><br/>
	</div>

        <p>If either one of the types of the operands is optional, the
        type obtained by propagating the optional occurrence
        indicator.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub>?
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
          <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>,<a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em><a href="#id-expanded-qnames"><em>expanded-QName</em></a></em>(<em>Expr</em><sub><font size="2">1</font></sub>,<em>Expr</em><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>?
		
	      
	    </td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>?
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub>
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
          <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>,<a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em><a href="#id-expanded-qnames"><em>expanded-QName</em></a></em>(<em>Expr</em><sub><font size="2">1</font></sub>,<em>Expr</em><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>?
		
	      
	    </td></tr>
	  </table><br/>
	</div>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>?
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub>?
		
	      
             </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
          <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>,<a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em><a href="#id-expanded-qnames"><em>expanded-QName</em></a></em>(<em>Expr</em><sub><font size="2">1</font></sub>,<em>Expr</em><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>?
		
	      
	    </td></tr>
	  </table><br/>
	</div>

      <p>In the case of unary operators, if the type of the operand is
      empty, the resulting type is empty.</p>

	<div align="center">
	  <table cellpadding="0" cellspacing="0" summary="">
	    <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em>Expr</em><sub><font size="2">1</font></sub> <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>
		
	      
             </td></tr>
	    </table></td></tr></table></td></tr>
	    <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <em><a href="#id-expanded-qnames"><em>expanded-QName</em></a></em>(<em>Expr</em><sub><font size="2">1</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> empty
		
	      
	    </td></tr>
	  </table><br/>
	</div>

      <p>Finally, the resulting type is obtained by performing type
      promotion and accessing the operators mapping table (using the
      <a href="#jd_operator_type_for" class="judgment"><b>operator type for</b></a> judgment defined below).</p>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>'
              </td></tr>
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub>'
              </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <a href="#jd_operator_type_for" class="judgment"><b>operator type for</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub> <a href="#jd_operator_type_for" class="judgment"><b>and</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub> <a href="#jd_operator_type_for" class="judgment"><b>is</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>
		
	      
             </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                  <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>,<a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>
                
              
            </td></tr>
          </table></td></tr></table></td></tr>
        </table><br/>
      </div>

      <div align="center">
        <table cellpadding="0" cellspacing="0" summary="">
          <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
                 <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                        <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub> <a href="#jd_can_be_promoted_to" class="judgment"><b>can be promoted to</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>'
              </td></tr>
             <tr valign="middle" align="center"><td>
	      
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
		
		  <a href="#jd_operator_type_for" class="judgment"><b>operator type for</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub> <a href="#jd_operator_type_for" class="judgment"><b>is</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>
		
	      
             </td></tr>
          </table></td></tr></table></td></tr>
          <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
              <a href="#xq_stat_env_def" class="env">statEnv</a> <b> |- </b>
                
                  <a href="#id-expanded-qnames"><em>expanded-QName</em></a>(<a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub>) <a href="#jd_has_type" class="judgment"><b>:</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>
                
              
            </td></tr>
          </table></td></tr></table></td></tr>
        </table><br/>
      </div>



    <p><b><a class="processing" href="#processing_dynamic">Dynamic Evaluation</a></b></p>
      <p>Each <code>fs:</code> overloaded operator maps to the
      corresponding equivalent overloaded <code>op:</code> operator,
      as defined in <a href="#xpath-functions">[Functions and Operators]</a>, and deals with the case where one
      of the operands is the empty sequence.</p>

      <p>The dynamic semantics of the <code>fs:</code> operator is
      similar to using the following user-defined function.</p>

      <table><tbody><tr><td><code>declare function</code> <em>fs:opname</em><code>($x1 as
            xdt:anyAtomicType?, $x2 as xdt:anyAtomicType?) as
            xdt:anyAtomicType? {</code></td></tr><tr><td>  <code>if (fn:empty($x1) or fn:empty($x2)) then () else</code>
            <font size="6">[</font><em>fs:opname($x1,$x2)</em><font size="6">]</font><a href="#jd_map_overloaded_op" class="judgment"><sub><font size="2">OverloadedOp</font></sub></a></td></tr><tr><td><code>};</code></td></tr></tbody></table>

      <p>Where
      <font size="6">[</font><em>fs:opname()</em><font size="6">]</font><a href="#jd_map_overloaded_op" class="judgment"><sub><font size="2">OverloadedOp</font></sub></a> maps
      to the corresponding op: operator in <a href="#xpath-functions">[Functions and Operators]</a>, as defined
      in the table below.</p>
    <p><b>Notation</b></p>
      <p>The operators mapping table is given below. The table is used
      to define the following auxiliary mapping rules and
      judgments.</p>

      <p id="jd_map_overloaded_op">The mapping rule for binary and
      unary operators</p>

      <div align="center">
        
        <font size="6">[</font><em>fs:opname1(<em>Expr</em><sub><font size="2">1</font></sub>,<em>Expr</em><sub><font size="2">2</font></sub>)</em><font size="6">]</font><a href="#jd_map_overloaded_op" class="judgment"><sub><font size="2">OverloadedOp</font></sub></a>
        == <em>op:opname2(<em>Expr</em><sub><font size="2">1</font></sub>,<em>Expr</em><sub><font size="2">2</font></sub>)</em>
        
      </div>
    
      <p>and</p>

      <div align="center">
        
        <font size="6">[</font><em>fs:opname1(<em>Expr</em><sub><font size="2">1</font></sub>)</em><font size="6">]</font><a href="#jd_map_overloaded_op" class="judgment"><sub><font size="2">OverloadedOp</font></sub></a>
        == <em>op:opname2(<em>Expr</em><sub><font size="2">1</font></sub>)</em>
        
      </div>

      <p>where the operator depends on the type of each value returned
      by <em>Expr</em><sub><font size="2">1</font></sub> and <em>Expr</em><sub><font size="2">2</font></sub>.</p>

      <p id="jd_operator_type_for">The judgments for binary and unary
      operators</p>

      <div align="center">
        
	 
	  <a href="#jd_operator_type_for" class="judgment"><b>operator type for</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub> <a href="#jd_operator_type_for" class="judgment"><b>and</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub> <a href="#jd_operator_type_for" class="judgment"><b>is</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>
	 
        
      </div>

      <p>and</p>

      <div align="center">
        
	 
	  <a href="#jd_operator_type_for" class="judgment"><b>operator type for</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub> <a href="#jd_operator_type_for" class="judgment"><b>is</b></a> <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub>
	 
        
      </div>

      <p>hold when the operator table indicates the output type
      <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub> for the input types <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub> and
      <a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub>.</p>

    <p>Note that in the following table, all numeric functions are
    applied to operands with the same type.  Values are promoted to
    compatible types using the function call semantics given in
    <a href="#id-function-calls"><b>[4.1.5 Function Calls]</b></a>.</p><p><b>Gregorian</b> refers to the types <code>xs:gYearMonth</code>,
    <code>xs:gYear</code>, <code>xs:gMonthDay</code>, <code>xs:gDay</code>, and <code>xs:gMonth</code>.  For
    binary operators that accept two Gregorian-type operands, both
    operands must have the same type (for example, if one operand is
    of type <code>xs:gDay</code>, the other operand must be of type
    <code>xs:gDay</code>.)</p><table border="1"><caption>Binary Operators</caption><tbody><tr><th><small>Internal Function</small></th><th><small><a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub></small></th><th><small><a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">2</font></sub></small></th><th><small>Denotes</small></th><th><small><a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub></small></th></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:numeric-add(A, B)</small></td><td><small><code>xs:integer</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small>op:numeric-add(A, B)</small></td><td><small><code>xs:decimal</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small>op:numeric-add(A, B)</small></td><td><small><code>xs:float</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small>op:numeric-add(A, B)</small></td><td><small><code>xs:double</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:add-yearMonthDuration-to-date(A, B)</small></td><td><small><code>xs:date</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><code>xs:date</code></small></td><td><small>op:add-yearMonthDuration-to-date(B, A)</small></td><td><small><code>xs:date</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:add-dayTimeDuration-to-date(A, B)</small></td><td><small><code>xs:date</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><code>xs:date</code></small></td><td><small>op:add-dayTimeDuration-to-date(B, A)</small></td><td><small><code>xs:date</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><code>xs:time</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:add-dayTimeDuration-to-time(A, B)</small></td><td><small><code>xs:time</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><code>xs:time</code></small></td><td><small>op:add-dayTimeDuration-to-time(B, A)</small></td><td><small><code>xs:time</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:add-yearMonthDuration-to-dateTime(A, B)</small></td><td><small><code>xs:dateTime</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><code>xs:dateTime</code></small></td><td><small>op:add-yearMonthDuration-to-dateTime(B, A)</small></td><td><small><code>xs:dateTime</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:add-dayTimeDuration-to-dateTime(A, B)</small></td><td><small><code>xs:dateTime</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><code>xs:dateTime</code></small></td><td><small>op:add-dayTimeDuration-to-dateTime(B, A)</small></td><td><small><code>xs:dateTime</code></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:add-yearMonthDurations(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td></tr><tr><td><small><em>fs:</em><code>plus</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:add-dayTimeDurations(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:numeric-subtract(A, B)</small></td><td><small><code>xs:integer</code></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small>op:numeric-subtract(A, B)</small></td><td><small><code>xs:decimal</code></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small>op:numeric-subtract(A, B)</small></td><td><small><code>xs:float</code></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small>op:numeric-subtract(A, B)</small></td><td><small><code>xs:double</code></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><code>xs:date</code></small></td><td><small>fn:subtract-dates(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:subtract-yearMonthDuration-from-date(A, B)</small></td><td><small><code>xs:date</code></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:subtract-dayTimeDuration-from-date(A, B)</small></td><td><small><code>xs:date</code></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:time</code></small></td><td><small><code>xs:time</code></small></td><td><small>fn:subtract-times(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:time</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:subtract-dayTimeDuration-from-time(A, B)</small></td><td><small><code>xs:time</code></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><code>xs:dateTime</code></small></td><td><small>fn:get-dayTimeDuration-from-dateTimes(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:subtract-yearMonthDuration-from-dateTime(A, B)</small></td><td><small><code>xs:dateTime</code></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:subtract-dayTimeDuration-from-dateTime(A, B)</small></td><td><small><code>xs:dateTime</code></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:subtract-yearMonthDurations(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td></tr><tr><td><small><em>fs:</em><code>minus</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:subtract-dayTimeDurations(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td></tr><tr><td><small><em>fs:</em><code>times</code>(A, B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:numeric-multiply(A, B)</small></td><td><small><code>xs:integer</code></small></td></tr><tr><td><small><em>fs:</em><code>times</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small>op:numeric-multiply(A, B)</small></td><td><small><code>xs:decimal</code></small></td></tr><tr><td><small><em>fs:</em><code>times</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small>op:numeric-multiply(A, B)</small></td><td><small><code>xs:float</code></small></td></tr><tr><td><small><em>fs:</em><code>times</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small>op:numeric-multiply(A, B)</small></td><td><small><code>xs:double</code></small></td></tr><tr><td><small><em>fs:</em><code>times</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><code>xs:double</code></small></td><td><small>op:multiply-yearMonthDuration(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td></tr><tr><td><small><em>fs:</em><code>times</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:multiply-yearMonthDuration(B, A)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td></tr><tr><td><small><em>fs:</em><code>times</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><code>xs:double</code></small></td><td><small>op:multiply-dayTimeDuration(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td></tr><tr><td><small><em>fs:</em><code>times</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:multiply-dayTimeDuration(B, A)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td></tr><tr><td><small><em>fs:</em><code>idiv</code>(A, B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:integer-div(A, B)</small></td><td><small><code>xs:integer</code></small></td></tr><tr><td><small><em>fs:</em><code>div</code>(A, B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:numeric-divide(A, B)</small></td><td><small><code>xs:double</code></small></td></tr><tr><td><small><em>fs:</em><code>div</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small>op:numeric-divide(A, B)</small></td><td><small><code>xs:decimal</code></small></td></tr><tr><td><small><em>fs:</em><code>div</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small>op:numeric-divide(A, B)</small></td><td><small><code>xs:float</code></small></td></tr><tr><td><small><em>fs:</em><code>div</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small>op:numeric-divide(A, B)</small></td><td><small><code>xs:double</code></small></td></tr><tr><td><small><em>fs:</em><code>div</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><code>xs:double</code></small></td><td><small>op:divide-yearMonthDuration(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td></tr><tr><td><small><em>fs:</em><code>div</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><code>xs:double</code></small></td><td><small>op:divide-dayTimeDuration(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td></tr><tr><td><small><em>fs:</em><code>div</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:divide-yearMonthDuration-by-yearMonthDuration(A, B)</small></td><td><small><code>xs:decimal</code></small></td></tr><tr><td><small><em>fs:</em><code>div</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:divide-dayTimeDuration-by-dayTimeDuration(A, B)</small></td><td><small><code>xs:decimal</code></small></td></tr><tr><td><small><em>fs:</em><code>mod</code>(A, B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:numeric-mod(A, B)</small></td><td><small><code>xs:integer</code></small></td></tr><tr><td><small><em>fs:</em><code>mod</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small>op:numeric-mod(A, B)</small></td><td><small><code>xs:decimal</code></small></td></tr><tr><td><small><em>fs:</em><code>mod</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small>op:numeric-mod(A, B)</small></td><td><small><code>xs:float</code></small></td></tr><tr><td><small><em>fs:</em><code>mod</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small>op:numeric-mod(A, B)</small></td><td><small><code>xs:double</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:numeric-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small>op:numeric-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small>op:numeric-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small>op:numeric-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:boolean</code></small></td><td><small><code>xs:boolean</code></small></td><td><small>op:boolean-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:string</code></small></td><td><small><code>xs:string</code></small></td><td><small>op:numeric-equal(fn:compare(A, B), 1)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><code>xs:date</code></small></td><td><small>op:date-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:time</code></small></td><td><small><code>xs:time</code></small></td><td><small>op:time-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><code>xs:dateTime</code></small></td><td><small>op:datetime-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:yearMonthDuration-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:dayTimeDuration-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small>Gregorian</small></td><td><small>Gregorian</small></td><td><small>op:gYear-equal(A, B) etc.</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:hexBinary</code></small></td><td><small><code>xs:hexBinary</code></small></td><td><small>op:hex-binary-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:base64Binary</code></small></td><td><small><code>xs:base64Binary</code></small></td><td><small>op:base64-binary-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:anyURI</code></small></td><td><small><code>xs:anyURI</code></small></td><td><small>op:anyURI-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:QName</code></small></td><td><small><code>xs:QName</code></small></td><td><small>op:QName-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>eq</code>(A, B)</small></td><td><small><code>xs:NOTATION</code></small></td><td><small><code>xs:NOTATION</code></small></td><td><small>op:NOTATION-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small><code>fn:not</code>(op:numeric-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:boolean</code></small></td><td><small><code>xs:boolean</code></small></td><td><small><code>fn:not</code>(op:boolean-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:string</code></small></td><td><small><code>xs:string</code></small></td><td><small><code>fn:not</code>(op:numeric-equal(fn:compare(A, B), 1))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><code>xs:date</code></small></td><td><small><code>fn:not</code>(op:date-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:time</code></small></td><td><small><code>xs:time</code></small></td><td><small><code>fn:not</code>(op:time-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><code>xs:dateTime</code></small></td><td><small><code>fn:not</code>(op:datetime-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><code>fn:not</code>(op:yearMonthDuration-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><code>fn:not</code>(op:dayTimeDuration-equal(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small>Gregorian</small></td><td><small>Gregorian</small></td><td><small><code>fn:not</code>(op:gYear-equal(A, B)) etc.</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:hexBinary</code></small></td><td><small><code>xs:hexBinary</code></small></td><td><small><code>fn:not</code>(op:hex-binary-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:base64Binary</code></small></td><td><small><code>xs:base64Binary</code></small></td><td><small><code>fn:not</code>(op:base64-binary-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:anyURI</code></small></td><td><small><code>xs:anyURI</code></small></td><td><small><code>fn:not</code>(op:anyURI-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:QName</code></small></td><td><small><code>xs:QName</code></small></td><td><small><code>fn:not</code>(op:QName-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ne</code>(A, B)</small></td><td><small><code>xs:NOTATION</code></small></td><td><small><code>xs:NOTATION</code></small></td><td><small><code>fn:not</code>(op:NOTATION-equal(A, B))</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small>integer</small></td><td><small>integer</small></td><td><small>op:numeric-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small>decimal</small></td><td><small>decimal</small></td><td><small>op:numeric-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small>float</small></td><td><small>float</small></td><td><small>op:numeric-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small>double</small></td><td><small>double</small></td><td><small>op:numeric-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small><code>xs:boolean</code></small></td><td><small><code>xs:boolean</code></small></td><td><small>op:boolean-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small><code>xs:string</code></small></td><td><small><code>xs:string</code></small></td><td><small>op:numeric-greater-than(<code>fn:compare</code>(A, B), 0)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><code>xs:date</code></small></td><td><small>op:date-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small><code>xs:time</code></small></td><td><small><code>xs:time</code></small></td><td><small>op:time-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><code>xs:dateTime</code></small></td><td><small>op:datetime-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:yearMonthDuration-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>gt</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:dayTimeDuration-greater-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:numeric-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small>op:numeric-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small>op:numeric-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small>op:numeric-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><code>xs:boolean</code></small></td><td><small><code>xs:boolean</code></small></td><td><small>op:boolean-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><code>xs:string</code></small></td><td><small><code>xs:string</code></small></td><td><small>op:numeric-less-than(<code>fn:compare</code>(A, B), 0)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><code>xs:date</code></small></td><td><small>op:date-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><code>xs:time</code></small></td><td><small><code>xs:time</code></small></td><td><small>op:time-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><code>xs:dateTime</code></small></td><td><small>op:datetime-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:yearMonthDuration-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>lt</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:dayTimeDuration-less-than(A, B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A,
    B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><code>xs:boolean</code></small></td><td><small><code>xs:boolean</code></small></td><td><small>op:numeric-greater-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><code>xs:string</code></small></td><td><small><code>xs:string</code></small></td><td><small>op:numeric-greater-than(<code>fn:compare</code>(A, B), -1)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><code>xs:date</code></small></td><td><small>op:date-less-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><code>xs:time</code></small></td><td><small><code>xs:time</code></small></td><td><small>op:time-less-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><code>xs:dateTime</code></small></td><td><small>op:datetime-less-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:yearMonthDuration-less-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>ge</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:dayTimeDuration-less-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A,
    B)</small></td><td><small><code>xs:integer</code></small></td><td><small><code>xs:integer</code></small></td><td><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><code>xs:decimal</code></small></td><td><small><code>xs:decimal</code></small></td><td><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><code>xs:float</code></small></td><td><small><code>xs:float</code></small></td><td><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><code>xs:double</code></small></td><td><small><code>xs:double</code></small></td><td><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><code>xs:boolean</code></small></td><td><small><code>xs:boolean</code></small></td><td><small>op:numeric-less-than(A, B) or op:numeric-equal(A,B)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><code>xs:string</code></small></td><td><small><code>xs:string</code></small></td><td><small>op:numeric-less-than(<code>fn:compare</code>(A, B), 1)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><code>xs:date</code></small></td><td><small><code>xs:date</code></small></td><td><small>op:date-greater-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><code>xs:time</code></small></td><td><small><code>xs:time</code></small></td><td><small>op:time-greater-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><code>xs:dateTime</code></small></td><td><small><code>xs:dateTime</code></small></td><td><small>op:datetime-greater-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small><a href="#dt-xdt_durations"><code>xdt:yearMonthDuration</code></a></small></td><td><small>op:yearMonthDuration-greater-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>le</code>(A, B)</small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small><a href="#dt-xdt_durations"><code>xdt:dayTimeDuration</code></a>      </small></td><td><small>op:dayTimeDuration-greater-than(B, A)</small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>is-same-node</code>(A, B)</small></td><td><small>node()</small></td><td><small>node()</small></td><td><small><code>op:is-same-node</code></small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>node-before</code>(A, B)</small></td><td><small>node()</small></td><td><small>node()</small></td><td><small><code>op:node-before</code></small></td><td><small><code>xs:boolean</code></small></td></tr><tr><td><small><em>fs:</em><code>node-after</code>(A,
    B)</small></td><td><small>node()</small></td><td><small>node()</small></td><td><small><code>op:node-after</code></small></td><td><small><code>xs:boolean</code></small></td></tr></tbody></table><table border="1" summary="Unary operators" class="small"><caption>Unary Operators</caption><tbody><tr><th>Internal Function</th><th><a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">1</font></sub></th><th>Denotes</th><th><a href="#doc-core-AtomicType"><em>AtomicType</em></a><sub><font size="2">3</font></sub></th></tr><tr><td><em>fs:</em><code>unary-plus</code>(A)</td><td><code>xs:integer</code></td><td>op:numeric-unary-plus(A)</td><td><code>xs:integer</code></td></tr><tr><td><em>fs:</em><code>unary-plus</code>(A)</td><td><code>xs:decimal</code></td><td>op:numeric-unary-plus(A)</td><td><code>xs:decimal</code></td></tr><tr><td><em>fs:</em><code>unary-plus</code>(A)</td><td><code>xs:float</code></td><td>op:numeric-unary-plus(A)</td><td><code>xs:float</code></td></tr><tr><td><em>fs:</em><code>unary-plus</code>(A)</td><td><code>xs:double</code></td><td>op:numeric-unary-plus(A)</td><td><code>xs:double</code></td></tr><tr><td><em>fs:</em><code>unary-minus</code>(A)</td><td><code>xs:integer</code></td><td>op:numeric-unary-minus(A)</td><td><code>xs:integer</code></td></tr><tr><td><em>fs:</em><code>unary-minus</code>(A)</td><td><code>xs:decimal</code></td><td>op:numeric-unary-minus(A)</td><td><code>xs:decimal</code></td></tr><tr><td><em>fs:</em><code>unary-minus</code>(A)</td><td><code>xs:float</code></td><td>op:numeric-unary-minus(A)</td><td><code>xs:float</code></td></tr><tr><td><em>fs:</em><code>unary-minus</code>(A)</td><td><code>xs:double</code></td><td>op:numeric-unary-minus(A)</td><td><code>xs:double</code></td></tr></tbody></table></div></div><div class="div1">
<h2><a id="sec_importing_schema" name="sec_importing_schema"/>C Importing Schemas</h2><p>This section describes how XML Schema declarations, as specified
  by XML Schema are imported into the [XPath/XQuery] type system.</p><div class="div2">
<h3><a id="sec_import_intro" name="sec_import_intro"/>C.1 Introduction</h3><p>At compile time, the [XPath/XQuery] environment imports XML Schema
    declarations and loads them as declarations in the [XPath/XQuery] type
    system. The semantics of that loading process is defined by
    normalization rules that map XML Schema descriptions into the
    [XPath/XQuery] type system.</p><div class="div3">
<h4><a id="sec_import_features" name="sec_import_features"/>C.1.1 Features</h4><p>Here is summarized the XML Schema features which are covered
      by the formal semantics, and handled by the import mapping
      described in this section. For each feature, the following
      indications are used.</p><ul><li><p><b>Handled</b> indicates features that are relevant for
          [XPath/XQuery], are modeled in the [XPath/XQuery] type system,
          and are supported by the mapping.</p></li><li><p><b>Not in v1.0</b> indicates features that  are relevant to
          [XPath/XQuery], but are not yet modeled in the [XPath/XQuery]
          type system or are not handled by the mapping in XQuery
          V1.0. In case the [XPath/XQuery]
          type system provides appropriate support for those features,
          but the mapping is incomplete, the additional annotation
          <b>mapping only</b> is used.</p></li><li><p><b>Not handled</b> indicates features that are relevant
          for [XPath/XQuery], but are not modeled in the [XPath/XQuery]
          type system, and are not handled by the mapping. Such
          features are typically only related to validation, for which
          the formal semantics defines a partial model.</p></li><li><p><b>Ignored</b> Indicates features that are not relevant
          for [XPath/XQuery], are not modeled in the [XPath/XQuery] type
          system, and are not relevant for the mapping. Such features
          might have to do with documentation of the schema, or might
          affect which Schemas are legal, but do not affect which
          documents match which Schemas.</p></li></ul><p>Here is the exhaustive list of XML Schema features and their
      status in this document.</p><table summary="" class="figure"><col align="left" span="1"/><col align="center" span="1"/><col align="left" span="1"/><tbody><tr><td><b>Feature:</b></td><td><b>Supported</b></td></tr><tr><td>Primitive Simple types</td><td>Handled</td></tr><tr><td>Simple type derivation by restriction</td><td>Handled</td></tr><tr><td>Derivation by list and union</td><td>Handled</td></tr><tr><td>Facets on simple types</td><td>Not handled</td></tr><tr><td>ID and IDREF constraints</td><td>Ignored</td></tr><tr><td>Attribute Declarations</td><td/></tr><tr><td>    default,fixed,use</td><td>Not in v1.0</td></tr><tr><td>Element Declarations</td><td/></tr><tr><td>    default, fixed (value constraint)</td><td>Not in v1.0</td></tr><tr><td>    nillable</td><td>Handled</td></tr><tr><td>    substitution group affiliation</td><td>Handled</td></tr><tr><td>    substitution group exclusions</td><td>Ignored</td></tr><tr><td>    disallowed substitutions</td><td>Ignored</td></tr><tr><td>    abstract</td><td>Not in v1.0</td></tr><tr><td>Complex Type Definitions</td><td/></tr><tr><td>    derivation by restriction</td><td>Handled</td></tr><tr><td>    derivation by extension</td><td>Handled</td></tr><tr><td>    final</td><td>Ignored</td></tr><tr><td>    abstract</td><td>Not in v1.0</td></tr><tr><td>AttributeUses</td><td/></tr><tr><td>    required</td><td>Not in v1.0, mapping only</td></tr><tr><td>    default, fixed (value constraint)</td><td>Not in v1.0</td></tr><tr><td>Attribute Group Definitions</td><td>Not in v1.0, mapping only</td></tr><tr><td>Model Group Definitions</td><td>Not in v1.0, mapping only</td></tr><tr><td>Model Groups</td><td>Handled</td></tr><tr><td>Particles</td><td>Handled</td></tr><tr><td>Wildcards</td><td/></tr><tr><td>    process contents strict, skip, lax</td><td>Ignored</td></tr><tr><td>    namespace wild cards.</td><td>Ignored</td></tr><tr><td>Identity-constraint Definitions</td><td>Ignored</td></tr><tr><td>Notation Declarations</td><td>Ignored</td></tr><tr><td>Annotations</td><td>Ignored</td></tr></tbody></table><p>Note that the schema import feature specified here assumes
        it is given a legal schema as input. As a result, it is not
        necessary to check for 'block' or 'abstract' attributes.</p></div><div class="div3">
<h4><a id="sec_import_organization" name="sec_import_organization"/>C.1.2 Organization</h4><p>The presentation of the schema mapping is done according to
      the following organization.</p><p><b>Schema component</b></p>
  
    	<p>First each schema component is summarized using the same
    	notation used in the XML Representation Summary sections in
    	XML Schema. For instance, here is the XML Representation
    	Summary for complex types.</p>
  
    	<div class="exampleInner">
    	  <table summary=""><tbody><tr><td>  &lt;complexType</td></tr><tr><td>       <b> [ ignored ]  </b>
    	       abstract = boolean : false
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       block = (#all | List of (extension | restriction))
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       final = (#all | List of (extension | restriction))
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       id = ID
    	    </td></tr><tr><td>       
    	       mixed = boolean : false
    	    </td></tr><tr><td>       
    	       name = NCName
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       {any schemaAttributes with non-schema namespace ...}
    	    &gt;</td></tr><tr><td>       
    	      Content: (annotation?, (simpleContent | complexContent |
    	      ((group | all | choice | sequence)?, ((schemaAttribute |
    	      schemaAttributeGroup)*, anySchemaAttribute?))))
    	    </td></tr><tr><td>  &lt;/complexType&gt;</td></tr></tbody></table>
    	</div>
  
    	<p>Attributes indicated as <b>[ ignored ]</b> are not mapped
    	into the [XPath/XQuery] type system.</p>
  
    	<p>Attributes indicated as <b>[ not handled ]</b> are not
    	currently handled by the mapping.</p>
  
    	<p>Note that in order to simplify the mapping, it is assumed
    	that the default values for all attributes in the XML
    	Representation of Schema are filled in. For instance in the
    	above complex type, if the <code>mixed</code> attribute is not
    	present, it will be treated as being present and having the
    	value <code>"false"</code>.</p>
  
      <p><b>Schema mapping</b></p>
  
    	<p>XML Schema import is specified by means of mapping
    	rules. All mapping rules have the structure below.</p>
  
    	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
    	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
    	    
    	      <font size="6">[</font><em>SchemaComponent</em><font size="6">]</font><sub><font size="2">Subscript</font></sub>
    	    
    	  </td></tr>
    	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
    	    
    	      <em>TypeComponent</em>
    	    
    	  </td></tr>
    	</table></div>
  
    	<p>The <em>SchemaComponent</em> above the horizontal rule
    	denotes an XML Schema component before translation and the
    	<em>TypeComponent</em> beneath the horizontal rule denotes
    	an equivalent type component in the [XPath/XQuery] type system.</p>
  
      <p><b>Notation</b></p>
  
    	<p>Whenever necessary for the mapping rules, specific grammar
    	productions which describe fragments of XML Schema may be
    	introduced. For instance, here are grammar productions used to
    	describes fragments of the XML Representation Summary for the
    	complexType Element Information Item.</p>
  
    	
<h5><a id="N26EA7" name="N26EA7"/>Complex type content</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="noid_N263F5.doc-fs-ComplexTypeContent" name="noid_N263F5.doc-fs-ComplexTypeContent"/>[<small>62 (Formal)</small>]   </td><td><code>ComplexTypeContent</code></td><td>   ::=   </td><td><code>"annotation"?  ("simpleContent"  |  "complexContent"  |  (<a href="#doc-fs-ChildrenContent">ChildrenContent</a>  <a href="#doc-fs-AttributeContent">AttributeContent</a>))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="noid_N263FB.doc-fs-AttributeContent" name="noid_N263FB.doc-fs-AttributeContent"/>[<small>65 (Formal)</small>]   </td><td><code>AttributeContent</code></td><td>   ::=   </td><td><code>("attribute"  |  "attributeGroup")*  "anyAttribute"?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="noid_N26401.doc-fs-ChildrenContent" name="noid_N26401.doc-fs-ChildrenContent"/>[<small>63 (Formal)</small>]   </td><td><code>ChildrenContent</code></td><td>   ::=   </td><td><code>("group"  |  "all"  |  "choice"  |  "sequence")?</code></td></tr></tbody></table>
   
    	<p>As in the rest of this document, some mapping rules may use
    	fragments of the XML Representation corresponding to the
    	syntactic categories defined by those grammar productions. For
    	instance, the following complex type fragment uses the
    	syntactic categories: <a href="#doc-fs-TypeName"><em>TypeName</em></a>, <em>ComplexTypeContent</em>,
    	and <em>AttributeContent</em>, <em>ChildrenContent</em>, and
    	<em>MixedAttribute</em>.</p>
  
    	<table summary=""><tbody><tr><td>  &lt;complexType</td></tr><tr><td>       
    	     name = <a href="#doc-fs-TypeName"><em>TypeName</em></a>
    	  </td></tr><tr><td>       
    	     <em>MixedAttribute</em>
    	  &gt;</td></tr><tr><td>       <em>ChildrenContent</em> <em>AttributeContent</em></td></tr><tr><td>  &lt;/complexType&gt;</td></tr></tbody></table>
  
      </div><div class="div3">
<h4><a id="sec_import_mapping" name="sec_import_mapping"/>C.1.3 Main mapping rules</h4><p><b>Notation</b></p>
        <p id="jd_map_schema">The normalization rule</p>

        <div align="center">
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
  	         <font size="6">[</font><em>Schema</em><font size="6">]</font><a href="#jd_map_schema" class="judgment"><sub><font size="2">Schema</font></sub></a>
              
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  	        <em>Definitions</em>
              
  	    </td></tr>
  	  </table></div>
        </div>

        <p>maps a complete schema into a set of <em>Definitions</em> in
        the [XPath/XQuery] type system.</p>

  	<p id="jd_map_definition">The normalization rule</p>

  	<div align="center">
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
  	         <font size="6">[</font><em>SchemaComponent</em><font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>
              
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  	        <a href="#sec_top_level_definitions"><em>Definition</em></a>
              
  	    </td></tr>
  	  </table></div>
  	</div>

        <p>maps a top level schema component into a <a href="#sec_top_level_definitions"><em>Definition</em></a> in
        the [XPath/XQuery] type system, given the target namespace
        <em>target</em><em>URI</em>.</p>

  	<p id="jd_map_content">The normalization rule</p>
      	
  	<div align="center">
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
  	         <font size="6">[</font><em>SchemaComponent</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
              
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  	        <em>TypeComponent</em>
              
  	    </td></tr>
  	  </table></div>
  	</div>

        <p>maps a schema component not directly under the schema
        element, into a <em>TypeComponent</em> in the [XPath/XQuery]
        type system, given the target namespace <em>target</em><em>URI</em>.</p>
      </div><div class="div3">
<h4><a id="sec_use" name="sec_use"/>C.1.4 Special attributes</h4><p>The XML Schema attributes: use, default, fixed, minOccurs,
      maxOccurs, mixed, nillable, and substitutionGroup, require
      specific mapping rules.</p><div class="div4">
<h5><a id="sec_import_attributes" name="sec_import_attributes"/>C.1.4.1 use, default, and fixed</h5><p>The "use", "default", and
        "fixed" attributes are used to describe the
        occurrence and default behavior of a given attribute.</p><p><b>Notation</b></p>
  	  <p>The following auxiliary grammar productions are used to
  	  describe the "use", "default", and
  	  "fixed" attributes.</p>
      
  	  
<h5><a id="N26FB5" name="N26FB5"/>Use, default, and fixed attributes</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-UseAttribute" name="doc-fs-UseAttribute"/>[<small>67 (Formal)</small>]   </td><td><code>UseAttribute</code></td><td>   ::=   </td><td><code>"use"  "="  ("optional"  |  "prohibited"  |  "required")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-DefaultAttribute" name="doc-fs-DefaultAttribute"/>[<small>68 (Formal)</small>]   </td><td><code>DefaultAttribute</code></td><td>   ::=   </td><td><code>"default"  "="  String</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-FixedAttribute" name="doc-fs-FixedAttribute"/>[<small>69 (Formal)</small>]   </td><td><code>FixedAttribute</code></td><td>   ::=   </td><td><code>"fixed"  "="  String</code></td></tr></tbody></table>

  	  <p id="jd_map_use">The normalization rule</p>
      
  	  <div align="center">
  	    <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <font size="6">[</font><em>UseAttribute</em> <em>DefaultAttribute</em>? <em>FixedAttribute</em>? <font size="6">]</font><a href="#jd_map_use" class="judgment"><sub><font size="2">use</font></sub></a>
  		
  	      </td></tr>
  	      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <em>Occurrence</em>
  		
  	      </td></tr>
  	    </table></div>
  	  </div>
  
  	  <p>maps a combination of a use attribute <em>UseAttribute</em>,
  	  along with an optional default or fixed attribute in Schema
  	  into the occurrence indicator <em>Occurrence</em> in the
  	  [XPath/XQuery] type system.</p>
  	<p><b>Schema mapping</b></p>
  	  <p>Use attributes are mapped to the type system in the
  	  following way. In case there is a default or fixed
  	  attribute, the attribute is always present in the PSVI and
  	  the use attribute is ignored.</p>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <em>UseAttribute</em> <em>DefaultAttribute</em><a href="#jd_map_use" class="judgment"><sub><font size="2">use</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      1
  	    </td></tr>
  	  </table></div>
  	
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <em>UseAttribute</em> <em>FixedAttribute</em><a href="#jd_map_use" class="judgment"><sub><font size="2">use</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      1
  	    </td></tr>
  	  </table></div>
  	
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      use = "optional"<a href="#jd_map_use" class="judgment"><sub><font size="2">use</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      ?
  	    </td></tr>
  	  </table></div>
  	
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      use = "required"<a href="#jd_map_use" class="judgment"><sub><font size="2">use</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      1
  	    </td></tr>
  	  </table></div>
  	
  	  <table border="1" summary="Editorial note"><tr><td width="50%" valign="top" align="left"><b>Editorial note</b></td><td width="50%" valign="top" align="right"> </td></tr><tr><td valign="top" align="left" colspan="2">Issue: how derivation of attribute declaration and
  	    the "prohibited" use attributes are mapped in
  	    the [XPath/XQuery] type system is still an open
  	    issue.</td></tr></table>
  
  	</div><div class="div4">
<h5><a id="prod-formal-OccursAttributes" name="prod-formal-OccursAttributes"/>C.1.4.2 minOccurs, maxOccurs, minLength, maxLength, and length</h5><p><b>Notation</b></p>
  	  <p>The following auxiliary grammar productions are used to
  	  describe occurrence attributes and the length facets.</p>
  	  
  	  
<h5><a id="N27072" name="N27072"/>Occurrence attributes</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-OccursAttributes" name="doc-fs-OccursAttributes"/>[<small>61 (Formal)</small>]   </td><td><code>OccursAttributes</code></td><td>   ::=   </td><td><code><a href="#doc-fs-maxOccurs">maxOccurs</a>  |  <a href="#doc-fs-minOccurs">minOccurs</a>  |  <a href="#doc-fs-maxLength">maxLength</a>  |  <a href="#doc-fs-minLength">minLength</a>  |  <a href="#doc-fs-length">length</a></code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-maxOccurs" name="doc-fs-maxOccurs"/>[<small>59 (Formal)</small>]   </td><td><code>maxOccurs</code></td><td>   ::=   </td><td><code>"maxOccurs"  "="  ("nonNegativeInteger"  |  "unbounded")</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-minOccurs" name="doc-fs-minOccurs"/>[<small>60 (Formal)</small>]   </td><td><code>minOccurs</code></td><td>   ::=   </td><td><code>"minOccurs"  "="  "nonNegativeInteger"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-maxLength" name="doc-fs-maxLength"/>[<small>56 (Formal)</small>]   </td><td><code>maxLength</code></td><td>   ::=   </td><td><code>"maxLength"  "="  "nonNegativeInteger"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-minLength" name="doc-fs-minLength"/>[<small>57 (Formal)</small>]   </td><td><code>minLength</code></td><td>   ::=   </td><td><code>"minLength"  "="  "nonNegativeInteger"</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-length" name="doc-fs-length"/>[<small>58 (Formal)</small>]   </td><td><code>length</code></td><td>   ::=   </td><td><code>"length"  "="  "nonNegativeInteger"</code></td></tr></tbody></table>
  
  	  <p id="jd_map_occurs">The normalization rule</p>
      
  	  <div align="center">
  	    <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  		
  	      </td></tr>
  	      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <em>Occurrence</em>
  		
  	      </td></tr>
  	    </table></div>
  	  </div>
  
  	  <p>maps the occurrence attributes and facets <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a> in
  	  Schema into the occurrence indicator <em>Occurrence</em> in the
  	  [XPath/XQuery] type system.</p>
  	<p><b>Schema mapping</b></p>
  	  
  	  <p>Occurrence attributes are mapped to the type system in
  	  the following way.</p>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minOccurs="0" maxOccurs="1"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      ?
  	    </td></tr>
  	  </table></div>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minOccurs="1" maxOccurs="1"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  	    </td></tr>
  	  </table></div>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minOccurs="0" maxOccurs="n"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      *
  	    </td></tr>
  	  </table></div>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minOccurs="1" maxOccurs="n"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      +
  	    </td></tr>
  	  </table></div>
  	  
  	  <p>where n &gt; 1.</p>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minOccurs="n" maxOccurs="m"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      +
  	    </td></tr>
  	  </table></div>
  	  
  	  <p>where m &gt;= n &gt; 1</p>

  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minLength="0" maxLength="1"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      ?
  	    </td></tr>
  	  </table></div>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minLength="1" maxLength="1"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  	    </td></tr>
  	  </table></div>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minLength="0" maxLength="n"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      *
  	    </td></tr>
  	  </table></div>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minLength="1" maxLength="n"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      +
  	    </td></tr>
  	  </table></div>
  	  
  	  <p>where n &gt; 1.</p>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>minLength="n" maxLength="m"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      +
  	    </td></tr>
  	  </table></div>
  	  
  	  <p>where m &gt;= n &gt; 1</p>

  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>length="1"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  	    </td></tr>
  	  </table></div>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      <font size="6">[</font>length="n"<font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      +
  	    </td></tr>
  	  </table></div>
  	  
  	  <p>where n &gt; 1</p>
  	</div><div class="div4">
<h5><a id="sec_import_mixed" name="sec_import_mixed"/>C.1.4.3 mixed</h5><p><b>Notation</b></p>
  	  <p>The following auxiliary grammar productions are used to
  	  describe the "mixed" attribute.</p>
    
  	  
<h5><a id="N27211" name="N27211"/>Mixed attribute</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-MixedAttribute" name="doc-fs-MixedAttribute"/>[<small>53 (Formal)</small>]   </td><td><code>MixedAttribute</code></td><td>   ::=   </td><td><code>"mixed"  "="  Boolean</code></td></tr></tbody></table>
  
  	  <p id="jd_map_mixed">The normalization rule</p>
      
  	  <div align="center">
  	    <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <font size="6">[</font><em>MixedAttribute</em><font size="6">]</font><a href="#jd_map_mixed" class="judgment"><sub><font size="2">mixed</font></sub></a>
  		
  	      </td></tr>
  	      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <a href="#doc-fs-Mixed"><em>Mixed</em></a>
  		
  	      </td></tr>
  	    </table></div>
  	  </div>
  
  	  <p>maps the mixed attribute <em>MixedAttribute</em> in Schema into
  	  a <a href="#doc-fs-Mixed"><em>Mixed</em></a> notation in the [XPath/XQuery] type system.</p>
  	<p><b>Schema mapping</b></p>
  	  <p>If the mixed attribute is true it is mapped to a mixed
  	  notation in the [XPath/XQuery] type system.</p>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  		<font size="6">[</font>
  		  mixed = "true"
  	      <font size="6">]</font><a href="#jd_map_mixed" class="judgment"><sub><font size="2">mixed</font></sub></a>
  	    
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      mixed
  	    </td></tr>
  	  </table></div>
  	  
  	  <p>If the mixed attribute is false it is mapped to empty in
  	  the [XPath/XQuery] type system.</p>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  		<font size="6">[</font>
  		  mixed = "false"
  		<font size="6">]</font><a href="#jd_map_mixed" class="judgment"><sub><font size="2">mixed</font></sub></a>
  	    
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  	    </td></tr>
  	  </table></div>
  	
  	</div><div class="div4">
<h5><a id="sec_import_nillable" name="sec_import_nillable"/>C.1.4.4 nillable</h5><p><b>Notation</b></p>
  	  <p>The following auxiliary grammar productions are used to
  	  describe the "nillable" attribute.</p>
    
  	  
<h5><a id="N27293" name="N27293"/>Nillable attribute</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-NillableAttribute" name="doc-fs-NillableAttribute"/>[<small>54 (Formal)</small>]   </td><td><code>NillableAttribute</code></td><td>   ::=   </td><td><code>"nillable"  "="  Boolean</code></td></tr></tbody></table>
  
  	  <p id="jd_map_nillable">The normalization rule</p>
      
  	  <div align="center">
  	    <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <font size="6">[</font><em>NillableAttribute</em><font size="6">]</font><a href="#jd_map_nillable" class="judgment"><sub><font size="2">nillable</font></sub></a>
  		
  	      </td></tr>
  	      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <a href="#doc-fs-Nillable"><em>Nillable</em></a>
  		
  	      </td></tr>
  	    </table></div>
  	  </div>
  
  	  <p>maps the nillable attribute <em>NillableAttribute</em> in
  	  Schema into a <a href="#doc-fs-Nillable"><em>Nillable</em></a> notation in the [XPath/XQuery] type
  	  system.</p>
  	<p><b>Schema mapping</b></p>
  	  <p>If the nillable attribute is true it is mapped to a
  	  nillable notation in the [XPath/XQuery] type system.</p>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  		<font size="6">[</font>
  		  nillable = "true"
  	      <font size="6">]</font><a href="#jd_map_nillable" class="judgment"><sub><font size="2">nillable</font></sub></a>
  	    
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      nillable
  	    </td></tr>
  	  </table></div>
  	  
  	  <p>If the nillable attribute is false it is mapped to empty
  	  in the [XPath/XQuery] type system.</p>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  		<font size="6">[</font>
  		  nillable = "false"
  		<font size="6">]</font><a href="#jd_map_nillable" class="judgment"><sub><font size="2">nillable</font></sub></a>
  	    
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  	    </td></tr>
  	  </table></div>
  	
  	</div><div class="div4">
<h5><a id="sec_import_substitution" name="sec_import_substitution"/>C.1.4.5 substitutionGroup</h5><p><b>Notation</b></p>
  	  <p>The substitution group declaration indicates the element
  	  that a given element can be substituted for. The following
  	  auxiliary grammar productions are used to describe the
  	  "substitutionGroup" attribute.</p>
    
  	  
<h5><a id="N27315" name="N27315"/>substitutionGroup attribute</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-substitutionGroupAttribute" name="doc-fs-substitutionGroupAttribute"/>[<small>55 (Formal)</small>]   </td><td><code>substitutionGroupAttribute</code></td><td>   ::=   </td><td><code>"substitutionGroup"  "="  <a href="#prod-core-QName">QName</a></code></td></tr></tbody></table>
  
  	  <p id="jd_map_substitution">The normalization rule</p>
      
  	  <div align="center">
  	    <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	      <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <font size="6">[</font><em>substitutionGroupAttribute</em><font size="6">]</font><a href="#jd_map_substitution" class="judgment"><sub><font size="2">substitution</font></sub></a>
  		
  	      </td></tr>
  	      <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  		
  		  <em>Substitution</em>
  		
  	      </td></tr>
  	    </table></div>
  	  </div>
  
  	  <p>maps the substitutionGroup attribute
  	  <em>substitutionGroupAttribute</em> in Schema into a
  	  <em>Substitution</em> notation in the [XPath/XQuery] type
  	  system.</p>
  	<p><b>Schema mapping</b></p>
  	  <p>If the substitutionGroup attribute is present, it is
  	  mapped to a substitutionGroup notation in the [XPath/XQuery]
  	  type system.</p>
  	  
  	  <div align="center"><table cellpadding="0" cellspacing="0" summary="">
  	    <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
  	      
  		<font size="6">[</font>
  		  substitutionGroup = <em>QName</em>
  	      <font size="6">]</font><a href="#jd_map_substitution" class="judgment"><sub><font size="2">substitution</font></sub></a>
  	    
  	    </td></tr>
  	    <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
  	      substitutes for <em>QName</em>
  	    </td></tr>
  	  </table></div>

  	  <p>Otherwise, it is mapped to empty.</p>
  	</div></div><div class="div3">
<h4><a id="sec_import_anonymous" name="sec_import_anonymous"/>C.1.5 Anonymous type names</h4><p><b>Notation</b></p>
        <p>As explained in <a href="#sec_types"><b>[2.4 The [XPath/XQuery] Type System]</b></a>, the [XPath/XQuery]
        type uses system-generated type names for anonymous types. For
        the purpose of this document those type names are generated at
        XML Schema import time.</p>
      </div></div><div class="div2">
<h3><a id="sec_schema_as_a_whole" name="sec_schema_as_a_whole"/>C.2 Schemas as a whole</h3><div class="div3">
<h4><a id="sec_import_whole" name="sec_import_whole"/>C.2.1 Schema</h4><p><b>Schema component</b></p>
        <p>A schema is represented in XML by the following
        structure.</p>
  
        <div class="exampleInner">
        <table summary=""><tbody><tr><td>  &lt;schema</td></tr><tr><td>       <b> [ not handled ]  </b>
             attributeFormDefault = (qualified | unqualified) : unqualified
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             blockDefault = (#all | List of (extension | restriction | substitution))  : ' '
          </td></tr><tr><td>       <b> [ not handled ]  </b>
             elementFormDefault = (qualified | unqualified) : unqualified
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             finalDefault = (#all | List of (extension | restriction)) :  ' '
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             id = ID
          </td></tr><tr><td>       
             targetNamespace = anyURI
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             version = token
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             xml:lang = language
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             {any attributes with non-schema namespace ...}
          &gt;</td></tr><tr><td>       
            Content: ((include | import | redefine | annotation)*,
            (((simpleType | complexType | group | attributeGroup) |
            element | attribute | notation), annotation*)*)
          </td></tr><tr><td>  &lt;/schema&gt;</td></tr></tbody></table>
        </div>
  
      <p><b>Notation</b></p>
        <p>The following auxiliary grammar productions are used.</p>
  
        
<h5><a id="N273C2" name="N273C2"/>XML Schema Pragma and Content</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-SPragma" name="doc-fs-SPragma"/>[<small>51 (Formal)</small>]   </td><td><code>SPragma</code></td><td>   ::=   </td><td><code>("include"  |  "import"  |  "redefine"  |  "annotation")*</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-Content" name="doc-fs-Content"/>[<small>52 (Formal)</small>]   </td><td><code>Content</code></td><td>   ::=   </td><td><code>(("simpleType"  |  "complexType"  |  "element"  |  "attribute"  |  "attributeGroup"  |  "group"  |  "notation")  "annotation"*)*</code></td></tr></tbody></table>
   
        <p id="jd_map_pragma">The auxiliary normalization rule</p>
    
        <div align="center">
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
            <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
                <font size="6">[</font><em>Pragma</em><font size="6">]</font><a href="#jd_map_pragma" class="judgment"><sub><font size="2">pragma(targetNCName)</font></sub></a>
              
            </td></tr>
            <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                <em>Definitions</em>
              
            </td></tr>
          </table></div>
        </div>
    
        <p>maps the a schema pragma into a set of definitions in the
        [XPath/XQuery] type system.</p>
      <p><b>Schema mapping</b></p>
        <p>Schemas are imported by the "schema"
        declaration in the preamble of a query. To import a schema,
        the document referred to by the given URI is opened and the
        schema declarations contained in the document are translated
        into the corresponding in-line type definitions.  The
        mechanism for finding a schema document, possibly using the
        optional schema location hint, is not specified formally. </p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>schema <em>StringLiteral</em> (at <em>StringLiteral</em>)?<font size="6">]</font><a href="#jd_map_schema" class="judgment"><sub><font size="2">Schema</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>open-schema-document(<em>StringLiteral</em> (at <em>StringLiteral</em>)?)<font size="6">]</font><a href="#jd_map_schema" class="judgment"><sub><font size="2">Schema</font></sub></a>
            
          </td></tr>
        </table></div>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
             <font size="6">[</font>
                 <table summary=""><tbody><tr><td>  &lt;schema</td></tr><tr><td>       
                      targetNamespace = <em>target</em><em>URI</em>
                   &gt;</td></tr><tr><td>       
                     <em>Pragma</em> <em>Content</em>
                   </td></tr><tr><td>  &lt;/schema&gt;</td></tr></tbody></table>
             <font size="6">]</font><a href="#jd_map_schema" class="judgment"><sub><font size="2">Schema</font></sub></a>
           
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
                <font size="6">[</font><em>Pragma</em><font size="6">]</font><a href="#jd_map_pragma" class="judgment"><sub><font size="2">pragma(targetNCName)</font></sub></a>
                <font size="6">[</font><em>Content</em><font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>
            
          </td></tr>
        </table></div>
      </div><div class="div3">
<h4><a id="sec_import_include" name="sec_import_include"/>C.2.2 Include</h4><p><b>Schema component</b></p>
          <p>A schema include is represented in XML by the following
          structure.</p>
  
          <div class="exampleInner">
            <table summary=""><tbody><tr><td>  &lt;include</td></tr><tr><td>       <b> [ ignored ]  </b>
                 id = ID
              </td></tr><tr><td>       
                 schemaLocation = anyURI
              </td></tr><tr><td>       <b> [ ignored ]  </b>
                 {any attributes with non-schema namespace ...}
              &gt;</td></tr><tr><td>       
                Content: (annotation?)
              </td></tr><tr><td>  &lt;/include&gt;</td></tr></tbody></table>
          </div>

        <p><b>Schema mapping</b></p>

          <p>A schema include is not specified here, and is assumed
          to be handled by the XML Schema processor.</p>
        </div><div class="div3">
<h4><a id="sec_import_redefine" name="sec_import_redefine"/>C.2.3 Redefine</h4><p><b>Schema component</b></p>
          <p>A schema redefinition is represented in XML by the
          following structure.</p>

          <div class="exampleInner">
            <table summary=""><tbody><tr><td>  &lt;redefine</td></tr><tr><td>       <b> [ ignored ]  </b>
                 id = ID
              </td></tr><tr><td>       
                 schemaLocation = anyURI
              </td></tr><tr><td>       <b> [ ignored ]  </b>
                 {any attributes with non-schema namespace ...}
              &gt;</td></tr><tr><td>       
                Content: (annotation | (simpleType | complexType | group | attributeGroup))*
              </td></tr><tr><td>  &lt;/redefine&gt;</td></tr></tbody></table>
          </div>

        <p><b>Schema mapping</b></p>

          <p>A schema redefine is not specified here, and is assumed
          to be handled by the XML Schema processor.</p>

        </div><div class="div3">
<h4><a id="sec_import_import" name="sec_import_import"/>C.2.4 Import</h4><p><b>Schema component</b></p>
          <p>A schema import is represented in XML by the following
          structure.</p>

          <div class="exampleInner">
            <table summary=""><tbody><tr><td>  &lt;import</td></tr><tr><td>       <b> [ ignored ]  </b>
                 id = ID
              </td></tr><tr><td>       
                 namespace = anyURI
              </td></tr><tr><td>       
                 schemaLocation = anyURI
              </td></tr><tr><td>       <b> [ ignored ]  </b>
                 {any attributes with non-schema namespace ...}
              &gt;</td></tr><tr><td>       
                Content: (annotation?)
              </td></tr><tr><td>  &lt;/import&gt;</td></tr></tbody></table>
          </div>

        <p><b>Schema mapping</b></p>
          <p>A schema import is not specified here, and is assumed to
          be handled by the XML Schema processor.</p>
        </div></div><div class="div2">
<h3><a id="sec_import_attribute_decl" name="sec_import_attribute_decl"/>C.3 Attribute Declarations</h3><p><b>Schema component</b></p>
      <p>The following structure describes attribute declarations in
      XML Schema.</p>
  
    	<div class="exampleInner">
    	  <table summary=""><tbody><tr><td>  &lt;attribute</td></tr><tr><td>       <b> [ not handled ]  </b>
    	       default = string
    	    </td></tr><tr><td>       <b> [ not handled ]  </b>
    	       fixed = string
    	    </td></tr><tr><td>       <b> [ not handled ]  </b>
    	       form = (qualified | unqualified)
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       id = ID
    	    </td></tr><tr><td>       
    	       name = NCName
    	    </td></tr><tr><td>       
    	       ref = QName
    	    </td></tr><tr><td>       
    	       type = QName
    	    </td></tr><tr><td>       
    	       use = (optional | prohibited | required) : optional
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       {any attributes with non-schema namespace ...}
    	    &gt;</td></tr><tr><td>       
    	      Content: (annotation?, (simpleType?))
    	    </td></tr><tr><td>  &lt;/attribute&gt;</td></tr></tbody></table>
    	</div>
    <div class="div3">
<h4><a id="sec_import_global_attributes" name="sec_import_global_attributes"/>C.3.1 Global attributes declarations</h4><p>Schema import distinguishes between global attribute
      declarations and local attribute declarations.</p><p><b>Schema mapping</b></p>
        <p>Global attribute declarations are mapped like local
        attribute declarations, but are prefixed by a
        "define" keyword in the [XPath/XQuery] type
        system.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>AttributeDecl</em><font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            define <font size="6">[</font><em>AttributeDecl</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
          </td></tr>
        </table></div>
      </div><div class="div3">
<h4><a id="sec_import_local_attributes" name="sec_import_local_attributes"/>C.3.2 Local attribute declarations</h4><p><b>Schema mapping</b></p>
        <p>Local attributes whose type is given by a reference to a
        global type name are mapped in the type system as
        follows.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
    	  	  <table summary=""><tbody><tr><td>  &lt;attribute</td></tr><tr><td>       
    	  	       name = <em>NCName</em>
    	  	    </td></tr><tr><td>       
    	  	       type = <em>QName</em>
    	  	    </td></tr><tr><td>       
    	  	       <em>UseAttribute</em>
    	  	     /&gt;</td></tr></tbody></table>
              <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            ( attribute <em>target</em><em>NCName</em>:<em>NCName</em> {
            of type <em>QName</em> }
            )<font size="6">[</font><em>UseAttribute</em><font size="6">]</font><a href="#jd_map_use" class="judgment"><sub><font size="2">use</font></sub></a>
          </td></tr>
        </table></div>
    
        <p>References to a global attribute are mapped in the type
        system as follows.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
    	  	  <table summary=""><tbody><tr><td>  &lt;attribute</td></tr><tr><td>       
    	  	       ref = <em>QName</em>
    	  	    </td></tr><tr><td>       
    	  	       <em>UseAttribute</em>
    	  	     /&gt;</td></tr></tbody></table>
              <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            ( attribute <em>QName</em>
            )<font size="6">[</font><em>UseAttribute</em><font size="6">]</font><a href="#jd_map_use" class="judgment"><sub><font size="2">use</font></sub></a>
          </td></tr>
        </table></div>
    
        <p>A local attribute with a local content is mapped to the
        [XPath/XQuery] type system as follows. Let <em>fs:</em>anon<sub><font size="2">k</font></sub> be a newly
        generated anonymous name.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
    	  	  <table summary=""><tbody><tr><td>  &lt;attribute</td></tr><tr><td>       
    	  	       name = <em>NCName</em>
    	  	    </td></tr><tr><td>       
    	  	       <em>UseAttribute</em>
    	  	    &gt;</td></tr><tr><td>       
    	    	      <em>simpleType</em>
    	    	    </td></tr><tr><td>  &lt;/attribute&gt;</td></tr></tbody></table>
              <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
            <table><tbody><tr><td>( attribute <em>target</em><em>NCName</em>:<em>NCName</em> of
            type <em>fs:</em>anon<sub><font size="2">k</font></sub>
            )<font size="6">[</font><em>UseAttribute</em><font size="6">]</font><a href="#jd_map_use" class="judgment"><sub><font size="2">use</font></sub></a></td></tr><tr><td>  with</td></tr><tr><td>define type <em>fs:</em>anon<sub><font size="2">k</font></sub> of type
            xs:anySimpleType {
            <font size="6">[</font><em>simpleType</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a> }</td></tr></tbody></table>
            
          </td></tr>
        </table></div>

    
      </div></div><div class="div2">
<h3><a id="sec_import_element" name="sec_import_element"/>C.4 Element Declarations</h3><p><b>Schema component</b></p>
      <p>The following structure describes attribute declarations in
      XML Schema.</p>
  
      <div class="exampleInner">
        <table summary=""><tbody><tr><td>  &lt;element</td></tr><tr><td>       <b> [ ignored ]  </b>
            abstract = boolean : false
          </td></tr><tr><td>       <b> [ ignored ]  </b>
    	    block = (#all | List of (extension | restriction))
    	  </td></tr><tr><td>       <b> [ not handled ]  </b>
            default = string
          </td></tr><tr><td>       <b> [ ignored ]  </b>
    	    final = (#all | List of (extension | restriction))
    	  </td></tr><tr><td>       <b> [ not handled ]  </b>
            fixed = string
          </td></tr><tr><td>       <b> [ not handled ]  </b>
            form = (qualified | unqualified)
          </td></tr><tr><td>       <b> [ ignored ]  </b>
            id = ID
          </td></tr><tr><td>       
    	    maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	  </td></tr><tr><td>       
    	    minOccurs = nonNegativeInteger : 1
    	  </td></tr><tr><td>       
            name = NCName
          </td></tr><tr><td>       
            nillable = boolean : false
          </td></tr><tr><td>       
            ref = QName
          </td></tr><tr><td>       
            substitutionGroup = QName
          </td></tr><tr><td>       
             type = QName
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             {any attributes with non-schema namespace ...}
          &gt;</td></tr><tr><td>       
            Content: (annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))
          </td></tr><tr><td>  &lt;/element&gt;</td></tr></tbody></table>
      </div>
    <div class="div3">
<h4><a id="sec_import_global_element" name="sec_import_global_element"/>C.4.1 Global element declarations</h4><p>Schema import distinguishes between global element
      declarations and local element declarations.</p><p><b>Schema mapping</b></p>
        <p>Global element declarations are mapped like local element
        declarations, but are prefixed by a "define"
        keyword in the [XPath/XQuery] type system.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
        	<table summary=""><tbody><tr><td>  &lt;element</td></tr><tr><td>       
        	    name = <em>NCName</em>
        	  </td></tr><tr><td>       
        	    <em>NillableAttribute</em>
        	  </td></tr><tr><td>       
        	    <em>substitutionGroupAttribute</em>
        	  </td></tr><tr><td>       
        	    type = <em>QName</em>
        	   /&gt;</td></tr></tbody></table>
              <font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            define element <em>target</em><em>NCName</em>:<em>NCName</em>
            <font size="6">[</font><em>substitutionGroupAttribute</em><font size="6">]</font><a href="#jd_map_substitution" class="judgment"><sub><font size="2">substitution</font></sub></a>
            <font size="6">[</font><em>NillableAttribute</em><font size="6">]</font><a href="#jd_map_nillable" class="judgment"><sub><font size="2">nillable</font></sub></a> of type
            <em>QName</em>
          </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
        	<table summary=""><tbody><tr><td>  &lt;element</td></tr><tr><td>       
        	    name = <em>NCName</em>
        	  </td></tr><tr><td>       
        	    <em>NillableAttribute</em>
        	  </td></tr><tr><td>       
        	    <em>substitutionGroupAttribute</em>
        	  &gt;</td></tr><tr><td>       
        	    <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a>
        	  </td></tr><tr><td>  &lt;/element&gt;</td></tr></tbody></table>
              <font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            define element <em>target</em><em>NCName</em>:<em>NCName</em>
            <font size="6">[</font><em>substitutionGroupAttribute</em><font size="6">]</font><a href="#jd_map_substitution" class="judgment"><sub><font size="2">substitution</font></sub></a>
            <font size="6">[</font><em>NillableAttribute</em><font size="6">]</font><a href="#jd_map_nillable" class="judgment"><sub><font size="2">nillable</font></sub></a>
            <font size="6">[</font><a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
          </td></tr>
        </table></div>

      </div><div class="div3">
<h4><a id="sec_import_local_element" name="sec_import_local_element"/>C.4.2 Local element declarations</h4><p><b>Schema mapping</b></p>
        <p>Local element declarations, but mapped into corresponding
        notations in the [XPath/XQuery] type system. Note that
        substitution group cannot be declared on local elements.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
        	<table summary=""><tbody><tr><td>  &lt;element</td></tr><tr><td>       
          	    <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
    	    	  </td></tr><tr><td>       
        	    name = <em>NCName</em>
        	  </td></tr><tr><td>       
        	    <em>NillableAttribute</em>
        	  </td></tr><tr><td>       
        	    type = <em>QName</em>
        	   /&gt;</td></tr></tbody></table>
              <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            ( element <em>target</em><em>NCName</em>:<em>NCName</em>
            <font size="6">[</font><em>NillableAttribute</em><font size="6">]</font><a href="#jd_map_nillable" class="judgment"><sub><font size="2">nillable</font></sub></a> of type
            <em>QName</em> )
            <font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
          </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
        	<table summary=""><tbody><tr><td>  &lt;element</td></tr><tr><td>       
          	    <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
    	    	  </td></tr><tr><td>       
        	    ref = <em>QName</em>
        	   /&gt;</td></tr></tbody></table>
              <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            ( element <em>QName</em> )
            <font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
          </td></tr>
        </table></div>

        <p>Let <em>fs:</em>anon<sub><font size="2">k</font></sub> be a newly generated anonymous name.</p>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
        	<table summary=""><tbody><tr><td>  &lt;element</td></tr><tr><td>       
          	    <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
    	    	  </td></tr><tr><td>       
        	    name = <em>NCName</em>
        	  </td></tr><tr><td>       
        	    <em>NillableAttribute</em>
        	  &gt;</td></tr><tr><td>       
        	    <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a>
        	  </td></tr><tr><td>  &lt;/element&gt;</td></tr></tbody></table>
              <font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            
            <table><tbody><tr><td>( element
            <em>target</em><em>NCName</em>:<em>NCName</em>
            <font size="6">[</font><em>NillableAttribute</em><font size="6">]</font><a href="#jd_map_nillable" class="judgment"><sub><font size="2">nillable</font></sub></a> of type
            <em>fs:</em>anon<sub><font size="2">k</font></sub> )
            <font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a></td></tr><tr><td>  with</td></tr><tr><td>define type <em>fs:</em>anon<sub><font size="2">k</font></sub>
            <font size="6">[</font><a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            }</td></tr></tbody></table>
            
          </td></tr>
        </table></div>
      </div></div><div class="div2">
<h3><a id="sec_complex_type" name="sec_complex_type"/>C.5 Complex Type Definitions</h3><p><b>Schema component</b></p>
      <p>A complex type definition is represented in XML by the
      following structure.</p>
  
    	<div class="exampleInner">
    	  <table summary=""><tbody><tr><td>  &lt;complexType</td></tr><tr><td>       <b> [ ignored ]  </b>
    	       abstract = boolean : false
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       block = (#all | List of (extension | restriction))
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       final = (#all | List of (extension | restriction))
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       id = ID
    	    </td></tr><tr><td>       
    	       mixed = boolean : false
    	    </td></tr><tr><td>       
    	       name = NCName
    	    </td></tr><tr><td>       <b> [ ignored ]  </b>
    	       {any attributes with non-schema namespace ...}
    	    &gt;</td></tr><tr><td>       
    	      Content: (annotation?, (simpleContent | complexContent |
    	      ((group | all | choice | sequence)?, ((attribute |
    	      attributeGroup)*, anyAttribute?))))
    	    </td></tr><tr><td>  &lt;/complexType&gt;</td></tr></tbody></table>
    	</div>
    <p><b>Notation</b></p>
      <p>The following auxiliary grammar productions are used to
      describe the content of a complex type definition.</p>
  
      
<h5><a id="N278D9" name="N278D9"/>Complex type content</h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-ComplexTypeContent" name="doc-fs-ComplexTypeContent"/>[<small>62 (Formal)</small>]   </td><td><code>ComplexTypeContent</code></td><td>   ::=   </td><td><code>"annotation"?  ("simpleContent"  |  "complexContent"  |  (<a href="#doc-fs-ChildrenContent">ChildrenContent</a>  <a href="#doc-fs-AttributeContent">AttributeContent</a>))</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-AttributeContent" name="doc-fs-AttributeContent"/>[<small>65 (Formal)</small>]   </td><td><code>AttributeContent</code></td><td>   ::=   </td><td><code>("attribute"  |  "attributeGroup")*  "anyAttribute"?</code></td></tr></tbody><tbody><tr valign="baseline"><td><a id="doc-fs-ChildrenContent" name="doc-fs-ChildrenContent"/>[<small>63 (Formal)</small>]   </td><td><code>ChildrenContent</code></td><td>   ::=   </td><td><code>("group"  |  "all"  |  "choice"  |  "sequence")?</code></td></tr></tbody></table>
  
    <div class="div3">
<h4><a id="sec_import_global_complex_type" name="sec_import_global_complex_type"/>C.5.1 Global complex type</h4><p>Schema import distinguishes between global complex types
      (which are mapped to sort declarations) and local complex types
      (which are mapped to type definitions).</p><p><b>Schema mapping</b></p>
        <p>In the case of global complex types, the mapping rule which
        applies is denoted by <font size="6">[</font><font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
    	  	  <table summary=""><tbody><tr><td>  &lt;complexType</td></tr><tr><td>       
    	  	       <em>MixedAttribute</em>
    	  	    </td></tr><tr><td>       
    	  	       name = <em>NCName</em>
    	  	    &gt;</td></tr><tr><td>       
    	  	       <em>ComplexTypeContent</em>
    	  	    </td></tr><tr><td>  &lt;/complexType&gt;</td></tr></tbody></table>
            <font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>
          
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            define type <em>target</em><em>NCName</em>:<em>NCName</em>
            <font size="6">[</font><em>MixedAttribute</em>
            <em>ComplexTypeContent</em><font size="6">]</font><a href="#jd_map_mixed_content" class="judgment"><sub><font size="2">mixed_content(targetNCName)</font></sub></a>
          </td></tr>
        </table></div>
  
        <p>Note that the <code>mixed</code> is passed along in the
        normalization rules, in order to map it later on to the
        appropriate indication in the [XPath/XQuery] type system.</p>
      </div><div class="div3">
<h4><a id="sec_import_local_complex_type" name="sec_import_local_complex_type"/>C.5.2 Local complex type</h4><p><b>Schema mapping</b></p>
        <p>In the case of a local complex types, there must not be a
        name attribute and the mapping rule which applies is denoted
        by <font size="6">[</font><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
    	  	  <table summary=""><tbody><tr><td>  &lt;complexType</td></tr><tr><td>       
    	  	       <em>MixedAttribute</em>
    	  	    &gt;</td></tr><tr><td>       
    	  	       <em>ComplexTypeContent</em>
    	  	    </td></tr><tr><td>  &lt;/complexType&gt;</td></tr></tbody></table>
            <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
          
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            <font size="6">[</font><em>MixedAttribute</em>
            <em>ComplexTypeContent</em><font size="6">]</font><a href="#jd_map_mixed_content" class="judgment"><sub><font size="2">mixed_content(targetNCName)</font></sub></a>
          </td></tr>
        </table></div>
  
        <p>Note that the <code>mixed</code> is passed along in the
        normalization rules, in order to map it later on to the
        appropriate indication in the [XPath/XQuery] type system.</p>
      </div><div class="div3">
<h4><a id="sec_import_ct_simple" name="sec_import_ct_simple"/>C.5.3 Complex type with simple content</h4><p><b>Schema component</b></p>
    	  <p>A complex type can be of simple content. A simple content
    	  is represented in XML by the following structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;simpleContent</td></tr><tr><td>       <b> [ ignored ]  </b>
    		 id = ID
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
    		Content: (annotation?, (restriction | extension))
    	      </td></tr><tr><td>  &lt;/simpleContent&gt;</td></tr></tbody></table>
        </div>
  
        <p>Derivation by restriction inside a simple content is
        represented in XML by the following structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;restriction</td></tr><tr><td>       
    		 base = QName
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 id = ID
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
    		Content: (annotation?, (simpleType?, (minExclusive |
    		minInclusive | maxExclusive | maxInclusive |
    		totalDigits | fractionDigits | length | minLength |
    		maxLength | enumeration | whiteSpace | pattern)*)?,
    		((attribute | attributeGroup)*, anyAttribute?))
    	      </td></tr><tr><td>  &lt;/restriction&gt;</td></tr></tbody></table>
        </div>
  
        <p>Derivation by extension inside a simple content is
        represented in XML by the following structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;extension</td></tr><tr><td>       
    		 <b>base</b> = QName
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 id = ID
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
              Content: (annotation?, ((attribute | attributeGroup)*,
              anyAttribute?))
    	      </td></tr><tr><td>  &lt;/extension&gt;</td></tr></tbody></table>
        </div>
      <p><b>Notation</b></p>
        <p id="jd_map_mixed_content">The normalization rule</p>
      
        <div align="center">
          <div align="center"><table cellpadding="0" cellspacing="0" summary="">
            <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
              
                <font size="6">[</font><em>MixedAttribute</em> <em>ComplexTypeContent</em><font size="6">]</font><a href="#jd_map_mixed_content" class="judgment"><sub><font size="2">mixed_content(targetNCName)</font></sub></a>
              
            </td></tr>
            <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
              
                <a href="#doc-fs-TypeDerivation"><em>TypeDerivation</em></a>
              
            </td></tr>
          </table></div>
        </div>
      
        <p>maps a pair of mixed attribute and complex type content to
        a type derivation.</p>
      <p><b>Schema mapping</b></p>
        <p>A complex types with simple content must not have a
        <code>mixed</code> attribute set to "true".</p>
  
        <p>If the simple content is derived by restriction, it is
        mapped into a simple type restriction in the [XPath/XQuery] type
        system. Only the name of the base atomic type and attributes
        are mapped, while the actual simple type restriction is
        ignored. (Remember that facets are not captured in the
        [XPath/XQuery] type system.)</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
                <table summary=""><tbody><tr><td>mixed = "false"</td><td>
   	  	  <table summary=""><tbody><tr><td>  &lt;simpleContent&gt;</td></tr><tr><td>
    	    	      <table summary=""><tbody><tr><td>  &lt;restriction</td></tr><tr><td>       
    	 		   base = <em>QName</em>
    	    		&gt;</td></tr><tr><td>       
    	 		  <em>simpleContentRestriction</em> <em>AttributeContent</em>
    	    		</td></tr><tr><td>  &lt;/restriction&gt;</td></tr></tbody></table>
    	  	    </td></tr><tr><td>  &lt;/simpleContent&gt;</td></tr></tbody></table>
               </td></tr></tbody></table>
            <font size="6">]</font><a href="#jd_map_mixed_content" class="judgment"><sub><font size="2">mixed_content(targetNCName)</font></sub></a>
          
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            restricts <em>QName</em> {
            <font size="6">[</font><em>AttributeContent</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            <em>QName</em> }
          </td></tr>
        </table></div>
  
        <p>If the simple type is derived by extension, it is mapped
        into an extended type specifier into the [XPath/XQuery] type
        system.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
                <table summary=""><tbody><tr><td>mixed = "false"</td><td>
   	  	  <table summary=""><tbody><tr><td>  &lt;simpleContent&gt;</td></tr><tr><td>
    	    	      <table summary=""><tbody><tr><td>  &lt;extension</td></tr><tr><td>       
    	 		   base = <em>QName</em>
    	    		&gt;</td></tr><tr><td>       
    	 		  <em>AttributeContent</em>
    	    		</td></tr><tr><td>  &lt;/extension&gt;</td></tr></tbody></table>
    	  	    </td></tr><tr><td>  &lt;/simpleContent&gt;</td></tr></tbody></table>
               </td></tr></tbody></table>
            <font size="6">]</font><a href="#jd_map_mixed_content" class="judgment"><sub><font size="2">mixed_content(targetNCName)</font></sub></a>
          
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            extends <em>QName</em> {
            <font size="6">[</font><em>AttributeContent</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            }
          </td></tr>
        </table></div>
  
      </div><div class="div3">
<h4><a id="sec_import_ct_complex" name="sec_import_ct_complex"/>C.5.4 Complex type with complex content</h4><p><b>Schema component</b></p>
    	  <p>A complex type can be of complex content. A complex
    	  content is represented in XML by the following
    	  structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;complexContent</td></tr><tr><td>       <b> [ ignored ]  </b>
    		 id = ID
    	      </td></tr><tr><td>       
        	 mixed = boolean : false
            </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
               Content: (annotation?, (restriction | extension))
    	      </td></tr><tr><td>  &lt;/complexContent&gt;</td></tr></tbody></table>
        </div>
  
        <p>Derivation by restriction inside a complex content is
        represented in XML by the following structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;restriction</td></tr><tr><td>       
    		 base = QName
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 id = ID
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
               Content: (annotation?, (group | all | choice |
               sequence)?, ((attribute | attributeGroup)*,
               anyAttribute?))
            </td></tr><tr><td>  &lt;/restriction&gt;</td></tr></tbody></table>
        </div>
  
        <p>Derivation by extension inside a complex content is
        represented in XML by the following structure.</p>
  
        <div class="exampleInner">
          <table summary=""><tbody><tr><td>  &lt;extension</td></tr><tr><td>       
               <b>base</b> = QName
            </td></tr><tr><td>       <b> [ ignored ]  </b>
               id = ID
            </td></tr><tr><td>       <b> [ ignored ]  </b>
               {any attributes with non-schema namespace ...}
            &gt;</td></tr><tr><td>       
            Content: (annotation?, ((group | all | choice |
            sequence)?, ((attribute | attributeGroup)*,
            anyAttribute?)))
            </td></tr><tr><td>  &lt;/extension&gt;</td></tr></tbody></table>
        </div>
      <p><b>Schema mapping</b></p>
        <p>If the complex content is derived by restriction, it is
        mapped into a type restriction in the [XPath/XQuery] type
        system, and the </p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
                <table summary=""><tbody><tr><td><em>MixedAttribute</em></td><td>
   	  	  <table summary=""><tbody><tr><td>  &lt;complexContent&gt;</td></tr><tr><td>
    	    	      <table summary=""><tbody><tr><td>  &lt;restriction</td></tr><tr><td>       
    	 		   base = <em>QName</em>
    	    		&gt;</td></tr><tr><td>       
    	 		  <em>annotation</em>? <em>ChildrenContent</em> <em>AttributeContent</em>
    	    		</td></tr><tr><td>  &lt;/restriction&gt;</td></tr></tbody></table>
    	  	    </td></tr><tr><td>  &lt;/complexContent&gt;</td></tr></tbody></table>
               </td></tr></tbody></table>
            <font size="6">]</font><a href="#jd_map_mixed_content" class="judgment"><sub><font size="2">mixed_content(targetNCName)</font></sub></a>
          
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            restricts <em>QName</em>
            <font size="6">[</font><em>MixedAttribute</em><font size="6">]</font><a href="#jd_map_mixed" class="judgment"><sub><font size="2">mixed</font></sub></a> {
            <font size="6">[</font><em>AttributeContent</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            <font size="6">[</font><em>ChildrenContent</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            }
          </td></tr>
        </table></div>
  
        <p>If the complex content is derived by extension, it is
        mapped into an extended type specifier into the [XPath/XQuery]
        type system.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
                <table summary=""><tbody><tr><td><em>MixedAttribute</em></td><td>
   	  	  <table summary=""><tbody><tr><td>  &lt;complexContent&gt;</td></tr><tr><td>
    	    	      <table summary=""><tbody><tr><td>  &lt;extension</td></tr><tr><td>       
    	 		   base = <em>QName</em>
    	    		&gt;</td></tr><tr><td>       
    	 		  <em>annotation</em>? <em>ChildrenContent</em> <em>AttributeContent</em>
    	    		</td></tr><tr><td>  &lt;/extension&gt;</td></tr></tbody></table>
    	  	    </td></tr><tr><td>  &lt;/complexContent&gt;</td></tr></tbody></table>
               </td></tr></tbody></table>
            <font size="6">]</font><a href="#jd_map_mixed_content" class="judgment"><sub><font size="2">mixed_content(targetNCName)</font></sub></a>
          
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            extends <em>QName</em>
            <font size="6">[</font><em>MixedAttribute</em><font size="6">]</font><a href="#jd_map_mixed" class="judgment"><sub><font size="2">mixed</font></sub></a> {
            <font size="6">[</font><em>AttributeContent</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            <font size="6">[</font><em>ChildrenContent</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            }
          </td></tr>
        </table></div>
  
      </div></div><div class="div2">
<h3><a id="sec_attribute_use" name="sec_attribute_use"/>C.6 Attribute Uses</h3><p>Mapping for attribute uses is given in <a href="#sec_use"><b>[C.1.4 Special attributes]</b></a>.</p></div><div class="div2">
<h3><a id="sec_attribute_group" name="sec_attribute_group"/>C.7 Attribute Group Definitions</h3><div class="div3">
<h4><a id="sec_attribute_group_def" name="sec_attribute_group_def"/>C.7.1 Attribute group definitions</h4><p><b>Schema component</b></p>
    	  <p>Model group definitions are represented in XML by the
    	  following structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;attributeGroup</td></tr><tr><td>       <b> [ ignored ]  </b>
    		 id = ID
    	      </td></tr><tr><td>       
    		   name = NCame
    	      </td></tr><tr><td>       
    		   ref = QName
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
    		Content: (annotation?, ((attribute | attributeGroup)*,
    		anyAttribute?))
    	      </td></tr><tr><td>  &lt;/attributeGroup&gt;</td></tr></tbody></table>
    	  </div>
    	<p><b>Schema mapping</b></p>
    	  <p>Attribute group definitions are not currently handled by
    	  the mapping. See Issue 501 (FS-Issue-0158).</p>
    	</div><div class="div3">
<h4><a id="sec_import_attribute_group_ref" name="sec_import_attribute_group_ref"/>C.7.2 Attribute group reference</h4><p><b>Schema mapping</b></p>
    	  <p>Attribute group references are not currently handled by
    	  the mapping. See Issue 501 (FS-Issue-0158).</p>
    	</div></div><div class="div2">
<h3><a id="sec_import_model" name="sec_import_model"/>C.8 Model Group Definitions</h3><p><b>Schema component</b></p>
      <p>Model group definitions are represented in XML by the
      following structure.</p>
  
    	<div class="exampleInner">
    	  <table summary=""><tbody><tr><td>  &lt;group</td></tr><tr><td>       
    		 <b>name</b> = NCame
    	    &gt;</td></tr><tr><td>       
            Content: (annotation?, (all | choice | sequence))
    	    </td></tr><tr><td>  &lt;/group&gt;</td></tr></tbody></table>
      </div>
    <p><b>Schema mapping</b></p>
      <p>Model group definitions are not currently handled by the
      mapping. See Issue 501 (FS-Issue-0158).</p>
    </div><div class="div2">
<h3><a id="sec_import_model_groups" name="sec_import_model_groups"/>C.9 Model Groups</h3><p>Model groups are either "all",
    "sequence" or "choice". One can also
    refer to a model group definition.</p><div class="div3">
<h4><a id="sec_import_all_groups" name="sec_import_all_groups"/>C.9.1 All groups</h4><p><b>Schema component</b></p>
    	  <p>All groups are represented in XML by the following
    	  structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;all</td></tr><tr><td>       <b> [ ignored ]  </b>
    		 id = ID
    	      </td></tr><tr><td>       
    		 maxOccurs = 1 : 1
    	      </td></tr><tr><td>       
    		 minOccurs = (0 | 1) : 1
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
    		Content: (annotation?, element*)
    	      </td></tr><tr><td>  &lt;/all&gt;</td></tr></tbody></table>
    	  </div>
    	<p><b>Schema mapping</b></p>
         <p>All groups are mapped into the "&amp;"
         operation in the [XPath/XQuery] type system.</p>
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
    	    	  <table summary=""><tbody><tr><td>  &lt;all</td></tr><tr><td>       
          	      <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
    	    	    &gt;</td></tr><tr><td>       
    	 	      <em>Element</em><sub><font size="2">1</font></sub> ... <em>Element</em><sub><font size="2">n</font></sub>
    	    	    </td></tr><tr><td>  &lt;/all&gt;</td></tr></tbody></table>
             <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            (<font size="6">[</font><em>Element</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            &amp; ... &amp;
            <font size="6">[</font><em>Element</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>)
            <font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
          </td></tr>
        </table></div>
  
      </div><div class="div3">
<h4><a id="sec_import_choice_groups" name="sec_import_choice_groups"/>C.9.2 Choice groups</h4><p><b>Schema component</b></p>
    	  <p>Choice groups are represented in XML by the following
    	  structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;choice</td></tr><tr><td>       <b> [ ignored ]  </b>
    		 id = ID
    	      </td></tr><tr><td>       
    		 maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </td></tr><tr><td>       
    		 minOccurs = nonNegativeInteger : 1
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
    		Content: (annotation?, (element | group | choice |
    		sequence | any)*)
    	      </td></tr><tr><td>  &lt;/choice&gt;</td></tr></tbody></table>
    	  </div>
    	<p><b>Notation</b></p>
        <p>The following auxiliary grammar productions are used to
        describe group components.</p>
  	  
        
<h5><a id="N27D70" name="N27D70"/>Group Component </h5><table summary="Scrap" class="scrap"><tbody><tr valign="baseline"><td><a id="doc-fs-GroupComponent" name="doc-fs-GroupComponent"/>[<small>64 (Formal)</small>]   </td><td><code>GroupComponent</code></td><td>   ::=   </td><td><code>"element"  |  "group"  |  "choice"  |  "sequence"  |  "any"</code></td></tr></tbody></table>
      <p><b>Schema mapping</b></p>
        <p>Choice groups are mapped into the "|"
        operation in the [XPath/XQuery] type system.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
    	    	  <table summary=""><tbody><tr><td>  &lt;choice</td></tr><tr><td>       
          	      <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
    	    	    &gt;</td></tr><tr><td>       
    	 	      <em>GroupComponent</em><sub><font size="2">1</font></sub> ... <em>GroupComponent</em><sub><font size="2">n</font></sub>
    	    	    </td></tr><tr><td>  &lt;/choice&gt;</td></tr></tbody></table>
             <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            (<font size="6">[</font><em>GroupComponent</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            | ... |
            <font size="6">[</font><em>GroupComponent</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>)
            <font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
          </td></tr>
        </table></div>
  
      </div><div class="div3">
<h4><a id="sec_import_sequence_groups" name="sec_import_sequence_groups"/>C.9.3 Sequence groups</h4><p><b>Schema component</b></p>
    	  <p>Sequence groups are represented in XML by the following
    	  structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;sequence</td></tr><tr><td>       <b> [ ignored ]  </b>
    		 id = ID
    	      </td></tr><tr><td>       
    		 maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </td></tr><tr><td>       
    		 minOccurs = nonNegativeInteger : 1
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
    		Content: (annotation?, (element | group | choice |
    		sequence | any)*)
    	      </td></tr><tr><td>  &lt;/sequence&gt;</td></tr></tbody></table>
    	  </div>
    	<p><b>Schema mapping</b></p>
        <p>Sequence groups are mapped into the ","
        operation in the [XPath/XQuery] type system.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
              <font size="6">[</font>
    	    	  <table summary=""><tbody><tr><td>  &lt;sequence</td></tr><tr><td>       
          	      <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
    	    	    &gt;</td></tr><tr><td>       
    	 	      <em>GroupComponent</em><sub><font size="2">1</font></sub> ... <em>GroupComponent</em><sub><font size="2">n</font></sub>
    	    	    </td></tr><tr><td>  &lt;/sequence&gt;</td></tr></tbody></table>
             <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            (<font size="6">[</font><em>GroupComponent</em><sub><font size="2">1</font></sub><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            , ... ,
            <font size="6">[</font><em>GroupComponent</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>)
            <font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
          </td></tr>
        </table></div>
      </div></div><div class="div2">
<h3><a id="sec_import_particles" name="sec_import_particles"/>C.10 Particles</h3><p>Particles contribute to the definition of content models.</p><p>A particle can be either an element reference, a group
    reference or a wildcard.</p><div class="div3">
<h4><a id="sec_import_element_ref" name="sec_import_element_ref"/>C.10.1 Element reference</h4><p><b>Schema component</b></p>
    	  <p>Element reference particles are represented in XML by the
    	  following structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;element</td></tr><tr><td>       
    		 ref = QName
    	      </td></tr><tr><td>       
    		   maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </td></tr><tr><td>       
    		   minOccurs = nonNegativeInteger : 1
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr></tbody></table>
    	  </div>
    	<p><b>Schema mapping</b></p>
        <p>Element references are mapped into element references in
        the [XPath/XQuery] type system.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
      	<font size="6">[</font>
    	      	  <table summary=""><tbody><tr><td>  &lt;element</td></tr><tr><td>       
    	  	       ref = <em>QName</em>
    	     	    </td></tr><tr><td>       
    	  	       <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
    	     	     /&gt;</td></tr></tbody></table>
              <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            element <em>QName</em>
            <font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
          </td></tr>
        </table></div>
      </div><div class="div3">
<h4><a id="sec_group_ref" name="sec_group_ref"/>C.10.2 Group reference</h4><p><b>Schema component</b></p>
    	  <p>Group reference particles are represented in XML by the
    	  following structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;group</td></tr><tr><td>       
    		 ref = QName
    	      </td></tr><tr><td>       
    		   maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </td></tr><tr><td>       
    		   minOccurs = nonNegativeInteger : 1
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr></tbody></table>
    	  </div>
    	<p><b>Schema mapping</b></p>
        <p>Model group references are not currently handled by the
        mapping.</p>
      </div></div><div class="div2">
<h3><a id="sec_import_wildcards" name="sec_import_wildcards"/>C.11 Wildcards</h3><div class="div3">
<h4><a id="sec_import_attribute_wildcards" name="sec_import_attribute_wildcards"/>C.11.1 Attribute wildcards</h4><p><b>Schema component</b></p>
    	  <p>Attribute wildcards are represented in XML by the
    	  following structure.</p>
  
    	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;anyAttribute</td></tr><tr><td>       <b> [ ignored ]  </b>
        	 id = ID
            </td></tr><tr><td>       <b> [ not handled ]  </b>
    		 namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any
    	      </td></tr><tr><td>       
    		 processContents = (lax | skip | strict) : strict
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
               Content: (annotation?)
            </td></tr><tr><td>  &lt;/anyAttribute&gt;</td></tr></tbody></table>
    	  </div>
    	<p><b>Schema mapping</b></p>
        <p>An attribute wildcard with a "skip" process
        content is mapped as an attribute wildcard in the [XPath/XQuery]
        type system.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
        	<font size="6">[</font>
    		  <table summary=""><tbody><tr><td>  &lt;anyAttribute</td></tr><tr><td>       
    		       processContents = "skip"
    		    &gt;</td></tr><tr><td>       
      	       <em>annotation</em>?
      	    </td></tr><tr><td>  &lt;/anyAttribute&gt;</td></tr></tbody></table>
      	 <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            (attribute (*, <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>))*
          </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
        	<font size="6">[</font>
    		  <table summary=""><tbody><tr><td>  &lt;anyAttribute</td></tr><tr><td>       
    		       processContents = "lax"
    		    &gt;</td></tr><tr><td>       
      	       <em>annotation</em>?
      	    </td></tr><tr><td>  &lt;/anyAttribute&gt;</td></tr></tbody></table>
      	 <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            attribute *
          </td></tr>
        </table></div>

        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
        	<font size="6">[</font>
    		  <table summary=""><tbody><tr><td>  &lt;anyAttribute</td></tr><tr><td>       
    		       processContents = "strict"
    		    &gt;</td></tr><tr><td>       
      	       <em>annotation</em>?
      	    </td></tr><tr><td>  &lt;/anyAttribute&gt;</td></tr></tbody></table>
      	 <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            attribute *
          </td></tr>
        </table></div>



  	<table border="1" summary="Editorial note"><tr><td width="50%" valign="top" align="left"><b>Editorial note</b></td><td width="50%" valign="top" align="right"> </td></tr><tr><td valign="top" align="left" colspan="2">Namespace wildcards are not
  	  handled by the mapping.</td></tr></table>
      </div><div class="div3">
<h4><a id="sec_import_element_wildcards" name="sec_import_element_wildcards"/>C.11.2 Element wildcards</h4><p><b>Schema component</b></p>
    	  <p>Element wildcards are represented in XML by the following
    	  structure.</p>
  
   	  <div class="exampleInner">
    	    <table summary=""><tbody><tr><td>  &lt;any</td></tr><tr><td>       <b> [ ignored ]  </b>
        	 id = ID
            </td></tr><tr><td>       
    		 maxOccurs = (nonNegativeInteger | unbounded)  : 1
    	      </td></tr><tr><td>       
    		 minOccurs = nonNegativeInteger : 1
    	      </td></tr><tr><td>       <b> [ not handled ]  </b>
    		 namespace = ((##any | ##other) | List of (anyURI | (##targetNamespace | ##local)) )  : ##any
    	      </td></tr><tr><td>       
    		 processContents = (lax | skip | strict) : strict
    	      </td></tr><tr><td>       <b> [ ignored ]  </b>
    		 {any attributes with non-schema namespace ...}
    	      &gt;</td></tr><tr><td>       
               Content: (annotation?)
            </td></tr><tr><td>  &lt;/any&gt;</td></tr></tbody></table>
    	  </div>
    	<p><b>Schema mapping</b></p>
        <p>An element wildcard with a "skip" process
        content is mapped as an element wildcard in the [XPath/XQuery]
        type system.</p>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
      	<font size="6">[</font>
    		  <table summary=""><tbody><tr><td>  &lt;any</td></tr><tr><td>       
    		       <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
    		    </td></tr><tr><td>       
    		       processContents = "skip"
    		    &gt;</td></tr><tr><td>       
      	       <em>annotation</em>?
      	    </td></tr><tr><td>  &lt;/any&gt;</td></tr></tbody></table>
      	 <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            ( element (*, <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a>)
            )<font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
          </td></tr>
        </table></div>
  
        <div align="center"><table cellpadding="0" cellspacing="0" summary="">
          <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
            
      	<font size="6">[</font>
    		  <table summary=""><tbody><tr><td>  &lt;any</td></tr><tr><td>       
    		       <a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a>
    		    </td></tr><tr><td>       
    		       processContents = "lax"
    		    &gt;</td></tr><tr><td>       
      	       <em>annotation</em>?
      	    </td></tr><tr><td>  &lt;/any&gt;</td></tr></tbody></table>
      	 <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            
          </td></tr>
          <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
            ( element (*, <code>xs:anyType</code>)
            )<font size="6">[</font><a href="#prod-formal-OccursAttributes"><em>OccursAttributes</em></a><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
          </td></tr>
        </table></div>
  
  	<table border="1" summary="Editorial note"><tr><td width="50%" valign="top" align="left"><b>Editorial note</b></td><td width="50%" valign="top" align="right"> </td></tr><tr><td valign="top" align="left" colspan="2">Element wildcards with a
          "lax" or "strict" process content
          are not handled by the mapping. </td></tr></table>

  	<table border="1" summary="Editorial note"><tr><td width="50%" valign="top" align="left"><b>Editorial note</b></td><td width="50%" valign="top" align="right"> </td></tr><tr><td valign="top" align="left" colspan="2">Namespace wildcards are not
  	  handled by the mapping.</td></tr></table>
      </div></div><div class="div2">
<h3><a id="sec_import_identity" name="sec_import_identity"/>C.12 Identity-constraint Definitions</h3><p>All identity-constraints definitions are ignored when mapping
    into the [XPath/XQuery] type system.</p></div><div class="div2">
<h3><a id="sec_import_notation" name="sec_import_notation"/>C.13 Notation Declarations</h3><p>All notation declarations are ignored when mapping into the
    [XPath/XQuery] type system.</p></div><div class="div2">
<h3><a id="sec_import_annotation" name="sec_import_annotation"/>C.14 Annotation</h3><p>All annotation are ignored when mapping into the [XPath/XQuery]
    type system.</p></div><div class="div2">
<h3><a id="sec_import_simple_type" name="sec_import_simple_type"/>C.15 Simple Type Definitions</h3><p><b>Schema component</b></p>
      <p>A simple type is represented in XML by the following
      structure.</p>

      <div class="exampleInner">
        <table summary=""><tbody><tr><td>  &lt;simpleType</td></tr><tr><td>       <b> [ ignored ]  </b>
             final = (#all | (list | union | restriction))
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             id = ID
          </td></tr><tr><td>       
             name = NCName
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             {any attributes with non-schema namespace ...}
          &gt;</td></tr><tr><td>       
            name = NCName
          </td></tr><tr><td>  &lt;/simpleType&gt;</td></tr></tbody></table>
      </div>

      <p>Derivation by restriction inside a simple type is represented
      in XML by the following structure.</p>
  
      <div class="exampleInner">
        <table summary=""><tbody><tr><td>  &lt;restriction</td></tr><tr><td>       
             base = QName
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             id = ID
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             {any attributes with non-schema namespace ...}
          &gt;</td></tr><tr><td>       
            Content: (annotation?, (simpleType?, (minExclusive |
            minInclusive | maxExclusive | maxInclusive |
            totalDigits | fractionDigits | length | minLength |
            maxLength | enumeration | whiteSpace | pattern)*)?)
          </td></tr><tr><td>  &lt;/restriction&gt;</td></tr></tbody></table>
      </div>
  
      <p>Derivation by list inside a simple type is represented in XML
      by the following structure.</p>
  
      <div class="exampleInner">
        <table summary=""><tbody><tr><td>  &lt;list</td></tr><tr><td>       <b> [ ignored ]  </b>
             id = ID
          </td></tr><tr><td>       
             itemType = QName
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             {any attributes with non-schema namespace ...}
          &gt;</td></tr><tr><td>       
             Content: (annotation?, (simpleType?))
          </td></tr><tr><td>  &lt;/list&gt;</td></tr></tbody></table>
      </div>

      <p>Derivation by union inside a simple type is represented in
      XML by the following structure.</p>
  
      <div class="exampleInner">
        <table summary=""><tbody><tr><td>  &lt;union</td></tr><tr><td>       <b> [ ignored ]  </b>
             id = ID
          </td></tr><tr><td>       
             memberTypes = List of QName
          </td></tr><tr><td>       <b> [ ignored ]  </b>
             {any attributes with non-schema namespace ...}
          &gt;</td></tr><tr><td>       
             Content: (annotation?, (simpleType*))
          </td></tr><tr><td>  &lt;/union&gt;</td></tr></tbody></table>
      </div>
    <div class="div3">
<h4><a id="sec_import_global_simple_type" name="sec_import_global_simple_type"/>C.15.1 Global simple type definition</h4><p>Schema import distinguishes between global simple types
      (which are mapped to sort declarations) and local simple types
      (which are mapped to type definitions).</p><p><b>Schema mapping</b></p>
        <p>In the case of global simple types, the mapping rule which
        applies is denoted by <font size="6">[</font><font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>.</p>
  
      	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
      	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <font size="6">[</font>
      		<table summary=""><tbody><tr><td>  &lt;simpleType</td></tr><tr><td>       
      		     name = <em>NCName</em>
      		  &gt;</td></tr><tr><td>       
      		     <em>SimpleTypeContent</em>
      		  </td></tr><tr><td>  &lt;/simpleType&gt;</td></tr></tbody></table>
      	    <font size="6">]</font><a href="#jd_map_definition" class="judgment"><sub><font size="2">definition(targetNCName)</font></sub></a>
      	  
      	  </td></tr>
      	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      	    define type <em>target</em><em>NCName</em>:<em>NCName</em>
      	    <font size="6">[</font><em>SimpleTypeContent</em><font size="6">]</font><a href="#jd_map_simple_content" class="judgment"><sub><font size="2">simple_content(targetNCName)</font></sub></a>
      	  </td></tr>
      	</table></div>
      </div><div class="div3">
<h4><a id="sec_import_local_simple_type" name="sec_import_local_simple_type"/>C.15.2 Local simple type definition</h4><p><b>Schema mapping</b></p>
        <p>In the case of global simple types, the mapping rule which
        applies is denoted by <font size="6">[</font><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>.</p>
  
      	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
      	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <font size="6">[</font>
      		<table summary=""><tbody><tr><td>  &lt;simpleType&gt;</td></tr><tr><td>
      		     <em>SimpleTypeContent</em>
      		  </td></tr><tr><td>  &lt;/simpleType&gt;</td></tr></tbody></table>
      	    <font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
      	  
      	  </td></tr>
      	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      	    <font size="6">[</font><em>SimpleTypeContent</em><font size="6">]</font><a href="#jd_map_simple_content" class="judgment"><sub><font size="2">simple_content(targetNCName)</font></sub></a>
      	  </td></tr>
      	</table></div>
      </div><div class="div3">
<h4><a id="sec_import_simple_type_content" name="sec_import_simple_type_content"/>C.15.3 Simple type content</h4><p><b>Notation</b></p>
        <p id="jd_map_simple_content">The normalization rule
        <font size="6">[</font><font size="6">]</font><a href="#jd_map_simple_content" class="judgment"><sub><font size="2">simple_content(targetNCName)</font></sub></a> maps a simple type content
        to a type specifier and an optional occurrence indicator.</p>
      <p><b>Schema mapping</b></p>
        <p>If the simple type is derived by restriction, it is mapped
        into a simple type restriction in the [XPath/XQuery] type
        system.   The name of the base atomic type and attributes
        are mapped.  Only the minLength, maxLength, and length facets in the simple type
        restriction are handled.  All other properties of the simple-type restriction are ignored.</p>

      	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
      	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <font size="6">[</font>
      		<table summary=""><tbody><tr><td>  &lt;restriction</td></tr><tr><td>       
      		     base = <em>QName</em>
      		  &gt;</td></tr><tr><td>       
      		     <em>simpleContentRestriction</em>
      		  </td></tr><tr><td>  &lt;/restriction&gt;</td></tr></tbody></table>
      	    <font size="6">]</font><a href="#jd_map_simple_content" class="judgment"><sub><font size="2">simple_content(targetNCName)</font></sub></a>
      	  
      	  </td></tr>
      	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      	    restricts <em>QName</em> { <em>QName</em> } <font size="6">[</font><em>simpleContentRestriction</em><font size="6">]</font><a href="#jd_map_occurs" class="judgment"><sub><font size="2">occurs</font></sub></a>
      	  </td></tr>
      	</table></div>
      
        <p>If the simple type is derived by list, and its content type
        does not constrain the length of the list, 
        it is mapped into a zero-or-more repetition type into the [XPath/XQuery] type system.</p>
      
      	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
      	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <font size="6">[</font>
                <table summary=""><tbody><tr><td>  &lt;list&gt;</td></tr><tr><td>
                    <em>SimpleType</em>
                  </td></tr><tr><td>  &lt;/list&gt;</td></tr></tbody></table>
      	      <font size="6">]</font><a href="#jd_map_simple_content" class="judgment"><sub><font size="2">simple_content(targetNCName)</font></sub></a>
              <a href="#doc-fs-Type"><em>Type</em></a> = <font size="6">[</font><em>SimpleType</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
      	    
      	  </td></tr>
      	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      	    { <a href="#doc-fs-Type"><em>Type</em></a> * }
      	  </td></tr>
      	</table></div>

        <p>If the simple type is derived by list, and its content type
        does constrain the length of the list, then it is mapped into
        a zero-or-more repetition type into the [XPath/XQuery] type
        system.</p>

      	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
      	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <font size="6">[</font>
                <table summary=""><tbody><tr><td>  &lt;list&gt;</td></tr><tr><td>
                    <em>SimpleType</em>
                  </td></tr><tr><td>  &lt;/list&gt;</td></tr></tbody></table>
      	      <font size="6">]</font><a href="#jd_map_simple_content" class="judgment"><sub><font size="2">simple_content(targetNCName)</font></sub></a>
              <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_quantifier" class="judgment">·</a> <em>Occurrence</em> = <font size="6">[</font><em>SimpleType</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
      	    
      	  </td></tr>
      	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      	    { <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_quantifier" class="judgment">·</a> <em>Occurrence</em> }
      	  </td></tr>
      	</table></div>
  
      	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
      	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <font size="6">[</font>
                <table summary=""><tbody><tr><td>  &lt;list</td></tr><tr><td>       
                     itemType = <em>QName</em>
                   /&gt;</td></tr></tbody></table>
      	      <font size="6">]</font><a href="#jd_map_simple_content" class="judgment"><sub><font size="2">simple_content(targetNCName)</font></sub></a>
      	    
      	  </td></tr>
      	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      	    { <em>QName</em>* }
      	  </td></tr>
      	</table></div>

        <p>If the simple type is derived by union, it is mapped into a
        union type into the [XPath/XQuery] type system.</p>
      
      	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
      	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <font size="6">[</font>
                <table summary=""><tbody><tr><td>  &lt;union&gt;</td></tr><tr><td>
                    <em>SimpleType</em><sub><font size="2">1</font></sub> ... <em>SimpleType</em><sub><font size="2">n</font></sub>
                  </td></tr><tr><td>  &lt;/union&gt;</td></tr></tbody></table>
      	      <font size="6">]</font><a href="#jd_map_simple_content" class="judgment"><sub><font size="2">simple_content(targetNCName)</font></sub></a>
      	    
      	  </td></tr>
      	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      	    { (<font size="6">[</font><em>SimpleType</em><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>
            | ... | <font size="6">[</font><em>SimpleType</em><sub><font size="2">n</font></sub><font size="6">]</font><a href="#jd_map_content" class="judgment"><sub><font size="2">content(targetNCName)</font></sub></a>) }
      	  </td></tr>
      	</table></div>
  
      	<div align="center"><table cellpadding="0" cellspacing="0" summary="">
      	  <tr><td> </td></tr><tr><td style="margin-right:1cm;" align="center">
      	    
      	      <font size="6">[</font>
                <table summary=""><tbody><tr><td>  &lt;union</td></tr><tr><td>       
                     memberTypes = <em>QName</em><sub><font size="2">1</font></sub> ... <em>QName</em><sub><font size="2">n</font></sub>
                   /&gt;</td></tr></tbody></table>
      	      <font size="6">]</font><a href="#jd_map_simple_content" class="judgment"><sub><font size="2">simple_content(targetNCName)</font></sub></a>
      	    
      	  </td></tr>
      	  <tr><td align="center"><b>==</b></td></tr><tr><td style="margin-right:1cm;" align="center">
      	    { <em>QName</em><sub><font size="2">1</font></sub> | ... | <em>QName</em><sub><font size="2">n</font></sub> }
      	  </td></tr>
      	</table></div>

      </div></div></div><div class="div1">
<h2><a id="appendix_references" name="appendix_references"/>D References</h2><div class="div2">
<h3><a id="id-normative-references" name="id-normative-references"/>D.1 Normative References</h3><dl><dt class="label"><span><a id="REC-xml" name="REC-xml"/>XML</span></dt><dd><div>
      <a href="http://www.w3.org/TR/REC-xml"><cite>Extensible Markup Language (XML) 1.0 (Third Edition)</cite></a>, C. M. Sperberg-McQueen, Eve Maler, Tim Bray, <em>et. al.</em>, Editors. World Wide Web Consortium, 04 Feb 2004. This version is http://www.w3.org/TR/2004/REC-xml-20040204. The <a href="http://www.w3.org/TR/REC-xml">latest version</a> is available at http://www.w3.org/TR/REC-xml.</div></dd><dt class="label"><span><a id="XMLNAMES11" name="XMLNAMES11"/>XML Names 1.1</span></dt><dd><div>World Wide Web

Consortium. <em>Namespaces in XML 1.1.</em> W3C

Recommendation. See <a href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</a></div></dd><dt class="label"><span><a id="xmlschema-1" name="xmlschema-1"/>Schema Part 1</span></dt><dd><div>
      <a href="http://www.w3.org/TR/xmlschema-1/"><cite>XML Schema Part 1: Structures Second Edition</cite></a>, David Beech, Noah Mendelsohn, Murray Maloney, and Henry S. Thompson, Editors. World Wide Web Consortium, 28 Oct 2004. This version is http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The <a href="http://www.w3.org/TR/xmlschema-1/">latest version</a> is available at http://www.w3.org/TR/xmlschema-1/.</div></dd><dt class="label"><span><a id="xmlschema-2" name="xmlschema-2"/>Schema Part 2</span></dt><dd><div>
      <a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema Part 2: Datatypes Second Edition</cite></a>, Paul V. Biron and Ashok Malhotra, Editors. World Wide Web Consortium, 28 Oct 2004. This version is http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The <a href="http://www.w3.org/TR/xmlschema-2/">latest version</a> is available at http://www.w3.org/TR/xmlschema-2/.</div></dd><dt class="label"><span><a id="xpath-datamodel" name="xpath-datamodel"/>Data Model</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath-datamodel/"><cite>XQuery 1.0 and XPath 2.0 Data Model</cite></a>,
Norman Walsh, Mary Fernández, Ashok Malhotra, <em>et. al.</em>, Editors.
World Wide Web Consortium,
15 Sep 2005.
This version is http://www.w3.org/TR/2005/WD-xpath-datamodel-20050915/.
The <a href="http://www.w3.org/TR/xpath-datamodel/">latest version</a>
is available at http://www.w3.org/TR/xpath-datamodel/.</div></dd><dt class="label"><span><a id="xslt-xquery-serialization" name="xslt-xquery-serialization"/>Data Model Serialization</span></dt><dd><div>
<a href="http://www.w3.org/TR/xslt-xquery-serialization/"><cite>XSLT 2.0 and XQuery 1.0 Serialization</cite></a>,
Joanne Tong, Michael Kay, Norman Walsh, <em>et. al.</em>, Editors.
World Wide Web Consortium,
15 Sep 2005.
This version is http://www.w3.org/TR/2005/WD-xslt-xquery-serialization-20050915/.
The <a href="http://www.w3.org/TR/xslt-xquery-serialization/">latest version</a>
is available at http://www.w3.org/TR/xslt-xquery-serialization/.</div></dd><dt class="label"><span><a id="xquery" name="xquery"/>XQuery 1.0: A Query Language for XML</span></dt><dd><div>
<a href="http://www.w3.org/TR/xquery/"><cite>XQuery 1.0: An XML Query Language</cite></a>,
Don Chamberlin , Anders Berglund, Scott Boag, <em>et. al.</em>, Editors.
World Wide Web Consortium,
15 Sep 2005.
This version is http://www.w3.org/TR/2005/WD-xquery-20050915/.
The <a href="http://www.w3.org/TR/xquery/">latest version</a>
is available at http://www.w3.org/TR/xquery/.</div></dd><dt class="label"><span><a id="xpath20" name="xpath20"/>XML Path Language (XPath) 2.0</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath20/"><cite>XML Path Language (XPath) 2.0</cite></a>,
Don Chamberlin , Anders Berglund, Scott Boag, <em>et. al.</em>, Editors.
World Wide Web Consortium,
15 Sep 2005.
This version is http://www.w3.org/TR/2005/WD-xpath20-20050915/.
The <a href="http://www.w3.org/TR/xpath20/">latest version</a>
is available at http://www.w3.org/TR/xpath20/.</div></dd><dt class="label"><span><a id="xpath-functions" name="xpath-functions"/>Functions and Operators</span></dt><dd><div>
<a href="http://www.w3.org/TR/xpath-functions/"><cite>XQuery 1.0 and XPath 2.0 Functions and Operators</cite></a>,
Ashok Malhotra, Jim Melton, and Norman Walsh, Editors.
World Wide Web Consortium,
15 Sep 2005.
This version is http://www.w3.org/TR/2005/WD-xpath-functions-20050915/.
The <a href="http://www.w3.org/TR/xpath-functions/">latest version</a>
is available at http://www.w3.org/TR/xpath-functions/.</div></dd></dl></div><div class="div2">
<h3><a id="id-non-normative-references" name="id-non-normative-references"/>D.2 Non-normative References</h3><dl><dt class="label"><span><a id="xmlschema-0" name="xmlschema-0"/>XML Schema Part 0</span></dt><dd><div>
      <a href="http://www.w3.org/TR/xmlschema-0/"><cite>XML Schema Part 0: Primer Second Edition</cite></a>, David C. Fallside and Priscilla Walmsley, Editors. World Wide Web Consortium, 28 Oct 2004. This version is http://www.w3.org/TR/2004/REC-xmlschema-0-20041028/. The <a href="http://www.w3.org/TR/xmlschema-0/">latest version</a> is available at http://www.w3.org/TR/xmlschema-0/.</div></dd><dt class="label"><span><a id="xquery-requirements" name="xquery-requirements"/>XML Query 1.0 Requirements</span></dt><dd><div>
<a href="http://www.w3.org/TR/xquery-requirements/"><cite>XML Query (XQuery) Requirements</cite></a>,
Don Chamberlin, Peter Fankhauser, Massimo Marchiori, and Jonathan Robie, Editors.
World Wide Web Consortium,
3 Jun 2005.
This version is http://www.w3.org/TR/2005/WD-xquery-requirements-20050603/.
The <a href="http://www.w3.org/TR/xquery-requirements">latest version</a>
is available at http://www.w3.org/TR/xquery-requirements/.</div></dd></dl></div><div class="div2">
<h3><a id="id-background-references" name="id-background-references"/>D.3 Background References</h3><dl><dt class="label"><span><a id="Languages" name="Languages"/>Languages</span></dt><dd><div>

       Handbook of Formal Languages. G. Rozenberg and A. Salomaa,

       editors. <em>Springer-Verlag</em>. 1997.

     </div></dd><dt class="label"><span><a id="TATA" name="TATA"/>TATA</span></dt><dd><div>

       Tree Automata Techniques and Applications. H. Comon and

       M. Dauchet and R. Gilleron and F. Jacquemard and D. Lugiez and

       S. Tison and M. Tommasi. See <a href="http://www.grappa.univ-lille3.fr/tata/">http://www.grappa.univ-lille3.fr/tata/</a>. 1997.

     </div></dd></dl></div></div><div class="div1">
<h2><a id="sec_validation_judgments" name="sec_validation_judgments"/>E Auxiliary Judgments for Validation (Non-Normative)</h2><div class="div2">
<h3><a id="sec_validate" name="sec_validate"/>E.1 Judgments for the validate expression</h3><p>XQuery supports XML Schema validation using the validate
    expression. This section gives a non-normative formal semantics of XML Schema
    validation, solely for the purpose of specifying its usage in XQuery.</p><p>Specifying XML Schema validation requires a fairly large number
    of auxiliary judgments. There are two main judgments used to
    describe the semantics of validation.</p><ul><li><p>The "erase" judgment takes a value and removes
        all type information from it. This operation is necessary
        since, in XQuery, validation can occur both on well-formed or
        already validated documents.</p></li><li><p>The "annotate" operation takes an untyped
        value and a type and either fails or succeeds by returning a
        new -validated- value.</p></li></ul><p>Before defining those three judgments, we first introduce
    auxiliary judgments used to describe specific parts of the XML
    Schema's semantics.</p><div class="div3">
<h4><a id="N283F9" name="N283F9"/>E.1.1 Type resolution</h4><p><b>Notation</b></p>
        <p id="jd_resolves_to">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          (<a href="#doc-fs-TypeReference"><em>TypeReference</em></a> | <a href="#doc-fs-TypeDerivation"><em>TypeDerivation</em></a>)
          <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
          
        </div>

        <p>holds when a type reference or a type derivation resolves
        to the given type name and type content.</p>
      <p><b>Semantics</b></p>     
        <p>This judgment is specified by the following rules.</p>

	<p>If the type is omitted, it is resolved as the empty
	sequence type.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Derivation"><em>Derivation</em></a>? <a href="#doc-fs-Mixed"><em>Mixed</em></a>? { empty } <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
            
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Derivation"><em>Derivation</em></a>? <a href="#doc-fs-Mixed"><em>Mixed</em></a>? { } <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
            
           </td></tr>
          </table><br/>
        </div>

        <p>In case of a type reference, then the type name is the name
        of that type, and the type is taken by resolving the type
        declaration of the global type.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
            </td></tr>
            <tr valign="middle" align="center"><td>

             
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) =&gt; define type
                <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#doc-fs-TypeDerivation"><em>TypeDerivation</em></a>
              
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeDerivation"><em>TypeDerivation</em></a> <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a>
              <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             of type <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
            
           </td></tr>
          </table><br/>
        </div>

        <p>In the above inference rule, note that <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a> is
        the base type of the type referred to. So this is indeed the
        original type name, <a href="#doc-fs-TypeName"><em>TypeName</em></a>, which must be returned, and
        eventually used to annotated the corresponding element or
        attribute. However, the type needs to be obtained through a
        second application of the <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a> judgment.</p>

        <p>If the type derivation is a restriction, then the type name
        is the name of the base type, and the type is taken from the
        type derivation.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Mixed"><em>Mixed</em></a>? <a href="#doc-fs-Type"><em>Type</em></a> <a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a> <em>Adjusted</em><a href="#doc-fs-Type"><em>Type</em></a>
            
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             restricts <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#doc-fs-Mixed"><em>Mixed</em></a>? {
             <a href="#doc-fs-Type"><em>Type</em></a> } <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a> {
             <em>Adjusted</em><a href="#doc-fs-Type"><em>Type</em></a> }
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the type derivation is an extension, then the type name
        is the name of the base type, and the type is the base type
        extended by the type in the type derivation.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
          
           <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
           
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#jd_elem_qname_expands_to" class="judgment"><b>of elem/type expands to</b></a> <a href="#id-expanded-qnames"><em>expanded-QName</em></a>
           
          
            </td></tr>
            <tr valign="middle" align="center"><td>

             
              
                <a href="#xq_stat_env_def" class="env">statEnv</a>.<a href="#xq_type_defn" class="env">typeDefn</a>(<a href="#id-expanded-qnames"><em>expanded-QName</em></a>) =&gt; define type
                <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#doc-fs-Derivation"><em>Derivation</em></a>? <em>Base</em><a href="#doc-fs-Mixed"><em>Mixed</em></a>? {
                <em>Base</em><a href="#doc-fs-Type"><em>Type</em></a>? }
              
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <em>Base</em><a href="#doc-fs-Type"><em>Type</em></a>? <a href="#jd_extended_by" class="judgment"><b>extended by</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
              <a href="#jd_extended_by" class="judgment"><b>is</b></a> <em>Extended</em><a href="#doc-fs-Type"><em>Type</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Mixed"><em>Mixed</em></a>? <em>Extended</em><a href="#doc-fs-Type"><em>Type</em></a>
              <a href="#jd_adjusts_to" class="judgment"><b>adjusts to</b></a> <em>Adjusted</em><a href="#doc-fs-Type"><em>Type</em></a>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             extends <a href="#doc-fs-TypeName"><em>TypeName</em></a> <a href="#doc-fs-Mixed"><em>Mixed</em></a>? { <a href="#doc-fs-Type"><em>Type</em></a>
             } <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <em>Adjusted</em><a href="#doc-fs-Type"><em>Type</em></a> }
            
           </td></tr>
          </table><br/>
        </div>
  
      </div><div class="div3">
<h4><a id="N2866D" name="N2866D"/>E.1.2 Interleaving</h4><p><b>Notation</b></p>
        <p id="jd_interleave">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_interleave" class="judgment"><b>interleave</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
          <a href="#jd_interleave" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
          
        </div>

        <p>holds if some interleaving of <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
        yields <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>.  Interleaving is non-deterministic; it is
        used for processing all groups.</p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>Interleaving two empty sequences yields the empty
        sequence.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             () <a href="#jd_interleave" class="judgment"><b>interleave</b></a> () <a href="#jd_interleave" class="judgment"><b>yields</b></a>
             ()
            
           </td></tr>
          </table><br/>
        </div>

        <p>Otherwise, pick an item from the head of one of the
        sequences, and recursively interleave the remainder.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_interleave" class="judgment"><b>interleave</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             <a href="#jd_interleave" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
            
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Item"><em>Item</em></a>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_interleave" class="judgment"><b>interleave</b></a>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_interleave" class="judgment"><b>yields</b></a>
             <a href="#doc-fs-Item"><em>Item</em></a>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_interleave" class="judgment"><b>interleave</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             <a href="#jd_interleave" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
            
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_interleave" class="judgment"><b>interleave</b></a>
             <a href="#doc-fs-Item"><em>Item</em></a>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_interleave" class="judgment"><b>yields</b></a>
             <a href="#doc-fs-Item"><em>Item</em></a>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

      </div><div class="div3">
<h4><a id="sec_jd_filter" name="sec_jd_filter"/>E.1.3 Attribute filtering</h4><p><b>Introduction</b></p>
        <p>Finally, we introduce an auxiliary judgment which extracts
        the value of a given attribute if it exists. This judgment is
        not used in the semantics of step expressions, but in <a href="#sec_type_matching"><b>[8.3 Judgments for type matching]</b></a>, and is based on the other filter
        judgments.</p>
      <p><b>Notation</b></p>
        <p id="jd_filter">The judgment</p>

        <div align="center">
          
          <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter" class="judgment"><b>filter</b></a> @<em>QName</em> <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> ()
          
        </div>

        <p>holds if there are no occurrences of the attribute
        <em>QName</em> in <a href="#doc-fs-Value"><em>Value</em></a>. The judgment</p>

        <div align="center">
          
          <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter" class="judgment"><b>filter</b></a> @<em>QName</em> <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>
          
        </div>

        <p>holds if there is one occurrence of the attribute
        <em>QName</em> in <a href="#doc-fs-Value"><em>Value</em></a>, and the value of that attribute is
        <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>.  The judgment</p>

        <div align="center">
          
          <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter" class="judgment"><b>filter</b></a> @<em>QName</em>
          <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> () <a href="#jd_filter" class="judgment"><b>or</b></a> <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>
          
        </div>

        <p>holds if either of the previous two judgments hold.</p>
      <p><b>Semantics</b></p>
        <p>The <a href="#jd_filter" class="judgment"><b>filter</b></a> judgments are defined as follows.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_axis" class="judgment"><b>of</b></a> attribute::
              <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_axis" class="judgment"><b>of</b></a> attribute,
              <em>QName</em> <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> ()
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_filter" class="judgment"><b>filter</b></a> @<em>QName</em>
              <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> ()
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_axis" class="judgment"><b>of</b></a> attribute::
              <a href="#jd_axis" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_dyn_env_def" class="env">dynEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_axis" class="judgment"><b>of</b></a>
              attribute,<em>QName</em> <a href="#jd_axis" class="judgment"><b>=&gt;</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">3</font></sub> = attribute <em>QName</em> {
              <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> }
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_filter" class="judgment"><b>filter</b></a> @<em>QName</em>
              <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>
            
           </td></tr>
          </table><br/>
        </div>
      </div><div class="div3">
<h4><a id="N28965" name="N28965"/>E.1.4 Erasure</h4><div class="div4">
<h5><a id="N28968" name="N28968"/>E.1.4.1 Simply erases</h5><p><b>Notation</b></p>
        <p id="jd_simply_erases_to">To define erasure, an auxiliary
        judgment is needed.  The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href="#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
          <em>String</em>
          
        </div>

        <p>holds when <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> erases to the string
        <em>String</em>.</p>

      <p><b>Semantics</b></p>

        <p>This judgment is specified by the following rules.</p>

        <p>The empty sequence erases to the empty string.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             () <a href="#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a> ""
            
           </td></tr>
          </table><br/>
        </div>

        <p>The concatenation of two non-empty sequences of values
        erases to the concatenation of their erasures with a
        separating space.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub> <a href="#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
              <em>String</em><sub><font size="2">1</font></sub> <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub> != ()
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub> <a href="#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
              <em>String</em><sub><font size="2">2</font></sub> <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub> != ()
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>
             <a href="#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a> <code>fn:concat</code>(<em>String</em><sub><font size="2">1</font></sub>,"
             ",<em>String</em><sub><font size="2">2</font></sub>)
            
           </td></tr>
          </table><br/>
        </div>

        <p>An atomic value erases to its string representation as an
        instance of <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a> of type <a href="#doc-fs-AtomicTypeName"><em>AtomicTypeName</em></a>
             <a href="#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
             <em>dm:</em><code>string-value</code>(<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>) of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>
            
           </td></tr>
          </table><br/>
        </div>

      </div><div class="div4">
<h5><a id="N28A83" name="N28A83"/>E.1.4.2 Erases</h5><p><b>Notation</b></p>
        <p id="jd_erases_to">
The <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> judgment is used in the definition of the dynamic
semantics of validation. 
The normative dynamic semantics of validation is specified in 
<a href="http://www.w3.org/TR/xquery#id-validate">Section 
3.13 Validate Expressions</a><sup><small>XQ</small></sup>.
The effect of the validate expression is equivalent to:
</p><ul><li><p>serialization of the data model, as described in
<a href="#xslt-xquery-serialization">[Data Model Serialization]</a>, followed by </p></li><li><p>validation of the serialized value into a Post-Schema
Validated Infoset, as described in <a href="#xmlschema-1">[Schema Part 1]</a>, followed by</p></li><li><p>construction of a new data model value, as described in
<a href="#xpath-datamodel">[Data Model]</a>.</p></li></ul><p>
Erasure is the formal equivalent of serialization followed by
construction a new data model value in which all element nodes are
labeled with <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a> and all attribute nodes with <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.
</p>

<p>
The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_erases_to" class="judgment"><b>erases to</b></a>
          <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
          
        </div>

        <p>holds when the erasure of <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> is <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>.</p>

      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>The empty sequence erases to itself.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             () <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> ()
            
           </td></tr>
          </table><br/>
        </div>

        <p>The erasure of the concatenation of two values is the
        concatenation of their erasure, so long as neither of the two
        original values is simple.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_erases_to" class="judgment"><b>erases to</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>'
                 
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> not a simple value
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_erases_to" class="judgment"><b>erases to</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>'
                 
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> not a simple value
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> <a href="#jd_erases_to" class="judgment"><b>erases to</b></a>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>',<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>'
            
           </td></tr>
          </table><br/>
        </div>

        <p>The erasure of an element is an element that has the same
        name and the type <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a> and the erasure of the original
        content.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             element <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> } <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> element
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a> { <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             }
            
           </td></tr>
          </table><br/>
        </div>

        <p>The erasure of an attribute is an attribute that has the
        same name and the type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> and the simple erasure
        of the original content labeled with <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
              <em>String</em>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> of type
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Value"><em>Value</em></a> } <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> attribute
             <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> { <em>String</em>
             of type <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> }
            
           </td></tr>
          </table><br/>
        </div>

        <p>The erasure of a document is a document with the erasure of
        the original content.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_erases_to" class="judgment"><b>erases to</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             document { <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> } <a href="#jd_erases_to" class="judgment"><b>erases to</b></a>
             document { <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> }
            
           </td></tr>
          </table><br/>
        </div>

        <p>The erasure of a text or comment or processing-instruction node is itself.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b> text
             { <em>String</em> } <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> text { <em>String</em>
             }
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b> comment
             { <em>String</em> } <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> comment { <em>String</em>
             }
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             processing-instruction <em>QName</em>
             { <em>String</em> } <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> processing-instruction <em>QName</em> { <em>String</em>
             }
            
           </td></tr>
          </table><br/>
        </div>

        <p>The erasure of a simple value is the corresponding text
        node.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href="#jd_simply_erases_to" class="judgment"><b>simply erases to</b></a>
              <em>String</em>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> <a href="#jd_erases_to" class="judgment"><b>erases to</b></a> text {
             <em>String</em> }
            
           </td></tr>
          </table><br/>
        </div>

      </div></div><div class="div3">
<h4><a id="N28D8B" name="N28D8B"/>E.1.5 Annotate</h4><p>The <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> judgment is used in the definition of the dynamic
semantics of validation. 
The normative dynamic semantics of validation is specified in 
<a href="http://www.w3.org/TR/xquery#id-validate">Section 
3.13 Validate Expressions</a><sup><small>XQ</small></sup>.
The effect of the validate expression is equivalent to:
</p><ul><li><p>serialization of the data model, as described in
<a href="#xslt-xquery-serialization">[Data Model Serialization]</a>, followed by</p></li><li><p>parsing of the serialized value into the Infoset</p></li><li><p>validation of the Infoset into a Post-Schema
Validated Infoset, as described in <a href="#xmlschema-1">[Schema Part 1]</a>, followed by</p></li><li><p>construction of a new data model value, as described in
<a href="#xpath-datamodel">[Data Model]</a>.</p></li></ul><p>
Annotation is the formal equivalent of schema validation of an Infoset
value value into the PSVI followed by construction of a new data model
value.   Because the Formal Semantics is defined on data model values,
not the Infoset, annotation is applied to a data model values in which
all element nodes are labeled with <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a> and all attribute
nodes with <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a> -- that is, the result of erasure. 
</p><div class="div4">
<h5><a id="sec_simply_annotate" name="sec_simply_annotate"/>E.1.5.1 Simply annotate</h5><p><b>Notation</b></p>
          <p id="jd_cast_as">The judgment</p>
  
          <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
            <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em> ( <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>
            ) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>
          
          </div>
  
          <p>holds if the result of casting the <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub> to
          <em>SimpleType</em> is <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>.</p>

  
        <p><b>Semantics</b></p>
          <p>This judgment is specified by the following rules.</p>
  
          <p>Simply annotating a simple value to a union type yields the
          result of simply annotating the simple value to either the
          first or second type in the union. Note that simply annotating
          to the second type is attempted only if simply annotating to
          the first type <em>fails</em>.</p>
  
          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em><sub><font size="2">1</font></sub>
                (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
                <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>
               
              </td></tr>
             </table></td></tr></table></td></tr>
             <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a>
               <em>SimpleType</em><sub><font size="2">1</font></sub>|<em>SimpleType</em><sub><font size="2">2</font></sub> (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>)
               <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>
              
             </td></tr>
            </table><br/>
          </div>
  
          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                (<a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em><sub><font size="2">1</font></sub>
                (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>)
                fails
               
              </td></tr>
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em><sub><font size="2">2</font></sub>
                (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
                <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>
               
              </td></tr>
             </table></td></tr></table></td></tr>
             <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a>
               <em>SimpleType</em><sub><font size="2">1</font></sub>|<em>SimpleType</em><sub><font size="2">2</font></sub> (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>)
               <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>
              
             </td></tr>
            </table><br/>
          </div>
  
          <p>The simple annotation rules for ?, +, * are similar.</p>
  
          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
             </td></tr>
             <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>? ( () )
               <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a> ()
              
             </td></tr>
            </table><br/>
          </div>
  
          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>
                (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
                <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>
               
              </td></tr>
             </table></td></tr></table></td></tr>
             <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>?
               (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>
              
             </td></tr>
            </table><br/>
          </div>
  
          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
             </td></tr>
             <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>* ( () )
               <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a> ()
              
             </td></tr>
            </table><br/>
          </div>
  
          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>
                (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
                <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>'
               
</td></tr>
<tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>*
                (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
                <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>'
               
              </td></tr>
             </table></td></tr></table></td></tr>
             <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>*
               (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>',<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>'
              
             </td></tr>
            </table><br/>
          </div>
  
          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
              <tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>
                (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
                <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>'
               
</td></tr>
<tr valign="middle" align="center"><td>
               
                <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
                <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>*
                (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
                <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>'
               
              </td></tr>
             </table></td></tr></table></td></tr>
             <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em>+
               (<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
               <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">1</font></sub>',<a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a><sub><font size="2">2</font></sub>'
              
             </td></tr>
            </table><br/>
          </div>
  
          <p>Simply annotating an atomic value to <code>xs:string</code> yields its
          string representation.</p>
  
          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
             </td></tr>
             <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <code>xs:string</code> (<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>)
               <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
               <em>dm:</em>string-value(<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>)
              
             </td></tr>
            </table><br/>
          </div>
  
          <p>Simply annotating an atomic value to <code>xs:decimal</code> yields
          the decimal that results from parsing its string
          representation.</p>
  
          <div align="center">
            <table cellpadding="0" cellspacing="0" summary="">
             <tr valign="middle" align="center"><td>
             </td></tr>
             <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
              
               <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
               <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <code>xs:decimal</code> (<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>)
               <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
               <code>xs:decimal</code>(<em>dm:</em><code>string-value</code>(<a href="#doc-fs-AtomicValue"><em>AtomicValue</em></a>))
              
             </td></tr>
            </table><br/>
          </div>
  
          <p>Similar rules are assumed for the rest of the 19 XML Schema
          primitive types.</p>
  
      </div><div class="div4">
<h5><a id="N2915A" name="N2915A"/>E.1.5.2 Nil-annotate</h5><p><b>Notation</b></p>
        <p id="jd_nil_annotate_as">The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#jd_nil_annotate_as" class="judgment"><b>nil-annotate as</b></a> <a href="#doc-fs-Nillable"><em>Nillable</em></a>? <a href="#doc-fs-Type"><em>Type</em></a> (
          <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> ) <a href="#jd_nil_annotate_as" class="judgment"><b>=&gt;</b></a>
          <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
          
        </div>

        <p>holds if it is possible to annotate value <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> as if
        it had the nillable type <a href="#doc-fs-Type"><em>Type</em></a> and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> is the
        corresponding annotated value.</p>

      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>If the type is not nillable, then the xsi:nil attribute
        must not appear in the value, and it must be possible to
        annotate value <a href="#doc-fs-Value"><em>Value</em></a> as if it had the type <a href="#doc-fs-Type"><em>Type</em></a>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_filter" class="judgment"><b>filter</b></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> ()
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a> ( <a href="#doc-fs-Value"><em>Value</em></a> )
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_nil_annotate_as" class="judgment"><b>nil-annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a> ( <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> )
             <a href="#jd_nil_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the type is nillable, and the xsi:nil attribute does not
        appear or is false, then it must be possible to annotate value
        <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> as if it had the type <a href="#doc-fs-Type"><em>Type</em></a>.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_filter" class="judgment"><b>filter</b></a> @xsi:nil
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> () <a href="#jd_filter" class="judgment"><b>or</b></a>
              false
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a> ( <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> )
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_nil_annotate_as" class="judgment"><b>nil-annotate as</b></a> nillable <a href="#doc-fs-Type"><em>Type</em></a> (
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> ) <a href="#jd_nil_annotate_as" class="judgment"><b>=&gt;</b></a>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <p>If the type is nillable, and the xsi:nil attribute is true,
        then it must be possible to annotate value <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> as if
        it had a type where the attributes in the type are kept and
        the element content of the type is ignored.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_filter" class="judgment"><b>filter</b></a> @xsi:nil
              <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> true
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <em>AttributeAll</em> (
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> ) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_nil_annotate_as" class="judgment"><b>nil-annotate as</b></a> nillable
             (<em>AttributeAll</em>, <a href="#doc-fs-ElementContentType"><em>ElementContentType</em></a>) ( <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> )
             <a href="#jd_nil_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

      </div><div class="div4">
<h5><a id="N2934E" name="N2934E"/>E.1.5.3 Annotate</h5><p id="jd_annotate_as">
The <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> judgment is used in the definition of the dynamic
semantics of validation. 
The normative dynamic semantics of validation is specified in 
<a href="http://www.w3.org/TR/xquery#id-validate">Section 
3.13 Validate Expressions</a><sup><small>XQ</small></sup>.
The effect of the validate expression is equivalent to:
</p><ul><li><p>serialization of the data model, as described in
<a href="#xslt-xquery-serialization">[Data Model Serialization]</a>, followed by</p></li><li><p>parsing of the serialized value into the Infoset</p></li><li><p>validation of the Infoset into a Post-Schema
Validated Infoset, as described in <a href="#xmlschema-1">[Schema Part 1]</a>, followed by</p></li><li><p>construction of a new data model value, as described in
<a href="#xpath-datamodel">[Data Model]</a>.</p></li></ul><p>
Erasure is the formal equivalent of serialization followed by construction a new data model value in which all element nodes are labeled with <a href="#dt-xdt_untyped"><code>xdt:untyped</code></a> and all attribute nodes with <a href="#dt-xdt_untypedAtomic"><code>xdt:untypedAtomic</code></a>.
</p><p><b>Notation</b></p>
        <p>The judgment</p>

        <div align="center">
          
          <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
          <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a> ( <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> )
          <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
          
        </div>

        <p>holds if it is possible to annotate value <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> as if
        it had type <a href="#doc-fs-Type"><em>Type</em></a> and <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> is the corresponding
        annotated value.</p>

      <p><b>Note</b></p>
        <p>Assume an XML Infoset instance X1 is validated against an
        XML Schema S, yielding PSVI instance X2. Then if X1
        corresponds to <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> and S corresponds to <a href="#doc-fs-Type"><em>Type</em></a> and
        X2 corresponds to <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>, the following should hold:
        <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a> ( <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> )
        <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>.</p>
      <p><b>Semantics</b></p>
        <p>This judgment is specified by the following rules.</p>

        <p>Annotating the empty sequence as the empty type yields the
        empty sequence.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> () (())
             <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> ()
            
           </td></tr>
          </table><br/>
        </div>

        <p>Annotating a concatenation of values as a concatenation of
        types yields the concatenation of the annotated values.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>'
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>)
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>'
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>',<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>'
            
           </td></tr>
          </table><br/>
        </div>

        <p>Annotating a value as a choice type yields the result of
        annotating the value as either the first or second type in the
        choice.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub>|<a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
             <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <p>Annotating a value as an all group uses interleaving to
        decompose the original value and recompose the annotated
        value.</p>

        <table border="1" summary="Editorial note"><tr><td width="50%" valign="top" align="left"><b>Editorial note</b></td><td width="50%" valign="top" align="right"> </td></tr><tr><td valign="top" align="left" colspan="2">Jerome and Phil: Note that this may reorder the
          original sequence.  Perhaps we should disallow such
          reordering. Specifying that formally is not as easy as we
          would like.</td></tr></table>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> ( <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> )
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>'
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub> ( <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub> )
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>'
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub> <a href="#jd_interleave" class="judgment"><b>interleave</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
              <a href="#jd_interleave" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>' <a href="#jd_interleave" class="judgment"><b>interleave</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>'
              <a href="#jd_interleave" class="judgment"><b>yields</b></a> <a href="#doc-fs-Value"><em>Value</em></a>'
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">1</font></sub> &amp; <a href="#doc-fs-Type"><em>Type</em></a><sub><font size="2">2</font></sub>
             ( <a href="#doc-fs-Value"><em>Value</em></a> ) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
             <a href="#doc-fs-Value"><em>Value</em></a>'
            
           </td></tr>
          </table><br/>
        </div>

        <p>The annotation rules for ?, +, * are similar.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> (<a href="#doc-fs-Type"><em>Type</em></a> |
              empty)(<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a>? (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)
             <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a> (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>'
                 
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a>* (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>)
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>'
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a>+
             (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
             (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>',<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>')
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a>* ( () )
             <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> ()
            
           </td></tr>
          </table><br/>
        </div>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a> (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>)
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>'
                 
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a>* (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>)
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>'
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a>*
             (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>,<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
             (<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">1</font></sub>',<a href="#doc-fs-Value"><em>Value</em></a><sub><font size="2">2</font></sub>')
            
           </td></tr>
          </table><br/>
        </div>

        <p>To annotate an element with no xsi:type attribute, first
        look up the element type, next resolve the resulting type
        reference, then annotate the value against the resolved type,
        and finally return a new element with the name of the original
        element, the resolved type name, and the annotated value.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter" class="judgment"><b>filter</b></a> @xsi:type
              <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> ()
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup" class="judgment"><b>name lookup</b></a>
              <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup" class="judgment"><b>yields</b></a> <a href="#doc-fs-Nillable"><em>Nillable</em></a>?
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a>
              <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_nil_annotate_as" class="judgment"><b>nil-annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
              <a href="#doc-fs-Nillable"><em>Nillable</em></a>? (<a href="#doc-fs-Value"><em>Value</em></a>) <a href="#jd_nil_annotate_as" class="judgment"><b>=&gt;</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a>'
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a> ( element
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type <code>xs:anyType</code> { <a href="#doc-fs-Value"><em>Value</em></a> } )
             <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> element <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Value"><em>Value</em></a>' }
            
           </td></tr>
          </table><br/>
        </div>

        <p>To annotate an element with an xsi:type attribute, define a
        type reference corresponding to the xsi:type.  Look up the
        element type, yielding a type reference, and check that the
        xsi:type reference derives from this type reference.  Resolve
        the xsi:type reference, then annotate the value against the
        resolved type, and finally return a new element with the name
        of the original element, the resolved type name, and the
        annotated value.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#doc-fs-Value"><em>Value</em></a> <a href="#jd_filter" class="judgment"><b>filter</b></a> @xsi:type
              <a href="#jd_filter" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-TypeName"><em>TypeName</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <em>Xsi</em><a href="#doc-fs-TypeReference"><em>TypeReference</em></a> = of type
              <a href="#doc-fs-TypeName"><em>TypeName</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-ElementName"><em>ElementName</em></a> <a href="#jd_lookup" class="judgment"><b>name lookup</b></a>
              <a href="#doc-fs-ElementType"><em>ElementType</em></a> <a href="#jd_lookup" class="judgment"><b>yields</b></a> <a href="#doc-fs-Nillable"><em>Nillable</em></a>?
              of type <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeName"><em>TypeName</em></a>
              <a href="#jd_derives_from" class="judgment"><b>derives from</b></a>
              <a href="#doc-fs-TypeName"><em>BaseTypeName</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <em>Xsi</em><a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a>
              <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_nil_annotate_as" class="judgment"><b>nil-annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
              <a href="#doc-fs-Nillable"><em>Nillable</em></a>? (<a href="#doc-fs-Value"><em>Value</em></a>) <a href="#jd_nil_annotate_as" class="judgment"><b>=&gt;</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a>'
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-ElementType"><em>ElementType</em></a> ( element
             <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type <code>xs:anyType</code> { <a href="#doc-fs-Value"><em>Value</em></a> } )
             <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> element <a href="#doc-fs-ElementName"><em>ElementName</em></a> of type
             <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Value"><em>Value</em></a>' }
            
           </td></tr>
          </table><br/>
        </div>

        <p>The rule for attributes is similar to the first rule for
        elements.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary=""><tr valign="middle" align="center"><td><table cellpadding="0" cellspacing="0" summary="">
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>name lookup</b></a>
              <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> <a href="#jd_attribute_lookup" class="judgment"><b>yields</b></a>
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a>
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#doc-fs-TypeReference"><em>TypeReference</em></a> <a href="#jd_resolves_to" class="judgment"><b>resolves to</b></a>
              <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Type"><em>Type</em></a> }
             
            </td></tr>
            <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_nil_annotate_as" class="judgment"><b>nil-annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a>
              <a href="#doc-fs-Nillable"><em>Nillable</em></a>? (<a href="#doc-fs-Value"><em>Value</em></a>) <a href="#jd_nil_annotate_as" class="judgment"><b>=&gt;</b></a>
              <a href="#doc-fs-Value"><em>Value</em></a>'
             
            </td></tr>
           </table></td></tr></table></td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-AttributeType"><em>AttributeType</em></a> (
             attribute <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> of type <code>xs:anySimpleType</code> {
             <a href="#doc-fs-Value"><em>Value</em></a> } ) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> attribute
             <a href="#doc-fs-AttributeName"><em>AttributeName</em></a> of type <a href="#doc-fs-TypeName"><em>TypeName</em></a> { <a href="#doc-fs-Value"><em>Value</em></a>'
             }
            
           </td></tr>
          </table><br/>
        </div>

        <p>Annotating a document node yields a document with the
        annotation of its contents.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <a href="#doc-fs-Type"><em>Type</em></a> (<a href="#doc-fs-Value"><em>Value</em></a>)
              <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> <a href="#doc-fs-Value"><em>Value</em></a>'
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> document { <a href="#doc-fs-Type"><em>Type</em></a> } (
             document { <a href="#doc-fs-Value"><em>Value</em></a> } ) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> document
             { <a href="#doc-fs-Value"><em>Value</em></a>' }
            
           </td></tr>
          </table><br/>
        </div>

        <p>Annotating a text node as text yields itself.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> text (text { <em>String</em> })
             <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a> text { <em>String</em> }
            
           </td></tr>
          </table><br/>
        </div>

        <p>Annotating a text nodes as a simple type is identical to
        casting.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em> ( <em>String</em>
              as <code>xs:anySimpleType</code> ) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
              <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>'
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <em>SimpleType</em> ( text {
             <em>String</em> } ) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
             <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>'
            
           </td></tr>
          </table><br/>
        </div>

        <p>Annotating a simple value as a simple type is identical to
        casting.</p>

        <div align="center">
          <table cellpadding="0" cellspacing="0" summary="">
           <tr valign="middle" align="center"><td>
             
              <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
              <a href="#jd_cast_as" class="judgment"><b>simply annotate as</b></a> <em>SimpleType</em> (
              <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> ) <a href="#jd_cast_as" class="judgment"><b>=&gt;</b></a>
              <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>'
             
           </td></tr>
           <tr><td><hr noshade="noshade" size="1" style="color:black"/></td></tr><tr valign="middle" align="center"><td>
            
             <a href="#xq_stat_env_def" class="env">statEnv</a><b> |- </b>
             <a href="#jd_annotate_as" class="judgment"><b>annotate as</b></a> <em>SimpleType</em> (
             <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a> ) <a href="#jd_annotate_as" class="judgment"><b>=&gt;</b></a>
             <a href="#doc-fs-SimpleValue"><em>SimpleValue</em></a>'
            
           </td></tr>
          </table><br/>
        </div>
      </div></div></div></div><div class="div1">
<h2><a id="id-fs-revisions-log" name="id-fs-revisions-log"/>F Revision Log (Non-Normative)</h2><p>This log records the changes that have been made to this document
  since the Working Draft of 3 June 2005 Last Call Working Draft.</p><div class="div2">
<h3><a id="N29C51" name="N29C51"/>F.1 15 September 2005</h3><ol class="enumar"><li><p>Completely removed the formal specification of error
      propagation, and which kind of dynamic errors are
      raised.</p></li><li><p>Fixed static typing rules for fn:subsequence</p></li><li><p>Numerous fixes to static typing rules for function
      calls, including overloaded functions in Appendix B.2.</p></li><li><p>Fixed bugs in auxiliary functions dealing with type
      promotion and atomization in the semantics of function
      calls.</p></li><li><p>Fixed handling of namespace "unbinding" under the
      namespaces rules for XML 1.1.</p></li><li><p>Fixed dynamic evaluation rules for literals.</p></li><li><p>Fixed static typing rules for document constructors.</p></li><li><p>Fixed a bug in the rule implementing the 'union
      interpretation' for derivation by extension.</p></li><li><p>Fixed bugs in the rules for module import, now dealing
      with multiple modules with the same namespace properly.</p></li><li><p>Fixed terminology for some aspects of the type system,
      and added clarification pointers in a number of
      places.</p></li><li><p>Fixed numerous bugs and typos, as a result of
      processing last call comments.</p></li><li><p>A few minor fixes to the core grammar (e.g.,
      Constructor production was missing).</p></li></ol></div></div></div></body></html>