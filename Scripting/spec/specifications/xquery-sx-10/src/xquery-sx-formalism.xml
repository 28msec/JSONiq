<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE spec SYSTEM "../../xpath-semantics-10/schema/xquery-semantics.dtd"[

<!-- Fix the broken definition for prodrecap from the XML spec DTD - jpcs -->
<!ENTITY % ref-req.att "ref    NMTOKEN    #REQUIRED">

<!ENTITY doc.version "1.0">
<!ENTITY doc.version-code "10">
<!ENTITY doc.stage "WD">
<!ENTITY doc.w3c-doctype "wd">
<!ENTITY doc.w3c-doctype-full "Working Draft">
<!ENTITY date.day "21">
<!ENTITY date.DD "21">
<!ENTITY date.month "January">
<!ENTITY date.monthnum "01">
<!ENTITY date.year "2011">
<!ENTITY doc.date "&date.year;&date.monthnum;&date.DD;">
<!ENTITY w3c.tr "http://www.w3.org/TR">
<!ENTITY doc.shortname "xquery-sx-&doc.version-code;">
<!ENTITY doc.w3c-designation "&doc.stage;-&doc.shortname;">
<!ENTITY doc.publoc "&w3c.tr;/&date.year;/&doc.w3c-designation;-&doc.date;">
<!ENTITY doc.latestloc "&w3c.tr;/&doc.shortname;/">
<!ENTITY language "XQuery Scripting Extension Proposal">

<!ENTITY xqsx-xqueryx SYSTEM "xqsx-xqueryx.xml">
<!ENTITY xqsx-xqueryx-schema SYSTEM "xqsx-schema.xml">
<!ENTITY xqsx-xqueryx-redef-schema SYSTEM "xqsx-redef-schema.xml">
<!ENTITY xqsx-xqueryx-stylesheet SYSTEM "xqsx-stylesheet.xml">
<!ENTITY xqsx-xqueryx-xq-example1a SYSTEM "xqsx-example-1a.xml">
<!ENTITY xqsx-xqueryx-xqx-example1b SYSTEM "xqsx-example-1b.xml">
<!ENTITY xqsx-xqueryx-xq-trans-example1c SYSTEM "xqsx-example-1c.xml">

<!ENTITY % status-entities SYSTEM "../../../etc/status-entities.dtd">
%status-entities;

<!ENTITY doc.WD-pubdate "21 January 2011">
<!ENTITY doc.LC-pubdate "TO BE SPECIFIED">
<!ENTITY doc.LC-comments-due "TO BE SPECIFIED">
<!ENTITY doc.CR-pubdate "TO BE SPECIFIED">
<!ENTITY doc.CR-comments-due "TO BE SPECIFIED">
<!ENTITY doc.PR-expected "TO BE SPECIFIED">
<!ENTITY doc.PR-pubdate "TO BE SPECIFIED">
<!ENTITY doc.PR-comments-due "TO BE SPECIFIED">
<!ENTITY doc.REC-pubdate "TO BE SPECIFIED">
<!ENTITY doc.pubdate "&doc.WD-pubdate;">
<!ENTITY doc.comments-due "$doc.WD-comments-due;">

<!ENTITY status-section-id "status">
<!ENTITY spec-devby "&devby.xquery;">
<!ENTITY changelog-id "id-revisions-log">
<!ENTITY changes-para "&post.WD.changes;">
<!ENTITY implementation-report-location "">
<!ENTITY implementation-report-availability "&report-public;">
<!ENTITY implementation-report "&no-implementation-report-or-test-suite-yet;">
<!ENTITY test-suite-location "TO BE PROVIDED">
<!ENTITY disclosure.one "&disclosure.xquery;">
<!ENTITY Bugzilla-key "SX">
<!ENTITY patent-policy-paragraph "&ppp-one;">
<!ENTITY documents-and-relationships "&not-set-of-documents;">
<!ENTITY advancement.statement "&advance.1WG;">
<!ENTITY doc-stability "&doc-stability-WD;">
<!ENTITY features-at-risk-para "&no-features-at-risk;">
<!ENTITY document-stage "&doc-stage-WD;">
<!ENTITY customized-paragraph '<p>This is the last version of XQuery Scripting Extension that
is aligned with XQuery Update Facility 1.0.  In future versions of this document, the Working Group
intends to reposition XQuery Scripting Extension 1.0 against the <bibref ref="XQ11"/> set of
specifications, and remove it from the <bibref ref="XQ10"/> publication track.</p>'>

<!ENTITY status-section SYSTEM "../../../etc/status-general.xml">
]>
<spec id="spec-top" w3c-doctype="&doc.w3c-doctype;">
  <header id="spec-header">
    <title>&language;</title>
    <w3c-designation>&doc.w3c-designation;</w3c-designation>
    <w3c-doctype>W3C &doc.w3c-doctype-full;</w3c-doctype>
    <pubdate>
      <day>&date.day;</day>
      <month>&date.month;</month>
      <year>&date.year;</year>
    </pubdate>
    <publoc>
      <loc href="&doc.publoc;">&doc.publoc;</loc>
    </publoc>
    <latestloc>
      <loc href="&doc.latestloc;">&doc.latestloc;</loc>
    </latestloc>
    <prevlocs>
		</prevlocs>
    <authlist>
      <author>
        <name>Matthias Brantner</name>
        <affiliation>28msec, Inc.</affiliation>
        <email href="mailto:matthias.brantner@28msec.com">matthias.brantner@28msec.com</email>
      </author>
      <author>
        <name>Daniela Florescu</name>
        <affiliation>Oracle Corporation</affiliation>
        <email href="mailto:daniela.florescu@oracle.com">daniela.florescu@oracle.com</email>
      </author>
      <author>
        <name>Ghislain Fourny</name>
        <affiliation>FLWOR Foundation</affiliation>
        <email href="mailto:ghislain.fourny@flworfound.org">ghislain.fourny@flworfound.org</email>
      </author>
      <author>
        <name>Josh Spiegel</name>
        <affiliation>Oracle Corporation</affiliation>
        <email href="mailto:josh.spiegel@oracle.com">josh.spiegel@oracle.com</email>
      </author>
      <author>
        <name>(This document includes an idea by Jonathan Robie (using an apply function and comma expressions))</name>
      </author>
    </authlist>

    &status-section;

    <abstract>
      <p>This specification defines an extension to XQuery 3.0
         and XQuery Update Facility 3.0.
         It leaves the end-user syntax open and tries to minimize syntactic changes. A syntactic
         layer (sugar) can be put on top of this specification to define syntax more explicitly.
      </p>
      <p>
         It introduces new expressions including the local variable declaration, assignment,
         while, break, continue and exit expressions.
         It introduces blocks to control the scope of local variables.
         It also introduces a new built-in function for applying a PUL.
         </p>
         <p>
           Expressions can have side effects such as applying a PUL or reassigning a variable.
           Sequential expressions must be evaluated in a specific order, which is
         described in this document. Subsequent expressions can see the effects of the expressions that
         came before them. 
      </p>
    </abstract>

    <langusage>
      <language id="en">English</language>
    </langusage>

    <revisiondesc id="id-revision-log">
      <p>Fourny, 9 March 2011.  Initial draft.</p>
    </revisiondesc>
  </header>

  <body>

    <div1 id="Introduction">
      <head>Introduction</head>

      <p>XQuery Scripting Extension Proposal extends XQuery 3.0, enabling it to
         serve as a scripting language in order to satisfy <bibref ref="ScriptingRequirements"/>. 
         A prerequisite for this extension is XQuery Update Facility 3.0. 
         The following abbreviations are used in this specification: 
        <termdef term="XQUF" id="dt-xquf"><term>XQUF</term> is an abbreviation for XQuery Update Facility 3.0.</termdef>
        <termdef term="XQSX" id="dt-xqsx"><term>XQSX</term> is an abbreviation for XQuery Scripting Extension.</termdef></p>

      <p><termref def="dt-xqsx">XQSX</termref> has the following properties:</p>
      <ulist>
        <item>
          <p>It is a strict superset of XQuery 3.0, in the
            sense that all valid XQuery 3.0 expressions are also
            valid <termref def="dt-xqsx">XQSX</termref> expressions and have the same meaning. 
          </p>
        </item>
        <item>
          <p>It is a strict superset of <termref def="dt-xquf">XQUF</termref>, in the
            sense that all valid <termref def="dt-xquf">XQUF</termref> expressions are also
            valid <termref def="dt-xqsx">XQSX</termref> expressions and have the same meaning. 
          </p>
        </item>
      </ulist>
    </div1>

      <div1 id="id-extensions-to-processing-model">
        <head>Extensions to the Processing Model</head>

        <p>
          Expressions in XQSX may have side-effects that are visible to subsequent expressions (according to their
          <termref def="dt-eval-order">evaluation order</termref>). This requires a number of extensions to the 
          XQuery 3.0 and <termref def="dt-xquf">XQUF</termref> processing model.
        </p>

        <div2 id="id-expressions">
          <head>Expressions</head>
        <div3 id="id-updating-constraint">
          <head>Updating Expressions</head>
          <note>
            <p>XQuery Update Facility 3.0 is still under development. We assume it is an adaptation of XQUF 1.0 to XQuery 3.0.
              Furthermore, we assume it allows mixing XDM and PULs (for example with updating primitive items), e.g., an updating expression may return both
              a non-empty XDM and a non-empty PUL.</p>
          </note>
          <p>
            <termref def="dt-xqsx">XQSX</termref> builds on top of XQuery 3.0 and XQuery Update 3.0, so that it keeps
            the same constraints about an expression being simple (if it always returns an empty PUL), updating (if the returned
            PUL may be non-empty) or vacuous (if both XDM and PUL are empty).</p>
          <p>The composability constraints and category rules for updating expressions are inherited
            from the XQUF specification. Composability constraints are given for updating expressions in new expressions as well
          as for sequential expressions.</p>
        </div3>
        <div3 id="id-sequential">
          <head>Sequential Expressions</head>
          <p>XQSX introduces the following new expressions, which can have side effects:
              <ulist>
                <item><p>Variable assignment,</p></item>
                <item><p>Break, Continue and Exit.</p></item>
              </ulist>
          </p>
          <p>XQSX also introduces a new, built-in sequential function xqsx:apply which applies a PUL.</p>
          <p>
            In addition to the updating/non-updating categorization, XQSX
            introduces another dimension to classify expressions: sequential/non-sequential expressions.</p>
          <olist>
            <item>
              <p>
                <termdef term="sequential expression" id="dt-sequential-expr">A <term>sequential expression</term>
                  is an expression that can have side effects other than constructing a new node or raising an error.</termdef>
                Side effects include applying updates to an XDM instance,
                altering the dynamic context, or affecting the flow of control.</p>
              <p>An expression is sequential if it contains, directly or nested:</p>
              <ulist>
                <item>
                  <p>a call to a sequential function.</p>
                </item>
                <item>
                  <p>an assign expression, and the affected variable is declared outside
                    of the expression.</p>
                </item>
                <item>
                  <p>an apply expression, the operand of which is updating.</p>
                </item>
                <item>
                  <p>a break or continue expression without FLWOR or while expression inbetween in the expression tree.</p>
                </item>
                <item>
                  <p>an exit expression.</p>
                </item>
              </ulist>
              <p>
                The side effects of a sequential expression are immediately effective
                and are visible to subsequent expressions. 
                Because of their side effects, sequential expressions must be evaluated
                in evaluation order, as defined in this specification.
                In addition to its side effects, a sequential expression may return
                an XDM instance.</p>
            </item>
            <item>
              <p>
                <termdef term="pure expression" id="dt-pure-expr">A <term>non-sequential expression</term>
                  is an expression that is is not sequential.</termdef></p>
            </item>
          </olist>
          <p>The classification of each expression into one of the above categories is
            performed by static analysis.</p>
          <p>
            Note that updating/non-updating and sequential/non-sequential are two orthogonal classification dimensions.
            Hence, an expression can be non-updating and non-sequential, non-updating and sequential,
            or updating and non-sequential.
          </p>
        </div3>
      </div2>
        
        <div2 id="id-evaluation-order">
          <head>Evaluation Order</head>
          <p>
            <termdef term="evaluation order" id="dt-eval-order"><termref def="dt-xqsx">XQSX</termref> defines an <term>evaluation order</term> on
              many kinds of XQuery expressions, which is the order that operand expressions must be evaluated in order
              to determine what side-effects are visible to later expressions.</termdef></p>
          <p>
            An implementation may use any execution strategy as long as the result complies with
            the semantics of this ordering.</p>
        </div2>
        
      <div2 id="id-snapshot-scope">
        <head>Snapshots</head>
        <p>The term <term>snapshot</term> is defined in <bibref ref="XQueryUpdate"/> as follows:
           <termdef term="snapshot" id="dt-snapshot">A <term>snapshot</term> is a scope
           within which expressions are evaluated with respect to a fixed
           XDM instance, accessible through the dynamic context's bindings,
           and updates are held pending.</termdef>
           A snapshot is terminated by invocation of the <code>upd:applyUpdates</code> operation.
           Unlike <termref def="dt-xquf">XQUF</termref>, <termref def="dt-xqsx">XQSX</termref>
           permits an XQuery program to contain more than one snapshot.</p>

        <p>
          <bibref ref="FO"/> defines certain functions as <xtermref spec="FO" ref="stable">stable</xtermref>. Stable functions
          such as <code>fn:current-time</code> and <code>fn:doc</code> are defined to return the same result given the same
          arguments within an <xtermref spec="FO" ref="execution-scope">execution scope</xtermref>.
          <termref def="dt-xqsx">XQSX</termref> permits an XQuery program to contain more than one execution scope.</p>

        <p>In XQSX, a snapshot and execution scope is defined as the lapse between two side effects to the environment, reachable
          through the dynamic context, on which
        the XQuery program operates.</p>
        <p>Each of the following events marks the end of the current snapshot and execution scope, and the beginning of a new one:</p>
        <ulist>
          <item><p>The invocation of upd:applyUpdates,</p></item>
          <item><p>Calling an external, sequential function,</p></item>
          <item><p>Assigning a new value to a variable.</p></item>
        </ulist>
        
      </div2>
        <div2 id="id-nested-snapshots">
          <head>Nested Snapshots</head>

        <p>
          To avoid nested snapshots, it is forbidden for an expression to be both updating and sequential. If such is the case,
          a static error is raised.
        </p>
        
      </div2>

        <div2 id="id-variable-revalidation">
        <head>Variable Binding Revalidation</head>
        <p>
          To ensure type soundness, variable bindings are revalidated at the end of each scope to check that
          any updates applied have not made them invalid with repect to their declared types. It is a dynamic
          error <errorref code="0003" class="DY"/> if, after applying a pending update list (using <code>upd:applyUpdates</code>),
          the XDM instance bound to any in-scope variable does not match the static type of that variable according
          to SequenceType matching rules.
        </p>
      </div2>

      </div1>


    <div1 id="id-extensions-to-static-context">
      <head>Extensions to the Static Context</head>
      <div2 id="id-namespace">
        <head>Predefined Namespace</head>
        <p>
          <termref def="dt-xqsx">XQSX</termref> adds the pair (<code>xqsx</code>, <code>http://www.w3.org/2008/xquery-sx-10</code>) as a predefined
          namespace to the statically known namespaces.
        </p>
      </div2>
      <div2 id="id-in-scope-variables">
        <head>In-Scope Variables</head>
        <p>
          The in-scope variable mapping also contains, for each variable, a boolean which is true if the variable is assignable according
          to the %fn:assignable or %fn:unassignable annotation during variable declaration. It is thus a set of (expanded QName, type, assignable)
          tuples.
          Variables bound by let, for, some or every
          as well as function parameters, are always unassignable.
        </p>
      </div2>
    </div1>





      <div1 id="id-extensions-to-prolog">
        <head>Extensions to the Prolog</head>

        <div2 id="id-assignable-global-var">
          <head>Global Variable Declarations</head>
          <scrap><head/>
            <prodrecap ref="AnnotatedDecl"/>
            <prodrecap ref="Annotation"/>
            <prodrecap ref="VarDecl"/>
          </scrap>
          <glist>
            <gitem>
              <label>Definitions:</label>
              <def>
                <p>
                  <termref def="dt-xqsx">XQSX</termref> allows the built-in annotations <code>%fn:assignable</code> and <code>%fn:unassignable</code>
                  to be used in a Prolog variable declaration. If both annotations are used, a static error is raised.</p>
                <p><termdef term="assignable" id="dt-assignable">An <term>assignable prolog variable</term> is a global
                  variable whose declaration specifies %fn:assignable, and
                  may have its
                  value changed by an assign expression.</termdef></p>
                <p><termdef term="unassignable" id="dt-unassignable">An <term>unassignable prolog variable</term> is a global
                  variable whose declaration specifies %fn:unassignable, and may not have its
                  value changed by an assign expression.</termdef></p>
                <p>If an assignment qualifier is not used, the default is <code>unassignable</code>.
                </p>
              </def>
            </gitem>
            <gitem>
              <label>Composability Constraints:</label>
              <def>
                <p diff="add">The initializing expression of a prolog variable (whether assignable or not)
                  must be a non-updating and non-sequential expression <errorref code="0001" class="ST"/>.</p>
              </def>
            </gitem>
            <gitem>
            <label>Semantics:</label>
            <def>
              <p diff="add">The semantics of declaring assignable variables are the same as the semantics of unassignable variables, except that
            the static type of an assignable variable without a declared type is always <code>item()*</code>.
              </p>
            </def>
          </gitem>
          </glist>
        </div2>


        <div2 id="id-function-decl">
          <head>Function Declarations</head>
          <scrap><head/>
            <prodrecap id="FunctionDecl" ref="FunctionDecl"/>
            <prodrecap id="Annotation" ref="Annotation"/>
            <prodrecap id="BuiltinAnnotation" ref="BuiltinAnnotation"/>
          </scrap>
          <glist>
            <gitem>
              <label>Definitions:</label>
              <def>
                <p>
                  <termref def="dt-xqsx">XQSX</termref> allows the built-in annotations <code>%fn:sequential</code> and <code>%fn:non-sequential</code>
                  to be used in a Prolog function declaration. If both annotations are used, a static error is raised.</p>
                <p>
                  <termdef term="non-sequential function" id="dt-non-sequential-function">A <term>non-sequential function</term>
                  is a function whose declaration specifies <code>%fn:non-sequential </code>.
                    </termdef>
                  </p>
                <p>
                  <termdef term="sequential function" id="dt-sequential-function">A <term>sequential function</term>
                    is a function whose declaration specifies the annotation <code>%fn:sequential</code>.</termdef>
                </p>
                <p>If a qualifier is not used, the default is non-sequential.</p>
              </def>
            </gitem>
            <gitem>
              <label>Composability Constraints:</label>
              <def>
                <p>
                  The body of an <termref def="dt-non-sequential-function">non-sequential function</termref>
                  must be a non-sequential expression, except if the only reason why the expression
                  is sequential is that it contains an exit expression. Otherwise,
                  a static error is raised.</p>
                <p>
                  The body of an non-updating function
                  may not contain exit expressions with an updating operand.</p>
              </def>
            </gitem>
            <gitem>
              <label>Semantics:</label>
              <def>
                <p>The semantics of functions
                  are as follows. The function body is evaluated.
                  The result of the function is determined
                  by the first exit expression encountered during evaluation of the Block. 
                  If no exit expression is encountered, the result of the function is the value returned by the body expression.
                  Other than that, the semantics is as defined
                  in XQuery Update Facility 3.0.</p>
              </def>
            </gitem>
          </glist>
        </div2>
        
      </div1>
    










    <div1 id="id-new-expressions">
      <head>New Expressions</head>
      <p><termref def="dt-xqsx">XQSX</termref> extends the XQuery 1.0 syntax
        by adding new expressions to the grammar:</p>
      <scrap><head/>
        <prodrecap ref="ExprSingle"/>
        <prodrecap ref="PrimaryExpr"/>
      </scrap>
      
      <div2 id="id-assignment">
        <head>Assignment Expression</head>
        <scrap><head/>
          <prodrecap id="AssignExpr" ref="AssignExpr"/>
        </scrap>
        <glist>
          <gitem>
            <label>Semantics:</label>
            <def>
              <p>The variable on the left-hand side of the assignment must be in scope (in the in-scope variables of the static context)
                and assignable (the corresponding boolean set to true in the static context), otherwise a
                static error <errorref code="0007" class="ST"/> is raised. In particular, it must have been declared
                by a variable declaration, local or in the prolog.</p>
              <note>
                <p>Variables bound in FLWOR, typeswitch, or quantified expressions, as well as function
                  parameters, may not appear
                  on the left-hand side of an assignment.</p>
              </note>
              <p>
                The expression on the right-hand side is evaluated,
                resulting in an XDM instance.
              </p>
              <p>If the XDM instance
                returned by the expression on the right-hand side does not match the declared type
                of the variable according to SequenceType matching rules,
                a type error is raised <xerrorref spec="XQ" code="0004" class="TY"/>. 
                If the types match, the XDM instance
                returned by the expression is bound to the variable (this modifies <emph>variable values</emph>
                in the <emph>dynamic context</emph> of subsequent expressions.)</p>
              <p>The Assignment Expression returns the XDM which has just been assigned to the variable.</p>
            </def>
          </gitem>
          <gitem>
            <label>Evaluation order:</label>
            <def>
              <p>
                The operand expression is evaluated exactly once before the semantics of the Assignment Expression is applied.
              </p>
            </def>
          </gitem>
          <gitem>
            <label>Example:</label>
            <def>
              <eg>
$result := "Bidding exceeded 60000"
              </eg>
            </def>
          </gitem>
        </glist>
      </div2>
      

      
      <div2 id="id-block">
        <head>Block Expression</head>
        <scrap><head/>
          <prodrecap id="BlockExpr" ref="BlockExpr"/>
        </scrap>
        <note>
          <p>
            Enclosed expressions in node constructors as well as function bodies are considered
            blocks.
          </p>
        </note>
        <glist>
          <gitem>
            <label>Semantics:</label>
            <def>
              <p>A block expression returns the XDM and PUL returned
                by the operand expression.</p>
              <note>
                <p>
                  The purpose of a block expression is to provide a scope for declared variables.
                </p>
              </note>
            </def>
          </gitem>
          <gitem>
            <label>Evaluation order:</label>
            <def>
              <p>
                The expression is evaluated exactly once.
              </p>
            </def>
          </gitem>
          <gitem>
            <label>Example:</label>
            <def>
              <eg>
                { 1, variable $x := 1, $x + 1 }</eg>
            </def>
          </gitem>
        </glist>
      </div2>




      <div2 id="id-break">
        <head>Break Expression</head>
        <scrap><head/>
          <prodrecap id="BreakExpr" ref="BreakExpr"/>
        </scrap>
        
        <glist>
          <gitem>
            <label>Semantics:</label>
            <def>
              <p>A break expression interrupts the execution of the innermost while or FLWOR expression. If it is a FLWOR
                expression, the result
                returned by this FLWOR expression is the concatenation of the XDMs produced for earlier tuples in the stream,
                not including the current one.</p>
              <p>A static error is raised if there is no enclosing while or FLWOR expression.</p>
            </def>
          </gitem>
          <gitem>
            <label>Example:</label>
            <def>
              <eg>
break loop              </eg>
            </def>
          </gitem>
        </glist>
      </div2>
      
      
      
      <div2 id="id-continue">
        <head>Continue Expression</head>
        <scrap><head/>
          <prodrecap id="ContinueExpr" ref="ContinueExpr"/>
        </scrap>
        
        <glist>
          <gitem>
            <label>Semantics:</label>
            <def>
              <p>A continue expression interrupts the current execution of the operand or return expression of the
                innermost while or FLWOR expression.
                In the case of a while expression, the resumes with a new evaluation of the test expression and,
                possibly, of the inner expression. In the case of a FLWOR expression, the execution resumes with
                the next tuple and an empty XDM is produced for the current tuple.
              </p>
            </def>
          </gitem>
          <gitem>
            <label>Example:</label>
            <def>
              <eg>
continue loop              </eg>
            </def>
          </gitem>
        </glist>
      </div2>
      
      
      
      <div2 id="id-exit">
        <head>Exit Expression</head>
        <scrap><head/>
          <prodrecap id="ExitExpr" ref="ExitExpr"/>
        </scrap>
        
        <glist>
          <gitem>
            <label>Semantics:</label>
            <def>
              <p>An exit expression serves to define the result of the enclosing function or query body.</p>
              <p>
                The operand expression of the exit expression is evaluated, resulting in an
                XDM instance
                and a pending update list.
              </p>
              <p>If an exit expression is evaluated within the body of a function,
                further evaluation of the function body is interrupted and the
                XDM instance and
                pending update list returned by
                the operand expression are returned as the result of the function call.</p>
              <p>If an exit expression is evaluated within a query body
                (i.e., not within the body of a function), further evaluation of the query
                is interrupted and the XDM instance and
                pending update list
                returned by the operand expression are returned as the result of the query.</p>
            </def>
          </gitem>
          <gitem>
            <label>Evaluation order:</label>
            <def>
              <p>
                The operand expression is evaluated exactly once before the semantics of the Exit Expression is applied.
                Subsequent expressions within the enclosing function body or query are not evaluated at all.
              </p>
            </def>
          </gitem>
          <gitem>
            <label>Example:</label>
            <def>
              <eg>
exit returning local:error(concat("You cannot use the ",
                                  $request/method,
                                  " method with this URL."))              </eg>
            </def>
          </gitem>
        </glist>
      </div2>

      <div2 id="id-vardecl-expression">
        <head>Variable Declaration Expression</head>
        <scrap><head/>
          <prodrecap id="VarDeclExpr" ref="VarDeclExpr"/>
        </scrap>
        <p><termdef term="initializing expression" id="dt-initializing-expr">The expression on
          the right-hand side of a variable declaration is called an
          <term>initializing expression</term>.</termdef></p>
        <p><termdef term="scope expression" id="dt-scope-expr">The scope expression of a variable declaration
          is the innermost block expression, control flow clause (then/else clause,
          Switch/Typeswitch/FLWOR return clause, while body clause), function body or program
          containing the variable declaration expression.</termdef></p>
        <glist>
          <gitem>
            <label>Semantics:</label>
            <def>
              <p>A variable declaration defines a local variable whose scope
                is the remainder of its scope expression
                (not including its <termref def="dt-initializing-expr">initializing expression</termref>). 
                The variable defined in a variable declaration occludes (hides)
                any variable of the same name that is in scope at the location where
                the scope expression appears.</p>
              <p>It is a static error <errorref code="0005" class="ST"/> if two or more variables with
                the same scope expression have the same expanded QName.</p>
              <p>The type of each declared variable is added to <emph>in-scope variables</emph>
                in the <emph>static context</emph> of subsequent expressions in the scope expression (according
                to the evaluation order).
                If a variable has both an explicit type declaration and an
                <termref def="dt-initializing-expr">initializing expression</termref>,
                the value of the <termref def="dt-initializing-expr">initializing expression</termref> must match
                the declared type according to SequenceType matching rules; otherwise a type error is raised <xerrorref spec="XQ" code="0004" class="TY"/>.
                If no explicit type is declared and the variable is assignable, the type of the variable is <code>item()*</code>.
                If no explicit type is declared and the variable is unassignable, the type is statically inferred from the initializing expression.</p>
              <p>The variable may be annotated as assignable or as unassignable. By default, it is assignable.
                This is stored in in-scope
                variables in the static context with the type.
              </p>
              <note>
                <p>The default for local variable declarations is different from variables declared in the prolog.
                  The latter are unassignable if there is no annotation.</p>
              </note>
              <p>The variable declaration evaluates its <termref def="dt-initializing-expr">initializing expression</termref>
                and binds the resulting XDM instance to the <emph>variable values</emph> in
                the <emph>dynamic context</emph> of subsequent expressions in the scope expression.
                If no <termref def="dt-initializing-expr">initializing expression</termref> is present, the variable has no initial value. 
                A reference to a variable, other than on the left-hand side of an assignment expression,
                is an error if the variable has no value in <emph>variable values</emph>
                when the reference is evaluated <errorref code="0006" class="TY"/>.</p>
              <p>The Variable Declaration Expression returns the XDM assigned to the variable.</p>
            </def>
          </gitem>
          <gitem>
            <label>Evaluation order:</label>
            <def>
              <p>
                The operand expression is evaluated exactly once before the semantics of the Variable Declaration Expression is applied.
              </p>
            </def>
          </gitem>
          <gitem>
            <label>Example:</label>
            <def>
              <eg>
variable $uid := doc("users.xml")/users/user_tuple
                 [name = "Roger Smith"]/userid              </eg>
            </def>
          </gitem>
        </glist>
      </div2>
      
      
      
      <div2 id="id-while-expression">
        <head>While Expression</head>
        <scrap><head/>
          <prodrecap id="WhileExpr" ref="WhileExpr"/>
        </scrap>
        <p><termdef term="test expression" id="dt-test-expr">The expression enclosed in the
          parentheses of a while expression is called a <term>test expression</term>.</termdef></p>
        <glist>
          <gitem>
            <label>Semantics:</label>
            <def>
              <p>The while expression is used for conditional iteration.  It is evaluated as follows:</p>
              <p>
                The <termref def="dt-test-expr">test expression</termref> is evaluated, resulting in an
                XDM instance.
              </p>
              <p>
                If the effective Boolean value of the <termref def="dt-test-expr">test expression</termref>
                is false, the ExprSingle is not evaluated. If the effective Boolean value of the
                <termref def="dt-test-expr">test expression</termref> is true, the ExprSingle is evaluated repeatedly. 
                Each evaluation of the ExprSingle may cause side effects that affect the result of re-evaluating the
                <termref def="dt-test-expr">test expression</termref>. 
                The <termref def="dt-test-expr">test expression</termref> is re-evaluated after each evaluation of the ExprSingle. 
                This process continues until the effective Boolean value of the <termref def="dt-test-expr">test expression</termref>
                is evaluated to be false.
              </p>
              <p>The While Expression returns an empty XDM.</p>
              <note>
                <p>If the ExprSingle is non-sequential, the while expression does not need to be evaluated at all.</p>
              </note>
            </def>
          </gitem>
          <gitem>
            <label>Evaluation order:</label>
            <def>
              <p>
                The inner expression is executed exactly once after each evaluation of the test expression until its EBV is false.
              </p>
            </def>
          </gitem>
          <gitem>
            <label>Example:</label>
            <def>
              <p>In the following query, a while expression is used to compute a sequence
                containing all the Fibonacci numbers that are less than 100.</p>
              <eg>
{
  variable $a as xs:integer := 0,
  variable $b as xs:integer := 1,
  variable $c as xs:integer := $a + $b,
  variable $fibseq as xs:integer* := ($a, $b),

  while ($c &lt; 100) (
    $fibseq := ($fibseq, $c),
    $a := $b,
    $b := $c,
    $c := $a + $b
  )
}
              </eg>
            </def>
          </gitem>
        </glist>
      </div2>
    </div1>

    <div1 id="id-new-functions">
      <head>New Functions</head>
      
      <div2 id="id-function-apply">
        <head>xqsx:apply</head>
        <glist>
          <gitem>
            <label>Semantics</label>
            <def>
              <p>XQSX defines an additional, sequential, built-in function xqsx:apply() which exists in all arities.
              This function merges the PULs contained in all its parameters
              (with <code>upd:mergeUpdates</code>) and the result is applied (by <code>upd:applyUpdates</code>).
              It returns the concatenated XDM returned by its parameter expressions.</p>
            </def>
          </gitem>
          <gitem>
            <label>Example:</label>
            <def>
              <eg>
                xqsx:apply(delete nodes ($user, $items, $bids))
              </eg>
            </def>
          </gitem>
        </glist>
      </div2>
    </div1>
    
    <div1 id="id-expr-changes">
      <head>Evaluation Order for Existing Expressions</head>
      
      
      <div2 id="id-flwor-expressions">
        <head>FLWOR Expressions</head>
        <p>The return clauses are evaluated in the order in which these tuples
          appear in the input tuple stream, exactly once for each tuple.</p>
      </div2>

      <div2 id="id-if-expressions">
        <head>Conditional Expressions</head>
        <p>Depending on the EBV of the test expression, either the then clause or the
          else clause (but not both) is evaluated, exactly once.</p>
      </div2>

      <div2 id="id-switch-expressions">
        <head>Switch Expressions</head>
        <p>Only the return clause in the effective case is evaluated, exactly once.</p>
      </div2>
      
      <div2 id="id-trycatch-expressions">
        <head>Try-Catch Expressions</head>
        <p>If no error is dynamic or type error is raised during the evaluation of the try clause,
          no catch clause gets executed. Otherwise, the execution of the try clause is interrupted when
          this error is raised, and only the first catch expression that "matches" the error value is executed,
          exactly once.</p>
      </div2>
      
      <div2 id="id-typeswitch-expressions">
        <head>Typeswitch Expressions</head>
        <p>Only the return clause in the effective case is evaluated.</p>
      </div2>

      <div2 id="id-other-expr">
        <head>Other Expressions</head>
        <p>
          All expressions not listed above are evaluated from left to right, bottom-up in the expression tree.
          This includes the following kinds of expressions:
        </p>
        <ulist>
          <item>
            <p>Function calls</p>
          </item>
          <item>
            <p>Path expressions</p>
          </item>
          <item>
            <p>Concatenation expressions</p>
          </item>
          <item>
            <p>Range expressions</p>
          </item>
          <item>
            <p>Transform expressions</p>
          </item>
          <item>
            <p>Union, intersect, and except expressions</p>
          </item>
          <item>
            <p>Arithmetic, comparison, and logical expressions</p>
          </item>
          <item>
            <p>Ordered and unordered expressions</p>
          </item>
          <item>
            <p>Instance of, cast, castable, and treat expressions</p>
          </item>
          <item>
            <p>Validate expressions</p>
          </item>
          <item>
            <p>Extension expressions (pragmas)</p>
          </item>
        </ulist>
        <note>
          <p>
            Since insert, delete, replace and rename are updating expressions, their operands must be non-effecting,
            such that the evaluation order is irrelevant
            for them.
          </p>
        </note>
        <note>
          <p>
            In transform expressions, since the modify clause must be updating (or vacuous) according to XQUF,
            it must also be non-sequential. Furthermore, XQUF specifies that the return clause sees that the side-effect
            of applying the PUL returned by the modify expression is visible to the return expression.
          </p>
        </note>
      </div2>
    </div1>
    
    <div1 id="id-composability-constraints">
      <head>Composability Constraints</head>
      <p> Composability constraints are extended to allow any
        non-updating expression where XQUF allows a simple expression, except (a) if it would go against
        the rule preventing an expression being both updating and sequential and (b) in the four cases listed hereafter.
        The following expressions may not be sequential:</p>
      <ulist>
        <item><p>Any operand of a FLWOR expression except the return clause.</p></item>
        <item><p>A switch or typeswitch test expression.</p></item>
        <item><p>A test expression in a conditional or while expression.</p></item>
        <item><p>A quantified or predicate expression.</p></item>
      </ulist>
      <p>Furthermore, the following expressions (operands of new expressions) may not be updating:</p>
      <ulist>
        <item><p>Value assigned to a variable in VarDeclExpr or AssignExpr.</p></item>
        <item><p>A test expression in a while expression.</p></item>
      </ulist>
    </div1>
    
    <div1 id="id-example">
      <head>Example</head>
      <p>The following function returns <code>true</code> or <code>false</code>
         according to whether its parameter is a known user name, and logs the event:</p>
      <eg>declare %fn:sequential function validate-and-log($username as xs:string)
    as xs:boolean {
  variable $log as document-node() := fn:doc("log.xml"),

  variable $entry as element() :=
    &lt;access-attempt&gt;
      &lt;timestamp&gt;{fn:current-dateTime()}&lt;/timestamp&gt;
      &lt;user-name&gt;{$username}&lt;/user-name&gt;
      &lt;access-allowed/&gt;
    &lt;/access-attempt&gt;,

  variable  $result as xs:boolean,

  if ($username = doc("users.xml")/current-users/user/name )
  then (
    xqsx:apply(replace value of node $entry/access-allowed with "Yes"),
    $result := true()
  ) else (
    xqsx:apply(replace value of node $entry/access-allowed with "No"),
   $result := false()
  ),
  
  xqsx:apply(insert node $entry as last into $log),
  
  xqsx:apply(fn:put($log, "log.xml")),
  
  $result
} 
</eg>
    </div1>

  </body>

  <back>
<div1 id="id-grammar">
		<head>EBNF for XQuery 1.0 Grammar with Scripting Extensions</head>

<p>The EBNF in this document and in this section is aligned with
the current XML Query 1.0 grammar (see <bibref ref="XQ10"/>).</p>

		<scrap role="non-terminal-structure-expand"><head></head>
<prodrecap ref="BNF-Grammar-prods" role="BNF-Grammar-prods" at="../build/temp-xquery-grammar.xml"/>
</scrap>

<div2 id="id-terminal-symbols"><head>Terminal Symbols</head><scrap headstyle="show">
		    
		  <head></head><prodrecap ref="DefinedLexemes" role="DefinedLexemes" at="../build/temp-xquery-grammar.xml"/> 
		   
		</scrap>
<p>The following symbols are used only in the definition of
  terminal symbols; they are not terminal symbols in the
  grammar of <specref ref="id-grammar"/>.</p><scrap headstyle="show">
		    
		  <head></head><prodrecap ref="LocalTerminalSymbols" at="../build/temp-xquery-grammar.xml" role="LocalTerminalSymbols"/> 
		   
		</scrap>
</div2>

<div2 id="id-extra-grammatical-constraints" diff="add"><head>Extra-grammatical Constraints</head>
  <p>This section contains XQuery SX specific constraints on the EBNF productions, which are required to parse legal sentences.
  The notes below are referenced from the right side of the production, with the notation: <emph>/* gn: &lt;id&gt; */</emph>.</p>
<constraintnote id="parse-note-sx-reserved-function-names" type="xgc"><head>sx-reserved-function-names</head><p>
  XQuery SX adds the term "while" to the list of names in
  <xspecref spec="XQ" ref="id-reserved-fn-names"><?xm-replace_text {xspecref}?></xspecref>.
  <note><p>This is a backwards incompatibility with <bibref ref="XQ10"/>.</p></note>
</p></constraintnote>
</div2>
</div1>

    &xqsx-xqueryx;

    <div1 id="id-implementation-defined-items">
      <head>Implementation-Defined Items</head>
      <p>The following items in this specification are implementation-defined:</p>
      <olist>
        <item>
          <p>The effects of <termref def="dt-snapshot">snapshot semantics</termref> on persistent storage. 
             For example, it is implementation-defined whether the effects of an <code>fn:put</code> function
             are visible to an <code>fn:doc</code>, <code>fn:doc-available</code>, or <code>fn:collection</code>
             function executed in a subsequent <termref def="dt-snapshot">snapshot</termref>.</p>
        </item>
        <item>
          <p>The mechanism (if any) by which the XQuery environment exchanges parameters and results
             with an external function.</p>
        </item>
      </olist>
    </div1>
    <div1 id="id-references">
      <head>References</head>
      <blist>
        <bibl id="XQ10" key="XQuery 1.0" href="http://www.w3.org/TR/xquery">
          <loc href="http://www.w3.org/TR/xquery/">XQuery 1.0: An XML Query Language</loc>,
          W3C Recommendation, 23 January 2007.</bibl>
        <bibl id="XQX10" key="XML Syntax for XQuery 1.0" href="http://www.w3.org/TR/xqueryx">
          <loc href="http://www.w3.org/TR/xqueryx/">XML Syntax for XQuery 1.0</loc>,
          W3C Recommendation, 23 January 2007.</bibl>
        <bibl id="XDM" key="XQuery Data Model" href="http://www.w3.org/TR/xpath-datamodel/">
          <loc href="http://www.w3.org/TR/xpath-datamodel/">XQuery 1.0 and XPath 2.0 Data Model (XDM)</loc>,
          W3C Recommendation, 23 January 2007.</bibl>
        <bibl id="FO" key="XQuery 1.0 and XPath 2.0 Functions and Operators" href="http://www.w3.org/TR/xpath-functions/">
          <loc href="http://www.w3.org/TR/xpath-functions/">XQuery 1.0 and XPath 2.0 Functions and Operators</loc>,
          W3C Recommendation, 23 January 2007.</bibl>
        <bibl href="http://www.w3.org/TR/xquery-update-10/" id="XQueryUpdate" key="XQuery Update Facility">
          <loc href="http://www.w3.org/TR/xquery-update-10/">XQuery Update Facility 1.0</loc>,
          W3C Candidate Recommendation, March 2008.</bibl>
        <bibl href="http://www.w3.org/TR/xquery-sx-10-requirements/" id="ScriptingRequirements" key="XQuery Scripting Requirements">
          <loc href="http://www.w3.org/TR/xquery-sx-10-requirements/">XQuery Scripting Extension 1.0 Requirements</loc>,
          W3C Working Draft, 23 March 2007.</bibl>
        <bibl href="http://www.w3.org/TR/xquery-sx-10-use-cases/" id="ScriptingUseCases" key="XQuery Scripting Use Cases">
          <loc href="http://www.w3.org/TR/xquery-sx-10-use-cases/">XQuery Scripting Extension 1.0 Use Cases</loc>,
          W3C Working Draft 23 March 2007.</bibl>
        <bibl id="XQ11" key="XQuery 1.1" href="http://www.w3.org/TR/xquery">
          <loc href="http://www.w3.org/TR/xquery-11/">XQuery 1.1: An XML Query Language</loc>,
          W3C Working Draft, 15 December 2009.</bibl>
      </blist>
    </div1>
    <div1 id="id-errors">	
      <head>Error Conditions</head>	

      <div2 id="id-new-error-codes">
        <head>New Error Codes</head>
        <error-list>
          <error spec="SX" code="0002" class="ST" type="static">
            <p>
              It is a static error to mix both updating and
              <termref def="dt-sequential-expr">sequential</termref> operands in an expression.
            </p>
          </error>
          <error spec="SX" code="0003" class="DY" type="dynamic">
            <p>
              It is a dynamic
              error if, after applying a pending update list (using <code>upd:applyUpdates</code>),
              the XDM instance bound to any in-scope variable does not match the static type of that variable according
              to SequenceType matching rules.
            </p>
          </error>
          <error spec="SX" code="0004" class="DY" type="dynamic">
            <p>
              It is an dynamic error for an external sequential function to return a non-empty pending update list.
            </p>
          </error>
          <error spec="SX" code="0005" class="ST" type="static">
            <p>
              It is a static error if two or more variables declared in the same block expression
              have the same expanded QName.
            </p>
          </error>
          <error spec="SX" code="0006" class="TY" type="type">
            <p>
              A reference to a variable, other than on the left-hand side of an assignment expression,
              is an error if the variable has no value in <emph>variable values</emph>
              when the reference is evaluated.
            </p>
          </error>
          <error spec="SX" code="0007" class="ST" type="static">
            <p>
              The variable on the left-hand side of an assignment must have been declared in one of the following ways:
            </p>
            <ulist>
              <item><p>By a block variable declaration</p></item>
              <item><p>As a parameter to a sequential function</p></item>
              <item><p>By a variable declaration in the Prolog <phrase diff="add">declared as <termref def="dt-assignable">assignable</termref></phrase></p></item>
            </ulist>
          </error>
          <error spec="SX" code="0008" class="ST" type="static">
            <p>
              It is a static error if the body of a function violates the category rules for it's declared category.
            </p>
          </error>
          <error spec="SX" code="0009" class="ST" type="static">
            <p>
              A static error is raised if the value for a
              <code>xqsx:query-mode</code> option or pragma is not either <code>sequential</code> or <code>simple</code>.
            </p>
          </error>
        </error-list>
      </div2>
      <div2 id="id-amended-error-codes">
        <head>Amendments to Existing Error Codes</head>
        <error-list>
          <error spec="XU" code="0001" class="ST" type="static">
            <p>
              It is a static error for an updating or
              <termref def="dt-sequential-expr">sequential expression</termref> to occur in the following places:
            </p>
            <olist>
              <item>
                <p>
                  As the initializing expression of a prolog variable.
                </p>
              </item>
              <item>
                <p>
                  As a StepExpr in a RelativePathExpr when query mode is <code>simple</code>.
                </p>
              </item>
              <item>
                <p>
                  As the primary expression or a predicate expression of a FilterExpr or AxisStep
                  when query mode is <code>simple</code>.
                </p>
              </item>
              <item>
                <p>
                  In the <code>for</code>, <code>let</code>, <code>where</code>, or <code>order by</code>
                  clauses of a FLWOR expression when query mode is <code>simple</code>.
                </p>
              </item>
              <item>
                <p>
                  In a quantified expression clause or as the satisfies expression of a quantified expression
                  when query mode is <code>simple</code>.
                </p>
              </item>
            </olist>
          </error>
        </error-list>
      </div2>
    </div1>

    <inform-div1 id="id-glossary">
      <head>Glossary</head>
      <?glossary ?>
    </inform-div1>
  </back>
</spec>
