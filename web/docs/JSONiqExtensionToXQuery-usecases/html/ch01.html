<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 1. JSONiq: Use Cases</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="JSONiq_Extension_to_XQuery-Usecases_for_the_JSONiq_Extension_to_XQuery-1.0-en-US-0.4.43-0" /><link rel="home" href="index.html" title="Usecases for the JSONiq Extension to XQuery" /><link rel="up" href="index.html" title="Usecases for the JSONiq Extension to XQuery" /><link rel="prev" href="index.html" title="Usecases for the JSONiq Extension to XQuery" /><link rel="next" href="appe-Usecases_for_the_JSONiq_Extension_to_XQuery-Revision_History.html" title="Appendix A. Revision History" /></head><body><p id="title"><a class="left" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="index.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="appe-Usecases_for_the_JSONiq_Extension_to_XQuery-Revision_History.html"><strong>Next</strong></a></li></ul><div xml:lang="en-US" class="chapter" id="idm8735920" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 1. JSONiq: Use Cases</h2></div><div><h3 class="subtitle"><em>XQuery for JSON, JSON for XQuery</em></h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch01.html#idm31619264">1.1. Sample Queries</a></span></dt><dd><dl><dt><span class="section"><a href="ch01.html#json.joins">1.1.1. Joins</a></span></dt><dt><span class="section"><a href="ch01.html#jsongrouping">1.1.2. Grouping Queries for JSON</a></span></dt><dt><span class="section"><a href="ch01.html#json2json">1.1.3. JSON to JSON Transformations</a></span></dt><dt><span class="section"><a href="ch01.html#wikipedia.example">1.1.4. Converting XML to JSON</a></span></dt><dt><span class="section"><a href="ch01.html#svg.example">1.1.5. Transforming JSON to SVG</a></span></dt><dt><span class="section"><a href="ch01.html#html.example">1.1.6. Transforming Arrays to HTML Tables</a></span></dt><dt><span class="section"><a href="ch01.html#windowing.example">1.1.7. Windowing Queries</a></span></dt><dt><span class="section"><a href="ch01.html#rdb.example">1.1.8. JSON views in middleware</a></span></dt><dt><span class="section"><a href="ch01.html#update.example">1.1.9. JSON Updates</a></span></dt><dt><span class="section"><a href="ch01.html#idm276720">1.1.10. Data Transformations</a></span></dt></dl></dd></dl></div><div class="para">
		On the Internet, most data is exchanged and processed using JSON or XML, and displayed using HTML. These languages have a great deal in common: they are based on named structures that can be nested, using a Unicode-based representation that is both human-readable and machine-readable. HTML is optimized for representing web pages, XML is optimized for representing document data, and JSON is optimized for representing programming language structures. In many applications, programmers work with only one of these formats. In many others, programmers work with all three.
	</div><div class="para">
		JSON has been called a <span class="quote">“<span class="quote">fat free alternative to XML</span>”</span><sup>[<a id="idm31337088" href="#ftn.idm31337088" class="footnote">1</a>]</sup>. Markup for programming structures does not need XML namespaces, whitespace-handling rules, the distinction between elements and attributes, or a structure designed to support document order. Markup for programming structures does need datatypes. XML can support datatypes via XML Schema, a very complex specification that does not correspond closely to the type system of most programming languages, or it can be used without datatype support. Neither is optimal for programming structures. For traditional programming structures, programming with JSON is significantly easier than programming with XML.
	</div><div class="para">
		There is currently no standard query language for JSON. XQuery is the standard query language for XML, and has been implemented in databases, streaming processors, data integration platforms, application integration platforms, XML message routing software, web browser plugins, and other environments. JSONiq is a query language based on XQuery; it is designed to allow an existing XQuery processor to be rewritten to support JSON with moderate effort. JSONiq defines a profile called XQ-- that is based on XQuery, removing expressions that support constructing and navigating XML, and adding expressions that support constructing and navigating JSON. Syntax diagrams for XQ-- are available at <a href="http://jsoniq.com/grammars/xq--/ui.xhtml">http://jsoniq.com/grammars/xq--/ui.xhtml</a>. Because JSON is so much simpler than XML, XQ-- is much simpler than XQuery, for both users and implementers. XQ-- also makes it much easier to write middleware using JSON as a logical model, because JSON more closely resembles the data typically processed in middleware, and allows a much simpler type system.
	</div><div class="para">
		But programmers who work with JSON often work with XML and HTML as well. In some applications, XML is used because it can better represent document-oriented data such as medical records, legal documents, pharmaceutical trial data, or news feeds. In other applications, standards or existing software systems may require data to be produced or consumed as XML. Many applications require data to be converted to HTML formats; some use HTML documents as source data. To support such applications, JSONiq defines a profile called XQ++ that includes the complete XQuery language, adding the same JSON extensions found in XQ--. Syntax diagrams for XQ++ are available at <a href="http://jsoniq.com/grammars/xq++/ui.xhtml">http://jsoniq.com/grammars/xq++/ui.xhtml</a>.
	</div><div class="para">
		JSONiq is useful for applications like these:
	</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
				Queries and Transformations for JSON
			</div><div class="para">
				JSONiq can be used for queries on JSON that return JSON results. These queries have the full power of XQuery, including FLWOR expressions, grouping, windowing, updates, and full-text. But queries or implementations that do not use XML or produce XML can use a subset of XQuery, and need not deal with the additional complexity that XML requires. Used in this way, JSONiq adds significant value to NoSQL databases.
			</div><div class="para">
				Examples of these queries can be found in <a class="xref" href="ch01.html#json.joins">Section 1.1.1, “Joins”</a>, <a class="xref" href="ch01.html#jsongrouping">Section 1.1.2, “Grouping Queries for JSON”</a>, and <a class="xref" href="ch01.html#json2json">Section 1.1.3, “JSON to JSON Transformations”</a>.
			</div></li><li class="listitem"><div class="para">
				JSON Updates
			</div><div class="para">
				JSONiq provides updates for JSON, in the same way that the XQuery Update Facility provides updates for XML.
			</div><div class="para">
				An example of such a query can be found in <a class="xref" href="ch01.html#update.example">Section 1.1.9, “JSON Updates”</a>.
			</div></li><li class="listitem"><div class="para">
				JSON to XML transformations
			</div><div class="para">
				The most stubborn JSON programmer is sometimes forced to use XML-based formats. JSONiq makes it easy to create XML by querying JSON data.
			</div><div class="para">
				An example of such a query can be found in <a class="xref" href="ch01.html#svg.example">Section 1.1.5, “Transforming JSON to SVG”</a>.
			</div></li><li class="listitem"><div class="para">
				XML to JSON transformations
			</div><div class="para">
				XQuery hides much of the complexity of XML, and simplifies the process of converting XML to JSON, while also providing a full featured query language to create any JSON result desired.
			</div><div class="para">
				An example of such a query can be found in <a class="xref" href="ch01.html#wikipedia.example">Section 1.1.4, “Converting XML to JSON”</a>.
			</div></li><li class="listitem"><div class="para">
				JSON to HTML transformations
			</div><div class="para">
				JSON is often used for data that is displayed in HTML. JSONiq makes it easy to transform JSON data into various views, creating the HTML needed to display results.
			</div><div class="para">
				An example of such a query can be found in <a class="xref" href="ch01.html#html.example">Section 1.1.6, “Transforming Arrays to HTML Tables”</a>.
			</div></li><li class="listitem"><div class="para">
				Windowing and input sequences
			</div><div class="para">
				XQuery provides sliding windows and tumbling windows for processing events and input sequences.
			</div><div class="para">
				An example of such a query can be found in <a class="xref" href="ch01.html#windowing.example">Section 1.1.7, “Windowing Queries”</a>.
			</div></li><li class="listitem"><div class="para">
				JSON views in middleware
			</div><div class="para">
				XQuery is used in middleware systems to provide XML views of data sources. Because JSON is simpler than XQuery, JSON-based views are an attractive alternative to XML-based views in applications that use large scale relational, object, or semi-structured data. JSONiq provides a powerful query language for systems that provide such views.
			</div><div class="para">
				An example of such a query can be found in <a class="xref" href="ch01.html#rdb.example">Section 1.1.8, “JSON views in middleware”</a>.
			</div></li><li class="listitem"><div class="para">
				Adding missing functionality to XQuery
			</div><div class="para">
				JSON Objects and JSON Arrays are extremely convenient for intermediate results in XQuery programs, even if they query XML to create XML.
			</div><div class="para">
				XQuery currently has no way to create complex data structures without copying and atomization, and no way to nest Arrays. Objects and Arrays may be particularly useful for applications like:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						Function parameters
					</div></li><li class="listitem"><div class="para">
						Returning results from functions
					</div></li><li class="listitem"><div class="para">
						Indexes
					</div></li><li class="listitem"><div class="para">
						Maps of function items
					</div></li><li class="listitem"><div class="para">
						Representing internal XQuery structures such as tuple streams or Pending Update Lists.
					</div></li></ul></div></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm31619264">1.1. Sample Queries</h2></div></div></div><div class="section" id="json.joins"><div class="titlepage"><div><div><h3 class="title" id="json.joins">1.1.1. Joins</h3></div></div></div><div class="para">
				The following queries are based on a social media site that allows users to interact with their friends. <code class="code">collection("users")</code> contains data on users and their friends:
			</div><pre class="programlisting">{
  "name" : "Sarah",
  "age" : 13,
  "gender" : "female",
  "friends" : [ "Jim", "Mary", "Jennifer"]
}

{
  "name" : "Jim",
  "age" : 13,
  "gender" : "male",
  "friends" : [ "Sarah" ]
}
</pre><div class="para">
				The following query performs a join on Sarah's friend list to return the Object representing each of her friends:
			</div><pre class="programlisting">for $sarah in collection("users")
    $friend in collection("users")
where $sarah("name") = "Sarah"
  and (some $name in libjn:members($sarah("friends"))
       satisfies $friend("name") = $name)
return $friend</pre><div class="para">
				The query can be simplified using a filter. In the following expression, <code class="code">[.("name") = "Sarah"]</code> is a filter that restricts the set of users to the one named "Sarah". The following query returns the same results as the previous one:
			</div><pre class="programlisting">let $sarah := collection("users")[.("name") = "Sarah"]
for $friend in libjn:members($sarah("friends"))
return collection("users")[.("name") = $friend]
</pre></div><div class="section" id="jsongrouping"><div class="titlepage"><div><div><h3 class="title" id="jsongrouping">1.1.2. Grouping Queries for JSON<sup>[<a id="idm20496784" href="#ftn.idm20496784" class="footnote">2</a>]</sup></h3></div></div></div><div class="para">
				collection("sales") is an unordered sequence that contains the following objects:
			</div><pre class="programlisting">{ "product" : "broiler", "store number" : 1, "quantity" : 20  },
{ "product" : "toaster", "store number" : 2, "quantity" : 100 },
{ "product" : "toaster", "store number" : 2, "quantity" : 50 },
{ "product" : "toaster", "store number" : 3, "quantity" : 50 },
{ "product" : "blender", "store number" : 3, "quantity" : 100 },
{ "product" : "blender", "store number" : 3, "quantity" : 150 },
{ "product" : "socks", "store number" : 1, "quantity" : 500 },
{ "product" : "socks", "store number" : 2, "quantity" : 10 },
{ "product" : "shirt", "store number" : 3, "quantity" : 10 }
</pre><div class="para">
				We want to group sales by product, across stores.
			</div><div class="para">
				Query:
			</div><pre class="programlisting">jn:object(
  for $sales in collection("sales")
  let $pname := $sales("product")
  group by $pname
  return $pname : sum($sales("quantity"))
)</pre><div class="para">
				Result:
			</div><pre class="programlisting">{
  "blender" : 250,
  "broiler" : 20,
  "shirt" : 10,
  "socks" : 510,
  "toaster" : 200
}</pre><div class="para">
				Now let's do a more complex grouping query, showing sales by category within each state. We need further data to describe the categories of products and the location of stores.
			</div><div class="para">
				collection("products") contains the following data:
			</div><pre class="programlisting">{ "name" : "broiler", "category" : "kitchen", "price" : 100, "cost" : 70 },
{ "name" : "toaster", "category" : "kitchen", "price" : 30, "cost" : 10 },
{ "name" : "blender", "category" : "kitchen", "price" : 50, "cost" : 25 },
{ "name" : "socks", "category" : "clothes", "price" : 5, "cost" : 2 },
{ "name" : "shirt", "category" : "clothes", "price" : 10, "cost" : 3 }</pre><div class="para">
				collection("stores") contains the following data:
			</div><pre class="programlisting">{ "store number" : 1, "state" : CA },
{ "store number" : 2, "state" : CA },
{ "store number" : 3, "state" : MA },
{ "store number" : 4, "state" : MA }
</pre><div class="para">
				The following query groups by state, then by category, then lists individual products and the sales associated with each.
			</div><div class="para">
				Query:
			</div><pre class="programlisting">jn:object(
  for $store in collection("stores")
  let $state := $store("state")
  group by $state
  return {
    $state : jn:object(
      for $product in collection("products")
      let $category := $product("category")
      group by $category
      return {
        $category : jn:object(
          for $sales in collection("sales")
          where $sales("store number") = $store("store number")
            and $sales("product") = $product("name")
          let $pname := $sales("product")
          group by $pname
          return $pname : sum( $sales("quantity") )
        )
      }
    )
  }
)
</pre><div class="para">
				Result:
			</div><pre class="programlisting">{
  "CA" : {
      "clothes" : {
         "socks" :  510
      },
      "kitchen" : {
         "broiler" : 20,
         "toaster" : 150
      }
  },
  "MA" : {
      "clothes" : {
         "shirt" : 10
       },
      "kitchen" : {
         "blender" : 250,
         "toaster" : 50
      }
  }
}
</pre></div><div class="section" id="json2json"><div class="titlepage"><div><div><h3 class="title" id="json2json">1.1.3. JSON to JSON Transformations</h3></div></div></div><div class="para">
				The following query takes satellite data, and summarizes which satellites are visible. The data for the query is a simplified version of a Stellarium file that contains this information.
			</div><div class="para">
				<span class="emphasis"><em>Data:</em></span>
			</div><pre class="programlisting">{
  "creator" : "Satellites plugin version 0.6.4",
  "satellites" : {
    "AAU CUBESAT" : {
      "tle1" : "1 27846U 03031G 10322.04074654  .00000056  00000-0  45693-4 0  8768",
      "visible" : false
    },
    "AJISAI (EGS)" : {
      "tle1" : "1 16908U 86061A 10321.84797408 -.00000083  00000-0  10000-3 0  3696",
      "visible" : true
    },
    "AKARI (ASTRO-F)" : {
      "tle1" : "1 28939U 06005A 10321.96319841  .00000176  00000-0  48808-4 0  4294",
      "visible" : true
    }
  }
}</pre><div class="para">
				We want to query this data to return a summary that looks like this.
			</div><div class="para">
				<span class="emphasis"><em>Result:</em></span>
			</div><pre class="programlisting">{
  "visible" : [
     "AJISAI (EGS)",
     "AKARI (ASTRO-F)"
  ],
  "invisible" : [
     "AAU CUBESAT"
  ]
}</pre><div class="para">
				The following is a JSONiq query that returns the desired result.
			</div><div class="para">
				<span class="emphasis"><em>Query:</em></span>
			</div><pre class="programlisting">let $sats := jn:json-doc("satellites.json")("satellites")
return {
  "visible" : [
     for $sat in jn:keys($sats)
     where $sats($sat)("visible")
     return $sat
  ],
  "invisible" : [
     for $sat in jn:keys($sats)
     where not($sats($sat)("visible"))
     return $sat
  ]
}</pre></div><div class="section" id="wikipedia.example"><div class="titlepage"><div><div><h3 class="title" id="wikipedia.example">1.1.4. Converting XML to JSON</h3></div></div></div><div class="para">
				JSON programmers frequently need to convert XML to JSON. The following query is based on a Wikipedia XML export format, using data from the category "Origami". Here is an excerpt of this data:
			</div><div class="para">
				Data:
			</div><pre class="programlisting">&lt;mediawiki&gt;
  &lt;siteinfo&gt;
    &lt;sitename&gt;Wikipedia&lt;/sitename&gt;

    &lt;page&gt;
      &lt;title&gt;Kawasaki's theorem&lt;/title&gt;
      &lt;id&gt;14511776&lt;/id&gt;
      &lt;revision&gt;
        &lt;id&gt;435519187&lt;/id&gt;
        &lt;timestamp&gt;2011-06-21T20:08:56Z&lt;/timestamp&gt;
        &lt;contributor&gt;
          &lt;username&gt;Some jerk on the Internet&lt;/username&gt;
          &lt;id&gt;6636894&lt;/id&gt;
        &lt;/contributor&gt;

!!! SNIP !!!

    &lt;page&gt;
      &lt;title&gt;Origami techniques&lt;/title&gt;
      &lt;id&gt;193590&lt;/id&gt;
      &lt;revision&gt;
        &lt;id&gt;447687387&lt;/id&gt;
        &lt;timestamp&gt;2011-08-31T17:21:49Z&lt;/timestamp&gt;
        &lt;contributor&gt;
          &lt;username&gt;Dmcq&lt;/username&gt;
          &lt;id&gt;3784322&lt;/id&gt;
        &lt;/contributor&gt;

!!! SNIP !!!

    &lt;page&gt;
      &lt;title&gt;Mathematics of paper folding&lt;/title&gt;
      &lt;id&gt;232840&lt;/id&gt;
      &lt;revision&gt;
        &lt;id&gt;440970828&lt;/id&gt;
        &lt;timestamp&gt;2011-07-23T09:10:42Z&lt;/timestamp&gt;
        &lt;contributor&gt;
          &lt;username&gt;Tabletop&lt;/username&gt;
          &lt;id&gt;173687&lt;/id&gt;
        &lt;/contributor&gt;
</pre><div class="para">
				The following query converts this data to JSON:
			</div><div class="para">
				Query:
			</div><pre class="programlisting">for $page in doc("Wikipedia-Origami.xml")//page
return {
  "title": string($page/title),
  "id" : string($page/id),
  "last updated" : string($page/revision[1]/timestamp),
  "authors" : [
       for $a in $page/revision/contributor/username
       return string($a)
  ]
}
</pre><div class="para">
				Result:
			</div><pre class="programlisting">{
  "title" : "Kawasaki's theorem",
  "id" : "14511776",
  "last updated" : "2011-06-21T20:08:56Z",
  "timestamp" : "2011-06-21T20:08:56Z",
  "authors" : ["Some jerk on the Internet" ]
},
{
  "title" : "Origami techniques",
  "id" : "193590",
  "last updated" : "2011-08-31T17:21:49Z",
  "timestamp" : "2011-08-31T17:21:49Z",
  "authors" : ["Dmcq" ]
},
{
  "title" : "Mathematics of paper folding",
  "id" : "232840",
  "last updated" : "2011-07-23T09:10:42Z",
  "timestamp" : "2011-07-23T09:10:42Z",
  "authors" : ["Tabletop" ]
}
</pre></div><div class="section" id="svg.example"><div class="titlepage"><div><div><h3 class="title" id="svg.example">1.1.5. Transforming JSON to SVG</h3></div></div></div><div class="para">
				Suppose a JavaScript implementation provides an interface for JSONiq queries, and a JavaScript program contains the following data <sup>[<a id="idm25900096" href="#ftn.idm25900096" class="footnote">3</a>]</sup>:
			</div><pre class="programlisting">var data = {
   "color" : "blue",
   "closed" : true,
   "points" : [[10,10], [20,10], [20,20], [10,20]]
   };
</pre><div class="para">
				This data can be converted to SVG by placing the text of a query in a JavaScript variable and calling the appropriate JavaScript function to invoke the query:
			</div><pre class="programlisting">
var query =
 "declare variable $input external;
  declare variable $stroke := attribute $stroke { $input("color") };
  declare variable $points := attribute $points { jn:flatten($input("points")) };
  if ($input("closed")) then
    &lt;svg&gt;&lt;polygon&gt;{ $stroke, $points }&lt;/polygon&gt;&lt;/svg&gt;
  else
    &lt;svg&gt;&lt;polyline&gt;{ $stroke, $points }&lt;/polyline&gt;&lt;/svg&gt;"</pre><div class="para">
				This query can be invoked with a JavaScript API call:
			</div><pre class="programlisting">
jsoniq(data, query)
</pre><div class="para">
				Here is the result of the above query:
			</div><pre class="programlisting">&lt;svg&gt;&lt;polygon stroke="blue" points="10 10 20 10 20 20 10 20" /&gt;&lt;/svg&gt;</pre></div><div class="section" id="html.example"><div class="titlepage"><div><div><h3 class="title" id="html.example">1.1.6. Transforming Arrays to HTML Tables</h3></div></div></div><div class="para">
				The data in a JSON array is frequently displayed using HTML tables. The following query shows how to transform from the former to the latter.
			</div><div class="para">
				The following Object contains the labels desired for columns and rows, as well as the data for the table.
			</div><pre class="programlisting">{
  "col labels" : ["singular", "plural"],
  "row labels" : ["1p", "2p", "3p"],
  "data" :
     [
        ["spinne", "spinnen"],
        ["spinnst", "spinnt"],
        ["spinnt", "spinnen"]
     ]
}</pre><div class="para">
				The following query creates an HTML table, using the column headings and row labels as well as the data in the Object shown above.
			</div><pre class="programlisting">&lt;table&gt;
  &lt;tr&gt; (: Column headings :)
  {
     &lt;th&gt; &lt;/th&gt;,
     for $th in jn:members((jn:json-doc("table.json")("col labels")))
     return &lt;th&gt;{ $th }&lt;/th&gt;
  }
  &lt;/tr&gt;
  {  (: Data for each row :)
     for $r at $i in jn:members((jn:json-doc("table.json")("data")))
     return
        &lt;tr&gt;
         {
           &lt;td&gt;{ jn:members(jn:json-doc("table.json")("row labels")($i)) }&lt;/td&gt;,
           for $c in jn:members($r)
           return &lt;td&gt;{ $c }&lt;/td&gt;
         }
        &lt;/tr&gt;
  }
&lt;/table&gt;</pre></div><div class="section" id="windowing.example"><div class="titlepage"><div><div><h3 class="title" id="windowing.example">1.1.7. Windowing Queries</h3></div></div></div><div class="para">
				XQuery provides support for both sliding windows and tumbling windows, frequently used to analyze event streams or other sequential data. This simple windowing example converts a sequence of items to a table with three columns (using as many rows as necessary), and assigns a row number to each row.
			</div><div class="para">
				Data:
			</div><pre class="programlisting">[
  { "color" : "Green" },
  { "color" : "Pink" },
  { "color" : "Lilac" },
  { "color" : "Turquoise" },
  { "color" : "Peach" },
  { "color" : "Opal" },
  { "color" : "Champagne" }
]
</pre><div class="para">
				Query:
			</div><pre class="programlisting">
&lt;table&gt;{
  for tumbling window $w in jn:members(jn:json-doc("colors.json"))
    start at $x when fn:true()
    end at $y when $y - $x = 2
  return
    &lt;tr&gt;{
      for $i in $w
      return
        &lt;td&gt;{ $i }&lt;/td&gt;
    }&lt;/tr&gt;
}&lt;/table&gt;
</pre><div class="para">
				Result:
			</div><pre class="programlisting">&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;Green&lt;/td&gt;
    &lt;td&gt;Pink&lt;/td&gt;
    &lt;td&gt;Lilac&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Turquoise&lt;/td&gt;
    &lt;td&gt;Peach&lt;/td&gt;
    &lt;td&gt;Opal&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Champagne&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</pre></div><div class="section" id="rdb.example"><div class="titlepage"><div><div><h3 class="title" id="rdb.example">1.1.8. JSON views in middleware</h3></div></div></div><div class="para">
				This example assumes a middleware system that presents relational tables as JSON arrays. The following two tables are used as sample data.
			</div><div class="table"><h6>Table 1.1. Users</h6><div class="table-contents"><table summary="Users" border="1"><colgroup><col class="c1" width="33%" /><col class="c2" width="33%" /><col class="lastname" width="33%" /></colgroup><thead><tr><th>
								userid
							</th><th>
								firstname
							</th><th>
								lastname
							</th></tr></thead><tbody><tr><td>
								W0342
							</td><td>
								Walter
							</td><td>
								Denisovich
							</td></tr><tr><td>
								M0535
							</td><td>
								Mick
							</td><td>
								Goulish
							</td></tr></tbody></table></div></div><br class="table-break" /><div class="para">
				The JSON representation this particular implementation provides for the above table looks like this:
			</div><pre class="programlisting">[
  { "userid" : "W0342", "firstname" : "Walter", "lastname" : "Denisovich" },
  { "userid" : "M0535", "firstname" : "Mick", "lastname" : "Goulish" }
]</pre><div class="table"><h6>Table 1.2. Holdings</h6><div class="table-contents"><table summary="Holdings" border="1"><colgroup><col class="userid" width="33%" /><col class="stockticker" width="33%" /><col class="shares" width="33%" /></colgroup><thead><tr><th>
								userid
							</th><th>
								ticker
							</th><th>
								shares
							</th></tr></thead><tbody><tr><td>
								W0342
							</td><td>
								DIS
							</td><td>
								153212312
							</td></tr><tr><td>
								M0535
							</td><td>
								DIS
							</td><td>
								10
							</td></tr><tr><td>
								M0535
							</td><td>
								AIG
							</td><td>
								23412
							</td></tr></tbody></table></div></div><br class="table-break" /><div class="para">
				The JSON representation this particular implementation provides for the above table looks like this:
			</div><pre class="programlisting">[
  { "userid" : "W0342", "ticker" : "DIS", "shares" : 153212312 },
  { "userid" : "M0535", "ticker" : "DIS", "shares" : 10 },
  { "userid" : "M0535", "ticker" : "AIG", "shares" : 23412 }
]</pre><div class="para">
				The following query uses the fictitious vendor's <code class="function">vendor:table()</code> function to retrieve the values from a table, and creates an Object for each user, with a list of the user's holdings in the value of that Object.
			</div><pre class="programlisting">[
  for $u in vendor:table("Users")
  order by $u("userid")
  return jn:object(
    libjn:project($u, "userid"),
    {
      "first" :  $u("firstname"),
      "last" :   $u("lastname"),
      "holdings" : [
        for $h in vendor:table("Holdings")
        where $h("userid") = $u("userid")
        order by $h("ticker")
        return jn:object(
          libjn:project($h, "ticker"),
          { "share" : $h("shares") }
        )
      ]
    }
  )
]</pre></div><div class="section" id="update.example"><div class="titlepage"><div><div><h3 class="title" id="update.example">1.1.9. JSON Updates</h3></div></div></div><div class="para">
				The XQuery Update Facility allows XML data to be updated. JSONiq provides updating functions to allow JSON to be updated.
			</div><div class="para">
				Suppose an application receives an order that contains a credit card number, and needs to put the user on probation.
			</div><div class="para">
				Data for an order:
			</div><pre class="programlisting">{
  "user" : "Deadbeat Jim",
  "credit card" : VISA 4111 1111 1111 1111,
  "product" : "lottery tickets",
  "quantity" : 243
}
</pre><div class="para">
				collection("users") contains the data for each individual user:
			</div><pre class="programlisting">{
  "name" : "Deadbeat Jim",
  "address" : "1 E 161st St, Bronx, NY 10451",
  "risk tolerance" : "high"
}
</pre><div class="para">
				The following query adds <code class="code">"status" : "credit card declined"</code> to the user's record.
			</div><pre class="programlisting">let $dbj := collection("users")[ .("name") = "Deadbeat Jim" ]
return insert json { "status" : "credit card declined" } into $dbj
</pre><div class="para">
				After the update is finished, the user's record looks like this:
			</div><pre class="programlisting">{
  "name" : "Deadbeat Jim",
  "address" : "1 E 161st St, Bronx, NY 10451",
  "status" : "credit card declined",
  "risk tolerance" : "high"
}
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title" id="idm276720">1.1.10. Data Transformations</h3></div></div></div><div class="para">
				Many applications need to modify data before forwarding it to another source. The XQuery Update Facility provides an expression called a tranform expression that can be used to create modified copies. The transform expression uses updating expressions to perform a transformation. JSONiq defines updating functions for JSON, which can be used in the XQuery transform expression.
			</div><div class="para">
				Suppose an application make videos available using feeds from Youtube. The following data comes from one such feed:
			</div><pre class="programlisting">{
    "encoding" : "UTF-8",
    "feed" : {
        "author" : [
            {
                "name" : {
                    "$t" : "YouTube"
                },
                "uri" : {
                    "$t" : "http://www.youtube.com/"
                }
            }
        ],
        "category" : [
            {
                "scheme" : "http://schemas.google.com/g/2005#kind",
                "term" : "http://gdata.youtube.com/schemas/2007#video"
            }
        ],
        "entry" : [
            {
                "app$control" : {
                    "yt$state" : {
                        "$t" : "Syndication of this video was restricted by its owner.",
                        "name" : "restricted",
                        "reasonCode" : "limitedSyndication"
                    }
                },
                "author" : [
                    {
                        "name" : {
                            "$t" : "beyonceVEVO"
                        },
                        "uri" : {
                            "$t" : "http://gdata.youtube.com/feeds/api/users/beyoncevevo"
                        }
                    }
                ]
!!! SNIP !!!</pre><div class="para">
				The following query creates a modified copy of the feed by removing all entries that restrict syndication.
			</div><pre class="programlisting">let $feed := jn:json-doc("incoming.json")
return
   copy $out := $feed
   modify
      let $feed := $out("feed")
      let $feed-entry := $feed("entry")
      for $entry at $pos in jn:members( $feed-entry )
      where $entry("app$control")("yt$state")("name") = "restricted"
      return delete json $feed-entry($pos)
   return $out</pre></div></div><div class="footnotes"><br /><hr /><div class="footnote"><div class="para"><sup>[<a id="ftn.idm31337088" href="#idm31337088" class="para">1</a>] </sup>
			See <a href="http://www.json.org/fatfree.html">JSON: The Fat-Free Alternative to XML</a>.
		</div></div><div class="footnote"><div class="para"><sup>[<a id="ftn.idm20496784" href="#idm20496784" class="para">2</a>] </sup>
				These queries are based on similar queries in the XQuery 3.0 Use Cases.
			</div></div><div class="footnote"><div class="para"><sup>[<a id="ftn.idm25900096" href="#idm25900096" class="para">3</a>] </sup>
					This example is based on an example on Stefan Goessner's JSONT site (<a href="http://goessner.net/articles/jsont/">http://goessner.net/articles/jsont/</a>).
				</div></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="index.html"><strong>Prev</strong>Usecases for the JSONiq Extension to XQuery</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="appe-Usecases_for_the_JSONiq_Extension_to_XQuery-Revision_History.html"><strong>Next</strong>Appendix A. Revision History</a></li></ul></body></html>
