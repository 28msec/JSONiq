<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>JSound</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="JSound-JSound-0.1-en-US-0.1.3-0" /><meta name="description" content="This document is a description of the JSound, the JSON schema definition language. It describes how to declare constraints on the structure of JSON documents." /></head><body><p id="title"><a class="left" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><div xml:lang="en-US" class="book" id="idm2893920" lang="en-US"><div class="titlepage"><div><div class="producttitle"><span class="productname">JSound</span> <span class="productnumber">0.1</span></div><div><h1 id="idm2893920" class="title">JSound</h1></div><div><h2 class="subtitle">The complete reference</h2></div><p class="edition">Edition 0.1.3</p><div><h3 class="corpauthor">
		
	</h3></div><div><div xml:lang="en-US" class="authorgroup" lang="en-US"><div class="author"><h3 class="author"><span class="firstname">Cezar</span> <span class="surname">Andrei</span></h3><code class="email"><a class="email" href="mailto:cezar.andrei@oracle.com">cezar.andrei@oracle.com</a></code></div><div class="author"><h3 class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></h3><code class="email"><a class="email" href="mailto:ghislain.fourny@28msec.com">ghislain.fourny@28msec.com</a></code></div><div class="author"><h3 class="author"><span class="firstname">Daniela</span> <span class="surname">Florescu</span></h3><code class="email"><a class="email" href="mailto:dana.florescu@oracle.com">dana.florescu@oracle.com</a></code></div><div class="editor"><h4 class="editedby">Edited by</h4><h3 class="editor"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></h3><div class="affiliation"><span class="orgname">28msec, Inc.</span></div><code class="email"><a class="email" href="mailto:ghislain.fourny@28msec.com">ghislain.fourny@28msec.com</a></code></div></div></div><hr /><div><div class="abstract"><h6>Abstract</h6><div class="para">
			This document is a description of the JSound, the JSON schema definition language. It describes how to declare constraints on the structure of JSON documents.
		</div></div></div></div><hr /></div><div class="toc"><dl><dt><span class="chapter"><a href="#chap-Introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#idm51451824">1.1. Requirements</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Concepts">2. Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#idm18701312">2.1. Candidate Instance</a></span></dt><dt><span class="section"><a href="#idm66598464">2.2. Annotated Instance</a></span></dt><dt><span class="section"><a href="#idm57965472">2.3. Schema Document</a></span></dt><dt><span class="section"><a href="#idm66014912">2.4. Meta Schema Document</a></span></dt><dt><span class="section"><a href="#idm24202352">2.5. Type</a></span></dt><dt><span class="section"><a href="#idm65337008">2.6. Namespace</a></span></dt><dt><span class="section"><a href="#idm2141008">2.7. Qualified Name</a></span></dt><dt><span class="section"><a href="#idm18163328">2.8. Validation</a></span></dt><dt><span class="section"><a href="#idm23721952">2.9. Annotation</a></span></dt><dt><span class="section"><a href="#idm19285056">2.10. Meta Keys</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Schema">3. Schema Documents</a></span></dt><dd><dl><dt><span class="section"><a href="#idm39961008">3.1. Scope</a></span></dt><dt><span class="section"><a href="#idm53856560">3.2. Schema Document properties</a></span></dt><dt><span class="section"><a href="#idm52095408">3.3. Examples</a></span></dt><dt><span class="section"><a href="#idm5204384">3.4. Type Names and references to Types</a></span></dt><dt><span class="section"><a href="#idm39734928">3.5. Types</a></span></dt><dt><span class="section"><a href="#idm39728976">3.6. Derived Type properties</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Atomic">4. Atomic Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm65518560">4.1. Scope</a></span></dt><dt><span class="section"><a href="#idm23391680">4.2. Examples</a></span></dt><dt><span class="section"><a href="#idm55406528">4.3. Builtin Atomic Types</a></span></dt><dt><span class="section"><a href="#idm20142800">4.4. Atomic facets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Object">5. Object Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm64496432">5.1. Scope</a></span></dt><dt><span class="section"><a href="#idm2955680">5.2. Examples</a></span></dt><dt><span class="section"><a href="#idm65259744">5.3. Builtin Object Type</a></span></dt><dt><span class="section"><a href="#idm51306064">5.4. Object facets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Array">6. Array Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm24202064">6.1. Scope</a></span></dt><dt><span class="section"><a href="#idm61799616">6.2. Examples</a></span></dt><dt><span class="section"><a href="#idm54728848">6.3. Builtin Array Type</a></span></dt><dt><span class="section"><a href="#idm64327792">6.4. Array facets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Union">7. Union Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm51295136">7.1. Scope</a></span></dt><dt><span class="section"><a href="#idm1923072">7.2. Examples</a></span></dt><dt><span class="section"><a href="#idm67018960">7.3. Union facets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Operations">8. Validation and Annotation</a></span></dt><dd><dl><dt><span class="section"><a href="#idm23503504">8.1. Validation</a></span></dt><dt><span class="section"><a href="#idm52612464">8.2. Annotation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-SchemaSchema">9. Schema of Schemas</a></span></dt><dt><span class="appendix"><a href="#appe-JSound-Revision_History">A. Revision History</a></span></dt><dt><span class="index"><a href="#idm23706384">Index</a></span></dt></dl></div><div xml:lang="en-US" class="chapter" id="chap-Introduction" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 1. Introduction</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#idm51451824">1.1. Requirements</a></span></dt></dl></div><div class="para">
		Over the past decade, the need for more flexible and scalable databases has greatly increased. The NoSQL universe brings many new ideas on how to build both scalable data storage and scalable computing infrastructures.
	</div><div class="para">
		XML and <a href="http://www.json.org/">JSON</a> are probably the most popular two data formats that emerged. While XML reached a level of maturity that gives it an enterprise-ready status, JSON databases are still in their early stages. Scalable data stores (like <a href="http://www.mongodb.org/">MongoDB</a>) are already available. <a href="http://www.jsoniq.org/">JSONiq</a> brings SQL-like query capabilities to JSON. The last missing piece for a full-fledged JSON database is a way to make sure that the data stored is consistent and sound. This is where schemas come into play.
	</div><div class="para">
		Many lessons can be learned from 40 years of relational databases history and 15 years of XML. The goal of this document is to introduce a schema language, JSound, which is much simpler than XML Schema, just like JSON syntax is much simpler than XML syntax.
	</div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm51451824">1.1. Requirements</h2></div></div></div><div class="para">
			The JSound schema definition language is based on the following requirements:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					A schema document must be a well-formed JSON document in the sense that it parses against the JSON grammar.
				</div></li><li class="listitem"><div class="para">
					A schema document must be valid in the sense that there is a JSound metaschema document against which all schema documents (including itself) are valid.
				</div></li><li class="listitem"><div class="para">
					While the schema definition language is greatly inspired from XML Schema, it must avoid its complexity. It must be simpler and more readable.
				</div></li><li class="listitem"><div class="para">
					JSound must support most of the <a href="http://www.w3.org/TR/xmlschema11-2/#built-in-datatypes">XML Schema primitive atomic types</a>, as many of them are very useful and completely orthogonal to XML.
				</div></li><li class="listitem"><div class="para">
					JSound must avoid the XML Schema model of restriction/extension of structured types. Instead, it must support a different model of subtyping based on classical object-oriented inheritance. In JSound, a subtype's value space must always be a subset of its base type's value space.
				</div></li><li class="listitem"><div class="para">
					It must be possible to mark string/value pairs in an object type as optional or to specify a default value in case of absence.
				</div></li><li class="listitem"><div class="para">
					It should be possible, given a JSON document, to turn it into a schema against which it is valid with minimal changes.
				</div></li></ul></div></div></div><div xml:lang="en-US" class="chapter" id="chap-Concepts" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 2. Concepts</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#idm18701312">2.1. Candidate Instance</a></span></dt><dt><span class="section"><a href="#idm66598464">2.2. Annotated Instance</a></span></dt><dt><span class="section"><a href="#idm57965472">2.3. Schema Document</a></span></dt><dt><span class="section"><a href="#idm66014912">2.4. Meta Schema Document</a></span></dt><dt><span class="section"><a href="#idm24202352">2.5. Type</a></span></dt><dt><span class="section"><a href="#idm65337008">2.6. Namespace</a></span></dt><dt><span class="section"><a href="#idm2141008">2.7. Qualified Name</a></span></dt><dt><span class="section"><a href="#idm18163328">2.8. Validation</a></span></dt><dt><span class="section"><a href="#idm23721952">2.9. Annotation</a></span></dt><dt><span class="section"><a href="#idm19285056">2.10. Meta Keys</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm18701312">2.1. Candidate Instance</h2></div></div></div><div class="para">
			This is a JDM (JSONiq Data Model) value. A Candidate Instance may or not be valid against a Schema Type.
		</div><div class="para">
			In the JSONiq Data Model, instances can be objects, arrays, or atomics.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					An object has an unordered list of string/value pairs. A top-level object is also referred to as a "JSON document".
				</div></li><li class="listitem"><div class="para">
					An array has an ordered list of values.
				</div></li><li class="listitem"><div class="para">
					An atomic has a value annotated with an atomic type.
				</div></li></ul></div><div class="para">
			Typically, the Candidate Instance will have been freshly parsed and will only have atomics of type string, integer, decimal, double, boolean and null. Integer, decimal and double values correspond to parsed JSON numbers, depending on the presence of dots and scientific notation.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm66598464">2.2. Annotated Instance</h2></div></div></div><div class="para">
			An Annotated Instance is a "Post-validation JDM Instance", i.e., it corresponds to a Candidate Instance that has been recursively annotated after going through the Annotation process against a Type.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm57965472">2.3. Schema Document</h2></div></div></div><div class="para">
			A Schema Document is a JSON document which defines Types against which Candidate Instances are being validated. A Schema Document is also a Candidate Instance and must be valid against the Meta Schema Type.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm66014912">2.4. Meta Schema Document</h2></div></div></div><div class="para">
			A Meta Schema Document is a JSON document that defines the Type against which all Schema Documents are valid including itself.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm24202352">2.5. Type</h2></div></div></div><div class="para">
			A Schema Document defines Types, which may or may not be anonymous. A Candidate Instance may or may not be valid against a Type. A Candidate Instance can be annotated against a Type, which results in a Data Model Instance. There are four kinds of Types: Atomic, Array, Object and Union. Types are represented with objects that are nested in a Schema Document. Named Types can also be referred to with Qualified Names.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm65337008">2.6. Namespace</h2></div></div></div><div class="para">
			A JSound Schema Document is associated with a Namespace, and all types that it defines live in that Namespace. However, Namespaces in JSound are much closer to C++ namespaces or Java packages than to XML namespaces. Prefixes may still, but must not be, used as convenient shorcuts to avoid writing long URIs.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm2141008">2.7. Qualified Name</h2></div></div></div><div class="para">
			Type names are Qualified Names, which are made of a namespace and of a local name. Local names must be unique in a namespace, but not across namespaces -- like in C++ or Java. Qualified Names have the following string representation: "Q{&lt;namespace&gt;}&lt;local name&gt;". For example: "Q{http://www.example.com/types}small-integer"
		</div><div class="para">
			For convenience, Namespaces that are imported can be bound to prefixes in the containing Schema Document, and the prefix can be used as a shortcut to the full namespace like so: "&lt;prefix&gt;:&lt;local name&gt;". If the prefix "my" is bound to the Namespace "http://www.example.com/types" in the Schema Document, the above example can also be represented as "my:small-integer".
		</div><div class="para">
			Builtin Type names are special in that they are in no Namespace and can also be represented with no prefix : "integer".
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm18163328">2.8. Validation</h2></div></div></div><div class="para">
			A Candidate Instance can be validated against a Type. The Validation action takes a Candidate Instance and a Type (typically, a set of Schema Documents and the name of a Type defined in one of them). It results in a boolean that describes whether the Candidate Instance is valid against the Type given its definition in the set of Schema Documents. If the Candidate Instance is not valid, a list of errors is provided that describes how the Candidate Instance is not conforming to the Type.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm23721952">2.9. Annotation</h2></div></div></div><div class="para">
			Annotation is the action of passing a Candidate Instance through a Schema Type (identified with a name in a set of of Schema Documents) and recursively:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					annotating an object or an array with the current Schema Type as well as determining against which Schema Type the object pair values or array members will be annotated.
				</div><div class="para">
					casting an atomic to the current Schema Type.
				</div></li></ul></div><div class="para">
			Note that this action is independent of Validation: The two actions can be performed in tandem but they are not required. As the Validation action, the Annotation action takes a Candidate Instance, a Type (typically, a set of Schema Documents and the name of a Type defined in one of them) and results in a set of annotations on the Instance that describe the Types which the nested Instances match. This action also works on Instances that validate partially. When a Type cannot be found that matches a given nested Candidate Instance, a special annotation is used.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm19285056">2.10. Meta Keys</h2></div></div></div><div class="para">
			Schema Documents mix keys that are describing actual data fields (actual keys) and keys that define the Types (meta keys). To make the distinction between the two, we use the $ (dollar sign) to represent the meta keys. In order to use $ in actual keys one should use the escaped version by doubling the $ character. This is consistent with other JSON meta languages.
		</div></div></div><div xml:lang="en-US" class="chapter" id="chap-Schema" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 3. Schema Documents</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#idm39961008">3.1. Scope</a></span></dt><dt><span class="section"><a href="#idm53856560">3.2. Schema Document properties</a></span></dt><dt><span class="section"><a href="#idm52095408">3.3. Examples</a></span></dt><dt><span class="section"><a href="#idm5204384">3.4. Type Names and references to Types</a></span></dt><dt><span class="section"><a href="#idm39734928">3.5. Types</a></span></dt><dt><span class="section"><a href="#idm39728976">3.6. Derived Type properties</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm39961008">3.1. Scope</h2></div></div></div><div class="para">
			Schema Documents have a namespace and define multiple Types in this namespace.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm53856560">3.2. Schema Document properties</h2></div></div></div><div class="para">
			Schema Documents are (serialized) JSON objects which have the following properties
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$namespace (JSON string): the namespace (URI) in which the types defined in this Schema Document live.
				</div></li><li class="listitem"><div class="para">
					$about (JSON value): free content (documentation, comments, ...).
				</div></li><li class="listitem"><div class="para">
					$imports (JSON array of objects) : used to import Types located in other Schema Documents (i.e., in other Namespaces). Imports are not recursive, i.e., importing a Schema Document does not import the further Schema Documents that it may itself import.
				</div><div class="para">
					Each JSON object in this JSON array has the following properties:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							$namespace (JSON string): the namespace in which the Types being imported live.
						</div></li><li class="listitem"><div class="para">
							$location (JSON string): a hint about where to find the Schema Document for this namespace.
						</div></li><li class="listitem"><div class="para">
							$prefix (JSON string): the prefix used in Qualified Names to refer to Types in the above namespace. Must not contain a colon.
						</div></li></ul></div></li><li class="listitem"><div class="para">
					$types (JSON array of objects representing Types) : the Types defined in this document. How these objects look like is explained in subsequent sections.
				</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm52095408">3.3. Examples</h2></div></div></div><div class="para">
			This Schema Document defines two Atomic Types in the "http://www.example.com/my-schema" namespace and with the local names "small-number" and "big-number".
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "atomic",
      "$name" : "small-number",
      "$baseType" : "integer",
      "$enumeration" : [ 1, 2, 4, 8 ]
    },
    {
      "$kind" : "atomic",
      "$name" : "Q{http://www.example.com/my-schema}big-number",
      "$baseType" : "integer",
      "$enumeration" : [ 1000, 2000, 4000, 8000 ]
    }
  ]
}
</pre><div class="para">
			This Schema Document defines one Object Type in the "http://www.example.com/my-new-schema" namespace named "small-and-big".
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-new-schema",
  "$imports" : [
    {
      "$namespace" : "http://www.example.com/my-schema",
      "$prefix" : "other"
    }
  ],
  "$types" : [
    {
      "$kind" : "object",
      "$name" : "small-and-big",
      "$content" : {
        "small" : { "$type" : "other:small-number" },
        "big" : { "$type" : "other:big-number", "$optional" : true }
      }
    }
  ]
}
</pre><div class="para">
			Given this set of two Schema Documents, the following JSON object:
		</div><pre class="programlisting">
{
  "small" : 4
}
</pre><div class="para">
			is valid against the Type named "Q{http://www.example.com/my-new-schema}small-and-big".
		</div><div class="para">
			This JSON object is not valid, because the value associated with "big" is not in the value space of the Type "Q{http://www.example.com/my-schema}big-number".
		</div><pre class="programlisting">
{
  "small" : 4,
  "big" : 3
}
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm5204384">3.4. Type Names and references to Types</h2></div></div></div><div class="para">
			Type Names are Qualified Names, made of a namespace and of a local name, as described in the former chapter.
		</div><div class="para">
			Types names are used to (optionally) name Types, or to refer to another Type as a base type.
		</div><div class="para">
			References to Types that are defined in the same Schema Document can be referred to with no prefix as well: the namespace is that of the defining Schema Document. If there is a collision with Builtin Type names, the locally defined Type has precedence (the Builtin Type is hidden).
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm39734928">3.5. Types</h2></div></div></div><div class="para">
			There are four kinds of Types: atomic, object, array and union.
		</div><div class="para">
			Types are either Builtin, in which case their name is in no namespace, or Derived.
		</div><div class="para">
			The topmost Type is builtin and is named "item".
		</div><div class="para">
			The topmost Object Type is builtin and is named "object".
		</div><div class="para">
			The topmost Array Type is builtin and is named "array".
		</div><div class="para">
			The topmost Atomic Type is builtin and is named "atomic". There are many further Builtin Atomic Types.
		</div><div class="para">
			Derived Types are always defined by restricting the value space of a <span class="emphasis"><em>base type</em></span> by means of <span class="emphasis"><em>facets</em></span>. They have a JSON object representation.
		</div><div class="para">
			Derived Object Types are always directly derived from "object". Derived Array Types are always directly derived from "array". Derived Union Types are always directly derived from "item". Derived Atomic Types may be derived from any other Atomic Type.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm39728976">3.6. Derived Type properties</h2></div></div></div><div class="para">
			A Derived Type has the following properties:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$kind (JSON string): the kind of the Type. One of "atomic, "object", "array", "union".
				</div></li><li class="listitem"><div class="para">
					$name (JSON string): a string containing the Qualified Name (as defined above) of this Type.
				</div></li><li class="listitem"><div class="para">
					$baseType (JSON string): a string containing the Qualified Name of the Type which is the base type of this Type.
				</div></li><li class="listitem"><div class="para">
					$about (JSON value): free content (documentation, comments, ...).
				</div></li><li class="listitem"><div class="para">
					various facets properties. Which facets are available defines on the $kind of the Type.
				</div></li></ul></div><div class="para">
			There are the following constraints on these properties:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$name is optional and must live in the namespace of the Schema Document in which this Type is defined.
				</div></li><li class="listitem"><div class="para">
					A prefix may not appear twice in the $imports.
				</div></li><li class="listitem"><div class="para">
					Types defined directly in the top-level $types array must be named.
				</div></li><li class="listitem"><div class="para">
					$baseType must refer to a known Type - builtin, in the same Schema Document or in an imported Schema Document. In particular, if a prefix is used, it must be bound to an imported namespace.
				</div></li><li class="listitem"><div class="para">
					If $kind is "object", $baseType must be "object" if provided.
				</div></li><li class="listitem"><div class="para">
					If $kind is "array", $baseType must be "array" if provided.
				</div></li><li class="listitem"><div class="para">
					If $kind is "union", $baseType must be "item" if provided.
				</div></li><li class="listitem"><div class="para">
					If $kind is "atomic", $baseType must be the Qualified Name of an existing Atomic Type.
				</div></li></ul></div><div class="para">
			Here is an example of an invalid Schema Document, because it does not fulfill many of the above constraints.
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "atomic",
      "$name" : "type1",
      "$baseType" : "unbound:type", (: prefix is not bound :)
      "$maxInclusive" : 4
    },
    {
      "$kind" : "atomic",
      "$name" : "Q{http://www.example.com/other}type2", (: the namespace must match that of the Schema document :)
      "$baseType" : "integer",
      "$maxInclusive" : 4
    },
    {
      "$kind" : "atomic",
      "$name" : "Q{http://www.example.com/my-schema}type3",
      "$baseType" : "object", (: base type MUST also be an atomic type :)
      "$maxInclusive" : 4
    },
    {
      "$kind" : "object",
      "$name" : "object1",
      "$baseType" : "type1" (: base type MUST be "object":)
      "$content" : {}
    },
    {
      "$kind" : "object",
      "$name" : "object2",
      "$baseType" : "object1" (: base type MUST be "object":)
    }
  ]
}
</pre><div class="para">
			There are two facets common to all types:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$enumeration (array of JSON values): Constrains a value space to a specified set of values.
				</div></li><li class="listitem"><div class="para">
					$constraints (array of JSON strings): Constrains a value space to the values for which a set of JSONiq queries evaluates to true. In these JSONiq queries, the context item is bound to the Serialized Instance being validated, after parsing.
				</div></li></ul></div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "object"
      (: "$baseType" : "object" is implicit :)
      "$name" : "two-objects",
      "$enumeration" : [ { "foo" : "bar" }, {} ] (: only these two objects :)
    },
    {
      "$kind" : "array"
      (: "$baseType" : "array" is implicit :)
      "$name" : "uniform-array",
      "$constraints" : [ "every $i in 1 to size($$) satisfies deep-equals($$($i), $$(1))" ]  (: all members must be the same :)
    },
  ]
}
</pre><div class="para">
			The following JSON object is valid against Q{http://www.example.com/my-schema}two-objects.
		</div><pre class="programlisting">
{ "foo" : "bar" }
</pre><div class="para">
			The following JSON array is valid against Q{http://www.example.com/my-schema}uniform-array.
		</div><pre class="programlisting">
[ 42, 42, 42 ]
</pre></div></div><div xml:lang="en-US" class="chapter" id="chap-Atomic" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 4. Atomic Types</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#idm65518560">4.1. Scope</a></span></dt><dt><span class="section"><a href="#idm23391680">4.2. Examples</a></span></dt><dt><span class="section"><a href="#idm55406528">4.3. Builtin Atomic Types</a></span></dt><dt><span class="section"><a href="#idm20142800">4.4. Atomic facets</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm65518560">4.1. Scope</h2></div></div></div><div class="para">
			Atomic Types match atomics (JSON leaf values: strings, numbers, booleans, nulls).
		</div><div class="para">
			Atomic Types have a lexical space (a set of literals denoting the values), a value space (a set of actual values), and a lexical mapping which maps the former into the latter.
		</div><div class="para">
			An Atomic Type can be either the topmost <span class="emphasis"><em>atomic</em></span>, or a <span class="emphasis"><em>primitive</em></span> builtin type, or a builtin type <span class="emphasis"><em>derived</em></span> from a primitive type, or a user-defined type <span class="emphasis"><em>derived</em></span> from any other Atomic Type (except <span class="emphasis"><em>atomic</em></span>).
		</div><div class="para">
			A Derived Atomic Type can be defined by restricting the value space of another Atomic Type by specifying atomic facets. A restriction can also be made with the general facets $enumeration and $constraints.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm23391680">4.2. Examples</h2></div></div></div><div class="para">
			Given the following Schema Document:
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "atomic",
      "$name" : "foo-and-bar",
      "$baseType" : "string",
      "$enumeration" : [ "foo", "bar" ]
    },
    {
      "$kind" : "atomic",
      "$name" : "digits",
      "$baseType" : "integer",
      "$minInclusive" : 1,
      "$maxExclusive" : 10
    },
    {
      "$kind" : "atomic",
      "$name" : "few-digits",
      "$baseType" : "my:digits",
      "$enumeration" : [ 4, 6 ]
    }
  ]
}
</pre><div class="para">
			The strings "foo" and "bar" are valid against Type named "Q{http://www.example.com/my-schema}foo-and-bar". The string "foobar" and the array [ "foo", "bar" ] are not.
		</div><div class="para">
			The atomics (integers) 2 and 7 are valid against the Type named "Q{http://www.example.com/my-schema}digits". The string "2", the integer 0 and the array [ "foo", "bar" ] are not.
		</div><div class="para">
			The integer 4 is valid against the Type named "Q{http://www.example.com/my-schema}few-digits". The integer 2, the integer 0 and the array [ "foo", "bar" ] are not.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm55406528">4.3. Builtin Atomic Types</h2></div></div></div><div class="para">
			A number of builtin Atomic Types are predefined. Most of them have counterparts in XML Schema 1.1, because they are very useful also in JSON (for example : dates, times, ...). In particular, they have the same value space, the same lexical space, the same lexical mapping and (for primitive types) the same associated set of atomic facets.
		</div><div class="para">
			Some of these builtin types are primitive and marked as such below. Others are derived from another builtin type.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#string">string</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#anyURI">anyURI</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#base64Binary">base64Binary</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#hexBinary">hexBinary</a> (primitive).
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#date">date</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#dateTime">dateTime</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#time">time</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#dateTimeStamp">dateTimeStamp</a> (derived from dateTime),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gYear">gYear</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gYearMonth">gYearMonth</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gMonth">gMonth</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gMonthDay">gMonthDay</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gDay">gDay</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#duration">duration</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#dayTimeDuration">dayTimeDuration</a> (derived from duration),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#yearMonthDuration">yearMonthDuration</a> (derived from duration),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#decimal">decimal</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#integer">integer</a> (derived from decimal),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#long">long</a> (derived from integer),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#int">int</a> (derived from long),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#short">short</a> (derived from int),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#byte">byte</a> (derived from short),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#double">double</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#float">float</a> (primitive).
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#boolean">boolean</a> (primitive)
				</div></li><li class="listitem"><div class="para">
					null (primitive), which has a singleton value space containing the JSON null value with the lexical representation "null".
				</div></li></ul></div><div class="para">
			There is also a special builtin type <span class="emphasis"><em>atomic</em></span>, which is a supertype of all primitive types and, by transition, of all atomic types.
		</div><div class="para">
			The lexical namespace of dateTime as defined in XML Schema 1.1 is a superset of the date representation defined in <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">ECMAScript</a>. In addition, JSound extends the lexical representation of respectively date, time, dateTime defined above, to allow the format defined in <a href="http://tools.ietf.org/html/rfc2822#page-14">RFC 2822</a> (nonterminals date, time, date-time respectively). This is because many JavaScript implementations do so.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm20142800">4.4. Atomic facets</h2></div></div></div><div class="para">
			Restriction is done using the general facets, or the following atomic facets (they must be available for the base type).
		</div><div class="para">
			These facets are defined in XML Schema 1.1. For convenience, the summary from the XML Schema 1.1 specification is provided below. Which primitive type has which facets is defined in XML Schema 1.1 as well.
		</div><div class="para">
			The following atomic facets are available for the primitive types string, anyURI, base64Binary, hexBinary:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-length">$length</a> (integer): Constraining a value space to values with a specific number of units of length, where units of length varies depending on the base type.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-minLength">$minLength</a> (integer): Constraining a value space to values with at least a specific number of units of length, where units of length varies depending on the base type.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-maxLength">$maxLength</a> (integer): Constraining a value space to values with at most a specific number of units of length, where units of length varies depending on the base type.
				</div></li></ul></div><div class="para">
			The following atomic facets are available for the primitive types date, dateTime, time, gYear, gYearMonth, gMonth, gMonthDay, gDay, duration, decimal, double, float:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-maxInclusive">$maxInclusive</a> (atomic): Constraining a value space to values with a specific inclusive upper bound.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-maxExclusive">$maxExclusive</a> (atomic): Constraining a value space to values with a specific exclusive upper bound.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-minExclusive">$minExclusive</a> (atomic): Constraining a value space to values with a specific exclusive lower bound.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-minInclusive">$minInclusive</a> (atomic): Constraining a value space to values with a specific inclusive lower bound.
				</div></li></ul></div><div class="para">
			The following atomic facets are available for the primitive type decimal:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-totalDigits">$totalDigits</a> (integer): Restricting the magnitude and arithmetic precision of values in the value spaces of decimal and datatypes derived from it.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-fractionDigits">$fractionDigits</a> (integer): Placing an upper limit on the arithmetic precision of decimal values.
				</div></li></ul></div><div class="para">
			The following atomic facets are available for the primitive types date, dateTime, time:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-explicitTimezone">$explicitTimezone</a> ("required", "prohibited" or "optional"): Requiring or prohibiting the time zone offset in date/time datatypes.
				</div></li></ul></div><div class="para">
			The following atomic facets are available for all primitive types (including boolean and null):
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-pattern">$pattern</a> (string): Constraining a value space to values that are denoted by literals which match each of a set of regular expressions.
				</div></li></ul></div></div></div><div xml:lang="en-US" class="chapter" id="chap-Object" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 5. Object Types</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#idm64496432">5.1. Scope</a></span></dt><dt><span class="section"><a href="#idm2955680">5.2. Examples</a></span></dt><dt><span class="section"><a href="#idm65259744">5.3. Builtin Object Type</a></span></dt><dt><span class="section"><a href="#idm51306064">5.4. Object facets</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm64496432">5.1. Scope</h2></div></div></div><div class="para">
			Object Types match objects.
		</div><div class="para">
			There is one builtin Object Type: "object" which is the direct base type of all other Object Types.
		</div><div class="para">
			An Object Type can be defined by restricting the value space of "object" by specifying a layout (type of the pairs, optional or not, ...). A restriction can also be made with the general Types facets $enumeration and $constraints.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm2955680">5.2. Examples</h2></div></div></div><div class="para">
			Against the following Object Type:
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
     "$kind" : "object",
     "$content" : {
       "foo" : {
         "$type" : "string",
       }
     },
     "$open" : false,
     "$name" : "only-foo"
    },
    {
      "$kind" : "object",
      "$content" : {
        "foo" : {
          "$type" : "string",
        },
        "bar" : {
         "$type" : "boolean",
         "$optional" : true
       }
     }
    "$name" : "foo-bar-and-arrays"
    }
  ]
}
</pre><div class="para">
			The objects { "foo" : "bar" } and { "foo" : "foo" } are valid against the Type named "Q{http://www.example.com/my-schema}only-foo" because the foo pairs are strings.
		</div><div class="para">
			The object {} is not because the foo pair is missing.
		</div><div class="para">
			The object { "foo" : "bar", "bar" : "foo" } is not because no other pair than "foo" is allowed (closed Object Type).
		</div><div class="para">
			Against the Type named "Q{http://www.example.com/my-schema}only-foo":
		</div><div class="para">
			The objects { "foo" : "bar", "foobar" : [ "foo" ] } and { "foo" : "bar", "bar" : true } are valid because the foo pairs are strings, bar is optional and the Object Type is $open.
		</div><div class="para">
			The objects {} and { "bar" : "foo" } and { "foo" : "bar", "bar" : "foo" } are not because the foo pair is missing or the bar pair is not a boolean.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm65259744">5.3. Builtin Object Type</h2></div></div></div><div class="para">
			There is one topmost, builtin Object Type named <span class="emphasis"><em>object</em></span>, against which all objects are valid.
		</div><div class="para">
			This topmost type can be seen as having its $content facet as the empty object, and its $open facet as true.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm51306064">5.4. Object facets</h2></div></div></div><div class="para">
			Restriction is done using the general facets, or the following object facets. For the moment, restriction can only be made on the topmost object type, but this will be relaxed later.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$content (object): the layout definition. Each pair in $content is called a field descriptor. The value in each field descriptor has the following properties.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							$type (string or object) - required: the name of a Type (Qualified Name in a string) or the type itself (an object) that the value must match.
						</div></li><li class="listitem"><div class="para">
							$optional (boolean) - optional: indicates that the pair is optional. Default is false.
						</div></li><li class="listitem"><div class="para">
							$default (item) - optional: indicates a default value to be taken the value is missing in the Serialized Instance. $optional is then ignored.
						</div><div class="para">
							However, if this value is an object with a pair named $computed (which must be associated with a string), then the JSONiq query in $content.$default.$computed is executed upon Annotation, with the context item bound to the Candidate Instance being matched against the containing Object Type. It must result in one item, which is the default value for the Pair Descriptor.
						</div></li></ul></div><div class="para">
					An object $o is valid against the $content facet if the following conditions are met:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							For each pair $k : $v in the field descriptor such that $v."$optional" is false and $v."$default" is absent, there must be a pair named $k in $o.
						</div></li><li class="listitem"><div class="para">
							For each pair $k : $v in the field descriptor, if $o.$k exists, then $o.$k must be valid against the Type $v."$type".
						</div></li></ul></div></li><li class="listitem"><div class="para">
					$open (boolean) : specifies whether pairs not specified in $content are to be accepted. The default is the same as the $baseType (true if $baseType is object).
				</div><div class="para">
					All objects are valid against the $open facet if it is set to true.
				</div><div class="para">
					If it is set to false, an object $o is valid against the $open facet if all its keys appear in $content, or in the $content of a super type.
				</div></li></ul></div><div class="para">
			The object facets must fulfill the following consistency constraints against the super types (i.e., in the transitive closure of the $baseType relationship).
		</div><div class="para">
			These constraints make sure that the new value space is a subset of the base type's value space.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					If the $baseType's $open property is false, then $open cannot be set back to true.
				</div></li><li class="listitem"><div class="para">
					Field descriptors on new keys may only be defined in $content if the $baseType's $open property is true.
				</div></li><li class="listitem"><div class="para">
					Field descriptors on keys that were already defined in a super type are only allowed if they are more restrictive, i.e., $type must be a subtype of the $type associated to this key by the closest super type which does so.
				</div></li><li class="listitem"><div class="para">
					If a field descriptor redefines a key that was not $optional in the closest super type, $optional cannot be set back to true.
				</div></li></ul></div><div class="para">
			Note: since currently, the $baseType must be "object", these constraints are always fulfilled.
		</div></div></div><div xml:lang="en-US" class="chapter" id="chap-Array" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 6. Array Types</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#idm24202064">6.1. Scope</a></span></dt><dt><span class="section"><a href="#idm61799616">6.2. Examples</a></span></dt><dt><span class="section"><a href="#idm54728848">6.3. Builtin Array Type</a></span></dt><dt><span class="section"><a href="#idm64327792">6.4. Array facets</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm24202064">6.1. Scope</h2></div></div></div><div class="para">
			Array Types match arrays.
		</div><div class="para">
			There is one builtin topmost Array Type "array".
		</div><div class="para">
			An Array Type can be defined by restricting the value space of "array" by specifying a layout (type of the members) or size bounds. A restriction can also be made with the general Types facets $enumeration and $constraints.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm61799616">6.2. Examples</h2></div></div></div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "array",
      "$content" : [ "string" ],
      "$name" : "strings"
    },
    {
      "$kind" : "array",
      "$content" : [ "string" ],
      "$maxLength" : 5,
      "$name" : "less-than-five-members"
    },
    {
      "$kind" : "array",
      "$content" : [ "integer" ],
      "$constraints" : [ "every $i in $$ satisfies $i le 10" ],
      "$name" : "all-less-than-ten"
    }
  ]
}</pre><div class="para">
			[ "foo " "bar" ] is valid against the Type named "Q{http://www.example.com/my-schema}strings" but not [ 1, 2, "foo" ].
		</div><div class="literallayout"><p><br />
</p></div><div class="para">
			[ "foo " "bar" ] is valid against the Type named "Q{http://www.example.com/my-schema}less-than-five-members" but not [ "foo", "foo", "foo", "foo", "foo", "foo" ].
		</div><div class="literallayout"><p><br />
</p></div><div class="para">
			[ 1, 3, 5 ] is valid against the Type named "Q{http://www.example.com/my-schema}all-less-than-ten" but not [ 1, 3, 72 ].
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm54728848">6.3. Builtin Array Type</h2></div></div></div><div class="para">
			There is one topmost, builtin Array Type named <span class="emphasis"><em>array</em></span>, against which all arrays are valid.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm64327792">6.4. Array facets</h2></div></div></div><div class="para">
			Restriction is done using the general facets, or the following array facets.
		</div><div class="para">
			JSound supports the following array facets.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$content (singleton array of one string or object) : the name of a Type (Qualified Name in a string) or the type itself (an object) that all members must match.
				</div></li><li class="listitem"><div class="para">
					$minLength (integer) : the minimum length.
				</div></li><li class="listitem"><div class="para">
					$maxLength (integer) : the maximum length.
				</div></li></ul></div></div></div><div xml:lang="en-US" class="chapter" id="chap-Union" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Union Types</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#idm51295136">7.1. Scope</a></span></dt><dt><span class="section"><a href="#idm1923072">7.2. Examples</a></span></dt><dt><span class="section"><a href="#idm67018960">7.3. Union facets</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm51295136">7.1. Scope</h2></div></div></div><div class="para">
			The value space of a Union Type is the union of the value spaces of all its member types.
		</div><div class="para">
			There is no Builtin Union Type. All Union Types have directly the topmost "item" as their base type and restrict the value space by specifying the $content facet. General facets can also be used.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm1923072">7.2. Examples</h2></div></div></div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
    "$kind" : "union",
    "$content" : [ "string", { "$kind" : "array", "$content" : [ "integer" ] } ],
    "$name" : "string-or-integer-array"
    },
    {
    "$kind" : "union",
    "$content" : [ "string", { "$kind" : "array", "$content" : [ "integer" ] } ],
    "$enumeration" : [ "foo", [ 1, 2, 3, 4 ] ], 
    "$name" : "just-two"
    }
  ]
}
</pre><div class="para">
			"foo", "bar" and [ 1, 2, 3 ] are valid against the Type named "Q{http://www.example.com/my-schema}string-or-integer-array" but 3.14 and true are not.
		</div><div class="para">
			"foo", and [ 1, 2, 3, 4 ] are valid against the Type named "Q{http://www.example.com/my-schema}just-two" but [ 1 ] and "bar" are not.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm67018960">7.3. Union facets</h2></div></div></div><div class="para">
			The specification of member types is done using one (compulsory) union facet, and optionally general facets.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$content (array of (string or object) ) : each member in the array is the name of a Type (Qualified Name in a string) or the member type itself (an object).
				</div></li></ul></div></div></div><div xml:lang="en-US" class="chapter" id="chap-Operations" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 8. Validation and Annotation</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#idm23503504">8.1. Validation</a></span></dt><dt><span class="section"><a href="#idm52612464">8.2. Annotation</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm23503504">8.1. Validation</h2></div></div></div><div class="para">
			A Candidate Instance is valid against a Builtin Type if it is in its value space.
		</div><div class="para">
			A Candidate Instance is valid against a Derived Type if it is valid against its $baseType (recursively) and if it is valid against all facets.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm52612464">8.2. Annotation</h2></div></div></div><div class="para">
			A Candidate Instance is annotated against an Atomic Type as follows:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					If it is valid against the Type (which implies that it is an atomic value), it is cast to the Atomic Type.
				</div></li><li class="listitem"><div class="para">
					Otherwise, it is replaced with an object with the fields $invalid (true), $expected (Atomic Type name), $value (the Candidate Instance)
				</div></li></ul></div><div class="para">
			A Candidate Instance is annotated against an Object Type $t as follows:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					If it is valid against the Type (which implies that it is an object), it is annotated with the Object Type's Qualified Name (if it has any).
				</div></li><li class="listitem"><div class="para">
					If it is valid against the Type, each pair value associated with a key $key is annotated recursively against the Types described with $t."$content".$key."$type". For missing pairs for which a $t."$content".$key."$default" value is provided, a new pair with the (possibly computed) $default value is added.
				</div></li><li class="listitem"><div class="para">
					Otherwise, it is replaced with an object with the fields $invalid (true), $expected (Object Type name), $value (the Candidate Instance)
				</div></li></ul></div><div class="para">
			A Candidate Instance is annotated against an Array Type $t as follows:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					If it is valid against the Type (which implies that it is an array), it is annotated with the Array Type's Qualified Name (if it has any).
				</div></li><li class="listitem"><div class="para">
					If it is valid against the Type, each member is annotated recursively against the Type described with $t."$content"(1).
				</div></li><li class="listitem"><div class="para">
					Otherwise, it is replaced with an object with the fields $invalid (true), $expected (Array Type name), $value (the Candidate Instance)
				</div></li></ul></div><div class="para">
			A Candidate Instance is annotated against a Union Type $t as follows:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					If it is valid against the Type, then it is annotated against the first Type of $t."$content"() against which the Candidate Instance is valid.
				</div></li><li class="listitem"><div class="para">
					Otherwise, it is replaced with an object with the fields $invalid (true), $expected (Union Type name), $value (the Candidate Instance)
				</div></li></ul></div></div></div><div xml:lang="en-US" class="chapter" id="chap-SchemaSchema" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 9. Schema of Schemas</h2></div></div></div><pre class="programlisting"> 
{
  "$namespace" : "http://www.jsound.org/schemaschema",
  "$types" : [
    {
      "$kind" : "object",
      "$name" : "atomic-type",
      "$content" : {
        "$$kind" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "atomic" ]
          }
        },
        "$$name" :             { "$type" : "qualified-name", "$optional" : true },
        "$$baseType" :         { "$type" : "qualified-name" }
        "$$pattern" :          { "$type" : "string", "$optional" : true },
        "$$length" :           { "$type" : "integer","$optional" : true },
        "$$minLength" :        { "$type" : "integer","$optional" : true },
        "$$maxLength" :        { "$type" : "integer","$optional" : true },
        "$$totalDigits" :      { "$type" : "integer","$optional" : true },
        "$$fractionDigits" :   { "$type" : "integer","$optional" : true },
        "$$maxInclusive" :     { "$type" : "atomic", "$optional" : true },
        "$$maxExclusive" :     { "$type" : "atomic", "$optional" : true },
        "$$minExclusive" :     { "$type" : "atomic", "$optional" : true },
        "$$minInclusive" :     { "$type" : "atomic", "$optional" : true },
        "$$explicitTimezone" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "required", "prohibited", "optional" ]
          },
          "$optional" : true
        },
        "$$enumeration" : {
          "$type" : { "$kind" : "array", $content" : [ "atomic" ] },
          "$optional" : true
        },
        "$$constraints" : {
          "$type" : { "$kind" : "array", "$content" : [ "string" ] },
          "$optional" : true
        }
      }
    },
    {
      "$kind" : "object",
      "$name" : "object-type",
      "$content" : {
        "$$kind" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "object" ]
          }
        },
        "$$name" : { "$type" : "qualified-name", "$optional" : true },
        "$$content" : {
          "$type" : {
            "$kind" : "object",
            "$constraints" : [ "every $key in keys($$) satisfies $$.$key instance of pair-descriptor" ]
          }
          "$optional" : true
        },
        "$$open" : { "$type" : "boolean", $optional" : true },
        "$$enumeration" : {
          "$type" : { "$kind" : "array", $content" : [ "atomic" ] },
          "$optional" : true
        },
        "$$constraints" : {
          "$type" : { "$kind" : "array", "$content" : [ "string" ] },
          "$optional" : true
        }
      }
    },
    {
      "$kind" : "object",
      "$name" : "pair-descriptor"
      "$content" : {
        "$$type" : { "$type" : "type-or-reference" },
        "$$optional" : { "$type" : "boolean", "$default" : "false" }
        "$$default" : { "$type" : "item", "$optional" : true }
      }
    },
    {
      "$kind" : "object",
      "$name" : "array-type",
      "$content" : {
        "$$kind" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "array" ]
          }
        },
        "$$name" : { "$type" : "qualified-name", "$optional" : true },
        "$$content" : {
          "$type" : {
            "$kind" : "array",
            "$content" : [ "type-or-reference" ],
            "$minLength" : 1,
            "$maxLength" : 1
          }
        },
        "$$minLength" : { "$type" : "integer", "$optional" : true },
        "$$maxLength" : { "$type" : "integer", "$optional" : true },
        "$$enumeration" : {
          "$type" : { "$kind" : "array", $content" : [ "atomic" ] },
          "$optional" : true
        },
        "$$constraints" : {
          "$type" : { "$kind" : "array", "$content" : [ "string" ] },
          "$optional" : true
        }
      }
    },
    {
      "$kind" : "object",
      "$name" : "union-type",
      "$content" : {
        "$$kind" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "union" ]
          }
        },
        "$$name" : { "$type" : "qualified-name", "$optional" : true },
        "$$content" : { "$type" : { "$kind" : "array", "$content" : [ "type-or-reference" ] } },
        "$$enumeration" : {
          "$type" : { "$kind" : "array", $content" :  [ "atomic" ] },
          "$optional" : true },
        "$$constraints" : {
          "$type" : { "$kind" : "array", $content" :  [ "string" ] },
          "$optional" : true
        }
      }
    },
    {
      "$kind" : "atomic",
      "$name" : "qualified-name",
      "$baseType" : "string",
      "$pattern" : "([^:${}]+:|Q{[^${}]+})?[^:${}]+"
    },
    {
      "$kind" : "union",
      "$name" : "type-or-reference",
      "$content" : [ "qualified-name", "atomic-type", "object-type", "array-type", "union-type" ]
    }
  ]
}
</pre></div><div xml:lang="en-US" class="appendix" id="appe-JSound-Revision_History" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Revision History</h1></div></div></div><div class="para">
		<div class="revhistory"><table border="0" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><strong>Revision History</strong></th></tr><tr><td align="left">Revision 0.1.3</td><td align="left">Mon Jun 3, 2013</td><td align="left"><span class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Added constraints on $content and $open for objects, to ensure proper object-oriented inheritance. But for the moment, object derivation is limited to the topmost type, so that these constraints are trivially fulfilled.</td></tr><tr><td>Fixed typos.</td></tr><tr><td>Cleaned up Schema Schema.</td></tr></table>

				</td></tr><tr><td align="left">Revision 0.1.2</td><td align="left">Thu May 30 2013</td><td align="left"><span class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Annotating an atomic means casting it.</td></tr><tr><td>The lexical space of date/dateTime/time was extended to support RFC 2822.</td></tr><tr><td>Local types have no prefix.</td></tr><tr><td>The URI Qualified Name syntax may also be used to reference types.</td></tr><tr><td>$optional is ignored if a $default is provided for a pair.</td></tr><tr><td>Added $about field to Schema and Types for free content.</td></tr><tr><td>The Input of the Validation and Annotation processes is now a JDM instance (typically freshly parsed).</td></tr><tr><td>$layout and $member-types were renamed to $content</td></tr><tr><td>The special key $any was removed from object $content. JSONiq constraints can be used instead.</td></tr><tr><td>Default values can be computed with a JSONiq query.</td></tr></table>

				</td></tr><tr><td align="left">Revision 0.1.2</td><td align="left">Wed May 29 2013</td><td align="left"><span class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>First Working Draft.</td></tr></table>

				</td></tr></table></div>

	</div></div><div class="index" id="idm23706384"><div class="titlepage"><div><div><h2 class="title">Index</h2></div></div></div><div class="index"></div></div></div></body></html>
