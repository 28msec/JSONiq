<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Introduction to JSONiq</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="JSONiq-Introduction_to_JSONiq-0.1-en-US-0-0" /><meta name="description" content="JSONiq is a query and processing language specifically designed for the popular JSON data model. The main ideas behind JSONiq are based on lessons learned in more than 30 years of relational query systems and more than 15 years of experience with designing and implementing query languages for semi-structured data. As a result, JSONiq is an expressive and highly optimizable language to query and update any kind of JSONiq store or resource. It enables developers to leverage the same productive high-level language across a variety of NoSQL products. This book gives a complete introduction to the JSONiq language. It does so by giving examples for all types of expressions and functions. Those examples can be immediately used because they work standalone, which allows the interested reader to start diving into the language." /><link rel="home" href="index.html" title="Introduction to JSONiq" /><link rel="next" href="chapter-introduction.html" title="Chapter 1. Introduction" /></head><body><p id="title"><a class="left" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"></li><li class="next"><a accesskey="n" href="chapter-introduction.html"><strong>Next</strong></a></li></ul><div xml:lang="en-US" class="book" id="idp6073792" lang="en-US"><div class="titlepage"><div><div class="producttitle"><span class="productname">JSONiq</span> <span class="productnumber">0.1</span></div><div><h1 id="idp6073792" class="title">Introduction to JSONiq</h1></div><div><h2 class="subtitle">The SQL of NoSQL</h2></div><p class="edition">Edition 0</p><div><div xml:lang="en-US" class="authorgroup" lang="en-US"><div class="author"><h3 class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></h3></div></div></div><hr /><div><div class="abstract"><h6>Abstract</h6><div class="para">
			JSONiq is a query and processing language specifically designed for the popular JSON data model. The main ideas behind JSONiq are based on lessons learned in more than 30 years of relational query systems and more than 15 years of experience with designing and implementing query languages for semi-structured data. As a result, JSONiq is an expressive and highly optimizable language to query and update any kind of JSONiq store or resource. It enables developers to leverage the same productive high-level language across a variety of NoSQL products. This book gives a complete introduction to the JSONiq language. It does so by giving examples for all types of expressions and functions. Those examples can be immediately used because they work standalone, which allows the interested reader to start diving into the language.
		</div></div></div></div><hr /></div><div class="toc"><dl><dt><span class="chapter"><a href="chapter-introduction.html">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-introduction.html#idm45073280">1.1. NoSQL - Why Are Relational Databases Not Good Enough?</a></span></dt><dt><span class="section"><a href="ch01s02.html">1.2. Why JSONiq?</a></span></dt><dt><span class="section"><a href="ch01s03.html">1.3. How to Run the Queries in This Book?</a></span></dt><dt><span class="section"><a href="ch01s04.html">1.4. Acknowledgements</a></span></dt></dl></dd><dt><span class="part"><a href="pt01.html">I. JSON and the JSONiq Data Model</a></span></dt><dd><dl><dt><span class="chapter"><a href="chapter-JSON.html">2. The JSON Syntax</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-JSON.html#idm676896">2.1. JSON Strings</a></span></dt><dt><span class="section"><a href="ch02s02.html">2.2. JSON Numbers</a></span></dt><dt><span class="section"><a href="ch02s03.html">2.3. JSON Booleans</a></span></dt><dt><span class="section"><a href="ch02s04.html">2.4. JSON Null</a></span></dt><dt><span class="section"><a href="ch02s05.html">2.5. JSON Objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="chapter-DataModel.html">3. The JSONiq Data Model</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-DataModel.html#idm34438256">3.1. JSONiq Values: Items and Sequences</a></span></dt><dt><span class="section"><a href="ch03s02.html">3.2. Objects</a></span></dt><dt><span class="section"><a href="ch03s03.html">3.3. Arrays</a></span></dt><dt><span class="section"><a href="ch03s04.html">3.4. Atomics</a></span></dt></dl></dd><dt><span class="chapter"><a href="chapter-TypeSystem.html">4. The JSONiq Type System</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-TypeSystem.html#idp62560">4.1. Item Types</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-TypeSystem.html#idm34511680">4.1.1. Atomic Types</a></span></dt><dt><span class="section"><a href="chapter-TypeSystem.html#idm43645904">4.1.2. JSON Item Types : Object Types and Array Types</a></span></dt><dt><span class="section"><a href="chapter-TypeSystem.html#idm46735328">4.1.3. The Most General Item Type.</a></span></dt></dl></dd><dt><span class="section"><a href="ch04s02.html">4.2. Sequence Types</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt02.html">II. Construction of Items and JSON Navigation</a></span></dt><dd><dl><dt><span class="chapter"><a href="chapter-Construction.html">5. Construction of Items</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-Construction.html#idm34369312">5.1. Atomic Literals</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-Construction.html#idm43184432">5.1.1. String Literals</a></span></dt><dt><span class="section"><a href="chapter-Construction.html#idm37470224">5.1.2. Number Literals.</a></span></dt><dt><span class="section"><a href="chapter-Construction.html#idm39499312">5.1.3. Boolean and Null Literals</a></span></dt></dl></dd><dt><span class="section"><a href="ch05s02.html">5.2. Object Constructors</a></span></dt><dt><span class="section"><a href="ch05s03.html">5.3. Array Constructors</a></span></dt><dt><span class="section"><a href="ch05s04.html">5.4. Composing Constructors</a></span></dt></dl></dd><dt><span class="chapter"><a href="chapter-collections.html">6. Collections</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-collections.html#idm39242320">6.1. Collections Used Throughout This Book</a></span></dt></dl></dd><dt><span class="chapter"><a href="chapter-selectors.html">7. JSON Navigation</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-selectors.html#idm37787056">7.1. Object Navigation</a></span></dt><dt><span class="section"><a href="ch07s02.html">7.2. Array Unboxing</a></span></dt><dt><span class="section"><a href="section-predicateExpressions.html">7.3. Sequence Filtering</a></span></dt><dt><span class="section"><a href="ch07s04.html">7.4. Array Navigation</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt03.html">III. JSONiq Expressions</a></span></dt><dd><dl><dt><span class="chapter"><a href="chapter-basicOperations.html">8. Basic Operations</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-basicOperations.html#idm3200736">8.1. Construction of Sequences</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-basicOperations.html#idp5227520">8.1.1. Comma Operator</a></span></dt><dt><span class="section"><a href="chapter-basicOperations.html#idm41354688">8.1.2. Range Operator</a></span></dt></dl></dd><dt><span class="section"><a href="ch08s02.html">8.2. Parenthesized Expressions</a></span></dt><dt><span class="section"><a href="ch08s03.html">8.3. Arithmetics</a></span></dt><dt><span class="section"><a href="ch08s04.html">8.4. String Concatenation</a></span></dt><dt><span class="section"><a href="ch08s05.html">8.5. Comparison</a></span></dt><dt><span class="section"><a href="ch08s06.html">8.6. Empty Sequence Behavior</a></span></dt><dt><span class="section"><a href="section-logics.html">8.7. Logic</a></span></dt><dd><dl><dt><span class="section"><a href="section-logics.html#idp3437408">8.7.1. Propositional Logic</a></span></dt><dt><span class="section"><a href="ch08s07s02.html">8.7.2. First-Order Logic (Quantified Variables)</a></span></dt></dl></dd><dt><span class="section"><a href="ch08s08.html">8.8. Builtin Functions</a></span></dt></dl></dd><dt><span class="chapter"><a href="chapter-controlFlow.html">9. Control Flow Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-controlFlow.html#idp3410016">9.1. Conditional Expressions</a></span></dt><dt><span class="section"><a href="ch09s02.html">9.2. Switch expressions</a></span></dt><dt><span class="section"><a href="ch09s03.html">9.3. Try-Catch expressions</a></span></dt></dl></dd><dt><span class="chapter"><a href="chapter-FLWOR.html">10. FLWOR Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-FLWOR.html#section-Variables">10.1. Variables</a></span></dt><dt><span class="section"><a href="ch10s02.html">10.2. For Clauses</a></span></dt><dt><span class="section"><a href="ch10s03.html">10.3. Where Clauses</a></span></dt><dt><span class="section"><a href="ch10s04.html">10.4. Order Clauses</a></span></dt><dt><span class="section"><a href="ch10s05.html">10.5. Group Clauses</a></span></dt><dt><span class="section"><a href="ch10s06.html">10.6. Let Clauses</a></span></dt><dt><span class="section"><a href="ch10s07.html">10.7. Count Clauses</a></span></dt><dt><span class="section"><a href="ch10s08.html">10.8. Map Operator</a></span></dt><dt><span class="section"><a href="ch10s09.html">10.9. Composing FLWOR Expressions</a></span></dt><dt><span class="section"><a href="ch10s10.html">10.10. Ordered and Unordered Expressions</a></span></dt></dl></dd><dt><span class="chapter"><a href="chapter-TypeExpressions.html">11. Expressions Dealing with Types</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-TypeExpressions.html#idp37616">11.1. Instance-of Expressions</a></span></dt><dt><span class="section"><a href="ch11s02.html">11.2. Treat Expressions</a></span></dt><dt><span class="section"><a href="ch11s03.html">11.3. Castable Expressions</a></span></dt><dt><span class="section"><a href="ch11s04.html">11.4. Cast Expressions</a></span></dt><dt><span class="section"><a href="section-typeswitch.html">11.5. Typeswitch Expressions</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="pt04.html">IV. Prolog, Modules and Functions</a></span></dt><dd><dl><dt><span class="chapter"><a href="chapter-prolog.html">12. Prologs</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-prolog.html#idm3143264">12.1. Setters.</a></span></dt><dd><dl><dt><span class="section"><a href="chapter-prolog.html#idm47087840">12.1.1. Default Ordering Mode</a></span></dt><dt><span class="section"><a href="chapter-prolog.html#idm39377744">12.1.2. Default Ordering Behaviour for Empty Sequences</a></span></dt><dt><span class="section"><a href="chapter-prolog.html#idp6481104">12.1.3. Default Decimal Format</a></span></dt></dl></dd><dt><span class="section"><a href="ch12s02.html">12.2. Namespaces</a></span></dt><dt><span class="section"><a href="section-globalVariables.html">12.3. Global Variables</a></span></dt><dt><span class="section"><a href="ch12s04.html">12.4. User-Defined Functions</a></span></dt></dl></dd><dt><span class="chapter"><a href="chapter-modules.html">13. Modules</a></span></dt><dt><span class="chapter"><a href="chapter-functions.html">14. Function Library</a></span></dt></dl></dd><dt><span class="part"><a href="pt05.html">V. Advanced Notes</a></span></dt><dd><dl><dt><span class="chapter"><a href="ch15.html">15. Errors</a></span></dt><dt><span class="chapter"><a href="ch16.html">16. Equality vs. Identity</a></span></dt><dt><span class="chapter"><a href="ch17.html">17. Sequences vs. Arrays</a></span></dt><dt><span class="chapter"><a href="ch18.html">18. Null vs. Empty Sequence</a></span></dt></dl></dd><dt><span class="chapter"><a href="chapter-reference.html">19. Reference</a></span></dt></dl></div></div><ul class="docnav"><li class="previous"></li><li class="next"><a accesskey="n" href="chapter-introduction.html"><strong>Next</strong>Chapter 1. Introduction</a></li></ul></body></html>
