<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1.2. Why JSONiq?</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.8" /><meta name="package" content="JSONiq-Introduction_to_JSONiq-0.1-en-US-0-0" /><link rel="home" href="index.html" title="Introduction to JSONiq" /><link rel="up" href="chapter-introduction.html" title="Chapter 1. Introduction" /><link rel="prev" href="chapter-introduction.html" title="Chapter 1. Introduction" /><link rel="next" href="ch01s03.html" title="1.3. How to Run the Queries in This Book?" /></head><body><p id="title"><a class="left" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="chapter-introduction.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch01s03.html"><strong>Next</strong></a></li></ul><div class="section"><div class="titlepage"><div><div><h2 class="title" id="idm40126720">1.2. Why JSONiq?</h2></div></div></div><div class="para">
			NoSQL has a very broad meaning and, while the general principles are similar between data stores, each data stores has a specific format for the values (or trees) and a query language tailored for the data store.
		</div><div class="para">
			JSONiq was developed with the idea that many data stores share the same design principles (e.g., collections of trees) so that it should be possibly to query them in a unified and portable way.
		</div><div class="para">
			JSONiq is a query and processing language specifically designed for the popular JSON data model. The main ideas behind JSONiq are based on lessons learned in more than 30 years of relational query systems and more than 15 years of experience with designing and implementing query languages for semi-structured data like XML and RDF.
		</div><div class="para">
			The main source of inspiration behind JSONiq is XQuery, which has been proven so far a successful and productive query language for semi-structured data (in particular XML). JSONiq borrowed a large numbers of ideas from XQuery like the structure and semantics of a FLWOR construct, the functional aspect of the language, the semantics of comparisons in the face of data heterogeneity, the declarative, snapshot-based updates. However, unlike XQuery, JSON is not concerned with the peculiarities of XML like mixed content, ordered children, the confusion between attributes and elements, the complexities of namespaces and QNames, or the complexities of XML Schema, and so on.
		</div><div class="para">
			The power of the XQuery's FLWOR construct and the functional aspect combined with the simplicity of the JSON data model results in a clean, sleek, and easy to understand data processing language. As a matter of fact, JSONiq is a language that can do more than queries: it can describe powerful data processing programs from transformations, selections, joins of heterogeneous data sets, data enrichment, information extraction, information cleaning, and so on.
		</div><div class="para">
			Technically, the main characteristics of JSONiq (and XQuery) are the following:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					It is a <span class="emphasis"><em>set-oriented language</em></span>. While most programming languages are designed to manipulate one object at a time, JSONiq is designed to process sets (actually, sequences) of data objects.
				</div></li><li class="listitem"><div class="para">
					It is a <span class="emphasis"><em>functional language</em></span>. A JSONiq program is an expression; the result of the program is the result of the evaluation of the expression. Expressions have fundamental role in the language: every language construct is an expression and expressions are fully composable.
				</div></li><li class="listitem"><div class="para">
					It is a <span class="emphasis"><em>declarative language</em></span>. A program specifies what is the result being calculated, and does not specify low level algorithms like the sort algorithm. Neither does it specify whether an algorithm is executed in main memory or whether it is executed on a single machine or parallelized on several machines; or what access patterns (aka indexes) are being used during the evaluation of the program. Such implementation decisions should be taken automatically by an optimizer, based on the physical characteristics of the data and of the hardware environment -- just like a traditional database would do. The language has been designed from day one with optimizability in mind.
				</div></li><li class="listitem"><div class="para">
					It is designed for <span class="emphasis"><em>nested, heterogeneous, semi-structured data</em></span>. Data structures in JSON can be nested with arbitrary depth, do not have a specific type pattern (i.e. are heterogeneous), and may or may not have one or more schemas that describe the data. Even in the case of a schema, such a schema can be open and/or simply partially describe the data. Unlike SQL, which is designed to query tabular, flat, homogeneous structures. JSONiq has been designed from scratch as a query for nested and heterogeneous data.
				</div></li></ul></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="chapter-introduction.html"><strong>Prev</strong>Chapter 1. Introduction</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch01s03.html"><strong>Next</strong>1.3. How to Run the Queries in This Book?</a></li></ul></body></html>
